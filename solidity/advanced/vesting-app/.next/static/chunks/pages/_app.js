/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/ethers/dist/ethers.umd.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/dist/ethers.umd.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, function (exports) { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n['default'] || n;\n\t}\n\n\tvar _nodeResolve_empty = {};\n\n\tvar _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({\n\t\t'default': _nodeResolve_empty\n\t});\n\n\tvar require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);\n\n\tvar bn = createCommonjsModule(function (module) {\n\t(function (module, exports) {\n\t  'use strict';\n\n\t  // Utils\n\t  function assert (val, msg) {\n\t    if (!val) throw new Error(msg || 'Assertion failed');\n\t  }\n\n\t  // Could use `inherits` module, but don't want to move from single file\n\t  // architecture yet.\n\t  function inherits (ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\n\t  // BN\n\n\t  function BN (number, base, endian) {\n\t    if (BN.isBN(number)) {\n\t      return number;\n\t    }\n\n\t    this.negative = 0;\n\t    this.words = null;\n\t    this.length = 0;\n\n\t    // Reduction context\n\t    this.red = null;\n\n\t    if (number !== null) {\n\t      if (base === 'le' || base === 'be') {\n\t        endian = base;\n\t        base = 10;\n\t      }\n\n\t      this._init(number || 0, base || 10, endian || 'be');\n\t    }\n\t  }\n\t  if (typeof module === 'object') {\n\t    module.exports = BN;\n\t  } else {\n\t    exports.BN = BN;\n\t  }\n\n\t  BN.BN = BN;\n\t  BN.wordSize = 26;\n\n\t  var Buffer;\n\t  try {\n\t    Buffer = require$$0.Buffer;\n\t  } catch (e) {\n\t  }\n\n\t  BN.isBN = function isBN (num) {\n\t    if (num instanceof BN) {\n\t      return true;\n\t    }\n\n\t    return num !== null && typeof num === 'object' &&\n\t      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n\t  };\n\n\t  BN.max = function max (left, right) {\n\t    if (left.cmp(right) > 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.min = function min (left, right) {\n\t    if (left.cmp(right) < 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.prototype._init = function init (number, base, endian) {\n\t    if (typeof number === 'number') {\n\t      return this._initNumber(number, base, endian);\n\t    }\n\n\t    if (typeof number === 'object') {\n\t      return this._initArray(number, base, endian);\n\t    }\n\n\t    if (base === 'hex') {\n\t      base = 16;\n\t    }\n\t    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n\t    number = number.toString().replace(/\\s+/g, '');\n\t    var start = 0;\n\t    if (number[0] === '-') {\n\t      start++;\n\t    }\n\n\t    if (base === 16) {\n\t      this._parseHex(number, start);\n\t    } else {\n\t      this._parseBase(number, base, start);\n\t    }\n\n\t    if (number[0] === '-') {\n\t      this.negative = 1;\n\t    }\n\n\t    this.strip();\n\n\t    if (endian !== 'le') return;\n\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n\t    if (number < 0) {\n\t      this.negative = 1;\n\t      number = -number;\n\t    }\n\t    if (number < 0x4000000) {\n\t      this.words = [ number & 0x3ffffff ];\n\t      this.length = 1;\n\t    } else if (number < 0x10000000000000) {\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff\n\t      ];\n\t      this.length = 2;\n\t    } else {\n\t      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff,\n\t        1\n\t      ];\n\t      this.length = 3;\n\t    }\n\n\t    if (endian !== 'le') return;\n\n\t    // Reverse the bytes\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initArray = function _initArray (number, base, endian) {\n\t    // Perhaps a Uint8Array\n\t    assert(typeof number.length === 'number');\n\t    if (number.length <= 0) {\n\t      this.words = [ 0 ];\n\t      this.length = 1;\n\t      return this;\n\t    }\n\n\t    this.length = Math.ceil(number.length / 3);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    var off = 0;\n\t    if (endian === 'be') {\n\t      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n\t        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    } else if (endian === 'le') {\n\t      for (i = 0, j = 0; i < number.length; i += 3) {\n\t        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    }\n\t    return this.strip();\n\t  };\n\n\t  function parseHex (str, start, end) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r <<= 4;\n\n\t      // 'a' - 'f'\n\t      if (c >= 49 && c <= 54) {\n\t        r |= c - 49 + 0xa;\n\n\t      // 'A' - 'F'\n\t      } else if (c >= 17 && c <= 22) {\n\t        r |= c - 17 + 0xa;\n\n\t      // '0' - '9'\n\t      } else {\n\t        r |= c & 0xf;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseHex = function _parseHex (number, start) {\n\t    // Create possibly bigger array to ensure that it fits the number\n\t    this.length = Math.ceil((number.length - start) / 6);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    // Scan 24-bit chunks and add them to the number\n\t    var off = 0;\n\t    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n\t      w = parseHex(number, i, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t      off += 24;\n\t      if (off >= 26) {\n\t        off -= 26;\n\t        j++;\n\t      }\n\t    }\n\t    if (i + 6 !== start) {\n\t      w = parseHex(number, start, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t    }\n\t    this.strip();\n\t  };\n\n\t  function parseBase (str, start, end, mul) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r *= mul;\n\n\t      // 'a'\n\t      if (c >= 49) {\n\t        r += c - 49 + 0xa;\n\n\t      // 'A'\n\t      } else if (c >= 17) {\n\t        r += c - 17 + 0xa;\n\n\t      // '0' - '9'\n\t      } else {\n\t        r += c;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseBase = function _parseBase (number, base, start) {\n\t    // Initialize as zero\n\t    this.words = [ 0 ];\n\t    this.length = 1;\n\n\t    // Find length of limb in base\n\t    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n\t      limbLen++;\n\t    }\n\t    limbLen--;\n\t    limbPow = (limbPow / base) | 0;\n\n\t    var total = number.length - start;\n\t    var mod = total % limbLen;\n\t    var end = Math.min(total, total - mod) + start;\n\n\t    var word = 0;\n\t    for (var i = start; i < end; i += limbLen) {\n\t      word = parseBase(number, i, i + limbLen, base);\n\n\t      this.imuln(limbPow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\n\t    if (mod !== 0) {\n\t      var pow = 1;\n\t      word = parseBase(number, i, number.length, base);\n\n\t      for (i = 0; i < mod; i++) {\n\t        pow *= base;\n\t      }\n\n\t      this.imuln(pow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\t  };\n\n\t  BN.prototype.copy = function copy (dest) {\n\t    dest.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      dest.words[i] = this.words[i];\n\t    }\n\t    dest.length = this.length;\n\t    dest.negative = this.negative;\n\t    dest.red = this.red;\n\t  };\n\n\t  BN.prototype.clone = function clone () {\n\t    var r = new BN(null);\n\t    this.copy(r);\n\t    return r;\n\t  };\n\n\t  BN.prototype._expand = function _expand (size) {\n\t    while (this.length < size) {\n\t      this.words[this.length++] = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  // Remove leading `0` from `this`\n\t  BN.prototype.strip = function strip () {\n\t    while (this.length > 1 && this.words[this.length - 1] === 0) {\n\t      this.length--;\n\t    }\n\t    return this._normSign();\n\t  };\n\n\t  BN.prototype._normSign = function _normSign () {\n\t    // -0 = 0\n\t    if (this.length === 1 && this.words[0] === 0) {\n\t      this.negative = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.inspect = function inspect () {\n\t    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n\t  };\n\n\t  /*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = '';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += '0';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */\n\n\t  var zeros = [\n\t    '',\n\t    '0',\n\t    '00',\n\t    '000',\n\t    '0000',\n\t    '00000',\n\t    '000000',\n\t    '0000000',\n\t    '00000000',\n\t    '000000000',\n\t    '0000000000',\n\t    '00000000000',\n\t    '000000000000',\n\t    '0000000000000',\n\t    '00000000000000',\n\t    '000000000000000',\n\t    '0000000000000000',\n\t    '00000000000000000',\n\t    '000000000000000000',\n\t    '0000000000000000000',\n\t    '00000000000000000000',\n\t    '000000000000000000000',\n\t    '0000000000000000000000',\n\t    '00000000000000000000000',\n\t    '000000000000000000000000',\n\t    '0000000000000000000000000'\n\t  ];\n\n\t  var groupSizes = [\n\t    0, 0,\n\t    25, 16, 12, 11, 10, 9, 8,\n\t    8, 7, 7, 7, 7, 6, 6,\n\t    6, 6, 6, 6, 6, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5\n\t  ];\n\n\t  var groupBases = [\n\t    0, 0,\n\t    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n\t    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n\t    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n\t    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n\t    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n\t  ];\n\n\t  BN.prototype.toString = function toString (base, padding) {\n\t    base = base || 10;\n\t    padding = padding | 0 || 1;\n\n\t    var out;\n\t    if (base === 16 || base === 'hex') {\n\t      out = '';\n\t      var off = 0;\n\t      var carry = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        var w = this.words[i];\n\t        var word = (((w << off) | carry) & 0xffffff).toString(16);\n\t        carry = (w >>> (24 - off)) & 0xffffff;\n\t        if (carry !== 0 || i !== this.length - 1) {\n\t          out = zeros[6 - word.length] + word + out;\n\t        } else {\n\t          out = word + out;\n\t        }\n\t        off += 2;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          i--;\n\t        }\n\t      }\n\t      if (carry !== 0) {\n\t        out = carry.toString(16) + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = '0' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = '-' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    if (base === (base | 0) && base >= 2 && base <= 36) {\n\t      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n\t      var groupSize = groupSizes[base];\n\t      // var groupBase = Math.pow(base, groupSize);\n\t      var groupBase = groupBases[base];\n\t      out = '';\n\t      var c = this.clone();\n\t      c.negative = 0;\n\t      while (!c.isZero()) {\n\t        var r = c.modn(groupBase).toString(base);\n\t        c = c.idivn(groupBase);\n\n\t        if (!c.isZero()) {\n\t          out = zeros[groupSize - r.length] + r + out;\n\t        } else {\n\t          out = r + out;\n\t        }\n\t      }\n\t      if (this.isZero()) {\n\t        out = '0' + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = '0' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = '-' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    assert(false, 'Base should be between 2 and 36');\n\t  };\n\n\t  BN.prototype.toNumber = function toNumber () {\n\t    var ret = this.words[0];\n\t    if (this.length === 2) {\n\t      ret += this.words[1] * 0x4000000;\n\t    } else if (this.length === 3 && this.words[2] === 0x01) {\n\t      // NOTE: at this stage it is known that the top bit is set\n\t      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n\t    } else if (this.length > 2) {\n\t      assert(false, 'Number can only safely store up to 53 bits');\n\t    }\n\t    return (this.negative !== 0) ? -ret : ret;\n\t  };\n\n\t  BN.prototype.toJSON = function toJSON () {\n\t    return this.toString(16);\n\t  };\n\n\t  BN.prototype.toBuffer = function toBuffer (endian, length) {\n\t    assert(typeof Buffer !== 'undefined');\n\t    return this.toArrayLike(Buffer, endian, length);\n\t  };\n\n\t  BN.prototype.toArray = function toArray (endian, length) {\n\t    return this.toArrayLike(Array, endian, length);\n\t  };\n\n\t  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n\t    var byteLength = this.byteLength();\n\t    var reqLength = length || Math.max(1, byteLength);\n\t    assert(byteLength <= reqLength, 'byte array longer than desired length');\n\t    assert(reqLength > 0, 'Requested array length <= 0');\n\n\t    this.strip();\n\t    var littleEndian = endian === 'le';\n\t    var res = new ArrayType(reqLength);\n\n\t    var b, i;\n\t    var q = this.clone();\n\t    if (!littleEndian) {\n\t      // Assume big-endian\n\t      for (i = 0; i < reqLength - byteLength; i++) {\n\t        res[i] = 0;\n\t      }\n\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[reqLength - i - 1] = b;\n\t      }\n\t    } else {\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[i] = b;\n\t      }\n\n\t      for (; i < reqLength; i++) {\n\t        res[i] = 0;\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  if (Math.clz32) {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      return 32 - Math.clz32(w);\n\t    };\n\t  } else {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      var t = w;\n\t      var r = 0;\n\t      if (t >= 0x1000) {\n\t        r += 13;\n\t        t >>>= 13;\n\t      }\n\t      if (t >= 0x40) {\n\t        r += 7;\n\t        t >>>= 7;\n\t      }\n\t      if (t >= 0x8) {\n\t        r += 4;\n\t        t >>>= 4;\n\t      }\n\t      if (t >= 0x02) {\n\t        r += 2;\n\t        t >>>= 2;\n\t      }\n\t      return r + t;\n\t    };\n\t  }\n\n\t  BN.prototype._zeroBits = function _zeroBits (w) {\n\t    // Short-cut\n\t    if (w === 0) return 26;\n\n\t    var t = w;\n\t    var r = 0;\n\t    if ((t & 0x1fff) === 0) {\n\t      r += 13;\n\t      t >>>= 13;\n\t    }\n\t    if ((t & 0x7f) === 0) {\n\t      r += 7;\n\t      t >>>= 7;\n\t    }\n\t    if ((t & 0xf) === 0) {\n\t      r += 4;\n\t      t >>>= 4;\n\t    }\n\t    if ((t & 0x3) === 0) {\n\t      r += 2;\n\t      t >>>= 2;\n\t    }\n\t    if ((t & 0x1) === 0) {\n\t      r++;\n\t    }\n\t    return r;\n\t  };\n\n\t  // Return number of used bits in a BN\n\t  BN.prototype.bitLength = function bitLength () {\n\t    var w = this.words[this.length - 1];\n\t    var hi = this._countBits(w);\n\t    return (this.length - 1) * 26 + hi;\n\t  };\n\n\t  function toBitArray (num) {\n\t    var w = new Array(num.bitLength());\n\n\t    for (var bit = 0; bit < w.length; bit++) {\n\t      var off = (bit / 26) | 0;\n\t      var wbit = bit % 26;\n\n\t      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n\t    }\n\n\t    return w;\n\t  }\n\n\t  // Number of trailing zero bits\n\t  BN.prototype.zeroBits = function zeroBits () {\n\t    if (this.isZero()) return 0;\n\n\t    var r = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var b = this._zeroBits(this.words[i]);\n\t      r += b;\n\t      if (b !== 26) break;\n\t    }\n\t    return r;\n\t  };\n\n\t  BN.prototype.byteLength = function byteLength () {\n\t    return Math.ceil(this.bitLength() / 8);\n\t  };\n\n\t  BN.prototype.toTwos = function toTwos (width) {\n\t    if (this.negative !== 0) {\n\t      return this.abs().inotn(width).iaddn(1);\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.fromTwos = function fromTwos (width) {\n\t    if (this.testn(width - 1)) {\n\t      return this.notn(width).iaddn(1).ineg();\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.isNeg = function isNeg () {\n\t    return this.negative !== 0;\n\t  };\n\n\t  // Return negative clone of `this`\n\t  BN.prototype.neg = function neg () {\n\t    return this.clone().ineg();\n\t  };\n\n\t  BN.prototype.ineg = function ineg () {\n\t    if (!this.isZero()) {\n\t      this.negative ^= 1;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Or `num` with `this` in-place\n\t  BN.prototype.iuor = function iuor (num) {\n\t    while (this.length < num.length) {\n\t      this.words[this.length++] = 0;\n\t    }\n\n\t    for (var i = 0; i < num.length; i++) {\n\t      this.words[i] = this.words[i] | num.words[i];\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ior = function ior (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuor(num);\n\t  };\n\n\t  // Or `num` with `this`\n\t  BN.prototype.or = function or (num) {\n\t    if (this.length > num.length) return this.clone().ior(num);\n\t    return num.clone().ior(this);\n\t  };\n\n\t  BN.prototype.uor = function uor (num) {\n\t    if (this.length > num.length) return this.clone().iuor(num);\n\t    return num.clone().iuor(this);\n\t  };\n\n\t  // And `num` with `this` in-place\n\t  BN.prototype.iuand = function iuand (num) {\n\t    // b = min-length(num, this)\n\t    var b;\n\t    if (this.length > num.length) {\n\t      b = num;\n\t    } else {\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = this.words[i] & num.words[i];\n\t    }\n\n\t    this.length = b.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.iand = function iand (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuand(num);\n\t  };\n\n\t  // And `num` with `this`\n\t  BN.prototype.and = function and (num) {\n\t    if (this.length > num.length) return this.clone().iand(num);\n\t    return num.clone().iand(this);\n\t  };\n\n\t  BN.prototype.uand = function uand (num) {\n\t    if (this.length > num.length) return this.clone().iuand(num);\n\t    return num.clone().iuand(this);\n\t  };\n\n\t  // Xor `num` with `this` in-place\n\t  BN.prototype.iuxor = function iuxor (num) {\n\t    // a.length > b.length\n\t    var a;\n\t    var b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = a.words[i] ^ b.words[i];\n\t    }\n\n\t    if (this !== a) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = a.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ixor = function ixor (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuxor(num);\n\t  };\n\n\t  // Xor `num` with `this`\n\t  BN.prototype.xor = function xor (num) {\n\t    if (this.length > num.length) return this.clone().ixor(num);\n\t    return num.clone().ixor(this);\n\t  };\n\n\t  BN.prototype.uxor = function uxor (num) {\n\t    if (this.length > num.length) return this.clone().iuxor(num);\n\t    return num.clone().iuxor(this);\n\t  };\n\n\t  // Not ``this`` with ``width`` bitwidth\n\t  BN.prototype.inotn = function inotn (width) {\n\t    assert(typeof width === 'number' && width >= 0);\n\n\t    var bytesNeeded = Math.ceil(width / 26) | 0;\n\t    var bitsLeft = width % 26;\n\n\t    // Extend the buffer with leading zeroes\n\t    this._expand(bytesNeeded);\n\n\t    if (bitsLeft > 0) {\n\t      bytesNeeded--;\n\t    }\n\n\t    // Handle complete words\n\t    for (var i = 0; i < bytesNeeded; i++) {\n\t      this.words[i] = ~this.words[i] & 0x3ffffff;\n\t    }\n\n\t    // Handle the residue\n\t    if (bitsLeft > 0) {\n\t      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n\t    }\n\n\t    // And remove leading zeroes\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.notn = function notn (width) {\n\t    return this.clone().inotn(width);\n\t  };\n\n\t  // Set `bit` of `this`\n\t  BN.prototype.setn = function setn (bit, val) {\n\t    assert(typeof bit === 'number' && bit >= 0);\n\n\t    var off = (bit / 26) | 0;\n\t    var wbit = bit % 26;\n\n\t    this._expand(off + 1);\n\n\t    if (val) {\n\t      this.words[off] = this.words[off] | (1 << wbit);\n\t    } else {\n\t      this.words[off] = this.words[off] & ~(1 << wbit);\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Add `num` to `this` in-place\n\t  BN.prototype.iadd = function iadd (num) {\n\t    var r;\n\n\t    // negative + positive\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      this.negative = 0;\n\t      r = this.isub(num);\n\t      this.negative ^= 1;\n\t      return this._normSign();\n\n\t    // positive + negative\n\t    } else if (this.negative === 0 && num.negative !== 0) {\n\t      num.negative = 0;\n\t      r = this.isub(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\t    }\n\n\t    // a.length > b.length\n\t    var a, b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\n\t    this.length = a.length;\n\t    if (carry !== 0) {\n\t      this.words[this.length] = carry;\n\t      this.length++;\n\t    // Copy the rest of the words\n\t    } else if (a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Add `num` to `this`\n\t  BN.prototype.add = function add (num) {\n\t    var res;\n\t    if (num.negative !== 0 && this.negative === 0) {\n\t      num.negative = 0;\n\t      res = this.sub(num);\n\t      num.negative ^= 1;\n\t      return res;\n\t    } else if (num.negative === 0 && this.negative !== 0) {\n\t      this.negative = 0;\n\t      res = num.sub(this);\n\t      this.negative = 1;\n\t      return res;\n\t    }\n\n\t    if (this.length > num.length) return this.clone().iadd(num);\n\n\t    return num.clone().iadd(this);\n\t  };\n\n\t  // Subtract `num` from `this` in-place\n\t  BN.prototype.isub = function isub (num) {\n\t    // this - (-num) = this + num\n\t    if (num.negative !== 0) {\n\t      num.negative = 0;\n\t      var r = this.iadd(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\n\t    // -this - num = -(this + num)\n\t    } else if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iadd(num);\n\t      this.negative = 1;\n\t      return this._normSign();\n\t    }\n\n\t    // At this point both numbers are positive\n\t    var cmp = this.cmp(num);\n\n\t    // Optimization - zeroify\n\t    if (cmp === 0) {\n\t      this.negative = 0;\n\t      this.length = 1;\n\t      this.words[0] = 0;\n\t      return this;\n\t    }\n\n\t    // a > b\n\t    var a, b;\n\t    if (cmp > 0) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\n\t    // Copy rest of the words\n\t    if (carry === 0 && i < a.length && a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = Math.max(this.length, i);\n\n\t    if (a !== this) {\n\t      this.negative = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Subtract `num` from `this`\n\t  BN.prototype.sub = function sub (num) {\n\t    return this.clone().isub(num);\n\t  };\n\n\t  function smallMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    var len = (self.length + num.length) | 0;\n\t    out.length = len;\n\t    len = (len - 1) | 0;\n\n\t    // Peel one iteration (compiler can't do it, because of code complexity)\n\t    var a = self.words[0] | 0;\n\t    var b = num.words[0] | 0;\n\t    var r = a * b;\n\n\t    var lo = r & 0x3ffffff;\n\t    var carry = (r / 0x4000000) | 0;\n\t    out.words[0] = lo;\n\n\t    for (var k = 1; k < len; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = carry >>> 26;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = (k - j) | 0;\n\t        a = self.words[i] | 0;\n\t        b = num.words[j] | 0;\n\t        r = a * b + rword;\n\t        ncarry += (r / 0x4000000) | 0;\n\t        rword = r & 0x3ffffff;\n\t      }\n\t      out.words[k] = rword | 0;\n\t      carry = ncarry | 0;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry | 0;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  // TODO(indutny): it may be reasonable to omit it for users who don't need\n\t  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n\t  // multiplication (like elliptic secp256k1).\n\t  var comb10MulTo = function comb10MulTo (self, num, out) {\n\t    var a = self.words;\n\t    var b = num.words;\n\t    var o = out.words;\n\t    var c = 0;\n\t    var lo;\n\t    var mid;\n\t    var hi;\n\t    var a0 = a[0] | 0;\n\t    var al0 = a0 & 0x1fff;\n\t    var ah0 = a0 >>> 13;\n\t    var a1 = a[1] | 0;\n\t    var al1 = a1 & 0x1fff;\n\t    var ah1 = a1 >>> 13;\n\t    var a2 = a[2] | 0;\n\t    var al2 = a2 & 0x1fff;\n\t    var ah2 = a2 >>> 13;\n\t    var a3 = a[3] | 0;\n\t    var al3 = a3 & 0x1fff;\n\t    var ah3 = a3 >>> 13;\n\t    var a4 = a[4] | 0;\n\t    var al4 = a4 & 0x1fff;\n\t    var ah4 = a4 >>> 13;\n\t    var a5 = a[5] | 0;\n\t    var al5 = a5 & 0x1fff;\n\t    var ah5 = a5 >>> 13;\n\t    var a6 = a[6] | 0;\n\t    var al6 = a6 & 0x1fff;\n\t    var ah6 = a6 >>> 13;\n\t    var a7 = a[7] | 0;\n\t    var al7 = a7 & 0x1fff;\n\t    var ah7 = a7 >>> 13;\n\t    var a8 = a[8] | 0;\n\t    var al8 = a8 & 0x1fff;\n\t    var ah8 = a8 >>> 13;\n\t    var a9 = a[9] | 0;\n\t    var al9 = a9 & 0x1fff;\n\t    var ah9 = a9 >>> 13;\n\t    var b0 = b[0] | 0;\n\t    var bl0 = b0 & 0x1fff;\n\t    var bh0 = b0 >>> 13;\n\t    var b1 = b[1] | 0;\n\t    var bl1 = b1 & 0x1fff;\n\t    var bh1 = b1 >>> 13;\n\t    var b2 = b[2] | 0;\n\t    var bl2 = b2 & 0x1fff;\n\t    var bh2 = b2 >>> 13;\n\t    var b3 = b[3] | 0;\n\t    var bl3 = b3 & 0x1fff;\n\t    var bh3 = b3 >>> 13;\n\t    var b4 = b[4] | 0;\n\t    var bl4 = b4 & 0x1fff;\n\t    var bh4 = b4 >>> 13;\n\t    var b5 = b[5] | 0;\n\t    var bl5 = b5 & 0x1fff;\n\t    var bh5 = b5 >>> 13;\n\t    var b6 = b[6] | 0;\n\t    var bl6 = b6 & 0x1fff;\n\t    var bh6 = b6 >>> 13;\n\t    var b7 = b[7] | 0;\n\t    var bl7 = b7 & 0x1fff;\n\t    var bh7 = b7 >>> 13;\n\t    var b8 = b[8] | 0;\n\t    var bl8 = b8 & 0x1fff;\n\t    var bh8 = b8 >>> 13;\n\t    var b9 = b[9] | 0;\n\t    var bl9 = b9 & 0x1fff;\n\t    var bh9 = b9 >>> 13;\n\n\t    out.negative = self.negative ^ num.negative;\n\t    out.length = 19;\n\t    /* k = 0 */\n\t    lo = Math.imul(al0, bl0);\n\t    mid = Math.imul(al0, bh0);\n\t    mid = (mid + Math.imul(ah0, bl0)) | 0;\n\t    hi = Math.imul(ah0, bh0);\n\t    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n\t    w0 &= 0x3ffffff;\n\t    /* k = 1 */\n\t    lo = Math.imul(al1, bl0);\n\t    mid = Math.imul(al1, bh0);\n\t    mid = (mid + Math.imul(ah1, bl0)) | 0;\n\t    hi = Math.imul(ah1, bh0);\n\t    lo = (lo + Math.imul(al0, bl1)) | 0;\n\t    mid = (mid + Math.imul(al0, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh1)) | 0;\n\t    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n\t    w1 &= 0x3ffffff;\n\t    /* k = 2 */\n\t    lo = Math.imul(al2, bl0);\n\t    mid = Math.imul(al2, bh0);\n\t    mid = (mid + Math.imul(ah2, bl0)) | 0;\n\t    hi = Math.imul(ah2, bh0);\n\t    lo = (lo + Math.imul(al1, bl1)) | 0;\n\t    mid = (mid + Math.imul(al1, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh1)) | 0;\n\t    lo = (lo + Math.imul(al0, bl2)) | 0;\n\t    mid = (mid + Math.imul(al0, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh2)) | 0;\n\t    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n\t    w2 &= 0x3ffffff;\n\t    /* k = 3 */\n\t    lo = Math.imul(al3, bl0);\n\t    mid = Math.imul(al3, bh0);\n\t    mid = (mid + Math.imul(ah3, bl0)) | 0;\n\t    hi = Math.imul(ah3, bh0);\n\t    lo = (lo + Math.imul(al2, bl1)) | 0;\n\t    mid = (mid + Math.imul(al2, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh1)) | 0;\n\t    lo = (lo + Math.imul(al1, bl2)) | 0;\n\t    mid = (mid + Math.imul(al1, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh2)) | 0;\n\t    lo = (lo + Math.imul(al0, bl3)) | 0;\n\t    mid = (mid + Math.imul(al0, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh3)) | 0;\n\t    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n\t    w3 &= 0x3ffffff;\n\t    /* k = 4 */\n\t    lo = Math.imul(al4, bl0);\n\t    mid = Math.imul(al4, bh0);\n\t    mid = (mid + Math.imul(ah4, bl0)) | 0;\n\t    hi = Math.imul(ah4, bh0);\n\t    lo = (lo + Math.imul(al3, bl1)) | 0;\n\t    mid = (mid + Math.imul(al3, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh1)) | 0;\n\t    lo = (lo + Math.imul(al2, bl2)) | 0;\n\t    mid = (mid + Math.imul(al2, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh2)) | 0;\n\t    lo = (lo + Math.imul(al1, bl3)) | 0;\n\t    mid = (mid + Math.imul(al1, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh3)) | 0;\n\t    lo = (lo + Math.imul(al0, bl4)) | 0;\n\t    mid = (mid + Math.imul(al0, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh4)) | 0;\n\t    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n\t    w4 &= 0x3ffffff;\n\t    /* k = 5 */\n\t    lo = Math.imul(al5, bl0);\n\t    mid = Math.imul(al5, bh0);\n\t    mid = (mid + Math.imul(ah5, bl0)) | 0;\n\t    hi = Math.imul(ah5, bh0);\n\t    lo = (lo + Math.imul(al4, bl1)) | 0;\n\t    mid = (mid + Math.imul(al4, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh1)) | 0;\n\t    lo = (lo + Math.imul(al3, bl2)) | 0;\n\t    mid = (mid + Math.imul(al3, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh2)) | 0;\n\t    lo = (lo + Math.imul(al2, bl3)) | 0;\n\t    mid = (mid + Math.imul(al2, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh3)) | 0;\n\t    lo = (lo + Math.imul(al1, bl4)) | 0;\n\t    mid = (mid + Math.imul(al1, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh4)) | 0;\n\t    lo = (lo + Math.imul(al0, bl5)) | 0;\n\t    mid = (mid + Math.imul(al0, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh5)) | 0;\n\t    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n\t    w5 &= 0x3ffffff;\n\t    /* k = 6 */\n\t    lo = Math.imul(al6, bl0);\n\t    mid = Math.imul(al6, bh0);\n\t    mid = (mid + Math.imul(ah6, bl0)) | 0;\n\t    hi = Math.imul(ah6, bh0);\n\t    lo = (lo + Math.imul(al5, bl1)) | 0;\n\t    mid = (mid + Math.imul(al5, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh1)) | 0;\n\t    lo = (lo + Math.imul(al4, bl2)) | 0;\n\t    mid = (mid + Math.imul(al4, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh2)) | 0;\n\t    lo = (lo + Math.imul(al3, bl3)) | 0;\n\t    mid = (mid + Math.imul(al3, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh3)) | 0;\n\t    lo = (lo + Math.imul(al2, bl4)) | 0;\n\t    mid = (mid + Math.imul(al2, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh4)) | 0;\n\t    lo = (lo + Math.imul(al1, bl5)) | 0;\n\t    mid = (mid + Math.imul(al1, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh5)) | 0;\n\t    lo = (lo + Math.imul(al0, bl6)) | 0;\n\t    mid = (mid + Math.imul(al0, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh6)) | 0;\n\t    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n\t    w6 &= 0x3ffffff;\n\t    /* k = 7 */\n\t    lo = Math.imul(al7, bl0);\n\t    mid = Math.imul(al7, bh0);\n\t    mid = (mid + Math.imul(ah7, bl0)) | 0;\n\t    hi = Math.imul(ah7, bh0);\n\t    lo = (lo + Math.imul(al6, bl1)) | 0;\n\t    mid = (mid + Math.imul(al6, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh1)) | 0;\n\t    lo = (lo + Math.imul(al5, bl2)) | 0;\n\t    mid = (mid + Math.imul(al5, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh2)) | 0;\n\t    lo = (lo + Math.imul(al4, bl3)) | 0;\n\t    mid = (mid + Math.imul(al4, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh3)) | 0;\n\t    lo = (lo + Math.imul(al3, bl4)) | 0;\n\t    mid = (mid + Math.imul(al3, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh4)) | 0;\n\t    lo = (lo + Math.imul(al2, bl5)) | 0;\n\t    mid = (mid + Math.imul(al2, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh5)) | 0;\n\t    lo = (lo + Math.imul(al1, bl6)) | 0;\n\t    mid = (mid + Math.imul(al1, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh6)) | 0;\n\t    lo = (lo + Math.imul(al0, bl7)) | 0;\n\t    mid = (mid + Math.imul(al0, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh7)) | 0;\n\t    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n\t    w7 &= 0x3ffffff;\n\t    /* k = 8 */\n\t    lo = Math.imul(al8, bl0);\n\t    mid = Math.imul(al8, bh0);\n\t    mid = (mid + Math.imul(ah8, bl0)) | 0;\n\t    hi = Math.imul(ah8, bh0);\n\t    lo = (lo + Math.imul(al7, bl1)) | 0;\n\t    mid = (mid + Math.imul(al7, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh1)) | 0;\n\t    lo = (lo + Math.imul(al6, bl2)) | 0;\n\t    mid = (mid + Math.imul(al6, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh2)) | 0;\n\t    lo = (lo + Math.imul(al5, bl3)) | 0;\n\t    mid = (mid + Math.imul(al5, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh3)) | 0;\n\t    lo = (lo + Math.imul(al4, bl4)) | 0;\n\t    mid = (mid + Math.imul(al4, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh4)) | 0;\n\t    lo = (lo + Math.imul(al3, bl5)) | 0;\n\t    mid = (mid + Math.imul(al3, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh5)) | 0;\n\t    lo = (lo + Math.imul(al2, bl6)) | 0;\n\t    mid = (mid + Math.imul(al2, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh6)) | 0;\n\t    lo = (lo + Math.imul(al1, bl7)) | 0;\n\t    mid = (mid + Math.imul(al1, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh7)) | 0;\n\t    lo = (lo + Math.imul(al0, bl8)) | 0;\n\t    mid = (mid + Math.imul(al0, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh8)) | 0;\n\t    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n\t    w8 &= 0x3ffffff;\n\t    /* k = 9 */\n\t    lo = Math.imul(al9, bl0);\n\t    mid = Math.imul(al9, bh0);\n\t    mid = (mid + Math.imul(ah9, bl0)) | 0;\n\t    hi = Math.imul(ah9, bh0);\n\t    lo = (lo + Math.imul(al8, bl1)) | 0;\n\t    mid = (mid + Math.imul(al8, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh1)) | 0;\n\t    lo = (lo + Math.imul(al7, bl2)) | 0;\n\t    mid = (mid + Math.imul(al7, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh2)) | 0;\n\t    lo = (lo + Math.imul(al6, bl3)) | 0;\n\t    mid = (mid + Math.imul(al6, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh3)) | 0;\n\t    lo = (lo + Math.imul(al5, bl4)) | 0;\n\t    mid = (mid + Math.imul(al5, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh4)) | 0;\n\t    lo = (lo + Math.imul(al4, bl5)) | 0;\n\t    mid = (mid + Math.imul(al4, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh5)) | 0;\n\t    lo = (lo + Math.imul(al3, bl6)) | 0;\n\t    mid = (mid + Math.imul(al3, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh6)) | 0;\n\t    lo = (lo + Math.imul(al2, bl7)) | 0;\n\t    mid = (mid + Math.imul(al2, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh7)) | 0;\n\t    lo = (lo + Math.imul(al1, bl8)) | 0;\n\t    mid = (mid + Math.imul(al1, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh8)) | 0;\n\t    lo = (lo + Math.imul(al0, bl9)) | 0;\n\t    mid = (mid + Math.imul(al0, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh9)) | 0;\n\t    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n\t    w9 &= 0x3ffffff;\n\t    /* k = 10 */\n\t    lo = Math.imul(al9, bl1);\n\t    mid = Math.imul(al9, bh1);\n\t    mid = (mid + Math.imul(ah9, bl1)) | 0;\n\t    hi = Math.imul(ah9, bh1);\n\t    lo = (lo + Math.imul(al8, bl2)) | 0;\n\t    mid = (mid + Math.imul(al8, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh2)) | 0;\n\t    lo = (lo + Math.imul(al7, bl3)) | 0;\n\t    mid = (mid + Math.imul(al7, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh3)) | 0;\n\t    lo = (lo + Math.imul(al6, bl4)) | 0;\n\t    mid = (mid + Math.imul(al6, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh4)) | 0;\n\t    lo = (lo + Math.imul(al5, bl5)) | 0;\n\t    mid = (mid + Math.imul(al5, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh5)) | 0;\n\t    lo = (lo + Math.imul(al4, bl6)) | 0;\n\t    mid = (mid + Math.imul(al4, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh6)) | 0;\n\t    lo = (lo + Math.imul(al3, bl7)) | 0;\n\t    mid = (mid + Math.imul(al3, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh7)) | 0;\n\t    lo = (lo + Math.imul(al2, bl8)) | 0;\n\t    mid = (mid + Math.imul(al2, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh8)) | 0;\n\t    lo = (lo + Math.imul(al1, bl9)) | 0;\n\t    mid = (mid + Math.imul(al1, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh9)) | 0;\n\t    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n\t    w10 &= 0x3ffffff;\n\t    /* k = 11 */\n\t    lo = Math.imul(al9, bl2);\n\t    mid = Math.imul(al9, bh2);\n\t    mid = (mid + Math.imul(ah9, bl2)) | 0;\n\t    hi = Math.imul(ah9, bh2);\n\t    lo = (lo + Math.imul(al8, bl3)) | 0;\n\t    mid = (mid + Math.imul(al8, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh3)) | 0;\n\t    lo = (lo + Math.imul(al7, bl4)) | 0;\n\t    mid = (mid + Math.imul(al7, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh4)) | 0;\n\t    lo = (lo + Math.imul(al6, bl5)) | 0;\n\t    mid = (mid + Math.imul(al6, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh5)) | 0;\n\t    lo = (lo + Math.imul(al5, bl6)) | 0;\n\t    mid = (mid + Math.imul(al5, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh6)) | 0;\n\t    lo = (lo + Math.imul(al4, bl7)) | 0;\n\t    mid = (mid + Math.imul(al4, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh7)) | 0;\n\t    lo = (lo + Math.imul(al3, bl8)) | 0;\n\t    mid = (mid + Math.imul(al3, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh8)) | 0;\n\t    lo = (lo + Math.imul(al2, bl9)) | 0;\n\t    mid = (mid + Math.imul(al2, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh9)) | 0;\n\t    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n\t    w11 &= 0x3ffffff;\n\t    /* k = 12 */\n\t    lo = Math.imul(al9, bl3);\n\t    mid = Math.imul(al9, bh3);\n\t    mid = (mid + Math.imul(ah9, bl3)) | 0;\n\t    hi = Math.imul(ah9, bh3);\n\t    lo = (lo + Math.imul(al8, bl4)) | 0;\n\t    mid = (mid + Math.imul(al8, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh4)) | 0;\n\t    lo = (lo + Math.imul(al7, bl5)) | 0;\n\t    mid = (mid + Math.imul(al7, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh5)) | 0;\n\t    lo = (lo + Math.imul(al6, bl6)) | 0;\n\t    mid = (mid + Math.imul(al6, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh6)) | 0;\n\t    lo = (lo + Math.imul(al5, bl7)) | 0;\n\t    mid = (mid + Math.imul(al5, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh7)) | 0;\n\t    lo = (lo + Math.imul(al4, bl8)) | 0;\n\t    mid = (mid + Math.imul(al4, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh8)) | 0;\n\t    lo = (lo + Math.imul(al3, bl9)) | 0;\n\t    mid = (mid + Math.imul(al3, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh9)) | 0;\n\t    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n\t    w12 &= 0x3ffffff;\n\t    /* k = 13 */\n\t    lo = Math.imul(al9, bl4);\n\t    mid = Math.imul(al9, bh4);\n\t    mid = (mid + Math.imul(ah9, bl4)) | 0;\n\t    hi = Math.imul(ah9, bh4);\n\t    lo = (lo + Math.imul(al8, bl5)) | 0;\n\t    mid = (mid + Math.imul(al8, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh5)) | 0;\n\t    lo = (lo + Math.imul(al7, bl6)) | 0;\n\t    mid = (mid + Math.imul(al7, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh6)) | 0;\n\t    lo = (lo + Math.imul(al6, bl7)) | 0;\n\t    mid = (mid + Math.imul(al6, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh7)) | 0;\n\t    lo = (lo + Math.imul(al5, bl8)) | 0;\n\t    mid = (mid + Math.imul(al5, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh8)) | 0;\n\t    lo = (lo + Math.imul(al4, bl9)) | 0;\n\t    mid = (mid + Math.imul(al4, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh9)) | 0;\n\t    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n\t    w13 &= 0x3ffffff;\n\t    /* k = 14 */\n\t    lo = Math.imul(al9, bl5);\n\t    mid = Math.imul(al9, bh5);\n\t    mid = (mid + Math.imul(ah9, bl5)) | 0;\n\t    hi = Math.imul(ah9, bh5);\n\t    lo = (lo + Math.imul(al8, bl6)) | 0;\n\t    mid = (mid + Math.imul(al8, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh6)) | 0;\n\t    lo = (lo + Math.imul(al7, bl7)) | 0;\n\t    mid = (mid + Math.imul(al7, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh7)) | 0;\n\t    lo = (lo + Math.imul(al6, bl8)) | 0;\n\t    mid = (mid + Math.imul(al6, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh8)) | 0;\n\t    lo = (lo + Math.imul(al5, bl9)) | 0;\n\t    mid = (mid + Math.imul(al5, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh9)) | 0;\n\t    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n\t    w14 &= 0x3ffffff;\n\t    /* k = 15 */\n\t    lo = Math.imul(al9, bl6);\n\t    mid = Math.imul(al9, bh6);\n\t    mid = (mid + Math.imul(ah9, bl6)) | 0;\n\t    hi = Math.imul(ah9, bh6);\n\t    lo = (lo + Math.imul(al8, bl7)) | 0;\n\t    mid = (mid + Math.imul(al8, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh7)) | 0;\n\t    lo = (lo + Math.imul(al7, bl8)) | 0;\n\t    mid = (mid + Math.imul(al7, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh8)) | 0;\n\t    lo = (lo + Math.imul(al6, bl9)) | 0;\n\t    mid = (mid + Math.imul(al6, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh9)) | 0;\n\t    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n\t    w15 &= 0x3ffffff;\n\t    /* k = 16 */\n\t    lo = Math.imul(al9, bl7);\n\t    mid = Math.imul(al9, bh7);\n\t    mid = (mid + Math.imul(ah9, bl7)) | 0;\n\t    hi = Math.imul(ah9, bh7);\n\t    lo = (lo + Math.imul(al8, bl8)) | 0;\n\t    mid = (mid + Math.imul(al8, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh8)) | 0;\n\t    lo = (lo + Math.imul(al7, bl9)) | 0;\n\t    mid = (mid + Math.imul(al7, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh9)) | 0;\n\t    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n\t    w16 &= 0x3ffffff;\n\t    /* k = 17 */\n\t    lo = Math.imul(al9, bl8);\n\t    mid = Math.imul(al9, bh8);\n\t    mid = (mid + Math.imul(ah9, bl8)) | 0;\n\t    hi = Math.imul(ah9, bh8);\n\t    lo = (lo + Math.imul(al8, bl9)) | 0;\n\t    mid = (mid + Math.imul(al8, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh9)) | 0;\n\t    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n\t    w17 &= 0x3ffffff;\n\t    /* k = 18 */\n\t    lo = Math.imul(al9, bl9);\n\t    mid = Math.imul(al9, bh9);\n\t    mid = (mid + Math.imul(ah9, bl9)) | 0;\n\t    hi = Math.imul(ah9, bh9);\n\t    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n\t    w18 &= 0x3ffffff;\n\t    o[0] = w0;\n\t    o[1] = w1;\n\t    o[2] = w2;\n\t    o[3] = w3;\n\t    o[4] = w4;\n\t    o[5] = w5;\n\t    o[6] = w6;\n\t    o[7] = w7;\n\t    o[8] = w8;\n\t    o[9] = w9;\n\t    o[10] = w10;\n\t    o[11] = w11;\n\t    o[12] = w12;\n\t    o[13] = w13;\n\t    o[14] = w14;\n\t    o[15] = w15;\n\t    o[16] = w16;\n\t    o[17] = w17;\n\t    o[18] = w18;\n\t    if (c !== 0) {\n\t      o[19] = c;\n\t      out.length++;\n\t    }\n\t    return out;\n\t  };\n\n\t  // Polyfill comb\n\t  if (!Math.imul) {\n\t    comb10MulTo = smallMulTo;\n\t  }\n\n\t  function bigMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    out.length = self.length + num.length;\n\n\t    var carry = 0;\n\t    var hncarry = 0;\n\t    for (var k = 0; k < out.length - 1; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = hncarry;\n\t      hncarry = 0;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = k - j;\n\t        var a = self.words[i] | 0;\n\t        var b = num.words[j] | 0;\n\t        var r = a * b;\n\n\t        var lo = r & 0x3ffffff;\n\t        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n\t        lo = (lo + rword) | 0;\n\t        rword = lo & 0x3ffffff;\n\t        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n\t        hncarry += ncarry >>> 26;\n\t        ncarry &= 0x3ffffff;\n\t      }\n\t      out.words[k] = rword;\n\t      carry = ncarry;\n\t      ncarry = hncarry;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  function jumboMulTo (self, num, out) {\n\t    var fftm = new FFTM();\n\t    return fftm.mulp(self, num, out);\n\t  }\n\n\t  BN.prototype.mulTo = function mulTo (num, out) {\n\t    var res;\n\t    var len = this.length + num.length;\n\t    if (this.length === 10 && num.length === 10) {\n\t      res = comb10MulTo(this, num, out);\n\t    } else if (len < 63) {\n\t      res = smallMulTo(this, num, out);\n\t    } else if (len < 1024) {\n\t      res = bigMulTo(this, num, out);\n\t    } else {\n\t      res = jumboMulTo(this, num, out);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Cooley-Tukey algorithm for FFT\n\t  // slightly revisited to rely on looping instead of recursion\n\n\t  function FFTM (x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\n\t  FFTM.prototype.makeRBT = function makeRBT (N) {\n\t    var t = new Array(N);\n\t    var l = BN.prototype._countBits(N) - 1;\n\t    for (var i = 0; i < N; i++) {\n\t      t[i] = this.revBin(i, l, N);\n\t    }\n\n\t    return t;\n\t  };\n\n\t  // Returns binary-reversed representation of `x`\n\t  FFTM.prototype.revBin = function revBin (x, l, N) {\n\t    if (x === 0 || x === N - 1) return x;\n\n\t    var rb = 0;\n\t    for (var i = 0; i < l; i++) {\n\t      rb |= (x & 1) << (l - i - 1);\n\t      x >>= 1;\n\t    }\n\n\t    return rb;\n\t  };\n\n\t  // Performs \"tweedling\" phase, therefore 'emulating'\n\t  // behaviour of the recursive algorithm\n\t  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n\t    for (var i = 0; i < N; i++) {\n\t      rtws[i] = rws[rbt[i]];\n\t      itws[i] = iws[rbt[i]];\n\t    }\n\t  };\n\n\t  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n\t    this.permute(rbt, rws, iws, rtws, itws, N);\n\n\t    for (var s = 1; s < N; s <<= 1) {\n\t      var l = s << 1;\n\n\t      var rtwdf = Math.cos(2 * Math.PI / l);\n\t      var itwdf = Math.sin(2 * Math.PI / l);\n\n\t      for (var p = 0; p < N; p += l) {\n\t        var rtwdf_ = rtwdf;\n\t        var itwdf_ = itwdf;\n\n\t        for (var j = 0; j < s; j++) {\n\t          var re = rtws[p + j];\n\t          var ie = itws[p + j];\n\n\t          var ro = rtws[p + j + s];\n\t          var io = itws[p + j + s];\n\n\t          var rx = rtwdf_ * ro - itwdf_ * io;\n\n\t          io = rtwdf_ * io + itwdf_ * ro;\n\t          ro = rx;\n\n\t          rtws[p + j] = re + ro;\n\t          itws[p + j] = ie + io;\n\n\t          rtws[p + j + s] = re - ro;\n\t          itws[p + j + s] = ie - io;\n\n\t          /* jshint maxdepth : false */\n\t          if (j !== l) {\n\t            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n\t            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n\t            rtwdf_ = rx;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n\t    var N = Math.max(m, n) | 1;\n\t    var odd = N & 1;\n\t    var i = 0;\n\t    for (N = N / 2 | 0; N; N = N >>> 1) {\n\t      i++;\n\t    }\n\n\t    return 1 << i + 1 + odd;\n\t  };\n\n\t  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n\t    if (N <= 1) return;\n\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var t = rws[i];\n\n\t      rws[i] = rws[N - i - 1];\n\t      rws[N - i - 1] = t;\n\n\t      t = iws[i];\n\n\t      iws[i] = -iws[N - i - 1];\n\t      iws[N - i - 1] = -t;\n\t    }\n\t  };\n\n\t  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n\t        Math.round(ws[2 * i] / N) +\n\t        carry;\n\n\t      ws[i] = w & 0x3ffffff;\n\n\t      if (w < 0x4000000) {\n\t        carry = 0;\n\t      } else {\n\t        carry = w / 0x4000000 | 0;\n\t      }\n\t    }\n\n\t    return ws;\n\t  };\n\n\t  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < len; i++) {\n\t      carry = carry + (ws[i] | 0);\n\n\t      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n\t      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n\t    }\n\n\t    // Pad with zeroes\n\t    for (i = 2 * len; i < N; ++i) {\n\t      rws[i] = 0;\n\t    }\n\n\t    assert(carry === 0);\n\t    assert((carry & ~0x1fff) === 0);\n\t  };\n\n\t  FFTM.prototype.stub = function stub (N) {\n\t    var ph = new Array(N);\n\t    for (var i = 0; i < N; i++) {\n\t      ph[i] = 0;\n\t    }\n\n\t    return ph;\n\t  };\n\n\t  FFTM.prototype.mulp = function mulp (x, y, out) {\n\t    var N = 2 * this.guessLen13b(x.length, y.length);\n\n\t    var rbt = this.makeRBT(N);\n\n\t    var _ = this.stub(N);\n\n\t    var rws = new Array(N);\n\t    var rwst = new Array(N);\n\t    var iwst = new Array(N);\n\n\t    var nrws = new Array(N);\n\t    var nrwst = new Array(N);\n\t    var niwst = new Array(N);\n\n\t    var rmws = out.words;\n\t    rmws.length = N;\n\n\t    this.convert13b(x.words, x.length, rws, N);\n\t    this.convert13b(y.words, y.length, nrws, N);\n\n\t    this.transform(rws, _, rwst, iwst, N, rbt);\n\t    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n\t    for (var i = 0; i < N; i++) {\n\t      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n\t      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n\t      rwst[i] = rx;\n\t    }\n\n\t    this.conjugate(rwst, iwst, N);\n\t    this.transform(rwst, iwst, rmws, _, N, rbt);\n\t    this.conjugate(rmws, _, N);\n\t    this.normalize13b(rmws, N);\n\n\t    out.negative = x.negative ^ y.negative;\n\t    out.length = x.length + y.length;\n\t    return out.strip();\n\t  };\n\n\t  // Multiply `this` by `num`\n\t  BN.prototype.mul = function mul (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return this.mulTo(num, out);\n\t  };\n\n\t  // Multiply employing FFT\n\t  BN.prototype.mulf = function mulf (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return jumboMulTo(this, num, out);\n\t  };\n\n\t  // In-place Multiplication\n\t  BN.prototype.imul = function imul (num) {\n\t    return this.clone().mulTo(num, this);\n\t  };\n\n\t  BN.prototype.imuln = function imuln (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\n\t    // Carry\n\t    var carry = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var w = (this.words[i] | 0) * num;\n\t      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n\t      carry >>= 26;\n\t      carry += (w / 0x4000000) | 0;\n\t      // NOTE: lo is 27bit maximum\n\t      carry += lo >>> 26;\n\t      this.words[i] = lo & 0x3ffffff;\n\t    }\n\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.muln = function muln (num) {\n\t    return this.clone().imuln(num);\n\t  };\n\n\t  // `this` * `this`\n\t  BN.prototype.sqr = function sqr () {\n\t    return this.mul(this);\n\t  };\n\n\t  // `this` * `this` in-place\n\t  BN.prototype.isqr = function isqr () {\n\t    return this.imul(this.clone());\n\t  };\n\n\t  // Math.pow(`this`, `num`)\n\t  BN.prototype.pow = function pow (num) {\n\t    var w = toBitArray(num);\n\t    if (w.length === 0) return new BN(1);\n\n\t    // Skip leading zeroes\n\t    var res = this;\n\t    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n\t      if (w[i] !== 0) break;\n\t    }\n\n\t    if (++i < w.length) {\n\t      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n\t        if (w[i] === 0) continue;\n\n\t        res = res.mul(q);\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Shift-left in-place\n\t  BN.prototype.iushln = function iushln (bits) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\t    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n\t    var i;\n\n\t    if (r !== 0) {\n\t      var carry = 0;\n\n\t      for (i = 0; i < this.length; i++) {\n\t        var newCarry = this.words[i] & carryMask;\n\t        var c = ((this.words[i] | 0) - newCarry) << r;\n\t        this.words[i] = c | carry;\n\t        carry = newCarry >>> (26 - r);\n\t      }\n\n\t      if (carry) {\n\t        this.words[i] = carry;\n\t        this.length++;\n\t      }\n\t    }\n\n\t    if (s !== 0) {\n\t      for (i = this.length - 1; i >= 0; i--) {\n\t        this.words[i + s] = this.words[i];\n\t      }\n\n\t      for (i = 0; i < s; i++) {\n\t        this.words[i] = 0;\n\t      }\n\n\t      this.length += s;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishln = function ishln (bits) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushln(bits);\n\t  };\n\n\t  // Shift-right in-place\n\t  // NOTE: `hint` is a lowest bit before trailing zeroes\n\t  // NOTE: if `extended` is present - it will be filled with destroyed bits\n\t  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var h;\n\t    if (hint) {\n\t      h = (hint - (hint % 26)) / 26;\n\t    } else {\n\t      h = 0;\n\t    }\n\n\t    var r = bits % 26;\n\t    var s = Math.min((bits - r) / 26, this.length);\n\t    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t    var maskedWords = extended;\n\n\t    h -= s;\n\t    h = Math.max(0, h);\n\n\t    // Extended mode, copy masked part\n\t    if (maskedWords) {\n\t      for (var i = 0; i < s; i++) {\n\t        maskedWords.words[i] = this.words[i];\n\t      }\n\t      maskedWords.length = s;\n\t    }\n\n\t    if (s === 0) {\n\t      // No-op, we should not move anything at all\n\t    } else if (this.length > s) {\n\t      this.length -= s;\n\t      for (i = 0; i < this.length; i++) {\n\t        this.words[i] = this.words[i + s];\n\t      }\n\t    } else {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    var carry = 0;\n\t    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n\t      var word = this.words[i] | 0;\n\t      this.words[i] = (carry << (26 - r)) | (word >>> r);\n\t      carry = word & mask;\n\t    }\n\n\t    // Push carried bits as a mask\n\t    if (maskedWords && carry !== 0) {\n\t      maskedWords.words[maskedWords.length++] = carry;\n\t    }\n\n\t    if (this.length === 0) {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushrn(bits, hint, extended);\n\t  };\n\n\t  // Shift-left\n\t  BN.prototype.shln = function shln (bits) {\n\t    return this.clone().ishln(bits);\n\t  };\n\n\t  BN.prototype.ushln = function ushln (bits) {\n\t    return this.clone().iushln(bits);\n\t  };\n\n\t  // Shift-right\n\t  BN.prototype.shrn = function shrn (bits) {\n\t    return this.clone().ishrn(bits);\n\t  };\n\n\t  BN.prototype.ushrn = function ushrn (bits) {\n\t    return this.clone().iushrn(bits);\n\t  };\n\n\t  // Test if n bit is set\n\t  BN.prototype.testn = function testn (bit) {\n\t    assert(typeof bit === 'number' && bit >= 0);\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) return false;\n\n\t    // Check bit and return\n\t    var w = this.words[s];\n\n\t    return !!(w & q);\n\t  };\n\n\t  // Return only lowers bits of number (in-place)\n\t  BN.prototype.imaskn = function imaskn (bits) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\n\t    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n\t    if (this.length <= s) {\n\t      return this;\n\t    }\n\n\t    if (r !== 0) {\n\t      s++;\n\t    }\n\t    this.length = Math.min(s, this.length);\n\n\t    if (r !== 0) {\n\t      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t      this.words[this.length - 1] &= mask;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Return only lowers bits of number\n\t  BN.prototype.maskn = function maskn (bits) {\n\t    return this.clone().imaskn(bits);\n\t  };\n\n\t  // Add plain number `num` to `this`\n\t  BN.prototype.iaddn = function iaddn (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.isubn(-num);\n\n\t    // Possible sign change\n\t    if (this.negative !== 0) {\n\t      if (this.length === 1 && (this.words[0] | 0) < num) {\n\t        this.words[0] = num - (this.words[0] | 0);\n\t        this.negative = 0;\n\t        return this;\n\t      }\n\n\t      this.negative = 0;\n\t      this.isubn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    // Add without checks\n\t    return this._iaddn(num);\n\t  };\n\n\t  BN.prototype._iaddn = function _iaddn (num) {\n\t    this.words[0] += num;\n\n\t    // Carry\n\t    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n\t      this.words[i] -= 0x4000000;\n\t      if (i === this.length - 1) {\n\t        this.words[i + 1] = 1;\n\t      } else {\n\t        this.words[i + 1]++;\n\t      }\n\t    }\n\t    this.length = Math.max(this.length, i + 1);\n\n\t    return this;\n\t  };\n\n\t  // Subtract plain number `num` from `this`\n\t  BN.prototype.isubn = function isubn (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.iaddn(-num);\n\n\t    if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iaddn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    this.words[0] -= num;\n\n\t    if (this.length === 1 && this.words[0] < 0) {\n\t      this.words[0] = -this.words[0];\n\t      this.negative = 1;\n\t    } else {\n\t      // Carry\n\t      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n\t        this.words[i] += 0x4000000;\n\t        this.words[i + 1] -= 1;\n\t      }\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.addn = function addn (num) {\n\t    return this.clone().iaddn(num);\n\t  };\n\n\t  BN.prototype.subn = function subn (num) {\n\t    return this.clone().isubn(num);\n\t  };\n\n\t  BN.prototype.iabs = function iabs () {\n\t    this.negative = 0;\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.abs = function abs () {\n\t    return this.clone().iabs();\n\t  };\n\n\t  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n\t    var len = num.length + shift;\n\t    var i;\n\n\t    this._expand(len);\n\n\t    var w;\n\t    var carry = 0;\n\t    for (i = 0; i < num.length; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      var right = (num.words[i] | 0) * mul;\n\t      w -= right & 0x3ffffff;\n\t      carry = (w >> 26) - ((right / 0x4000000) | 0);\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\t    for (; i < this.length - shift; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\n\t    if (carry === 0) return this.strip();\n\n\t    // Subtraction overflow\n\t    assert(carry === -1);\n\t    carry = 0;\n\t    for (i = 0; i < this.length; i++) {\n\t      w = -(this.words[i] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i] = w & 0x3ffffff;\n\t    }\n\t    this.negative = 1;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n\t    var shift = this.length - num.length;\n\n\t    var a = this.clone();\n\t    var b = num;\n\n\t    // Normalize\n\t    var bhi = b.words[b.length - 1] | 0;\n\t    var bhiBits = this._countBits(bhi);\n\t    shift = 26 - bhiBits;\n\t    if (shift !== 0) {\n\t      b = b.ushln(shift);\n\t      a.iushln(shift);\n\t      bhi = b.words[b.length - 1] | 0;\n\t    }\n\n\t    // Initialize quotient\n\t    var m = a.length - b.length;\n\t    var q;\n\n\t    if (mode !== 'mod') {\n\t      q = new BN(null);\n\t      q.length = m + 1;\n\t      q.words = new Array(q.length);\n\t      for (var i = 0; i < q.length; i++) {\n\t        q.words[i] = 0;\n\t      }\n\t    }\n\n\t    var diff = a.clone()._ishlnsubmul(b, 1, m);\n\t    if (diff.negative === 0) {\n\t      a = diff;\n\t      if (q) {\n\t        q.words[m] = 1;\n\t      }\n\t    }\n\n\t    for (var j = m - 1; j >= 0; j--) {\n\t      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n\t        (a.words[b.length + j - 1] | 0);\n\n\t      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n\t      // (0x7ffffff)\n\t      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n\t      a._ishlnsubmul(b, qj, j);\n\t      while (a.negative !== 0) {\n\t        qj--;\n\t        a.negative = 0;\n\t        a._ishlnsubmul(b, 1, j);\n\t        if (!a.isZero()) {\n\t          a.negative ^= 1;\n\t        }\n\t      }\n\t      if (q) {\n\t        q.words[j] = qj;\n\t      }\n\t    }\n\t    if (q) {\n\t      q.strip();\n\t    }\n\t    a.strip();\n\n\t    // Denormalize\n\t    if (mode !== 'div' && shift !== 0) {\n\t      a.iushrn(shift);\n\t    }\n\n\t    return {\n\t      div: q || null,\n\t      mod: a\n\t    };\n\t  };\n\n\t  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n\t  //       to `div` to request div only, or be absent to\n\t  //       request both div & mod\n\t  //       2) `positive` is true if unsigned mod is requested\n\t  BN.prototype.divmod = function divmod (num, mode, positive) {\n\t    assert(!num.isZero());\n\n\t    if (this.isZero()) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: new BN(0)\n\t      };\n\t    }\n\n\t    var div, mod, res;\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      res = this.neg().divmod(num, mode);\n\n\t      if (mode !== 'mod') {\n\t        div = res.div.neg();\n\t      }\n\n\t      if (mode !== 'div') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.iadd(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    if (this.negative === 0 && num.negative !== 0) {\n\t      res = this.divmod(num.neg(), mode);\n\n\t      if (mode !== 'mod') {\n\t        div = res.div.neg();\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: res.mod\n\t      };\n\t    }\n\n\t    if ((this.negative & num.negative) !== 0) {\n\t      res = this.neg().divmod(num.neg(), mode);\n\n\t      if (mode !== 'div') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.isub(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: res.div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    // Both numbers are positive at this point\n\n\t    // Strip both numbers to approximate shift value\n\t    if (num.length > this.length || this.cmp(num) < 0) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: this\n\t      };\n\t    }\n\n\t    // Very short reduction\n\t    if (num.length === 1) {\n\t      if (mode === 'div') {\n\t        return {\n\t          div: this.divn(num.words[0]),\n\t          mod: null\n\t        };\n\t      }\n\n\t      if (mode === 'mod') {\n\t        return {\n\t          div: null,\n\t          mod: new BN(this.modn(num.words[0]))\n\t        };\n\t      }\n\n\t      return {\n\t        div: this.divn(num.words[0]),\n\t        mod: new BN(this.modn(num.words[0]))\n\t      };\n\t    }\n\n\t    return this._wordDiv(num, mode);\n\t  };\n\n\t  // Find `this` / `num`\n\t  BN.prototype.div = function div (num) {\n\t    return this.divmod(num, 'div', false).div;\n\t  };\n\n\t  // Find `this` % `num`\n\t  BN.prototype.mod = function mod (num) {\n\t    return this.divmod(num, 'mod', false).mod;\n\t  };\n\n\t  BN.prototype.umod = function umod (num) {\n\t    return this.divmod(num, 'mod', true).mod;\n\t  };\n\n\t  // Find Round(`this` / `num`)\n\t  BN.prototype.divRound = function divRound (num) {\n\t    var dm = this.divmod(num);\n\n\t    // Fast case - exact division\n\t    if (dm.mod.isZero()) return dm.div;\n\n\t    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n\t    var half = num.ushrn(1);\n\t    var r2 = num.andln(1);\n\t    var cmp = mod.cmp(half);\n\n\t    // Round down\n\t    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n\t    // Round up\n\t    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n\t  };\n\n\t  BN.prototype.modn = function modn (num) {\n\t    assert(num <= 0x3ffffff);\n\t    var p = (1 << 26) % num;\n\n\t    var acc = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      acc = (p * acc + (this.words[i] | 0)) % num;\n\t    }\n\n\t    return acc;\n\t  };\n\n\t  // In-place division by number\n\t  BN.prototype.idivn = function idivn (num) {\n\t    assert(num <= 0x3ffffff);\n\n\t    var carry = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var w = (this.words[i] | 0) + carry * 0x4000000;\n\t      this.words[i] = (w / num) | 0;\n\t      carry = w % num;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.divn = function divn (num) {\n\t    return this.clone().idivn(num);\n\t  };\n\n\t  BN.prototype.egcd = function egcd (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var x = this;\n\t    var y = p.clone();\n\n\t    if (x.negative !== 0) {\n\t      x = x.umod(p);\n\t    } else {\n\t      x = x.clone();\n\t    }\n\n\t    // A * x + B * y = x\n\t    var A = new BN(1);\n\t    var B = new BN(0);\n\n\t    // C * x + D * y = y\n\t    var C = new BN(0);\n\t    var D = new BN(1);\n\n\t    var g = 0;\n\n\t    while (x.isEven() && y.isEven()) {\n\t      x.iushrn(1);\n\t      y.iushrn(1);\n\t      ++g;\n\t    }\n\n\t    var yp = y.clone();\n\t    var xp = x.clone();\n\n\t    while (!x.isZero()) {\n\t      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        x.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (A.isOdd() || B.isOdd()) {\n\t            A.iadd(yp);\n\t            B.isub(xp);\n\t          }\n\n\t          A.iushrn(1);\n\t          B.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        y.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (C.isOdd() || D.isOdd()) {\n\t            C.iadd(yp);\n\t            D.isub(xp);\n\t          }\n\n\t          C.iushrn(1);\n\t          D.iushrn(1);\n\t        }\n\t      }\n\n\t      if (x.cmp(y) >= 0) {\n\t        x.isub(y);\n\t        A.isub(C);\n\t        B.isub(D);\n\t      } else {\n\t        y.isub(x);\n\t        C.isub(A);\n\t        D.isub(B);\n\t      }\n\t    }\n\n\t    return {\n\t      a: C,\n\t      b: D,\n\t      gcd: y.iushln(g)\n\t    };\n\t  };\n\n\t  // This is reduced incarnation of the binary EEA\n\t  // above, designated to invert members of the\n\t  // _prime_ fields F(p) at a maximal speed\n\t  BN.prototype._invmp = function _invmp (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var a = this;\n\t    var b = p.clone();\n\n\t    if (a.negative !== 0) {\n\t      a = a.umod(p);\n\t    } else {\n\t      a = a.clone();\n\t    }\n\n\t    var x1 = new BN(1);\n\t    var x2 = new BN(0);\n\n\t    var delta = b.clone();\n\n\t    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n\t      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        a.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (x1.isOdd()) {\n\t            x1.iadd(delta);\n\t          }\n\n\t          x1.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        b.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (x2.isOdd()) {\n\t            x2.iadd(delta);\n\t          }\n\n\t          x2.iushrn(1);\n\t        }\n\t      }\n\n\t      if (a.cmp(b) >= 0) {\n\t        a.isub(b);\n\t        x1.isub(x2);\n\t      } else {\n\t        b.isub(a);\n\t        x2.isub(x1);\n\t      }\n\t    }\n\n\t    var res;\n\t    if (a.cmpn(1) === 0) {\n\t      res = x1;\n\t    } else {\n\t      res = x2;\n\t    }\n\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(p);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  BN.prototype.gcd = function gcd (num) {\n\t    if (this.isZero()) return num.abs();\n\t    if (num.isZero()) return this.abs();\n\n\t    var a = this.clone();\n\t    var b = num.clone();\n\t    a.negative = 0;\n\t    b.negative = 0;\n\n\t    // Remove common factor of two\n\t    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n\t      a.iushrn(1);\n\t      b.iushrn(1);\n\t    }\n\n\t    do {\n\t      while (a.isEven()) {\n\t        a.iushrn(1);\n\t      }\n\t      while (b.isEven()) {\n\t        b.iushrn(1);\n\t      }\n\n\t      var r = a.cmp(b);\n\t      if (r < 0) {\n\t        // Swap `a` and `b` to make `a` always bigger than `b`\n\t        var t = a;\n\t        a = b;\n\t        b = t;\n\t      } else if (r === 0 || b.cmpn(1) === 0) {\n\t        break;\n\t      }\n\n\t      a.isub(b);\n\t    } while (true);\n\n\t    return b.iushln(shift);\n\t  };\n\n\t  // Invert number in the field F(num)\n\t  BN.prototype.invm = function invm (num) {\n\t    return this.egcd(num).a.umod(num);\n\t  };\n\n\t  BN.prototype.isEven = function isEven () {\n\t    return (this.words[0] & 1) === 0;\n\t  };\n\n\t  BN.prototype.isOdd = function isOdd () {\n\t    return (this.words[0] & 1) === 1;\n\t  };\n\n\t  // And first word and num\n\t  BN.prototype.andln = function andln (num) {\n\t    return this.words[0] & num;\n\t  };\n\n\t  // Increment at the bit position in-line\n\t  BN.prototype.bincn = function bincn (bit) {\n\t    assert(typeof bit === 'number');\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) {\n\t      this._expand(s + 1);\n\t      this.words[s] |= q;\n\t      return this;\n\t    }\n\n\t    // Add bit and propagate, if needed\n\t    var carry = q;\n\t    for (var i = s; carry !== 0 && i < this.length; i++) {\n\t      var w = this.words[i] | 0;\n\t      w += carry;\n\t      carry = w >>> 26;\n\t      w &= 0x3ffffff;\n\t      this.words[i] = w;\n\t    }\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.isZero = function isZero () {\n\t    return this.length === 1 && this.words[0] === 0;\n\t  };\n\n\t  BN.prototype.cmpn = function cmpn (num) {\n\t    var negative = num < 0;\n\n\t    if (this.negative !== 0 && !negative) return -1;\n\t    if (this.negative === 0 && negative) return 1;\n\n\t    this.strip();\n\n\t    var res;\n\t    if (this.length > 1) {\n\t      res = 1;\n\t    } else {\n\t      if (negative) {\n\t        num = -num;\n\t      }\n\n\t      assert(num <= 0x3ffffff, 'Number is too big');\n\n\t      var w = this.words[0] | 0;\n\t      res = w === num ? 0 : w < num ? -1 : 1;\n\t    }\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Compare two numbers and return:\n\t  // 1 - if `this` > `num`\n\t  // 0 - if `this` == `num`\n\t  // -1 - if `this` < `num`\n\t  BN.prototype.cmp = function cmp (num) {\n\t    if (this.negative !== 0 && num.negative === 0) return -1;\n\t    if (this.negative === 0 && num.negative !== 0) return 1;\n\n\t    var res = this.ucmp(num);\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Unsigned comparison\n\t  BN.prototype.ucmp = function ucmp (num) {\n\t    // At this point both numbers have the same sign\n\t    if (this.length > num.length) return 1;\n\t    if (this.length < num.length) return -1;\n\n\t    var res = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var a = this.words[i] | 0;\n\t      var b = num.words[i] | 0;\n\n\t      if (a === b) continue;\n\t      if (a < b) {\n\t        res = -1;\n\t      } else if (a > b) {\n\t        res = 1;\n\t      }\n\t      break;\n\t    }\n\t    return res;\n\t  };\n\n\t  BN.prototype.gtn = function gtn (num) {\n\t    return this.cmpn(num) === 1;\n\t  };\n\n\t  BN.prototype.gt = function gt (num) {\n\t    return this.cmp(num) === 1;\n\t  };\n\n\t  BN.prototype.gten = function gten (num) {\n\t    return this.cmpn(num) >= 0;\n\t  };\n\n\t  BN.prototype.gte = function gte (num) {\n\t    return this.cmp(num) >= 0;\n\t  };\n\n\t  BN.prototype.ltn = function ltn (num) {\n\t    return this.cmpn(num) === -1;\n\t  };\n\n\t  BN.prototype.lt = function lt (num) {\n\t    return this.cmp(num) === -1;\n\t  };\n\n\t  BN.prototype.lten = function lten (num) {\n\t    return this.cmpn(num) <= 0;\n\t  };\n\n\t  BN.prototype.lte = function lte (num) {\n\t    return this.cmp(num) <= 0;\n\t  };\n\n\t  BN.prototype.eqn = function eqn (num) {\n\t    return this.cmpn(num) === 0;\n\t  };\n\n\t  BN.prototype.eq = function eq (num) {\n\t    return this.cmp(num) === 0;\n\t  };\n\n\t  //\n\t  // A reduce context, could be using montgomery or something better, depending\n\t  // on the `m` itself.\n\t  //\n\t  BN.red = function red (num) {\n\t    return new Red(num);\n\t  };\n\n\t  BN.prototype.toRed = function toRed (ctx) {\n\t    assert(!this.red, 'Already a number in reduction context');\n\t    assert(this.negative === 0, 'red works only with positives');\n\t    return ctx.convertTo(this)._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.fromRed = function fromRed () {\n\t    assert(this.red, 'fromRed works only with numbers in reduction context');\n\t    return this.red.convertFrom(this);\n\t  };\n\n\t  BN.prototype._forceRed = function _forceRed (ctx) {\n\t    this.red = ctx;\n\t    return this;\n\t  };\n\n\t  BN.prototype.forceRed = function forceRed (ctx) {\n\t    assert(!this.red, 'Already a number in reduction context');\n\t    return this._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.redAdd = function redAdd (num) {\n\t    assert(this.red, 'redAdd works only with red numbers');\n\t    return this.red.add(this, num);\n\t  };\n\n\t  BN.prototype.redIAdd = function redIAdd (num) {\n\t    assert(this.red, 'redIAdd works only with red numbers');\n\t    return this.red.iadd(this, num);\n\t  };\n\n\t  BN.prototype.redSub = function redSub (num) {\n\t    assert(this.red, 'redSub works only with red numbers');\n\t    return this.red.sub(this, num);\n\t  };\n\n\t  BN.prototype.redISub = function redISub (num) {\n\t    assert(this.red, 'redISub works only with red numbers');\n\t    return this.red.isub(this, num);\n\t  };\n\n\t  BN.prototype.redShl = function redShl (num) {\n\t    assert(this.red, 'redShl works only with red numbers');\n\t    return this.red.shl(this, num);\n\t  };\n\n\t  BN.prototype.redMul = function redMul (num) {\n\t    assert(this.red, 'redMul works only with red numbers');\n\t    this.red._verify2(this, num);\n\t    return this.red.mul(this, num);\n\t  };\n\n\t  BN.prototype.redIMul = function redIMul (num) {\n\t    assert(this.red, 'redMul works only with red numbers');\n\t    this.red._verify2(this, num);\n\t    return this.red.imul(this, num);\n\t  };\n\n\t  BN.prototype.redSqr = function redSqr () {\n\t    assert(this.red, 'redSqr works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.sqr(this);\n\t  };\n\n\t  BN.prototype.redISqr = function redISqr () {\n\t    assert(this.red, 'redISqr works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.isqr(this);\n\t  };\n\n\t  // Square root over p\n\t  BN.prototype.redSqrt = function redSqrt () {\n\t    assert(this.red, 'redSqrt works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.sqrt(this);\n\t  };\n\n\t  BN.prototype.redInvm = function redInvm () {\n\t    assert(this.red, 'redInvm works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.invm(this);\n\t  };\n\n\t  // Return negative clone of `this` % `red modulo`\n\t  BN.prototype.redNeg = function redNeg () {\n\t    assert(this.red, 'redNeg works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.neg(this);\n\t  };\n\n\t  BN.prototype.redPow = function redPow (num) {\n\t    assert(this.red && !num.red, 'redPow(normalNum)');\n\t    this.red._verify1(this);\n\t    return this.red.pow(this, num);\n\t  };\n\n\t  // Prime numbers with efficient reduction\n\t  var primes = {\n\t    k256: null,\n\t    p224: null,\n\t    p192: null,\n\t    p25519: null\n\t  };\n\n\t  // Pseudo-Mersenne prime\n\t  function MPrime (name, p) {\n\t    // P = 2 ^ N - K\n\t    this.name = name;\n\t    this.p = new BN(p, 16);\n\t    this.n = this.p.bitLength();\n\t    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n\t    this.tmp = this._tmp();\n\t  }\n\n\t  MPrime.prototype._tmp = function _tmp () {\n\t    var tmp = new BN(null);\n\t    tmp.words = new Array(Math.ceil(this.n / 13));\n\t    return tmp;\n\t  };\n\n\t  MPrime.prototype.ireduce = function ireduce (num) {\n\t    // Assumes that `num` is less than `P^2`\n\t    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n\t    var r = num;\n\t    var rlen;\n\n\t    do {\n\t      this.split(r, this.tmp);\n\t      r = this.imulK(r);\n\t      r = r.iadd(this.tmp);\n\t      rlen = r.bitLength();\n\t    } while (rlen > this.n);\n\n\t    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\t    if (cmp === 0) {\n\t      r.words[0] = 0;\n\t      r.length = 1;\n\t    } else if (cmp > 0) {\n\t      r.isub(this.p);\n\t    } else {\n\t      r.strip();\n\t    }\n\n\t    return r;\n\t  };\n\n\t  MPrime.prototype.split = function split (input, out) {\n\t    input.iushrn(this.n, 0, out);\n\t  };\n\n\t  MPrime.prototype.imulK = function imulK (num) {\n\t    return num.imul(this.k);\n\t  };\n\n\t  function K256 () {\n\t    MPrime.call(\n\t      this,\n\t      'k256',\n\t      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n\t  }\n\t  inherits(K256, MPrime);\n\n\t  K256.prototype.split = function split (input, output) {\n\t    // 256 = 9 * 26 + 22\n\t    var mask = 0x3fffff;\n\n\t    var outLen = Math.min(input.length, 9);\n\t    for (var i = 0; i < outLen; i++) {\n\t      output.words[i] = input.words[i];\n\t    }\n\t    output.length = outLen;\n\n\t    if (input.length <= 9) {\n\t      input.words[0] = 0;\n\t      input.length = 1;\n\t      return;\n\t    }\n\n\t    // Shift by 9 limbs\n\t    var prev = input.words[9];\n\t    output.words[output.length++] = prev & mask;\n\n\t    for (i = 10; i < input.length; i++) {\n\t      var next = input.words[i] | 0;\n\t      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n\t      prev = next;\n\t    }\n\t    prev >>>= 22;\n\t    input.words[i - 10] = prev;\n\t    if (prev === 0 && input.length > 10) {\n\t      input.length -= 10;\n\t    } else {\n\t      input.length -= 9;\n\t    }\n\t  };\n\n\t  K256.prototype.imulK = function imulK (num) {\n\t    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n\t    num.words[num.length] = 0;\n\t    num.words[num.length + 1] = 0;\n\t    num.length += 2;\n\n\t    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\t    var lo = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var w = num.words[i] | 0;\n\t      lo += w * 0x3d1;\n\t      num.words[i] = lo & 0x3ffffff;\n\t      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n\t    }\n\n\t    // Fast length reduction\n\t    if (num.words[num.length - 1] === 0) {\n\t      num.length--;\n\t      if (num.words[num.length - 1] === 0) {\n\t        num.length--;\n\t      }\n\t    }\n\t    return num;\n\t  };\n\n\t  function P224 () {\n\t    MPrime.call(\n\t      this,\n\t      'p224',\n\t      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n\t  }\n\t  inherits(P224, MPrime);\n\n\t  function P192 () {\n\t    MPrime.call(\n\t      this,\n\t      'p192',\n\t      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n\t  }\n\t  inherits(P192, MPrime);\n\n\t  function P25519 () {\n\t    // 2 ^ 255 - 19\n\t    MPrime.call(\n\t      this,\n\t      '25519',\n\t      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n\t  }\n\t  inherits(P25519, MPrime);\n\n\t  P25519.prototype.imulK = function imulK (num) {\n\t    // K = 0x13\n\t    var carry = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var hi = (num.words[i] | 0) * 0x13 + carry;\n\t      var lo = hi & 0x3ffffff;\n\t      hi >>>= 26;\n\n\t      num.words[i] = lo;\n\t      carry = hi;\n\t    }\n\t    if (carry !== 0) {\n\t      num.words[num.length++] = carry;\n\t    }\n\t    return num;\n\t  };\n\n\t  // Exported mostly for testing purposes, use plain name instead\n\t  BN._prime = function prime (name) {\n\t    // Cached version of prime\n\t    if (primes[name]) return primes[name];\n\n\t    var prime;\n\t    if (name === 'k256') {\n\t      prime = new K256();\n\t    } else if (name === 'p224') {\n\t      prime = new P224();\n\t    } else if (name === 'p192') {\n\t      prime = new P192();\n\t    } else if (name === 'p25519') {\n\t      prime = new P25519();\n\t    } else {\n\t      throw new Error('Unknown prime ' + name);\n\t    }\n\t    primes[name] = prime;\n\n\t    return prime;\n\t  };\n\n\t  //\n\t  // Base reduction engine\n\t  //\n\t  function Red (m) {\n\t    if (typeof m === 'string') {\n\t      var prime = BN._prime(m);\n\t      this.m = prime.p;\n\t      this.prime = prime;\n\t    } else {\n\t      assert(m.gtn(1), 'modulus must be greater than 1');\n\t      this.m = m;\n\t      this.prime = null;\n\t    }\n\t  }\n\n\t  Red.prototype._verify1 = function _verify1 (a) {\n\t    assert(a.negative === 0, 'red works only with positives');\n\t    assert(a.red, 'red works only with red numbers');\n\t  };\n\n\t  Red.prototype._verify2 = function _verify2 (a, b) {\n\t    assert((a.negative | b.negative) === 0, 'red works only with positives');\n\t    assert(a.red && a.red === b.red,\n\t      'red works only with red numbers');\n\t  };\n\n\t  Red.prototype.imod = function imod (a) {\n\t    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\t    return a.umod(this.m)._forceRed(this);\n\t  };\n\n\t  Red.prototype.neg = function neg (a) {\n\t    if (a.isZero()) {\n\t      return a.clone();\n\t    }\n\n\t    return this.m.sub(a)._forceRed(this);\n\t  };\n\n\t  Red.prototype.add = function add (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.add(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.iadd = function iadd (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.iadd(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.sub = function sub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.sub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.isub = function isub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.isub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.shl = function shl (a, num) {\n\t    this._verify1(a);\n\t    return this.imod(a.ushln(num));\n\t  };\n\n\t  Red.prototype.imul = function imul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.imul(b));\n\t  };\n\n\t  Red.prototype.mul = function mul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.mul(b));\n\t  };\n\n\t  Red.prototype.isqr = function isqr (a) {\n\t    return this.imul(a, a.clone());\n\t  };\n\n\t  Red.prototype.sqr = function sqr (a) {\n\t    return this.mul(a, a);\n\t  };\n\n\t  Red.prototype.sqrt = function sqrt (a) {\n\t    if (a.isZero()) return a.clone();\n\n\t    var mod3 = this.m.andln(3);\n\t    assert(mod3 % 2 === 1);\n\n\t    // Fast case\n\t    if (mod3 === 3) {\n\t      var pow = this.m.add(new BN(1)).iushrn(2);\n\t      return this.pow(a, pow);\n\t    }\n\n\t    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n\t    //\n\t    // Find Q and S, that Q * 2 ^ S = (P - 1)\n\t    var q = this.m.subn(1);\n\t    var s = 0;\n\t    while (!q.isZero() && q.andln(1) === 0) {\n\t      s++;\n\t      q.iushrn(1);\n\t    }\n\t    assert(!q.isZero());\n\n\t    var one = new BN(1).toRed(this);\n\t    var nOne = one.redNeg();\n\n\t    // Find quadratic non-residue\n\t    // NOTE: Max is such because of generalized Riemann hypothesis.\n\t    var lpow = this.m.subn(1).iushrn(1);\n\t    var z = this.m.bitLength();\n\t    z = new BN(2 * z * z).toRed(this);\n\n\t    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n\t      z.redIAdd(nOne);\n\t    }\n\n\t    var c = this.pow(z, q);\n\t    var r = this.pow(a, q.addn(1).iushrn(1));\n\t    var t = this.pow(a, q);\n\t    var m = s;\n\t    while (t.cmp(one) !== 0) {\n\t      var tmp = t;\n\t      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n\t        tmp = tmp.redSqr();\n\t      }\n\t      assert(i < m);\n\t      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n\t      r = r.redMul(b);\n\t      c = b.redSqr();\n\t      t = t.redMul(c);\n\t      m = i;\n\t    }\n\n\t    return r;\n\t  };\n\n\t  Red.prototype.invm = function invm (a) {\n\t    var inv = a._invmp(this.m);\n\t    if (inv.negative !== 0) {\n\t      inv.negative = 0;\n\t      return this.imod(inv).redNeg();\n\t    } else {\n\t      return this.imod(inv);\n\t    }\n\t  };\n\n\t  Red.prototype.pow = function pow (a, num) {\n\t    if (num.isZero()) return new BN(1).toRed(this);\n\t    if (num.cmpn(1) === 0) return a.clone();\n\n\t    var windowSize = 4;\n\t    var wnd = new Array(1 << windowSize);\n\t    wnd[0] = new BN(1).toRed(this);\n\t    wnd[1] = a;\n\t    for (var i = 2; i < wnd.length; i++) {\n\t      wnd[i] = this.mul(wnd[i - 1], a);\n\t    }\n\n\t    var res = wnd[0];\n\t    var current = 0;\n\t    var currentLen = 0;\n\t    var start = num.bitLength() % 26;\n\t    if (start === 0) {\n\t      start = 26;\n\t    }\n\n\t    for (i = num.length - 1; i >= 0; i--) {\n\t      var word = num.words[i];\n\t      for (var j = start - 1; j >= 0; j--) {\n\t        var bit = (word >> j) & 1;\n\t        if (res !== wnd[0]) {\n\t          res = this.sqr(res);\n\t        }\n\n\t        if (bit === 0 && current === 0) {\n\t          currentLen = 0;\n\t          continue;\n\t        }\n\n\t        current <<= 1;\n\t        current |= bit;\n\t        currentLen++;\n\t        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n\t        res = this.mul(res, wnd[current]);\n\t        currentLen = 0;\n\t        current = 0;\n\t      }\n\t      start = 26;\n\t    }\n\n\t    return res;\n\t  };\n\n\t  Red.prototype.convertTo = function convertTo (num) {\n\t    var r = num.umod(this.m);\n\n\t    return r === num ? r.clone() : r;\n\t  };\n\n\t  Red.prototype.convertFrom = function convertFrom (num) {\n\t    var res = num.clone();\n\t    res.red = null;\n\t    return res;\n\t  };\n\n\t  //\n\t  // Montgomery method engine\n\t  //\n\n\t  BN.mont = function mont (num) {\n\t    return new Mont(num);\n\t  };\n\n\t  function Mont (m) {\n\t    Red.call(this, m);\n\n\t    this.shift = this.m.bitLength();\n\t    if (this.shift % 26 !== 0) {\n\t      this.shift += 26 - (this.shift % 26);\n\t    }\n\n\t    this.r = new BN(1).iushln(this.shift);\n\t    this.r2 = this.imod(this.r.sqr());\n\t    this.rinv = this.r._invmp(this.m);\n\n\t    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n\t    this.minv = this.minv.umod(this.r);\n\t    this.minv = this.r.sub(this.minv);\n\t  }\n\t  inherits(Mont, Red);\n\n\t  Mont.prototype.convertTo = function convertTo (num) {\n\t    return this.imod(num.ushln(this.shift));\n\t  };\n\n\t  Mont.prototype.convertFrom = function convertFrom (num) {\n\t    var r = this.imod(num.mul(this.rinv));\n\t    r.red = null;\n\t    return r;\n\t  };\n\n\t  Mont.prototype.imul = function imul (a, b) {\n\t    if (a.isZero() || b.isZero()) {\n\t      a.words[0] = 0;\n\t      a.length = 1;\n\t      return a;\n\t    }\n\n\t    var t = a.imul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.mul = function mul (a, b) {\n\t    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n\t    var t = a.mul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.invm = function invm (a) {\n\t    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\t    var res = this.imod(a._invmp(this.m).mul(this.r2));\n\t    return res._forceRed(this);\n\t  };\n\t})( false || module, commonjsGlobal);\n\t});\n\tvar bn_1 = bn.BN;\n\n\tvar _version = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"logger/5.0.0-beta.137\";\n\t});\n\n\tvar _version$1 = unwrapExports(_version);\n\tvar _version_1 = _version.version;\n\n\tvar lib = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar _permanentCensorErrors = false;\n\tvar _censorErrors = false;\n\tvar LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\n\tvar _logLevel = LogLevels[\"default\"];\n\n\tvar _globalLogger = null;\n\tfunction _checkNormalize() {\n\t    try {\n\t        var missing_1 = [];\n\t        // Make sure all forms of normalization are supported\n\t        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n\t            try {\n\t                if (\"test\".normalize(form) !== \"test\") {\n\t                    throw new Error(\"bad normalize\");\n\t                }\n\t                ;\n\t            }\n\t            catch (error) {\n\t                missing_1.push(form);\n\t            }\n\t        });\n\t        if (missing_1.length) {\n\t            throw new Error(\"missing \" + missing_1.join(\", \"));\n\t        }\n\t        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n\t            throw new Error(\"broken implementation\");\n\t        }\n\t    }\n\t    catch (error) {\n\t        return error.message;\n\t    }\n\t    return null;\n\t}\n\tvar _normalizeError = _checkNormalize();\n\tvar LogLevel;\n\t(function (LogLevel) {\n\t    LogLevel[\"DEBUG\"] = \"DEBUG\";\n\t    LogLevel[\"INFO\"] = \"INFO\";\n\t    LogLevel[\"WARNING\"] = \"WARNING\";\n\t    LogLevel[\"ERROR\"] = \"ERROR\";\n\t    LogLevel[\"OFF\"] = \"OFF\";\n\t})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\tvar ErrorCode;\n\t(function (ErrorCode) {\n\t    ///////////////////\n\t    // Generic Errors\n\t    // Unknown Error\n\t    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n\t    // Not Implemented\n\t    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n\t    // Unsupported Operation\n\t    //   - operation\n\t    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n\t    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n\t    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n\t    // Some sort of bad response from the server\n\t    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n\t    // Timeout\n\t    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n\t    ///////////////////\n\t    // Operational  Errors\n\t    // Buffer Overrun\n\t    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n\t    // Numeric Fault\n\t    //   - operation: the operation being executed\n\t    //   - fault: the reason this faulted\n\t    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n\t    ///////////////////\n\t    // Argument Errors\n\t    // Missing new operator to an object\n\t    //  - name: The name of the class\n\t    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n\t    // Invalid argument (e.g. value is incompatible with type) to a function:\n\t    //   - argument: The argument name that was invalid\n\t    //   - value: The value of the argument\n\t    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n\t    // Missing argument to a function:\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n\t    // Too many arguments\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n\t    ///////////////////\n\t    // Blockchain Errors\n\t    // Call exception\n\t    //  - transaction: the transaction\n\t    //  - address?: the contract address\n\t    //  - args?: The arguments passed into the function\n\t    //  - method?: The Solidity method signature\n\t    //  - errorSignature?: The EIP848 error signature\n\t    //  - errorArgs?: The EIP848 error parameters\n\t    //  - reason: The reason (only for EIP848 \"Error(string)\")\n\t    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n\t    // Insufficien funds (< value + gasLimit * gasPrice)\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n\t    // Nonce has already been used\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n\t    // The replacement fee for the transaction is too low\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n\t    // The gas limit could not be estimated\n\t    //   - transaction: the transaction passed to estimateGas\n\t    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n\t})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));\n\t;\n\tvar Logger = /** @class */ (function () {\n\t    function Logger(version) {\n\t        Object.defineProperty(this, \"version\", {\n\t            enumerable: true,\n\t            value: version,\n\t            writable: false\n\t        });\n\t    }\n\t    Logger.prototype._log = function (logLevel, args) {\n\t        var level = logLevel.toLowerCase();\n\t        if (LogLevels[level] == null) {\n\t            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n\t        }\n\t        if (_logLevel > LogLevels[level]) {\n\t            return;\n\t        }\n\t        console.log.apply(console, args);\n\t    };\n\t    Logger.prototype.debug = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.DEBUG, args);\n\t    };\n\t    Logger.prototype.info = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.INFO, args);\n\t    };\n\t    Logger.prototype.warn = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.WARNING, args);\n\t    };\n\t    Logger.prototype.makeError = function (message, code, params) {\n\t        // Errors are being censored\n\t        if (_censorErrors) {\n\t            return this.makeError(\"censored error\", code, {});\n\t        }\n\t        if (!code) {\n\t            code = Logger.errors.UNKNOWN_ERROR;\n\t        }\n\t        if (!params) {\n\t            params = {};\n\t        }\n\t        var messageDetails = [];\n\t        Object.keys(params).forEach(function (key) {\n\t            try {\n\t                messageDetails.push(key + \"=\" + JSON.stringify(params[key]));\n\t            }\n\t            catch (error) {\n\t                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n\t            }\n\t        });\n\t        messageDetails.push(\"code=\" + code);\n\t        messageDetails.push(\"version=\" + this.version);\n\t        var reason = message;\n\t        if (messageDetails.length) {\n\t            message += \" (\" + messageDetails.join(\", \") + \")\";\n\t        }\n\t        // @TODO: Any??\n\t        var error = new Error(message);\n\t        error.reason = reason;\n\t        error.code = code;\n\t        Object.keys(params).forEach(function (key) {\n\t            error[key] = params[key];\n\t        });\n\t        return error;\n\t    };\n\t    Logger.prototype.throwError = function (message, code, params) {\n\t        throw this.makeError(message, code, params);\n\t    };\n\t    Logger.prototype.throwArgumentError = function (message, name, value) {\n\t        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n\t            argument: name,\n\t            value: value\n\t        });\n\t    };\n\t    Logger.prototype.checkNormalize = function (message) {\n\t        if (message == null) {\n\t            message = \"platform missing String.prototype.normalize\";\n\t        }\n\t        if (_normalizeError) {\n\t            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"String.prototype.normalize\", form: _normalizeError\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkSafeUint53 = function (value, message) {\n\t        if (typeof (value) !== \"number\") {\n\t            return;\n\t        }\n\t        if (message == null) {\n\t            message = \"value not safe\";\n\t        }\n\t        if (value < 0 || value >= 0x1fffffffffffff) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: \"checkSafeInteger\",\n\t                fault: \"out-of-safe-range\",\n\t                value: value\n\t            });\n\t        }\n\t        if (value % 1) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: \"checkSafeInteger\",\n\t                fault: \"non-integer\",\n\t                value: value\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {\n\t        if (message) {\n\t            message = \": \" + message;\n\t        }\n\t        else {\n\t            message = \"\";\n\t        }\n\t        if (count < expectedCount) {\n\t            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t        if (count > expectedCount) {\n\t            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkNew = function (target, kind) {\n\t        if (target === Object || target == null) {\n\t            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.prototype.checkAbstract = function (target, kind) {\n\t        if (target === kind) {\n\t            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n\t        }\n\t        else if (target === Object || target == null) {\n\t            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.globalLogger = function () {\n\t        if (!_globalLogger) {\n\t            _globalLogger = new Logger(_version.version);\n\t        }\n\t        return _globalLogger;\n\t    };\n\t    Logger.setCensorship = function (censorship, permanent) {\n\t        if (!censorship && permanent) {\n\t            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setCensorship\"\n\t            });\n\t        }\n\t        if (_permanentCensorErrors) {\n\t            if (!censorship) {\n\t                return;\n\t            }\n\t            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setCensorship\"\n\t            });\n\t        }\n\t        _censorErrors = !!censorship;\n\t        _permanentCensorErrors = !!permanent;\n\t    };\n\t    Logger.setLogLevel = function (logLevel) {\n\t        var level = LogLevels[logLevel];\n\t        if (level == null) {\n\t            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n\t            return;\n\t        }\n\t        _logLevel = level;\n\t    };\n\t    Logger.errors = ErrorCode;\n\t    Logger.levels = LogLevel;\n\t    return Logger;\n\t}());\n\texports.Logger = Logger;\n\t});\n\n\tvar index = unwrapExports(lib);\n\tvar lib_1 = lib.LogLevel;\n\tvar lib_2 = lib.ErrorCode;\n\tvar lib_3 = lib.Logger;\n\n\tvar _version$2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"bytes/5.0.0-beta.138\";\n\t});\n\n\tvar _version$3 = unwrapExports(_version$2);\n\tvar _version_1$1 = _version$2.version;\n\n\tvar lib$1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$2.version);\n\t///////////////////////////////\n\tfunction isHexable(value) {\n\t    return !!(value.toHexString);\n\t}\n\tfunction addSlice(array) {\n\t    if (array.slice) {\n\t        return array;\n\t    }\n\t    array.slice = function () {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n\t    };\n\t    return array;\n\t}\n\tfunction isBytesLike(value) {\n\t    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n\t}\n\texports.isBytesLike = isBytesLike;\n\tfunction isBytes(value) {\n\t    if (value == null) {\n\t        return false;\n\t    }\n\t    if (value.constructor === Uint8Array) {\n\t        return true;\n\t    }\n\t    if (typeof (value) === \"string\") {\n\t        return false;\n\t    }\n\t    if (value.length == null) {\n\t        return false;\n\t    }\n\t    for (var i = 0; i < value.length; i++) {\n\t        var v = value[i];\n\t        if (v < 0 || v >= 256 || (v % 1)) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\texports.isBytes = isBytes;\n\tfunction arrayify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === \"number\") {\n\t        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\t        var result = [];\n\t        while (value) {\n\t            result.unshift(value & 0xff);\n\t            value = parseInt(String(value / 256));\n\t        }\n\t        if (result.length === 0) {\n\t            result.push(0);\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        value = value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        var hex = value.substring(2);\n\t        if (hex.length % 2) {\n\t            if (options.hexPad === \"left\") {\n\t                hex = \"0x0\" + hex.substring(2);\n\t            }\n\t            else if (options.hexPad === \"right\") {\n\t                hex += \"0\";\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n\t            }\n\t        }\n\t        var result = [];\n\t        for (var i = 0; i < hex.length; i += 2) {\n\t            result.push(parseInt(hex.substring(i, i + 2), 16));\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (isBytes(value)) {\n\t        return addSlice(new Uint8Array(value));\n\t    }\n\t    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n\t}\n\texports.arrayify = arrayify;\n\tfunction concat(items) {\n\t    var objects = items.map(function (item) { return arrayify(item); });\n\t    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n\t    var result = new Uint8Array(length);\n\t    objects.reduce(function (offset, object) {\n\t        result.set(object, offset);\n\t        return offset + object.length;\n\t    }, 0);\n\t    return addSlice(result);\n\t}\n\texports.concat = concat;\n\tfunction stripZeros(value) {\n\t    var result = arrayify(value);\n\t    if (result.length === 0) {\n\t        return result;\n\t    }\n\t    // Find the first non-zero entry\n\t    var start = 0;\n\t    while (start < result.length && result[start] === 0) {\n\t        start++;\n\t    }\n\t    // If we started with zeros, strip them\n\t    if (start) {\n\t        result = result.slice(start);\n\t    }\n\t    return result;\n\t}\n\texports.stripZeros = stripZeros;\n\tfunction zeroPad(value, length) {\n\t    value = arrayify(value);\n\t    if (value.length > length) {\n\t        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    result.set(value, length - value.length);\n\t    return addSlice(result);\n\t}\n\texports.zeroPad = zeroPad;\n\tfunction isHexString(value, length) {\n\t    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n\t        return false;\n\t    }\n\t    if (length && value.length !== 2 + 2 * length) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\texports.isHexString = isHexString;\n\tvar HexCharacters = \"0123456789abcdef\";\n\tfunction hexlify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === \"number\") {\n\t        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\t        var hex = \"\";\n\t        while (value) {\n\t            hex = HexCharacters[value & 0x0f] + hex;\n\t            value = Math.floor(value / 16);\n\t        }\n\t        if (hex.length) {\n\t            if (hex.length % 2) {\n\t                hex = \"0\" + hex;\n\t            }\n\t            return \"0x\" + hex;\n\t        }\n\t        return \"0x00\";\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        return value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        if (value.length % 2) {\n\t            if (options.hexPad === \"left\") {\n\t                value = \"0x0\" + value.substring(2);\n\t            }\n\t            else if (options.hexPad === \"right\") {\n\t                value += \"0\";\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n\t            }\n\t        }\n\t        return value.toLowerCase();\n\t    }\n\t    if (isBytes(value)) {\n\t        var result = \"0x\";\n\t        for (var i = 0; i < value.length; i++) {\n\t            var v = value[i];\n\t            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n\t}\n\texports.hexlify = hexlify;\n\t/*\n\tfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n\t    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n\t        return \"0x0\" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\t*/\n\tfunction hexDataLength(data) {\n\t    if (typeof (data) !== \"string\") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        return null;\n\t    }\n\t    return (data.length - 2) / 2;\n\t}\n\texports.hexDataLength = hexDataLength;\n\tfunction hexDataSlice(data, offset, endOffset) {\n\t    if (typeof (data) !== \"string\") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n\t    }\n\t    offset = 2 + 2 * offset;\n\t    if (endOffset != null) {\n\t        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n\t    }\n\t    return \"0x\" + data.substring(offset);\n\t}\n\texports.hexDataSlice = hexDataSlice;\n\tfunction hexConcat(items) {\n\t    var result = \"0x\";\n\t    items.forEach(function (item) {\n\t        result += hexlify(item).substring(2);\n\t    });\n\t    return result;\n\t}\n\texports.hexConcat = hexConcat;\n\tfunction hexValue(value) {\n\t    var trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n\t    if (trimmed === \"0x\") {\n\t        return \"0x0\";\n\t    }\n\t    return trimmed;\n\t}\n\texports.hexValue = hexValue;\n\tfunction hexStripZeros(value) {\n\t    if (typeof (value) !== \"string\") {\n\t        value = hexlify(value);\n\t    }\n\t    if (!isHexString(value)) {\n\t        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n\t    }\n\t    value = value.substring(2);\n\t    var offset = 0;\n\t    while (offset < value.length && value[offset] === \"0\") {\n\t        offset++;\n\t    }\n\t    return \"0x\" + value.substring(offset);\n\t}\n\texports.hexStripZeros = hexStripZeros;\n\tfunction hexZeroPad(value, length) {\n\t    if (typeof (value) !== \"string\") {\n\t        value = hexlify(value);\n\t    }\n\t    else if (!isHexString(value)) {\n\t        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n\t    }\n\t    if (value.length > 2 * length + 2) {\n\t        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n\t    }\n\t    while (value.length < 2 * length + 2) {\n\t        value = \"0x0\" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\texports.hexZeroPad = hexZeroPad;\n\tfunction splitSignature(signature) {\n\t    var result = {\n\t        r: \"0x\",\n\t        s: \"0x\",\n\t        _vs: \"0x\",\n\t        recoveryParam: 0,\n\t        v: 0\n\t    };\n\t    if (isBytesLike(signature)) {\n\t        var bytes = arrayify(signature);\n\t        if (bytes.length !== 65) {\n\t            logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n\t        }\n\t        // Get the r, s and v\n\t        result.r = hexlify(bytes.slice(0, 32));\n\t        result.s = hexlify(bytes.slice(32, 64));\n\t        result.v = bytes[64];\n\t        // Compute recoveryParam from v\n\t        result.recoveryParam = 1 - (result.v % 2);\n\t        // Allow a recid to be used as the v\n\t        if (result.v < 27) {\n\t            if (result.v === 0 || result.v === 1) {\n\t                result.v += 27;\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n\t            }\n\t        }\n\t        // Compute _vs from recoveryParam and s\n\t        if (result.recoveryParam) {\n\t            bytes[32] |= 0x80;\n\t        }\n\t        result._vs = hexlify(bytes.slice(32, 64));\n\t    }\n\t    else {\n\t        result.r = signature.r;\n\t        result.s = signature.s;\n\t        result.v = signature.v;\n\t        result.recoveryParam = signature.recoveryParam;\n\t        result._vs = signature._vs;\n\t        // If the _vs is available, use it to populate missing s, v and recoveryParam\n\t        // and verify non-missing s, v and recoveryParam\n\t        if (result._vs != null) {\n\t            var vs_1 = zeroPad(arrayify(result._vs), 32);\n\t            result._vs = hexlify(vs_1);\n\t            // Set or check the recid\n\t            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n\t            if (result.recoveryParam == null) {\n\t                result.recoveryParam = recoveryParam;\n\t            }\n\t            else if (result.recoveryParam !== recoveryParam) {\n\t                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n\t            }\n\t            // Set or check the s\n\t            vs_1[0] &= 0x7f;\n\t            var s = hexlify(vs_1);\n\t            if (result.s == null) {\n\t                result.s = s;\n\t            }\n\t            else if (result.s !== s) {\n\t                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n\t            }\n\t        }\n\t        // Use recid and v to populate each other\n\t        if (result.recoveryParam == null) {\n\t            if (result.v == null) {\n\t                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n\t            }\n\t            else {\n\t                result.recoveryParam = 1 - (result.v % 2);\n\t            }\n\t        }\n\t        else {\n\t            if (result.v == null) {\n\t                result.v = 27 + result.recoveryParam;\n\t            }\n\t            else if (result.recoveryParam !== (1 - (result.v % 2))) {\n\t                logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n\t            }\n\t        }\n\t        if (result.r == null || !isHexString(result.r)) {\n\t            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n\t        }\n\t        else {\n\t            result.r = hexZeroPad(result.r, 32);\n\t        }\n\t        if (result.s == null || !isHexString(result.s)) {\n\t            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n\t        }\n\t        else {\n\t            result.s = hexZeroPad(result.s, 32);\n\t        }\n\t        var vs = arrayify(result.s);\n\t        if (vs[0] >= 128) {\n\t            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n\t        }\n\t        if (result.recoveryParam) {\n\t            vs[0] |= 0x80;\n\t        }\n\t        var _vs = hexlify(vs);\n\t        if (result._vs) {\n\t            if (!isHexString(result._vs)) {\n\t                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n\t            }\n\t            result._vs = hexZeroPad(result._vs, 32);\n\t        }\n\t        // Set or check the _vs\n\t        if (result._vs == null) {\n\t            result._vs = _vs;\n\t        }\n\t        else if (result._vs !== _vs) {\n\t            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n\t        }\n\t    }\n\t    return result;\n\t}\n\texports.splitSignature = splitSignature;\n\tfunction joinSignature(signature) {\n\t    signature = splitSignature(signature);\n\t    return hexlify(concat([\n\t        signature.r,\n\t        signature.s,\n\t        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n\t    ]));\n\t}\n\texports.joinSignature = joinSignature;\n\t});\n\n\tvar index$1 = unwrapExports(lib$1);\n\tvar lib_1$1 = lib$1.isBytesLike;\n\tvar lib_2$1 = lib$1.isBytes;\n\tvar lib_3$1 = lib$1.arrayify;\n\tvar lib_4 = lib$1.concat;\n\tvar lib_5 = lib$1.stripZeros;\n\tvar lib_6 = lib$1.zeroPad;\n\tvar lib_7 = lib$1.isHexString;\n\tvar lib_8 = lib$1.hexlify;\n\tvar lib_9 = lib$1.hexDataLength;\n\tvar lib_10 = lib$1.hexDataSlice;\n\tvar lib_11 = lib$1.hexConcat;\n\tvar lib_12 = lib$1.hexValue;\n\tvar lib_13 = lib$1.hexStripZeros;\n\tvar lib_14 = lib$1.hexZeroPad;\n\tvar lib_15 = lib$1.splitSignature;\n\tvar lib_16 = lib$1.joinSignature;\n\n\tvar _version$4 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"bignumber/5.0.0-beta.139\";\n\t});\n\n\tvar _version$5 = unwrapExports(_version$4);\n\tvar _version_1$2 = _version$4.version;\n\n\tvar bignumber = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/**\n\t *  BigNumber\n\t *\n\t *  A wrapper around the BN.js object. We use the BN.js library\n\t *  because it is used by elliptic, so it is required regardles.\n\t *\n\t */\n\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\tvar _constructorGuard = {};\n\tvar MAX_SAFE = 0x1fffffffffffff;\n\tfunction isBigNumberish(value) {\n\t    return (value != null) && (BigNumber.isBigNumber(value) ||\n\t        (typeof (value) === \"number\" && (value % 1) === 0) ||\n\t        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n\t        lib$1.isHexString(value) ||\n\t        (typeof (value) === \"bigint\") ||\n\t        lib$1.isBytes(value));\n\t}\n\texports.isBigNumberish = isBigNumberish;\n\tvar BigNumber = /** @class */ (function () {\n\t    function BigNumber(constructorGuard, hex) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, BigNumber);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new (BigNumber)\"\n\t            });\n\t        }\n\t        this._hex = hex;\n\t        this._isBigNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    BigNumber.prototype.fromTwos = function (value) {\n\t        return toBigNumber(toBN(this).fromTwos(value));\n\t    };\n\t    BigNumber.prototype.toTwos = function (value) {\n\t        return toBigNumber(toBN(this).toTwos(value));\n\t    };\n\t    BigNumber.prototype.abs = function () {\n\t        if (this._hex[0] === \"-\") {\n\t            return BigNumber.from(this._hex.substring(1));\n\t        }\n\t        return this;\n\t    };\n\t    BigNumber.prototype.add = function (other) {\n\t        return toBigNumber(toBN(this).add(toBN(other)));\n\t    };\n\t    BigNumber.prototype.sub = function (other) {\n\t        return toBigNumber(toBN(this).sub(toBN(other)));\n\t    };\n\t    BigNumber.prototype.div = function (other) {\n\t        var o = BigNumber.from(other);\n\t        if (o.isZero()) {\n\t            throwFault(\"division by zero\", \"div\");\n\t        }\n\t        return toBigNumber(toBN(this).div(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mul = function (other) {\n\t        return toBigNumber(toBN(this).mul(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mod = function (other) {\n\t        var value = toBN(other);\n\t        if (value.isNeg()) {\n\t            throwFault(\"cannot modulo negative values\", \"mod\");\n\t        }\n\t        return toBigNumber(toBN(this).umod(value));\n\t    };\n\t    BigNumber.prototype.pow = function (other) {\n\t        return toBigNumber(toBN(this).pow(toBN(other)));\n\t    };\n\t    BigNumber.prototype.and = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'and' negative values\", \"and\");\n\t        }\n\t        return toBigNumber(toBN(this).and(value));\n\t    };\n\t    BigNumber.prototype.or = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'or' negative values\", \"or\");\n\t        }\n\t        return toBigNumber(toBN(this).or(value));\n\t    };\n\t    BigNumber.prototype.xor = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'xor' negative values\", \"xor\");\n\t        }\n\t        return toBigNumber(toBN(this).xor(value));\n\t    };\n\t    BigNumber.prototype.mask = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot mask negative values\", \"mask\");\n\t        }\n\t        return toBigNumber(toBN(this).maskn(value));\n\t    };\n\t    BigNumber.prototype.shl = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot shift negative values\", \"shl\");\n\t        }\n\t        return toBigNumber(toBN(this).shln(value));\n\t    };\n\t    BigNumber.prototype.shr = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot shift negative values\", \"shr\");\n\t        }\n\t        return toBigNumber(toBN(this).shrn(value));\n\t    };\n\t    BigNumber.prototype.eq = function (other) {\n\t        return toBN(this).eq(toBN(other));\n\t    };\n\t    BigNumber.prototype.lt = function (other) {\n\t        return toBN(this).lt(toBN(other));\n\t    };\n\t    BigNumber.prototype.lte = function (other) {\n\t        return toBN(this).lte(toBN(other));\n\t    };\n\t    BigNumber.prototype.gt = function (other) {\n\t        return toBN(this).gt(toBN(other));\n\t    };\n\t    BigNumber.prototype.gte = function (other) {\n\t        return toBN(this).gte(toBN(other));\n\t    };\n\t    BigNumber.prototype.isNegative = function () {\n\t        return (this._hex[0] === \"-\");\n\t    };\n\t    BigNumber.prototype.isZero = function () {\n\t        return toBN(this).isZero();\n\t    };\n\t    BigNumber.prototype.toNumber = function () {\n\t        try {\n\t            return toBN(this).toNumber();\n\t        }\n\t        catch (error) {\n\t            throwFault(\"overflow\", \"toNumber\", this.toString());\n\t        }\n\t        return null;\n\t    };\n\t    BigNumber.prototype.toString = function () {\n\t        // Lots of people expect this, which we do not support, so check\n\t        if (arguments.length !== 0) {\n\t            logger.throwError(\"bigNumber.toString does not accept parameters\", lib.Logger.errors.UNEXPECTED_ARGUMENT, {});\n\t        }\n\t        return toBN(this).toString(10);\n\t    };\n\t    BigNumber.prototype.toHexString = function () {\n\t        return this._hex;\n\t    };\n\t    BigNumber.from = function (value) {\n\t        if (value instanceof BigNumber) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            if (value.match(/-?0x[0-9a-f]+/i)) {\n\t                return new BigNumber(_constructorGuard, toHex(value));\n\t            }\n\t            if (value.match(/^-?[0-9]+$/)) {\n\t                return new BigNumber(_constructorGuard, toHex(new bn.BN(value)));\n\t            }\n\t            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n\t        }\n\t        if (typeof (value) === \"number\") {\n\t            if (value % 1) {\n\t                throwFault(\"underflow\", \"BigNumber.from\", value);\n\t            }\n\t            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n\t                throwFault(\"overflow\", \"BigNumber.from\", value);\n\t            }\n\t            return BigNumber.from(String(value));\n\t        }\n\t        if (typeof (value) === \"bigint\") {\n\t            return BigNumber.from(value.toString());\n\t        }\n\t        if (lib$1.isBytes(value)) {\n\t            return BigNumber.from(lib$1.hexlify(value));\n\t        }\n\t        if (value._hex && lib$1.isHexString(value._hex)) {\n\t            return BigNumber.from(value._hex);\n\t        }\n\t        if (value.toHexString) {\n\t            value = value.toHexString();\n\t            if (typeof (value) === \"string\") {\n\t                return BigNumber.from(value);\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n\t    };\n\t    BigNumber.isBigNumber = function (value) {\n\t        return !!(value && value._isBigNumber);\n\t    };\n\t    return BigNumber;\n\t}());\n\texports.BigNumber = BigNumber;\n\t// Normalize the hex string\n\tfunction toHex(value) {\n\t    // For BN, call on the hex string\n\t    if (typeof (value) !== \"string\") {\n\t        return toHex(value.toString(16));\n\t    }\n\t    // If negative, prepend the negative sign to the normalized positive value\n\t    if (value[0] === \"-\") {\n\t        // Strip off the negative sign\n\t        value = value.substring(1);\n\t        // Cannot have mulitple negative signs (e.g. \"--0x04\")\n\t        if (value[0] === \"-\") {\n\t            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n\t        }\n\t        // Call toHex on the positive component\n\t        value = toHex(value);\n\t        // Do not allow \"-0x00\"\n\t        if (value === \"0x00\") {\n\t            return value;\n\t        }\n\t        // Negate the value\n\t        return \"-\" + value;\n\t    }\n\t    // Add a \"0x\" prefix if missing\n\t    if (value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    // Normalize zero\n\t    if (value === \"0x\") {\n\t        return \"0x00\";\n\t    }\n\t    // Make the string even length\n\t    if (value.length % 2) {\n\t        value = \"0x0\" + value.substring(2);\n\t    }\n\t    // Trim to smallest even-length string\n\t    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n\t        value = \"0x\" + value.substring(4);\n\t    }\n\t    return value;\n\t}\n\tfunction toBigNumber(value) {\n\t    return BigNumber.from(toHex(value));\n\t}\n\tfunction toBN(value) {\n\t    var hex = BigNumber.from(value).toHexString();\n\t    if (hex[0] === \"-\") {\n\t        return (new bn.BN(\"-\" + hex.substring(3), 16));\n\t    }\n\t    return new bn.BN(hex.substring(2), 16);\n\t}\n\tfunction throwFault(fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value != null) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(fault, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\t});\n\n\tvar bignumber$1 = unwrapExports(bignumber);\n\tvar bignumber_1 = bignumber.isBigNumberish;\n\tvar bignumber_2 = bignumber.BigNumber;\n\n\tvar fixednumber = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\n\tvar _constructorGuard = {};\n\tvar Zero = bignumber.BigNumber.from(0);\n\tvar NegativeOne = bignumber.BigNumber.from(-1);\n\tfunction throwFault(message, fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value !== undefined) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(message, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\t// Constant to pull zeros from for multipliers\n\tvar zeros = \"0\";\n\twhile (zeros.length < 256) {\n\t    zeros += zeros;\n\t}\n\t// Returns a string \"1\" followed by decimal \"0\"s\n\tfunction getMultiplier(decimals) {\n\t    if (typeof (decimals) !== \"number\") {\n\t        try {\n\t            decimals = bignumber.BigNumber.from(decimals).toNumber();\n\t        }\n\t        catch (e) { }\n\t    }\n\t    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n\t        return (\"1\" + zeros.substring(0, decimals));\n\t    }\n\t    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n\t}\n\tfunction formatFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    // Make sure wei is a big number (convert as necessary)\n\t    value = bignumber.BigNumber.from(value);\n\t    var negative = value.lt(Zero);\n\t    if (negative) {\n\t        value = value.mul(NegativeOne);\n\t    }\n\t    var fraction = value.mod(multiplier).toString();\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction = \"0\" + fraction;\n\t    }\n\t    // Strip training 0\n\t    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\t    var whole = value.div(multiplier).toString();\n\t    value = whole + \".\" + fraction;\n\t    if (negative) {\n\t        value = \"-\" + value;\n\t    }\n\t    return value;\n\t}\n\texports.formatFixed = formatFixed;\n\tfunction parseFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n\t        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n\t    }\n\t    if (multiplier.length - 1 === 0) {\n\t        return bignumber.BigNumber.from(value);\n\t    }\n\t    // Is it negative?\n\t    var negative = (value.substring(0, 1) === \"-\");\n\t    if (negative) {\n\t        value = value.substring(1);\n\t    }\n\t    if (value === \".\") {\n\t        logger.throwArgumentError(\"missing value\", \"value\", value);\n\t    }\n\t    // Split it into a whole and fractional part\n\t    var comps = value.split(\".\");\n\t    if (comps.length > 2) {\n\t        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n\t    }\n\t    var whole = comps[0], fraction = comps[1];\n\t    if (!whole) {\n\t        whole = \"0\";\n\t    }\n\t    if (!fraction) {\n\t        fraction = \"0\";\n\t    }\n\t    // Prevent underflow\n\t    if (fraction.length > multiplier.length - 1) {\n\t        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n\t    }\n\t    // Fully pad the string with zeros to get to wei\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction += \"0\";\n\t    }\n\t    var wholeValue = bignumber.BigNumber.from(whole);\n\t    var fractionValue = bignumber.BigNumber.from(fraction);\n\t    var wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\t    if (negative) {\n\t        wei = wei.mul(NegativeOne);\n\t    }\n\t    return wei;\n\t}\n\texports.parseFixed = parseFixed;\n\tvar FixedFormat = /** @class */ (function () {\n\t    function FixedFormat(constructorGuard, signed, width, decimals) {\n\t        this.signed = signed;\n\t        this.width = width;\n\t        this.decimals = decimals;\n\t        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\t        this._multiplier = getMultiplier(decimals);\n\t        Object.freeze(this);\n\t    }\n\t    FixedFormat.from = function (value) {\n\t        if (value instanceof FixedFormat) {\n\t            return value;\n\t        }\n\t        var signed = true;\n\t        var width = 128;\n\t        var decimals = 18;\n\t        if (typeof (value) === \"string\") {\n\t            if (value === \"fixed\") {\n\t                // defaults...\n\t            }\n\t            else if (value === \"ufixed\") {\n\t                signed = false;\n\t            }\n\t            else if (value != null) {\n\t                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\t                if (!match) {\n\t                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n\t                }\n\t                signed = (match[1] !== \"u\");\n\t                width = parseInt(match[2]);\n\t                decimals = parseInt(match[3]);\n\t            }\n\t        }\n\t        else if (value) {\n\t            var check = function (key, type, defaultValue) {\n\t                if (value[key] == null) {\n\t                    return defaultValue;\n\t                }\n\t                if (typeof (value[key]) !== type) {\n\t                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n\t                }\n\t                return value[key];\n\t            };\n\t            signed = check(\"signed\", \"boolean\", signed);\n\t            width = check(\"width\", \"number\", width);\n\t            decimals = check(\"decimals\", \"number\", decimals);\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n\t        }\n\t        if (decimals > 80) {\n\t            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n\t        }\n\t        return new FixedFormat(_constructorGuard, signed, width, decimals);\n\t    };\n\t    return FixedFormat;\n\t}());\n\texports.FixedFormat = FixedFormat;\n\tvar FixedNumber = /** @class */ (function () {\n\t    function FixedNumber(constructorGuard, hex, value, format) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, FixedNumber);\n\t        this.format = format;\n\t        this._hex = hex;\n\t        this._value = value;\n\t        this._isFixedNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    FixedNumber.prototype._checkFormat = function (other) {\n\t        if (this.format.name !== other.format.name) {\n\t            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n\t        }\n\t    };\n\t    FixedNumber.prototype.addUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.subUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.mulUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.divUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n\t    };\n\t    // @TODO: Support other rounding algorithms\n\t    FixedNumber.prototype.round = function (decimals) {\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n\t            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n\t        }\n\t        // If we are already in range, we're done\n\t        var comps = this.toString().split(\".\");\n\t        if (comps[1].length <= decimals) {\n\t            return this;\n\t        }\n\t        // Bump the value up by the 0.00...0005\n\t        var bump = \"0.\" + zeros.substring(0, decimals) + \"5\";\n\t        comps = this.addUnsafe(FixedNumber.fromString(bump, this.format))._value.split(\".\");\n\t        // Now it is safe to truncate\n\t        return FixedNumber.fromString(comps[0] + \".\" + comps[1].substring(0, decimals));\n\t    };\n\t    FixedNumber.prototype.toString = function () { return this._value; };\n\t    FixedNumber.prototype.toHexString = function (width) {\n\t        if (width == null) {\n\t            return this._hex;\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n\t        }\n\t        var hex = bignumber.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n\t        return lib$1.hexZeroPad(hex, width / 8);\n\t    };\n\t    FixedNumber.prototype.toUnsafeFloat = function () { return parseFloat(this.toString()); };\n\t    FixedNumber.prototype.toFormat = function (format) {\n\t        return FixedNumber.fromString(this._value, format);\n\t    };\n\t    FixedNumber.fromValue = function (value, decimals, format) {\n\t        // If decimals looks more like a format, and there is no format, shift the parameters\n\t        if (format == null && decimals != null && !bignumber.isBigNumberish(decimals)) {\n\t            format = decimals;\n\t            decimals = null;\n\t        }\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n\t    };\n\t    FixedNumber.fromString = function (value, format) {\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        var numeric = parseFixed(value, fixedFormat.decimals);\n\t        if (!fixedFormat.signed && numeric.lt(Zero)) {\n\t            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n\t        }\n\t        var hex = null;\n\t        if (fixedFormat.signed) {\n\t            hex = numeric.toTwos(fixedFormat.width).toHexString();\n\t        }\n\t        else {\n\t            hex = numeric.toHexString();\n\t            hex = lib$1.hexZeroPad(hex, fixedFormat.width / 8);\n\t        }\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.fromBytes = function (value, format) {\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        if (lib$1.arrayify(value).length > fixedFormat.width / 8) {\n\t            throw new Error(\"overflow\");\n\t        }\n\t        var numeric = bignumber.BigNumber.from(value);\n\t        if (fixedFormat.signed) {\n\t            numeric = numeric.fromTwos(fixedFormat.width);\n\t        }\n\t        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.from = function (value, format) {\n\t        if (typeof (value) === \"string\") {\n\t            return FixedNumber.fromString(value, format);\n\t        }\n\t        if (lib$1.isBytes(value)) {\n\t            return FixedNumber.fromBytes(value, format);\n\t        }\n\t        try {\n\t            return FixedNumber.fromValue(value, 0, format);\n\t        }\n\t        catch (error) {\n\t            // Allow NUMERIC_FAULT to bubble up\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT) {\n\t                throw error;\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n\t    };\n\t    FixedNumber.isFixedNumber = function (value) {\n\t        return !!(value && value._isFixedNumber);\n\t    };\n\t    return FixedNumber;\n\t}());\n\texports.FixedNumber = FixedNumber;\n\t});\n\n\tvar fixednumber$1 = unwrapExports(fixednumber);\n\tvar fixednumber_1 = fixednumber.formatFixed;\n\tvar fixednumber_2 = fixednumber.parseFixed;\n\tvar fixednumber_3 = fixednumber.FixedFormat;\n\tvar fixednumber_4 = fixednumber.FixedNumber;\n\n\tvar lib$2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.BigNumber = bignumber.BigNumber;\n\n\texports.formatFixed = fixednumber.formatFixed;\n\texports.FixedFormat = fixednumber.FixedFormat;\n\texports.FixedNumber = fixednumber.FixedNumber;\n\texports.parseFixed = fixednumber.parseFixed;\n\t});\n\n\tvar index$2 = unwrapExports(lib$2);\n\tvar lib_1$2 = lib$2.BigNumber;\n\tvar lib_2$2 = lib$2.formatFixed;\n\tvar lib_3$2 = lib$2.FixedFormat;\n\tvar lib_4$1 = lib$2.FixedNumber;\n\tvar lib_5$1 = lib$2.parseFixed;\n\n\tvar _version$6 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"properties/5.0.0-beta.143\";\n\t});\n\n\tvar _version$7 = unwrapExports(_version$6);\n\tvar _version_1$3 = _version$6.version;\n\n\tvar lib$3 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$6.version);\n\tfunction defineReadOnly(object, name, value) {\n\t    Object.defineProperty(object, name, {\n\t        enumerable: true,\n\t        value: value,\n\t        writable: false,\n\t    });\n\t}\n\texports.defineReadOnly = defineReadOnly;\n\t// Crawl up the constructor chain to find a static method\n\tfunction getStatic(ctor, key) {\n\t    for (var i = 0; i < 32; i++) {\n\t        if (ctor[key]) {\n\t            return ctor[key];\n\t        }\n\t        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n\t            break;\n\t        }\n\t        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n\t    }\n\t    return null;\n\t}\n\texports.getStatic = getStatic;\n\tfunction resolveProperties(object) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var promises, results;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    promises = Object.keys(object).map(function (key) {\n\t                        var value = object[key];\n\t                        return Promise.resolve(value).then(function (v) { return ({ key: key, value: v }); });\n\t                    });\n\t                    return [4 /*yield*/, Promise.all(promises)];\n\t                case 1:\n\t                    results = _a.sent();\n\t                    return [2 /*return*/, results.reduce(function (accum, result) {\n\t                            accum[(result.key)] = result.value;\n\t                            return accum;\n\t                        }, {})];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.resolveProperties = resolveProperties;\n\tfunction checkProperties(object, properties) {\n\t    if (!object || typeof (object) !== \"object\") {\n\t        logger.throwArgumentError(\"invalid object\", \"object\", object);\n\t    }\n\t    Object.keys(object).forEach(function (key) {\n\t        if (!properties[key]) {\n\t            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n\t        }\n\t    });\n\t}\n\texports.checkProperties = checkProperties;\n\tfunction shallowCopy(object) {\n\t    var result = {};\n\t    for (var key in object) {\n\t        result[key] = object[key];\n\t    }\n\t    return result;\n\t}\n\texports.shallowCopy = shallowCopy;\n\tvar opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\tfunction _isFrozen(object) {\n\t    // Opaque objects are not mutable, so safe to copy by assignment\n\t    if (object === undefined || object === null || opaque[typeof (object)]) {\n\t        return true;\n\t    }\n\t    if (Array.isArray(object) || typeof (object) === \"object\") {\n\t        if (!Object.isFrozen(object)) {\n\t            return false;\n\t        }\n\t        var keys = Object.keys(object);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            if (!_isFrozen(object[keys[i]])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n\t}\n\t// Returns a new copy of object, such that no properties may be replaced.\n\t// New properties may be added only to objects.\n\tfunction _deepCopy(object) {\n\t    if (_isFrozen(object)) {\n\t        return object;\n\t    }\n\t    // Arrays are mutable, so we need to create a copy\n\t    if (Array.isArray(object)) {\n\t        return Object.freeze(object.map(function (item) { return deepCopy(item); }));\n\t    }\n\t    if (typeof (object) === \"object\") {\n\t        var result = {};\n\t        for (var key in object) {\n\t            var value = object[key];\n\t            if (value === undefined) {\n\t                continue;\n\t            }\n\t            defineReadOnly(result, key, deepCopy(value));\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n\t}\n\tfunction deepCopy(object) {\n\t    return _deepCopy(object);\n\t}\n\texports.deepCopy = deepCopy;\n\tvar Description = /** @class */ (function () {\n\t    function Description(info) {\n\t        for (var key in info) {\n\t            this[key] = deepCopy(info[key]);\n\t        }\n\t    }\n\t    return Description;\n\t}());\n\texports.Description = Description;\n\t});\n\n\tvar index$3 = unwrapExports(lib$3);\n\tvar lib_1$3 = lib$3.defineReadOnly;\n\tvar lib_2$3 = lib$3.getStatic;\n\tvar lib_3$3 = lib$3.resolveProperties;\n\tvar lib_4$2 = lib$3.checkProperties;\n\tvar lib_5$2 = lib$3.shallowCopy;\n\tvar lib_6$1 = lib$3.deepCopy;\n\tvar lib_7$1 = lib$3.Description;\n\n\tvar _version$8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"abi/5.0.0-beta.156\";\n\t});\n\n\tvar _version$9 = unwrapExports(_version$8);\n\tvar _version_1$4 = _version$8.version;\n\n\tvar fragments = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\t;\n\tvar _constructorGuard = {};\n\tvar ModifiersBytes = { calldata: true, memory: true, storage: true };\n\tvar ModifiersNest = { calldata: true, memory: true };\n\tfunction checkModifier(type, name) {\n\t    if (type === \"bytes\" || type === \"string\") {\n\t        if (ModifiersBytes[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type === \"address\") {\n\t        if (name === \"payable\") {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n\t        if (ModifiersNest[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    if (ModifiersBytes[name] || name === \"payable\") {\n\t        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n\t    }\n\t    return false;\n\t}\n\t// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\tfunction parseParamType(param, allowIndexed) {\n\t    var originalParam = param;\n\t    function throwError(i) {\n\t        logger.throwArgumentError(\"unexpected character at position \" + i, \"param\", param);\n\t    }\n\t    param = param.replace(/\\s/g, \" \");\n\t    function newNode(parent) {\n\t        var node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n\t        if (allowIndexed) {\n\t            node.indexed = false;\n\t        }\n\t        return node;\n\t    }\n\t    var parent = { type: \"\", name: \"\", state: { allowType: true } };\n\t    var node = parent;\n\t    for (var i = 0; i < param.length; i++) {\n\t        var c = param[i];\n\t        switch (c) {\n\t            case \"(\":\n\t                if (node.state.allowType && node.type === \"\") {\n\t                    node.type = \"tuple\";\n\t                }\n\t                else if (!node.state.allowParams) {\n\t                    throwError(i);\n\t                }\n\t                node.state.allowType = false;\n\t                node.type = verifyType(node.type);\n\t                node.components = [newNode(node)];\n\t                node = node.components[0];\n\t                break;\n\t            case \")\":\n\t                delete node.state;\n\t                if (node.name === \"indexed\") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = \"\";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = \"\";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var child = node;\n\t                node = node.parent;\n\t                if (!node) {\n\t                    throwError(i);\n\t                }\n\t                delete child.parent;\n\t                node.state.allowParams = false;\n\t                node.state.allowName = true;\n\t                node.state.allowArray = true;\n\t                break;\n\t            case \",\":\n\t                delete node.state;\n\t                if (node.name === \"indexed\") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = \"\";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = \"\";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var sibling = newNode(node.parent);\n\t                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\t                node.parent.components.push(sibling);\n\t                delete node.parent;\n\t                node = sibling;\n\t                break;\n\t            // Hit a space...\n\t            case \" \":\n\t                // If reading type, the type is done and may read a param or name\n\t                if (node.state.allowType) {\n\t                    if (node.type !== \"\") {\n\t                        node.type = verifyType(node.type);\n\t                        delete node.state.allowType;\n\t                        node.state.allowName = true;\n\t                        node.state.allowParams = true;\n\t                    }\n\t                }\n\t                // If reading name, the name is done\n\t                if (node.state.allowName) {\n\t                    if (node.name !== \"\") {\n\t                        if (node.name === \"indexed\") {\n\t                            if (!allowIndexed) {\n\t                                throwError(i);\n\t                            }\n\t                            if (node.indexed) {\n\t                                throwError(i);\n\t                            }\n\t                            node.indexed = true;\n\t                            node.name = \"\";\n\t                        }\n\t                        else if (checkModifier(node.type, node.name)) {\n\t                            node.name = \"\";\n\t                        }\n\t                        else {\n\t                            node.state.allowName = false;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            case \"[\":\n\t                if (!node.state.allowArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.allowArray = false;\n\t                node.state.allowName = false;\n\t                node.state.readArray = true;\n\t                break;\n\t            case \"]\":\n\t                if (!node.state.readArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.readArray = false;\n\t                node.state.allowArray = true;\n\t                node.state.allowName = true;\n\t                break;\n\t            default:\n\t                if (node.state.allowType) {\n\t                    node.type += c;\n\t                    node.state.allowParams = true;\n\t                    node.state.allowArray = true;\n\t                }\n\t                else if (node.state.allowName) {\n\t                    node.name += c;\n\t                    delete node.state.allowArray;\n\t                }\n\t                else if (node.state.readArray) {\n\t                    node.type += c;\n\t                }\n\t                else {\n\t                    throwError(i);\n\t                }\n\t        }\n\t    }\n\t    if (node.parent) {\n\t        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n\t    }\n\t    delete parent.state;\n\t    if (node.name === \"indexed\") {\n\t        if (!allowIndexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        if (node.indexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        node.indexed = true;\n\t        node.name = \"\";\n\t    }\n\t    else if (checkModifier(node.type, node.name)) {\n\t        node.name = \"\";\n\t    }\n\t    parent.type = verifyType(parent.type);\n\t    return parent;\n\t}\n\tfunction populate(object, params) {\n\t    for (var key in params) {\n\t        lib$3.defineReadOnly(object, key, params[key]);\n\t    }\n\t}\n\texports.FormatTypes = Object.freeze({\n\t    // Bare formatting, as is needed for computing a sighash of an event or function\n\t    sighash: \"sighash\",\n\t    // Human-Readable with Minimal spacing and without names (compact human-readable)\n\t    minimal: \"minimal\",\n\t    // Human-Readble with nice spacing, including all names\n\t    full: \"full\",\n\t    // JSON-format a la Solidity\n\t    json: \"json\"\n\t});\n\tvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\tvar ParamType = /** @class */ (function () {\n\t    function ParamType(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"use fromString\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new ParamType()\"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        var match = this.type.match(paramTypeArray);\n\t        if (match) {\n\t            populate(this, {\n\t                arrayLength: parseInt(match[2] || \"-1\"),\n\t                arrayChildren: ParamType.fromObject({\n\t                    type: match[1],\n\t                    components: this.components\n\t                }),\n\t                baseType: \"array\"\n\t            });\n\t        }\n\t        else {\n\t            populate(this, {\n\t                arrayLength: null,\n\t                arrayChildren: null,\n\t                baseType: ((this.components != null) ? \"tuple\" : this.type)\n\t            });\n\t        }\n\t        this._isParamType = true;\n\t        Object.freeze(this);\n\t    }\n\t    // Format the parameter fragment\n\t    //   - sighash: \"(uint256,address)\"\n\t    //   - minimal: \"tuple(uint256,address) indexed\"\n\t    //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n\t    ParamType.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            var result_1 = {\n\t                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n\t                name: (this.name || undefined)\n\t            };\n\t            if (typeof (this.indexed) === \"boolean\") {\n\t                result_1.indexed = this.indexed;\n\t            }\n\t            if (this.components) {\n\t                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });\n\t            }\n\t            return JSON.stringify(result_1);\n\t        }\n\t        var result = \"\";\n\t        // Array\n\t        if (this.baseType === \"array\") {\n\t            result += this.arrayChildren.format(format);\n\t            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n\t        }\n\t        else {\n\t            if (this.baseType === \"tuple\") {\n\t                if (format !== exports.FormatTypes.sighash) {\n\t                    result += this.type;\n\t                }\n\t                result += \"(\" + this.components.map(function (comp) { return comp.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \")\";\n\t            }\n\t            else {\n\t                result += this.type;\n\t            }\n\t        }\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.indexed === true) {\n\t                result += \" indexed\";\n\t            }\n\t            if (format === exports.FormatTypes.full && this.name) {\n\t                result += \" \" + this.name;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    ParamType.from = function (value, allowIndexed) {\n\t        if (typeof (value) === \"string\") {\n\t            return ParamType.fromString(value, allowIndexed);\n\t        }\n\t        return ParamType.fromObject(value);\n\t    };\n\t    ParamType.fromObject = function (value) {\n\t        if (ParamType.isParamType(value)) {\n\t            return value;\n\t        }\n\t        return new ParamType(_constructorGuard, {\n\t            name: (value.name || null),\n\t            type: verifyType(value.type),\n\t            indexed: ((value.indexed == null) ? null : !!value.indexed),\n\t            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n\t        });\n\t    };\n\t    ParamType.fromString = function (value, allowIndexed) {\n\t        function ParamTypify(node) {\n\t            return ParamType.fromObject({\n\t                name: node.name,\n\t                type: node.type,\n\t                indexed: node.indexed,\n\t                components: node.components\n\t            });\n\t        }\n\t        return ParamTypify(parseParamType(value, !!allowIndexed));\n\t    };\n\t    ParamType.isParamType = function (value) {\n\t        return !!(value != null && value._isParamType);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t;\n\tfunction parseParams(value, allowIndex) {\n\t    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });\n\t}\n\tvar Fragment = /** @class */ (function () {\n\t    function Fragment(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"use a static from method\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new Fragment()\"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        this._isFragment = true;\n\t        Object.freeze(this);\n\t    }\n\t    Fragment.from = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            return Fragment.fromString(value);\n\t        }\n\t        return Fragment.fromObject(value);\n\t    };\n\t    Fragment.fromObject = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        switch (value.type) {\n\t            case \"function\":\n\t                return FunctionFragment.fromObject(value);\n\t            case \"event\":\n\t                return EventFragment.fromObject(value);\n\t            case \"constructor\":\n\t                return ConstructorFragment.fromObject(value);\n\t            case \"fallback\":\n\t            case \"receive\":\n\t                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n\t                return null;\n\t        }\n\t        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n\t    };\n\t    Fragment.fromString = function (value) {\n\t        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n\t        value = value.replace(/\\s/g, \" \");\n\t        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n\t        value = value.trim();\n\t        if (value.split(\" \")[0] === \"event\") {\n\t            return EventFragment.fromString(value.substring(5).trim());\n\t        }\n\t        else if (value.split(\" \")[0] === \"function\") {\n\t            return FunctionFragment.fromString(value.substring(8).trim());\n\t        }\n\t        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n\t            return ConstructorFragment.fromString(value.trim());\n\t        }\n\t        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n\t    };\n\t    Fragment.isFragment = function (value) {\n\t        return !!(value && value._isFragment);\n\t    };\n\t    return Fragment;\n\t}());\n\texports.Fragment = Fragment;\n\tvar EventFragment = /** @class */ (function (_super) {\n\t    __extends(EventFragment, _super);\n\t    function EventFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    EventFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"event\",\n\t                anonymous: this.anonymous,\n\t                name: this.name,\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        var result = \"\";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += \"event \";\n\t        }\n\t        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.anonymous) {\n\t                result += \"anonymous \";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    EventFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return EventFragment.fromString(value);\n\t        }\n\t        return EventFragment.fromObject(value);\n\t    };\n\t    EventFragment.fromObject = function (value) {\n\t        if (EventFragment.isEventFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"event\") {\n\t            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n\t        }\n\t        var params = {\n\t            name: verifyIdentifier(value.name),\n\t            anonymous: value.anonymous,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            type: \"event\"\n\t        };\n\t        return new EventFragment(_constructorGuard, params);\n\t    };\n\t    EventFragment.fromString = function (value) {\n\t        var match = value.match(regexParen);\n\t        if (!match) {\n\t            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n\t        }\n\t        var anonymous = false;\n\t        match[3].split(\" \").forEach(function (modifier) {\n\t            switch (modifier.trim()) {\n\t                case \"anonymous\":\n\t                    anonymous = true;\n\t                    break;\n\t                case \"\":\n\t                    break;\n\t                default:\n\t                    logger.warn(\"unknown modifier: \" + modifier);\n\t            }\n\t        });\n\t        return EventFragment.fromObject({\n\t            name: match[1].trim(),\n\t            anonymous: anonymous,\n\t            inputs: parseParams(match[2], true),\n\t            type: \"event\"\n\t        });\n\t    };\n\t    EventFragment.isEventFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"event\");\n\t    };\n\t    return EventFragment;\n\t}(Fragment));\n\texports.EventFragment = EventFragment;\n\tfunction parseGas(value, params) {\n\t    params.gas = null;\n\t    var comps = value.split(\"@\");\n\t    if (comps.length !== 1) {\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n\t        }\n\t        if (!comps[1].match(/^[0-9]+$/)) {\n\t            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n\t        }\n\t        params.gas = lib$2.BigNumber.from(comps[1]);\n\t        return comps[0];\n\t    }\n\t    return value;\n\t}\n\tfunction parseModifiers(value, params) {\n\t    params.constant = false;\n\t    params.payable = false;\n\t    params.stateMutability = \"nonpayable\";\n\t    value.split(\" \").forEach(function (modifier) {\n\t        switch (modifier.trim()) {\n\t            case \"constant\":\n\t                params.constant = true;\n\t                break;\n\t            case \"payable\":\n\t                params.payable = true;\n\t                params.stateMutability = \"payable\";\n\t                break;\n\t            case \"nonpayable\":\n\t                params.payable = false;\n\t                params.stateMutability = \"nonpayable\";\n\t                break;\n\t            case \"pure\":\n\t                params.constant = true;\n\t                params.stateMutability = \"pure\";\n\t                break;\n\t            case \"view\":\n\t                params.constant = true;\n\t                params.stateMutability = \"view\";\n\t                break;\n\t            case \"external\":\n\t            case \"public\":\n\t            case \"\":\n\t                break;\n\t            default:\n\t                console.log(\"unknown modifier: \" + modifier);\n\t        }\n\t    });\n\t}\n\tfunction verifyState(value) {\n\t    var result = {\n\t        constant: false,\n\t        payable: true,\n\t        stateMutability: \"payable\"\n\t    };\n\t    if (value.stateMutability != null) {\n\t        result.stateMutability = value.stateMutability;\n\t        // Set (and check things are consistent) the constant property\n\t        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n\t        if (value.constant != null) {\n\t            if ((!!value.constant) !== result.constant) {\n\t                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n\t            }\n\t        }\n\t        // Set (and check things are consistent) the payable property\n\t        result.payable = (result.stateMutability === \"payable\");\n\t        if (value.payable != null) {\n\t            if ((!!value.payable) !== result.payable) {\n\t                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n\t            }\n\t        }\n\t    }\n\t    else if (value.payable != null) {\n\t        result.payable = !!value.payable;\n\t        // If payable we can assume non-constant; otherwise we can't assume\n\t        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n\t            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n\t        }\n\t        result.constant = !!value.constant;\n\t        if (result.constant) {\n\t            result.stateMutability = \"view\";\n\t        }\n\t        else {\n\t            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n\t        }\n\t        if (result.payable && result.constant) {\n\t            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n\t        }\n\t    }\n\t    else if (value.constant != null) {\n\t        result.constant = !!value.constant;\n\t        result.payable = !result.constant;\n\t        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n\t    }\n\t    else if (value.type !== \"constructor\") {\n\t        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n\t    }\n\t    return result;\n\t}\n\tvar ConstructorFragment = /** @class */ (function (_super) {\n\t    __extends(ConstructorFragment, _super);\n\t    function ConstructorFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ConstructorFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"constructor\",\n\t                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n\t                payble: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        if (format === exports.FormatTypes.sighash) {\n\t            logger.throwError(\"cannot format a constructor for sighash\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"format(sighash)\"\n\t            });\n\t        }\n\t        var result = \"constructor(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n\t            result += this.stateMutability + \" \";\n\t        }\n\t        return result.trim();\n\t    };\n\t    ConstructorFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return ConstructorFragment.fromString(value);\n\t        }\n\t        return ConstructorFragment.fromObject(value);\n\t    };\n\t    ConstructorFragment.fromObject = function (value) {\n\t        if (ConstructorFragment.isConstructorFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"constructor\") {\n\t            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n\t        }\n\t        var state = verifyState(value);\n\t        if (state.constant) {\n\t            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n\t        }\n\t        var params = {\n\t            name: null,\n\t            type: value.type,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new ConstructorFragment(_constructorGuard, params);\n\t    };\n\t    ConstructorFragment.fromString = function (value) {\n\t        var params = { type: \"constructor\" };\n\t        value = parseGas(value, params);\n\t        var parens = value.match(regexParen);\n\t        if (!parens || parens[1].trim() !== \"constructor\") {\n\t            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n\t        }\n\t        params.inputs = parseParams(parens[2].trim(), false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        return ConstructorFragment.fromObject(params);\n\t    };\n\t    ConstructorFragment.isConstructorFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"constructor\");\n\t    };\n\t    return ConstructorFragment;\n\t}(Fragment));\n\texports.ConstructorFragment = ConstructorFragment;\n\tvar FunctionFragment = /** @class */ (function (_super) {\n\t    __extends(FunctionFragment, _super);\n\t    function FunctionFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    FunctionFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"function\",\n\t                name: this.name,\n\t                constant: this.constant,\n\t                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n\t                payble: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n\t                ouputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),\n\t            });\n\t        }\n\t        var result = \"\";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += \"function \";\n\t        }\n\t        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.stateMutability) {\n\t                if (this.stateMutability !== \"nonpayable\") {\n\t                    result += (this.stateMutability + \" \");\n\t                }\n\t            }\n\t            else if (this.constant) {\n\t                result += \"view \";\n\t            }\n\t            if (this.outputs && this.outputs.length) {\n\t                result += \"returns (\" + this.outputs.map(function (output) { return output.format(format); }).join(\", \") + \") \";\n\t            }\n\t            if (this.gas != null) {\n\t                result += \"@\" + this.gas.toString() + \" \";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    FunctionFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return FunctionFragment.fromString(value);\n\t        }\n\t        return FunctionFragment.fromObject(value);\n\t    };\n\t    FunctionFragment.fromObject = function (value) {\n\t        if (FunctionFragment.isFunctionFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"function\") {\n\t            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n\t        }\n\t        var state = verifyState(value);\n\t        var params = {\n\t            type: value.type,\n\t            name: verifyIdentifier(value.name),\n\t            constant: state.constant,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new FunctionFragment(_constructorGuard, params);\n\t    };\n\t    FunctionFragment.fromString = function (value) {\n\t        var params = { type: \"function\" };\n\t        value = parseGas(value, params);\n\t        var comps = value.split(\" returns \");\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n\t        }\n\t        var parens = comps[0].match(regexParen);\n\t        if (!parens) {\n\t            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n\t        }\n\t        params.name = parens[1].trim();\n\t        if (params.name) {\n\t            verifyIdentifier(params.name);\n\t        }\n\t        params.inputs = parseParams(parens[2], false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        // We have outputs\n\t        if (comps.length > 1) {\n\t            var returns = comps[1].match(regexParen);\n\t            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n\t                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n\t            }\n\t            params.outputs = parseParams(returns[2], false);\n\t        }\n\t        else {\n\t            params.outputs = [];\n\t        }\n\t        return FunctionFragment.fromObject(params);\n\t    };\n\t    FunctionFragment.isFunctionFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"function\");\n\t    };\n\t    return FunctionFragment;\n\t}(ConstructorFragment));\n\texports.FunctionFragment = FunctionFragment;\n\t//export class ErrorFragment extends Fragment {\n\t//}\n\t//export class StructFragment extends Fragment {\n\t//}\n\tfunction verifyType(type) {\n\t    // These need to be transformed to their full description\n\t    if (type.match(/^uint($|[^1-9])/)) {\n\t        type = \"uint256\" + type.substring(4);\n\t    }\n\t    else if (type.match(/^int($|[^1-9])/)) {\n\t        type = \"int256\" + type.substring(3);\n\t    }\n\t    // @TODO: more verification\n\t    return type;\n\t}\n\tvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\tfunction verifyIdentifier(value) {\n\t    if (!value || !value.match(regexIdentifier)) {\n\t        logger.throwArgumentError(\"invalid identifier \\\"\" + value + \"\\\"\", \"value\", value);\n\t    }\n\t    return value;\n\t}\n\tvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\tfunction splitNesting(value) {\n\t    value = value.trim();\n\t    var result = [];\n\t    var accum = \"\";\n\t    var depth = 0;\n\t    for (var offset = 0; offset < value.length; offset++) {\n\t        var c = value[offset];\n\t        if (c === \",\" && depth === 0) {\n\t            result.push(accum);\n\t            accum = \"\";\n\t        }\n\t        else {\n\t            accum += c;\n\t            if (c === \"(\") {\n\t                depth++;\n\t            }\n\t            else if (c === \")\") {\n\t                depth--;\n\t                if (depth === -1) {\n\t                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (accum) {\n\t        result.push(accum);\n\t    }\n\t    return result;\n\t}\n\t});\n\n\tvar fragments$1 = unwrapExports(fragments);\n\tvar fragments_1 = fragments.FormatTypes;\n\tvar fragments_2 = fragments.ParamType;\n\tvar fragments_3 = fragments.Fragment;\n\tvar fragments_4 = fragments.EventFragment;\n\tvar fragments_5 = fragments.ConstructorFragment;\n\tvar fragments_6 = fragments.FunctionFragment;\n\n\tvar abstractCoder = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tfunction checkResultErrors(result) {\n\t    // Find the first error (if any)\n\t    var errors = [];\n\t    var checkErrors = function (path, object) {\n\t        if (!Array.isArray(object)) {\n\t            return;\n\t        }\n\t        for (var key in object) {\n\t            var childPath = path.slice();\n\t            childPath.push(key);\n\t            try {\n\t                checkErrors(childPath, object[key]);\n\t            }\n\t            catch (error) {\n\t                errors.push({ path: childPath, error: error });\n\t            }\n\t        }\n\t    };\n\t    checkErrors([], result);\n\t    return errors;\n\t}\n\texports.checkResultErrors = checkResultErrors;\n\tvar Coder = /** @class */ (function () {\n\t    function Coder(name, type, localName, dynamic) {\n\t        // @TODO: defineReadOnly these\n\t        this.name = name;\n\t        this.type = type;\n\t        this.localName = localName;\n\t        this.dynamic = dynamic;\n\t    }\n\t    Coder.prototype._throwError = function (message, value) {\n\t        logger.throwArgumentError(message, this.localName, value);\n\t    };\n\t    return Coder;\n\t}());\n\texports.Coder = Coder;\n\tvar Writer = /** @class */ (function () {\n\t    function Writer(wordSize) {\n\t        lib$3.defineReadOnly(this, \"wordSize\", wordSize || 32);\n\t        this._data = lib$1.arrayify([]);\n\t        this._padding = new Uint8Array(wordSize);\n\t    }\n\t    Object.defineProperty(Writer.prototype, \"data\", {\n\t        get: function () { return lib$1.hexlify(this._data); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Writer.prototype, \"length\", {\n\t        get: function () { return this._data.length; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Writer.prototype._writeData = function (data) {\n\t        this._data = lib$1.concat([this._data, data]);\n\t        return data.length;\n\t    };\n\t    // Arrayish items; padded on the right to wordSize\n\t    Writer.prototype.writeBytes = function (value) {\n\t        var bytes = lib$1.arrayify(value);\n\t        if (bytes.length % this.wordSize) {\n\t            bytes = lib$1.concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n\t        }\n\t        return this._writeData(bytes);\n\t    };\n\t    Writer.prototype._getValue = function (value) {\n\t        var bytes = lib$1.arrayify(lib$2.BigNumber.from(value));\n\t        if (bytes.length > this.wordSize) {\n\t            logger.throwError(\"value out-of-bounds\", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                length: this.wordSize,\n\t                offset: bytes.length\n\t            });\n\t        }\n\t        if (bytes.length % this.wordSize) {\n\t            bytes = lib$1.concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n\t        }\n\t        return bytes;\n\t    };\n\t    // BigNumberish items; padded on the left to wordSize\n\t    Writer.prototype.writeValue = function (value) {\n\t        return this._writeData(this._getValue(value));\n\t    };\n\t    Writer.prototype.writeUpdatableValue = function () {\n\t        var _this = this;\n\t        var offset = this.length;\n\t        this.writeValue(0);\n\t        return function (value) {\n\t            _this._data.set(_this._getValue(value), offset);\n\t        };\n\t    };\n\t    return Writer;\n\t}());\n\texports.Writer = Writer;\n\tvar Reader = /** @class */ (function () {\n\t    function Reader(data, wordSize, coerceFunc) {\n\t        lib$3.defineReadOnly(this, \"_data\", lib$1.arrayify(data));\n\t        lib$3.defineReadOnly(this, \"wordSize\", wordSize || 32);\n\t        lib$3.defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n\t        this._offset = 0;\n\t    }\n\t    Object.defineProperty(Reader.prototype, \"data\", {\n\t        get: function () { return lib$1.hexlify(this._data); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Reader.prototype, \"consumed\", {\n\t        get: function () { return this._offset; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // The default Coerce function\n\t    Reader.coerce = function (name, value) {\n\t        var match = name.match(\"^u?int([0-9]+)$\");\n\t        if (match && parseInt(match[1]) <= 48) {\n\t            value = value.toNumber();\n\t        }\n\t        return value;\n\t    };\n\t    Reader.prototype.coerce = function (name, value) {\n\t        if (this._coerceFunc) {\n\t            return this._coerceFunc(name, value);\n\t        }\n\t        return Reader.coerce(name, value);\n\t    };\n\t    Reader.prototype._peekBytes = function (offset, length) {\n\t        var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\t        if (this._offset + alignedLength > this._data.length) {\n\t            logger.throwError(\"data out-of-bounds\", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                length: this._data.length,\n\t                offset: this._offset + alignedLength\n\t            });\n\t        }\n\t        return this._data.slice(this._offset, this._offset + alignedLength);\n\t    };\n\t    Reader.prototype.subReader = function (offset) {\n\t        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n\t    };\n\t    Reader.prototype.readBytes = function (length) {\n\t        var bytes = this._peekBytes(0, length);\n\t        this._offset += bytes.length;\n\t        // @TODO: Make sure the length..end bytes are all 0?\n\t        return bytes.slice(0, length);\n\t    };\n\t    Reader.prototype.readValue = function () {\n\t        return lib$2.BigNumber.from(this.readBytes(this.wordSize));\n\t    };\n\t    return Reader;\n\t}());\n\texports.Reader = Reader;\n\t});\n\n\tvar abstractCoder$1 = unwrapExports(abstractCoder);\n\tvar abstractCoder_1 = abstractCoder.checkResultErrors;\n\tvar abstractCoder_2 = abstractCoder.Coder;\n\tvar abstractCoder_3 = abstractCoder.Writer;\n\tvar abstractCoder_4 = abstractCoder.Reader;\n\n\tvar sha3 = createCommonjsModule(function (module) {\n\t/**\r\n\t * [js-sha3]{@link https://github.com/emn178/js-sha3}\r\n\t *\r\n\t * @version 0.5.7\r\n\t * @author Chen, Yi-Cyuan [emn178@gmail.com]\r\n\t * @copyright Chen, Yi-Cyuan 2015-2016\r\n\t * @license MIT\r\n\t */\r\n\t/*jslint bitwise: true */\r\n\t(function () {\r\n\t  'use strict';\r\n\r\n\t  var root = typeof window === 'object' ? window : {};\r\n\t  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\r\n\t  if (NODE_JS) {\r\n\t    root = commonjsGlobal;\r\n\t  }\r\n\t  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;\r\n\t  var HEX_CHARS = '0123456789abcdef'.split('');\r\n\t  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\r\n\t  var KECCAK_PADDING = [1, 256, 65536, 16777216];\r\n\t  var PADDING = [6, 1536, 393216, 100663296];\r\n\t  var SHIFT = [0, 8, 16, 24];\r\n\t  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\r\n\t            0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\r\n\t            2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\r\n\t            2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\r\n\t            2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\r\n\t  var BITS = [224, 256, 384, 512];\r\n\t  var SHAKE_BITS = [128, 256];\r\n\t  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array'];\r\n\r\n\t  var createOutputMethod = function (bits, padding, outputType) {\r\n\t    return function (message) {\r\n\t      return new Keccak(bits, padding, bits).update(message)[outputType]();\r\n\t    };\r\n\t  };\r\n\r\n\t  var createShakeOutputMethod = function (bits, padding, outputType) {\r\n\t    return function (message, outputBits) {\r\n\t      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\r\n\t    };\r\n\t  };\r\n\r\n\t  var createMethod = function (bits, padding) {\r\n\t    var method = createOutputMethod(bits, padding, 'hex');\r\n\t    method.create = function () {\r\n\t      return new Keccak(bits, padding, bits);\r\n\t    };\r\n\t    method.update = function (message) {\r\n\t      return method.create().update(message);\r\n\t    };\r\n\t    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\r\n\t      var type = OUTPUT_TYPES[i];\r\n\t      method[type] = createOutputMethod(bits, padding, type);\r\n\t    }\r\n\t    return method;\r\n\t  };\r\n\r\n\t  var createShakeMethod = function (bits, padding) {\r\n\t    var method = createShakeOutputMethod(bits, padding, 'hex');\r\n\t    method.create = function (outputBits) {\r\n\t      return new Keccak(bits, padding, outputBits);\r\n\t    };\r\n\t    method.update = function (message, outputBits) {\r\n\t      return method.create(outputBits).update(message);\r\n\t    };\r\n\t    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\r\n\t      var type = OUTPUT_TYPES[i];\r\n\t      method[type] = createShakeOutputMethod(bits, padding, type);\r\n\t    }\r\n\t    return method;\r\n\t  };\r\n\r\n\t  var algorithms = [\r\n\t    {name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod},\r\n\t    {name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod},\r\n\t    {name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod}\r\n\t  ];\r\n\r\n\t  var methods = {}, methodNames = [];\r\n\r\n\t  for (var i = 0; i < algorithms.length; ++i) {\r\n\t    var algorithm = algorithms[i];\r\n\t    var bits  = algorithm.bits;\r\n\t    for (var j = 0; j < bits.length; ++j) {\r\n\t      var methodName = algorithm.name +'_' + bits[j];\r\n\t      methodNames.push(methodName);\r\n\t      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\r\n\t    }\r\n\t  }\r\n\r\n\t  function Keccak(bits, padding, outputBits) {\r\n\t    this.blocks = [];\r\n\t    this.s = [];\r\n\t    this.padding = padding;\r\n\t    this.outputBits = outputBits;\r\n\t    this.reset = true;\r\n\t    this.block = 0;\r\n\t    this.start = 0;\r\n\t    this.blockCount = (1600 - (bits << 1)) >> 5;\r\n\t    this.byteCount = this.blockCount << 2;\r\n\t    this.outputBlocks = outputBits >> 5;\r\n\t    this.extraBytes = (outputBits & 31) >> 3;\r\n\r\n\t    for (var i = 0; i < 50; ++i) {\r\n\t      this.s[i] = 0;\r\n\t    }\r\n\t  }\r\n\r\n\t  Keccak.prototype.update = function (message) {\r\n\t    var notString = typeof message !== 'string';\r\n\t    if (notString && message.constructor === ArrayBuffer) {\r\n\t      message = new Uint8Array(message);\r\n\t    }\r\n\t    var length = message.length, blocks = this.blocks, byteCount = this.byteCount,\r\n\t      blockCount = this.blockCount, index = 0, s = this.s, i, code;\r\n\r\n\t    while (index < length) {\r\n\t      if (this.reset) {\r\n\t        this.reset = false;\r\n\t        blocks[0] = this.block;\r\n\t        for (i = 1; i < blockCount + 1; ++i) {\r\n\t          blocks[i] = 0;\r\n\t        }\r\n\t      }\r\n\t      if (notString) {\r\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\r\n\t          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\r\n\t        }\r\n\t      } else {\r\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\r\n\t          code = message.charCodeAt(index);\r\n\t          if (code < 0x80) {\r\n\t            blocks[i >> 2] |= code << SHIFT[i++ & 3];\r\n\t          } else if (code < 0x800) {\r\n\t            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          } else if (code < 0xd800 || code >= 0xe000) {\r\n\t            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          } else {\r\n\t            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\r\n\t            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      this.lastByteIndex = i;\r\n\t      if (i >= byteCount) {\r\n\t        this.start = i - byteCount;\r\n\t        this.block = blocks[blockCount];\r\n\t        for (i = 0; i < blockCount; ++i) {\r\n\t          s[i] ^= blocks[i];\r\n\t        }\r\n\t        f(s);\r\n\t        this.reset = true;\r\n\t      } else {\r\n\t        this.start = i;\r\n\t      }\r\n\t    }\r\n\t    return this;\r\n\t  };\r\n\r\n\t  Keccak.prototype.finalize = function () {\r\n\t    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\r\n\t    blocks[i >> 2] |= this.padding[i & 3];\r\n\t    if (this.lastByteIndex === this.byteCount) {\r\n\t      blocks[0] = blocks[blockCount];\r\n\t      for (i = 1; i < blockCount + 1; ++i) {\r\n\t        blocks[i] = 0;\r\n\t      }\r\n\t    }\r\n\t    blocks[blockCount - 1] |= 0x80000000;\r\n\t    for (i = 0; i < blockCount; ++i) {\r\n\t      s[i] ^= blocks[i];\r\n\t    }\r\n\t    f(s);\r\n\t  };\r\n\r\n\t  Keccak.prototype.toString = Keccak.prototype.hex = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var hex = '', block;\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        block = s[i];\r\n\t        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\r\n\t               HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\r\n\t               HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\r\n\t               HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t        i = 0;\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      block = s[i];\r\n\t      if (extraBytes > 0) {\r\n\t        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\r\n\t      }\r\n\t      if (extraBytes > 1) {\r\n\t        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\r\n\t      }\r\n\t      if (extraBytes > 2) {\r\n\t        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\r\n\t      }\r\n\t    }\r\n\t    return hex;\r\n\t  };\r\n\r\n\t  Keccak.prototype.arrayBuffer = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var bytes = this.outputBits >> 3;\r\n\t    var buffer;\r\n\t    if (extraBytes) {\r\n\t      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\r\n\t    } else {\r\n\t      buffer = new ArrayBuffer(bytes);\r\n\t    }\r\n\t    var array = new Uint32Array(buffer);\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        array[j] = s[i];\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      array[i] = s[i];\r\n\t      buffer = buffer.slice(0, bytes);\r\n\t    }\r\n\t    return buffer;\r\n\t  };\r\n\r\n\t  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\r\n\r\n\t  Keccak.prototype.digest = Keccak.prototype.array = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var array = [], offset, block;\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        offset = j << 2;\r\n\t        block = s[i];\r\n\t        array[offset] = block & 0xFF;\r\n\t        array[offset + 1] = (block >> 8) & 0xFF;\r\n\t        array[offset + 2] = (block >> 16) & 0xFF;\r\n\t        array[offset + 3] = (block >> 24) & 0xFF;\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      offset = j << 2;\r\n\t      block = s[i];\r\n\t      if (extraBytes > 0) {\r\n\t        array[offset] = block & 0xFF;\r\n\t      }\r\n\t      if (extraBytes > 1) {\r\n\t        array[offset + 1] = (block >> 8) & 0xFF;\r\n\t      }\r\n\t      if (extraBytes > 2) {\r\n\t        array[offset + 2] = (block >> 16) & 0xFF;\r\n\t      }\r\n\t    }\r\n\t    return array;\r\n\t  };\r\n\r\n\t  var f = function (s) {\r\n\t    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\r\n\t        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\r\n\t        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\r\n\t        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\r\n\t    for (n = 0; n < 48; n += 2) {\r\n\t      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\r\n\t      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\r\n\t      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\r\n\t      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\r\n\t      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\r\n\t      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\r\n\t      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\r\n\t      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\r\n\t      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\r\n\t      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\r\n\r\n\t      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\r\n\t      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\r\n\t      s[0] ^= h;\r\n\t      s[1] ^= l;\r\n\t      s[10] ^= h;\r\n\t      s[11] ^= l;\r\n\t      s[20] ^= h;\r\n\t      s[21] ^= l;\r\n\t      s[30] ^= h;\r\n\t      s[31] ^= l;\r\n\t      s[40] ^= h;\r\n\t      s[41] ^= l;\r\n\t      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\r\n\t      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\r\n\t      s[2] ^= h;\r\n\t      s[3] ^= l;\r\n\t      s[12] ^= h;\r\n\t      s[13] ^= l;\r\n\t      s[22] ^= h;\r\n\t      s[23] ^= l;\r\n\t      s[32] ^= h;\r\n\t      s[33] ^= l;\r\n\t      s[42] ^= h;\r\n\t      s[43] ^= l;\r\n\t      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\r\n\t      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\r\n\t      s[4] ^= h;\r\n\t      s[5] ^= l;\r\n\t      s[14] ^= h;\r\n\t      s[15] ^= l;\r\n\t      s[24] ^= h;\r\n\t      s[25] ^= l;\r\n\t      s[34] ^= h;\r\n\t      s[35] ^= l;\r\n\t      s[44] ^= h;\r\n\t      s[45] ^= l;\r\n\t      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\r\n\t      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\r\n\t      s[6] ^= h;\r\n\t      s[7] ^= l;\r\n\t      s[16] ^= h;\r\n\t      s[17] ^= l;\r\n\t      s[26] ^= h;\r\n\t      s[27] ^= l;\r\n\t      s[36] ^= h;\r\n\t      s[37] ^= l;\r\n\t      s[46] ^= h;\r\n\t      s[47] ^= l;\r\n\t      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\r\n\t      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\r\n\t      s[8] ^= h;\r\n\t      s[9] ^= l;\r\n\t      s[18] ^= h;\r\n\t      s[19] ^= l;\r\n\t      s[28] ^= h;\r\n\t      s[29] ^= l;\r\n\t      s[38] ^= h;\r\n\t      s[39] ^= l;\r\n\t      s[48] ^= h;\r\n\t      s[49] ^= l;\r\n\r\n\t      b0 = s[0];\r\n\t      b1 = s[1];\r\n\t      b32 = (s[11] << 4) | (s[10] >>> 28);\r\n\t      b33 = (s[10] << 4) | (s[11] >>> 28);\r\n\t      b14 = (s[20] << 3) | (s[21] >>> 29);\r\n\t      b15 = (s[21] << 3) | (s[20] >>> 29);\r\n\t      b46 = (s[31] << 9) | (s[30] >>> 23);\r\n\t      b47 = (s[30] << 9) | (s[31] >>> 23);\r\n\t      b28 = (s[40] << 18) | (s[41] >>> 14);\r\n\t      b29 = (s[41] << 18) | (s[40] >>> 14);\r\n\t      b20 = (s[2] << 1) | (s[3] >>> 31);\r\n\t      b21 = (s[3] << 1) | (s[2] >>> 31);\r\n\t      b2 = (s[13] << 12) | (s[12] >>> 20);\r\n\t      b3 = (s[12] << 12) | (s[13] >>> 20);\r\n\t      b34 = (s[22] << 10) | (s[23] >>> 22);\r\n\t      b35 = (s[23] << 10) | (s[22] >>> 22);\r\n\t      b16 = (s[33] << 13) | (s[32] >>> 19);\r\n\t      b17 = (s[32] << 13) | (s[33] >>> 19);\r\n\t      b48 = (s[42] << 2) | (s[43] >>> 30);\r\n\t      b49 = (s[43] << 2) | (s[42] >>> 30);\r\n\t      b40 = (s[5] << 30) | (s[4] >>> 2);\r\n\t      b41 = (s[4] << 30) | (s[5] >>> 2);\r\n\t      b22 = (s[14] << 6) | (s[15] >>> 26);\r\n\t      b23 = (s[15] << 6) | (s[14] >>> 26);\r\n\t      b4 = (s[25] << 11) | (s[24] >>> 21);\r\n\t      b5 = (s[24] << 11) | (s[25] >>> 21);\r\n\t      b36 = (s[34] << 15) | (s[35] >>> 17);\r\n\t      b37 = (s[35] << 15) | (s[34] >>> 17);\r\n\t      b18 = (s[45] << 29) | (s[44] >>> 3);\r\n\t      b19 = (s[44] << 29) | (s[45] >>> 3);\r\n\t      b10 = (s[6] << 28) | (s[7] >>> 4);\r\n\t      b11 = (s[7] << 28) | (s[6] >>> 4);\r\n\t      b42 = (s[17] << 23) | (s[16] >>> 9);\r\n\t      b43 = (s[16] << 23) | (s[17] >>> 9);\r\n\t      b24 = (s[26] << 25) | (s[27] >>> 7);\r\n\t      b25 = (s[27] << 25) | (s[26] >>> 7);\r\n\t      b6 = (s[36] << 21) | (s[37] >>> 11);\r\n\t      b7 = (s[37] << 21) | (s[36] >>> 11);\r\n\t      b38 = (s[47] << 24) | (s[46] >>> 8);\r\n\t      b39 = (s[46] << 24) | (s[47] >>> 8);\r\n\t      b30 = (s[8] << 27) | (s[9] >>> 5);\r\n\t      b31 = (s[9] << 27) | (s[8] >>> 5);\r\n\t      b12 = (s[18] << 20) | (s[19] >>> 12);\r\n\t      b13 = (s[19] << 20) | (s[18] >>> 12);\r\n\t      b44 = (s[29] << 7) | (s[28] >>> 25);\r\n\t      b45 = (s[28] << 7) | (s[29] >>> 25);\r\n\t      b26 = (s[38] << 8) | (s[39] >>> 24);\r\n\t      b27 = (s[39] << 8) | (s[38] >>> 24);\r\n\t      b8 = (s[48] << 14) | (s[49] >>> 18);\r\n\t      b9 = (s[49] << 14) | (s[48] >>> 18);\r\n\r\n\t      s[0] = b0 ^ (~b2 & b4);\r\n\t      s[1] = b1 ^ (~b3 & b5);\r\n\t      s[10] = b10 ^ (~b12 & b14);\r\n\t      s[11] = b11 ^ (~b13 & b15);\r\n\t      s[20] = b20 ^ (~b22 & b24);\r\n\t      s[21] = b21 ^ (~b23 & b25);\r\n\t      s[30] = b30 ^ (~b32 & b34);\r\n\t      s[31] = b31 ^ (~b33 & b35);\r\n\t      s[40] = b40 ^ (~b42 & b44);\r\n\t      s[41] = b41 ^ (~b43 & b45);\r\n\t      s[2] = b2 ^ (~b4 & b6);\r\n\t      s[3] = b3 ^ (~b5 & b7);\r\n\t      s[12] = b12 ^ (~b14 & b16);\r\n\t      s[13] = b13 ^ (~b15 & b17);\r\n\t      s[22] = b22 ^ (~b24 & b26);\r\n\t      s[23] = b23 ^ (~b25 & b27);\r\n\t      s[32] = b32 ^ (~b34 & b36);\r\n\t      s[33] = b33 ^ (~b35 & b37);\r\n\t      s[42] = b42 ^ (~b44 & b46);\r\n\t      s[43] = b43 ^ (~b45 & b47);\r\n\t      s[4] = b4 ^ (~b6 & b8);\r\n\t      s[5] = b5 ^ (~b7 & b9);\r\n\t      s[14] = b14 ^ (~b16 & b18);\r\n\t      s[15] = b15 ^ (~b17 & b19);\r\n\t      s[24] = b24 ^ (~b26 & b28);\r\n\t      s[25] = b25 ^ (~b27 & b29);\r\n\t      s[34] = b34 ^ (~b36 & b38);\r\n\t      s[35] = b35 ^ (~b37 & b39);\r\n\t      s[44] = b44 ^ (~b46 & b48);\r\n\t      s[45] = b45 ^ (~b47 & b49);\r\n\t      s[6] = b6 ^ (~b8 & b0);\r\n\t      s[7] = b7 ^ (~b9 & b1);\r\n\t      s[16] = b16 ^ (~b18 & b10);\r\n\t      s[17] = b17 ^ (~b19 & b11);\r\n\t      s[26] = b26 ^ (~b28 & b20);\r\n\t      s[27] = b27 ^ (~b29 & b21);\r\n\t      s[36] = b36 ^ (~b38 & b30);\r\n\t      s[37] = b37 ^ (~b39 & b31);\r\n\t      s[46] = b46 ^ (~b48 & b40);\r\n\t      s[47] = b47 ^ (~b49 & b41);\r\n\t      s[8] = b8 ^ (~b0 & b2);\r\n\t      s[9] = b9 ^ (~b1 & b3);\r\n\t      s[18] = b18 ^ (~b10 & b12);\r\n\t      s[19] = b19 ^ (~b11 & b13);\r\n\t      s[28] = b28 ^ (~b20 & b22);\r\n\t      s[29] = b29 ^ (~b21 & b23);\r\n\t      s[38] = b38 ^ (~b30 & b32);\r\n\t      s[39] = b39 ^ (~b31 & b33);\r\n\t      s[48] = b48 ^ (~b40 & b42);\r\n\t      s[49] = b49 ^ (~b41 & b43);\r\n\r\n\t      s[0] ^= RC[n];\r\n\t      s[1] ^= RC[n + 1];\r\n\t    }\r\n\t  };\r\n\r\n\t  if (COMMON_JS) {\r\n\t    module.exports = methods;\r\n\t  } else {\r\n\t    for (var i = 0; i < methodNames.length; ++i) {\r\n\t      root[methodNames[i]] = methods[methodNames[i]];\r\n\t    }\r\n\t  }\r\n\t})();\n\t});\n\n\tvar lib$4 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar js_sha3_1 = __importDefault(sha3);\n\n\tfunction keccak256(data) {\n\t    return '0x' + js_sha3_1.default.keccak_256(lib$1.arrayify(data));\n\t}\n\texports.keccak256 = keccak256;\n\t});\n\n\tvar index$4 = unwrapExports(lib$4);\n\tvar lib_1$4 = lib$4.keccak256;\n\n\tvar _version$a = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"rlp/5.0.0-beta.133\";\n\t});\n\n\tvar _version$b = unwrapExports(_version$a);\n\tvar _version_1$5 = _version$a.version;\n\n\tvar lib$5 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\n\tvar logger = new lib.Logger(_version$a.version);\n\tfunction arrayifyInteger(value) {\n\t    var result = [];\n\t    while (value) {\n\t        result.unshift(value & 0xff);\n\t        value >>= 8;\n\t    }\n\t    return result;\n\t}\n\tfunction unarrayifyInteger(data, offset, length) {\n\t    var result = 0;\n\t    for (var i = 0; i < length; i++) {\n\t        result = (result * 256) + data[offset + i];\n\t    }\n\t    return result;\n\t}\n\tfunction _encode(object) {\n\t    if (Array.isArray(object)) {\n\t        var payload_1 = [];\n\t        object.forEach(function (child) {\n\t            payload_1 = payload_1.concat(_encode(child));\n\t        });\n\t        if (payload_1.length <= 55) {\n\t            payload_1.unshift(0xc0 + payload_1.length);\n\t            return payload_1;\n\t        }\n\t        var length_1 = arrayifyInteger(payload_1.length);\n\t        length_1.unshift(0xf7 + length_1.length);\n\t        return length_1.concat(payload_1);\n\t    }\n\t    if (!lib$1.isBytesLike(object)) {\n\t        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n\t    }\n\t    var data = Array.prototype.slice.call(lib$1.arrayify(object));\n\t    if (data.length === 1 && data[0] <= 0x7f) {\n\t        return data;\n\t    }\n\t    else if (data.length <= 55) {\n\t        data.unshift(0x80 + data.length);\n\t        return data;\n\t    }\n\t    var length = arrayifyInteger(data.length);\n\t    length.unshift(0xb7 + length.length);\n\t    return length.concat(data);\n\t}\n\tfunction encode(object) {\n\t    return lib$1.hexlify(_encode(object));\n\t}\n\texports.encode = encode;\n\tfunction _decodeChildren(data, offset, childOffset, length) {\n\t    var result = [];\n\t    while (childOffset < offset + 1 + length) {\n\t        var decoded = _decode(data, childOffset);\n\t        result.push(decoded.result);\n\t        childOffset += decoded.consumed;\n\t        if (childOffset > offset + 1 + length) {\n\t            logger.throwError(\"child data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t    }\n\t    return { consumed: (1 + length), result: result };\n\t}\n\t// returns { consumed: number, result: Object }\n\tfunction _decode(data, offset) {\n\t    if (data.length === 0) {\n\t        logger.throwError(\"data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t    }\n\t    // Array with extra length prefix\n\t    if (data[offset] >= 0xf8) {\n\t        var lengthLength = data[offset] - 0xf7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError(\"data short segment too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_2 > data.length) {\n\t            logger.throwError(\"data long segment too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);\n\t    }\n\t    else if (data[offset] >= 0xc0) {\n\t        var length_3 = data[offset] - 0xc0;\n\t        if (offset + 1 + length_3 > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1, length_3);\n\t    }\n\t    else if (data[offset] >= 0xb8) {\n\t        var lengthLength = data[offset] - 0xb7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_4 > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = lib$1.hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));\n\t        return { consumed: (1 + lengthLength + length_4), result: result };\n\t    }\n\t    else if (data[offset] >= 0x80) {\n\t        var length_5 = data[offset] - 0x80;\n\t        if (offset + 1 + length_5 > data.length) {\n\t            logger.throwError(\"data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = lib$1.hexlify(data.slice(offset + 1, offset + 1 + length_5));\n\t        return { consumed: (1 + length_5), result: result };\n\t    }\n\t    return { consumed: 1, result: lib$1.hexlify(data[offset]) };\n\t}\n\tfunction decode(data) {\n\t    var bytes = lib$1.arrayify(data);\n\t    var decoded = _decode(bytes, 0);\n\t    if (decoded.consumed !== bytes.length) {\n\t        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n\t    }\n\t    return decoded.result;\n\t}\n\texports.decode = decode;\n\t});\n\n\tvar index$5 = unwrapExports(lib$5);\n\tvar lib_1$5 = lib$5.encode;\n\tvar lib_2$4 = lib$5.decode;\n\n\tvar _version$c = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"address/5.0.0-beta.135\";\n\t});\n\n\tvar _version$d = unwrapExports(_version$c);\n\tvar _version_1$6 = _version$c.version;\n\n\tvar lib$6 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// We use this for base 36 maths\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$c.version);\n\tfunction getChecksumAddress(address) {\n\t    if (!lib$1.isHexString(address, 20)) {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    address = address.toLowerCase();\n\t    var chars = address.substring(2).split(\"\");\n\t    var expanded = new Uint8Array(40);\n\t    for (var i = 0; i < 40; i++) {\n\t        expanded[i] = chars[i].charCodeAt(0);\n\t    }\n\t    var hashed = lib$1.arrayify(lib$4.keccak256(expanded));\n\t    for (var i = 0; i < 40; i += 2) {\n\t        if ((hashed[i >> 1] >> 4) >= 8) {\n\t            chars[i] = chars[i].toUpperCase();\n\t        }\n\t        if ((hashed[i >> 1] & 0x0f) >= 8) {\n\t            chars[i + 1] = chars[i + 1].toUpperCase();\n\t        }\n\t    }\n\t    return \"0x\" + chars.join(\"\");\n\t}\n\t// Shims for environments that are missing some required constants and functions\n\tvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\tfunction log10(x) {\n\t    if (Math.log10) {\n\t        return Math.log10(x);\n\t    }\n\t    return Math.log(x) / Math.LN10;\n\t}\n\t// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\t// Create lookup table\n\tvar ibanLookup = {};\n\tfor (var i = 0; i < 10; i++) {\n\t    ibanLookup[String(i)] = String(i);\n\t}\n\tfor (var i = 0; i < 26; i++) {\n\t    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n\t}\n\t// How many decimal digits can we process? (for 64-bit float, this is 15)\n\tvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\tfunction ibanChecksum(address) {\n\t    address = address.toUpperCase();\n\t    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\t    var expanded = address.split(\"\").map(function (c) { return ibanLookup[c]; }).join(\"\");\n\t    // Javascript can handle integers safely up to 15 (decimal) digits\n\t    while (expanded.length >= safeDigits) {\n\t        var block = expanded.substring(0, safeDigits);\n\t        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n\t    }\n\t    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n\t    while (checksum.length < 2) {\n\t        checksum = \"0\" + checksum;\n\t    }\n\t    return checksum;\n\t}\n\t;\n\tfunction getAddress(address) {\n\t    var result = null;\n\t    if (typeof (address) !== \"string\") {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\t        // Missing the 0x prefix\n\t        if (address.substring(0, 2) !== \"0x\") {\n\t            address = \"0x\" + address;\n\t        }\n\t        result = getChecksumAddress(address);\n\t        // It is a checksummed address with a bad checksum\n\t        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n\t            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n\t        }\n\t        // Maybe ICAP? (we only support direct mode)\n\t    }\n\t    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\t        // It is an ICAP address with a bad checksum\n\t        if (address.substring(2, 4) !== ibanChecksum(address)) {\n\t            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n\t        }\n\t        result = (new bn.BN(address.substring(4), 36)).toString(16);\n\t        while (result.length < 40) {\n\t            result = \"0\" + result;\n\t        }\n\t        result = getChecksumAddress(\"0x\" + result);\n\t    }\n\t    else {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    return result;\n\t}\n\texports.getAddress = getAddress;\n\tfunction isAddress(address) {\n\t    try {\n\t        getAddress(address);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isAddress = isAddress;\n\tfunction getIcapAddress(address) {\n\t    var base36 = (new bn.BN(getAddress(address).substring(2), 16)).toString(36).toUpperCase();\n\t    while (base36.length < 30) {\n\t        base36 = \"0\" + base36;\n\t    }\n\t    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n\t}\n\texports.getIcapAddress = getIcapAddress;\n\t// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\tfunction getContractAddress(transaction) {\n\t    var from = null;\n\t    try {\n\t        from = getAddress(transaction.from);\n\t    }\n\t    catch (error) {\n\t        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n\t    }\n\t    var nonce = lib$1.stripZeros(lib$1.arrayify(lib$2.BigNumber.from(transaction.nonce).toHexString()));\n\t    return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$5.encode([from, nonce])), 12));\n\t}\n\texports.getContractAddress = getContractAddress;\n\tfunction getCreate2Address(from, salt, initCodeHash) {\n\t    if (lib$1.hexDataLength(salt) !== 32) {\n\t        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n\t    }\n\t    if (lib$1.hexDataLength(initCodeHash) !== 32) {\n\t        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n\t    }\n\t    return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n\t}\n\texports.getCreate2Address = getCreate2Address;\n\t});\n\n\tvar index$6 = unwrapExports(lib$6);\n\tvar lib_1$6 = lib$6.getAddress;\n\tvar lib_2$5 = lib$6.isAddress;\n\tvar lib_3$4 = lib$6.getIcapAddress;\n\tvar lib_4$3 = lib$6.getContractAddress;\n\tvar lib_5$3 = lib$6.getCreate2Address;\n\n\tvar address = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar AddressCoder = /** @class */ (function (_super) {\n\t    __extends(AddressCoder, _super);\n\t    function AddressCoder(localName) {\n\t        return _super.call(this, \"address\", \"address\", localName, false) || this;\n\t    }\n\t    AddressCoder.prototype.encode = function (writer, value) {\n\t        try {\n\t            lib$6.getAddress(value);\n\t        }\n\t        catch (error) {\n\t            this._throwError(error.message, value);\n\t        }\n\t        return writer.writeValue(value);\n\t    };\n\t    AddressCoder.prototype.decode = function (reader) {\n\t        return lib$6.getAddress(lib$1.hexZeroPad(reader.readValue().toHexString(), 20));\n\t    };\n\t    return AddressCoder;\n\t}(abstractCoder.Coder));\n\texports.AddressCoder = AddressCoder;\n\t});\n\n\tvar address$1 = unwrapExports(address);\n\tvar address_2 = address.AddressCoder;\n\n\tvar anonymous = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\t// Clones the functionality of an existing Coder, but without a localName\n\tvar AnonymousCoder = /** @class */ (function (_super) {\n\t    __extends(AnonymousCoder, _super);\n\t    function AnonymousCoder(coder) {\n\t        var _this = _super.call(this, coder.name, coder.type, undefined, coder.dynamic) || this;\n\t        _this.coder = coder;\n\t        return _this;\n\t    }\n\t    AnonymousCoder.prototype.encode = function (writer, value) {\n\t        return this.coder.encode(writer, value);\n\t    };\n\t    AnonymousCoder.prototype.decode = function (reader) {\n\t        return this.coder.decode(reader);\n\t    };\n\t    return AnonymousCoder;\n\t}(abstractCoder.Coder));\n\texports.AnonymousCoder = AnonymousCoder;\n\t});\n\n\tvar anonymous$1 = unwrapExports(anonymous);\n\tvar anonymous_1 = anonymous.AnonymousCoder;\n\n\tvar array = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\tfunction pack(writer, coders, values) {\n\t    var arrayValues = null;\n\t    if (Array.isArray(values)) {\n\t        arrayValues = values;\n\t    }\n\t    else if (values && typeof (values) === \"object\") {\n\t        var unique_1 = {};\n\t        arrayValues = coders.map(function (coder) {\n\t            var name = coder.localName;\n\t            if (!name) {\n\t                logger.throwError(\"cannot encode object for signature with missing names\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"values\",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            if (unique_1[name]) {\n\t                logger.throwError(\"cannot encode object for signature with duplicate names\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"values\",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            unique_1[name] = true;\n\t            return values[name];\n\t        });\n\t    }\n\t    else {\n\t        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n\t    }\n\t    if (coders.length !== arrayValues.length) {\n\t        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n\t    }\n\t    var staticWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var dynamicWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var updateFuncs = [];\n\t    coders.forEach(function (coder, index) {\n\t        var value = arrayValues[index];\n\t        if (coder.dynamic) {\n\t            // Get current dynamic offset (for the future pointer)\n\t            var dynamicOffset_1 = dynamicWriter.length;\n\t            // Encode the dynamic value into the dynamicWriter\n\t            coder.encode(dynamicWriter, value);\n\t            // Prepare to populate the correct offset once we are done\n\t            var updateFunc_1 = staticWriter.writeUpdatableValue();\n\t            updateFuncs.push(function (baseOffset) {\n\t                updateFunc_1(baseOffset + dynamicOffset_1);\n\t            });\n\t        }\n\t        else {\n\t            coder.encode(staticWriter, value);\n\t        }\n\t    });\n\t    // Backfill all the dynamic offsets, now that we know the static length\n\t    updateFuncs.forEach(function (func) { func(staticWriter.length); });\n\t    var length = writer.writeBytes(staticWriter.data);\n\t    length += writer.writeBytes(dynamicWriter.data);\n\t    return length;\n\t}\n\texports.pack = pack;\n\tfunction unpack(reader, coders) {\n\t    var values = [];\n\t    // A reader anchored to this base\n\t    var baseReader = reader.subReader(0);\n\t    // The amount of dynamic data read; to consume later to synchronize\n\t    var dynamicLength = 0;\n\t    coders.forEach(function (coder) {\n\t        var value = null;\n\t        if (coder.dynamic) {\n\t            var offset = reader.readValue();\n\t            var offsetReader = baseReader.subReader(offset.toNumber());\n\t            try {\n\t                value = coder.decode(offsetReader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t            dynamicLength += offsetReader.consumed;\n\t        }\n\t        else {\n\t            try {\n\t                value = coder.decode(reader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t        }\n\t        if (value != undefined) {\n\t            values.push(value);\n\t        }\n\t    });\n\t    // @TODO: get rid of this an see if it still works?\n\t    // Consume the dynamic components in the main reader\n\t    reader.readBytes(dynamicLength);\n\t    // We only output named properties for uniquely named coders\n\t    var uniqueNames = coders.reduce(function (accum, coder) {\n\t        var name = coder.localName;\n\t        if (name) {\n\t            if (!accum[name]) {\n\t                accum[name] = 0;\n\t            }\n\t            accum[name]++;\n\t        }\n\t        return accum;\n\t    }, {});\n\t    // Add any named parameters (i.e. tuples)\n\t    coders.forEach(function (coder, index) {\n\t        var name = coder.localName;\n\t        if (!name || uniqueNames[name] !== 1) {\n\t            return;\n\t        }\n\t        if (name === \"length\") {\n\t            name = \"_length\";\n\t        }\n\t        if (values[name] != null) {\n\t            return;\n\t        }\n\t        var value = values[index];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, name, {\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t        else {\n\t            values[name] = value;\n\t        }\n\t    });\n\t    var _loop_1 = function (i) {\n\t        var value = values[i];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, i, {\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t    };\n\t    for (var i = 0; i < values.length; i++) {\n\t        _loop_1(i);\n\t    }\n\t    return Object.freeze(values);\n\t}\n\texports.unpack = unpack;\n\tvar ArrayCoder = /** @class */ (function (_super) {\n\t    __extends(ArrayCoder, _super);\n\t    function ArrayCoder(coder, length, localName) {\n\t        var _this = this;\n\t        var type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n\t        var dynamic = (length === -1 || coder.dynamic);\n\t        _this = _super.call(this, \"array\", type, localName, dynamic) || this;\n\t        _this.coder = coder;\n\t        _this.length = length;\n\t        return _this;\n\t    }\n\t    ArrayCoder.prototype.encode = function (writer, value) {\n\t        if (!Array.isArray(value)) {\n\t            this._throwError(\"expected array value\", value);\n\t        }\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = value.length;\n\t            writer.writeValue(value.length);\n\t        }\n\t        logger.checkArgumentCount(count, value.length, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n\t        var coders = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            coders.push(this.coder);\n\t        }\n\t        return pack(writer, coders, value);\n\t    };\n\t    ArrayCoder.prototype.decode = function (reader) {\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = reader.readValue().toNumber();\n\t        }\n\t        var coders = [];\n\t        for (var i = 0; i < count; i++) {\n\t            coders.push(new anonymous.AnonymousCoder(this.coder));\n\t        }\n\t        return reader.coerce(this.name, unpack(reader, coders));\n\t    };\n\t    return ArrayCoder;\n\t}(abstractCoder.Coder));\n\texports.ArrayCoder = ArrayCoder;\n\t});\n\n\tvar array$1 = unwrapExports(array);\n\tvar array_1 = array.pack;\n\tvar array_2 = array.unpack;\n\tvar array_3 = array.ArrayCoder;\n\n\tvar boolean_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tvar BooleanCoder = /** @class */ (function (_super) {\n\t    __extends(BooleanCoder, _super);\n\t    function BooleanCoder(localName) {\n\t        return _super.call(this, \"bool\", \"bool\", localName, false) || this;\n\t    }\n\t    BooleanCoder.prototype.encode = function (writer, value) {\n\t        return writer.writeValue(value ? 1 : 0);\n\t    };\n\t    BooleanCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.type, !reader.readValue().isZero());\n\t    };\n\t    return BooleanCoder;\n\t}(abstractCoder.Coder));\n\texports.BooleanCoder = BooleanCoder;\n\t});\n\n\tvar boolean = unwrapExports(boolean_1);\n\tvar boolean_2 = boolean_1.BooleanCoder;\n\n\tvar bytes = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar DynamicBytesCoder = /** @class */ (function (_super) {\n\t    __extends(DynamicBytesCoder, _super);\n\t    function DynamicBytesCoder(type, localName) {\n\t        return _super.call(this, type, type, localName, true) || this;\n\t    }\n\t    DynamicBytesCoder.prototype.encode = function (writer, value) {\n\t        value = lib$1.arrayify(value);\n\t        var length = writer.writeValue(value.length);\n\t        length += writer.writeBytes(value);\n\t        return length;\n\t    };\n\t    DynamicBytesCoder.prototype.decode = function (reader) {\n\t        return reader.readBytes(reader.readValue().toNumber());\n\t    };\n\t    return DynamicBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.DynamicBytesCoder = DynamicBytesCoder;\n\tvar BytesCoder = /** @class */ (function (_super) {\n\t    __extends(BytesCoder, _super);\n\t    function BytesCoder(localName) {\n\t        return _super.call(this, \"bytes\", localName) || this;\n\t    }\n\t    BytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, lib$1.hexlify(_super.prototype.decode.call(this, reader)));\n\t    };\n\t    return BytesCoder;\n\t}(DynamicBytesCoder));\n\texports.BytesCoder = BytesCoder;\n\t});\n\n\tvar bytes$1 = unwrapExports(bytes);\n\tvar bytes_2 = bytes.DynamicBytesCoder;\n\tvar bytes_3 = bytes.BytesCoder;\n\n\tvar fixedBytes = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\t// @TODO: Merge this with bytes\n\tvar FixedBytesCoder = /** @class */ (function (_super) {\n\t    __extends(FixedBytesCoder, _super);\n\t    function FixedBytesCoder(size, localName) {\n\t        var _this = this;\n\t        var name = \"bytes\" + String(size);\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        return _this;\n\t    }\n\t    FixedBytesCoder.prototype.encode = function (writer, value) {\n\t        var data = lib$1.arrayify(value);\n\t        if (data.length !== this.size) {\n\t            this._throwError(\"incorrect data length\", value);\n\t        }\n\t        return writer.writeBytes(data);\n\t    };\n\t    FixedBytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, lib$1.hexlify(reader.readBytes(this.size)));\n\t    };\n\t    return FixedBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.FixedBytesCoder = FixedBytesCoder;\n\t});\n\n\tvar fixedBytes$1 = unwrapExports(fixedBytes);\n\tvar fixedBytes_1 = fixedBytes.FixedBytesCoder;\n\n\tvar _null = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tvar NullCoder = /** @class */ (function (_super) {\n\t    __extends(NullCoder, _super);\n\t    function NullCoder(localName) {\n\t        return _super.call(this, \"null\", \"\", localName, false) || this;\n\t    }\n\t    NullCoder.prototype.encode = function (writer, value) {\n\t        if (value != null) {\n\t            this._throwError(\"not null\", value);\n\t        }\n\t        return writer.writeBytes([]);\n\t    };\n\t    NullCoder.prototype.decode = function (reader) {\n\t        reader.readBytes(0);\n\t        return reader.coerce(this.name, null);\n\t    };\n\t    return NullCoder;\n\t}(abstractCoder.Coder));\n\texports.NullCoder = NullCoder;\n\t});\n\n\tvar _null$1 = unwrapExports(_null);\n\tvar _null_1 = _null.NullCoder;\n\n\tvar lib$7 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tvar AddressZero = \"0x0000000000000000000000000000000000000000\";\n\texports.AddressZero = AddressZero;\n\tvar HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\texports.HashZero = HashZero;\n\t// NFKC (composed)             // (decomposed)\n\tvar EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n\texports.EtherSymbol = EtherSymbol;\n\tvar NegativeOne = lib$2.BigNumber.from(-1);\n\texports.NegativeOne = NegativeOne;\n\tvar Zero = lib$2.BigNumber.from(0);\n\texports.Zero = Zero;\n\tvar One = lib$2.BigNumber.from(1);\n\texports.One = One;\n\tvar Two = lib$2.BigNumber.from(2);\n\texports.Two = Two;\n\tvar WeiPerEther = lib$2.BigNumber.from(\"1000000000000000000\");\n\texports.WeiPerEther = WeiPerEther;\n\tvar MaxUint256 = lib$2.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\texports.MaxUint256 = MaxUint256;\n\t});\n\n\tvar index$7 = unwrapExports(lib$7);\n\tvar lib_1$7 = lib$7.AddressZero;\n\tvar lib_2$6 = lib$7.HashZero;\n\tvar lib_3$5 = lib$7.EtherSymbol;\n\tvar lib_4$4 = lib$7.NegativeOne;\n\tvar lib_5$4 = lib$7.Zero;\n\tvar lib_6$2 = lib$7.One;\n\tvar lib_7$2 = lib$7.Two;\n\tvar lib_8$1 = lib$7.WeiPerEther;\n\tvar lib_9$1 = lib$7.MaxUint256;\n\n\tvar number = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar NumberCoder = /** @class */ (function (_super) {\n\t    __extends(NumberCoder, _super);\n\t    function NumberCoder(size, signed, localName) {\n\t        var _this = this;\n\t        var name = ((signed ? \"int\" : \"uint\") + (size * 8));\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        _this.signed = signed;\n\t        return _this;\n\t    }\n\t    NumberCoder.prototype.encode = function (writer, value) {\n\t        var v = lib$2.BigNumber.from(value);\n\t        // Check bounds are safe for encoding\n\t        var maxUintValue = lib$7.MaxUint256.mask(writer.wordSize * 8);\n\t        if (this.signed) {\n\t            var bounds = maxUintValue.mask(this.size * 8 - 1);\n\t            if (v.gt(bounds) || v.lt(bounds.add(lib$7.One).mul(lib$7.NegativeOne))) {\n\t                this._throwError(\"value out-of-bounds\", value);\n\t            }\n\t        }\n\t        else if (v.lt(lib$7.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n\t            this._throwError(\"value out-of-bounds\", value);\n\t        }\n\t        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\t        if (this.signed) {\n\t            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n\t        }\n\t        return writer.writeValue(v);\n\t    };\n\t    NumberCoder.prototype.decode = function (reader) {\n\t        var value = reader.readValue().mask(this.size * 8);\n\t        if (this.signed) {\n\t            value = value.fromTwos(this.size * 8);\n\t        }\n\t        return reader.coerce(this.name, value);\n\t    };\n\t    return NumberCoder;\n\t}(abstractCoder.Coder));\n\texports.NumberCoder = NumberCoder;\n\t});\n\n\tvar number$1 = unwrapExports(number);\n\tvar number_1 = number.NumberCoder;\n\n\tvar _version$e = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"strings/5.0.0-beta.137\";\n\t});\n\n\tvar _version$f = unwrapExports(_version$e);\n\tvar _version_1$7 = _version$e.version;\n\n\tvar utf8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$e.version);\n\t///////////////////////////////\n\tvar UnicodeNormalizationForm;\n\t(function (UnicodeNormalizationForm) {\n\t    UnicodeNormalizationForm[\"current\"] = \"\";\n\t    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n\t    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n\t    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n\t    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n\t})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n\t;\n\tvar Utf8ErrorReason;\n\t(function (Utf8ErrorReason) {\n\t    // A continuation byte was present where there was nothing to continue\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n\t    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n\t    // The string is too short to process the expected codepoint\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n\t    // A missing continuation byte was expected but not found\n\t    // - offset = the index the continuation byte was expected at\n\t    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n\t    // The computed code point is outside the range for UTF-8\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n\t    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n\t    // UTF-8 strings may not contain UTF-16 surrogate pairs\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n\t    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n\t    // The string is an overlong reperesentation\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; already bounds checked\n\t    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n\t})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\n\t;\n\tfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n\t    return logger.throwArgumentError(\"invalid codepoint at offset \" + offset + \"; \" + reason, \"bytes\", bytes);\n\t}\n\tfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n\t    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n\t        var i = 0;\n\t        for (var o = offset + 1; o < bytes.length; o++) {\n\t            if (bytes[o] >> 6 !== 0x02) {\n\t                break;\n\t            }\n\t            i++;\n\t        }\n\t        return i;\n\t    }\n\t    // This byte runs us past the end of the string, so just jump to the end\n\t    // (but the first byte was read already read and therefore skipped)\n\t    if (reason === Utf8ErrorReason.OVERRUN) {\n\t        return bytes.length - offset - 1;\n\t    }\n\t    // Nothing to skip\n\t    return 0;\n\t}\n\tfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n\t    if (reason === Utf8ErrorReason.OVERLONG) {\n\t        output.push(badCodepoint);\n\t        return 0;\n\t    }\n\t    // Put the replacement character into the output\n\t    output.push(0xfffd);\n\t    // Otherwise, process as if ignoring errors\n\t    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n\t}\n\t// Common error handing strategies\n\texports.Utf8ErrorFuncs = Object.freeze({\n\t    error: errorFunc,\n\t    ignore: ignoreFunc,\n\t    replace: replaceFunc\n\t});\n\t// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n\tfunction getUtf8CodePoints(bytes, onError) {\n\t    if (onError == null) {\n\t        onError = exports.Utf8ErrorFuncs.error;\n\t    }\n\t    bytes = lib$1.arrayify(bytes);\n\t    var result = [];\n\t    var i = 0;\n\t    // Invalid bytes are ignored\n\t    while (i < bytes.length) {\n\t        var c = bytes[i++];\n\t        // 0xxx xxxx\n\t        if (c >> 7 === 0) {\n\t            result.push(c);\n\t            continue;\n\t        }\n\t        // Multibyte; how many bytes left for this character?\n\t        var extraLength = null;\n\t        var overlongMask = null;\n\t        // 110x xxxx 10xx xxxx\n\t        if ((c & 0xe0) === 0xc0) {\n\t            extraLength = 1;\n\t            overlongMask = 0x7f;\n\t            // 1110 xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf0) === 0xe0) {\n\t            extraLength = 2;\n\t            overlongMask = 0x7ff;\n\t            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf8) === 0xf0) {\n\t            extraLength = 3;\n\t            overlongMask = 0xffff;\n\t        }\n\t        else {\n\t            if ((c & 0xc0) === 0x80) {\n\t                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n\t            }\n\t            else {\n\t                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n\t            }\n\t            continue;\n\t        }\n\t        // Do we have enough bytes in our data?\n\t        if (i - 1 + extraLength >= bytes.length) {\n\t            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n\t            continue;\n\t        }\n\t        // Remove the length prefix from the char\n\t        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n\t        for (var j = 0; j < extraLength; j++) {\n\t            var nextChar = bytes[i];\n\t            // Invalid continuation byte\n\t            if ((nextChar & 0xc0) != 0x80) {\n\t                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n\t                res = null;\n\t                break;\n\t            }\n\t            ;\n\t            res = (res << 6) | (nextChar & 0x3f);\n\t            i++;\n\t        }\n\t        // See above loop for invalid contimuation byte\n\t        if (res === null) {\n\t            continue;\n\t        }\n\t        // Maximum code point\n\t        if (res > 0x10ffff) {\n\t            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Reserved for UTF-16 surrogate halves\n\t        if (res >= 0xd800 && res <= 0xdfff) {\n\t            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Check for overlong sequences (more bytes than needed)\n\t        if (res <= overlongMask) {\n\t            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        result.push(res);\n\t    }\n\t    return result;\n\t}\n\t// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\tfunction toUtf8Bytes(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    if (form != UnicodeNormalizationForm.current) {\n\t        logger.checkNormalize();\n\t        str = str.normalize(form);\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\t        if (c < 0x80) {\n\t            result.push(c);\n\t        }\n\t        else if (c < 0x800) {\n\t            result.push((c >> 6) | 0xc0);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t        else if ((c & 0xfc00) == 0xd800) {\n\t            i++;\n\t            var c2 = str.charCodeAt(i);\n\t            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n\t                throw new Error(\"invalid utf-8 string\");\n\t            }\n\t            // Surrogate Pair\n\t            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n\t            result.push((pair >> 18) | 0xf0);\n\t            result.push(((pair >> 12) & 0x3f) | 0x80);\n\t            result.push(((pair >> 6) & 0x3f) | 0x80);\n\t            result.push((pair & 0x3f) | 0x80);\n\t        }\n\t        else {\n\t            result.push((c >> 12) | 0xe0);\n\t            result.push(((c >> 6) & 0x3f) | 0x80);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t    }\n\t    return lib$1.arrayify(result);\n\t}\n\texports.toUtf8Bytes = toUtf8Bytes;\n\t;\n\tfunction escapeChar(value) {\n\t    var hex = (\"0000\" + value.toString(16));\n\t    return \"\\\\u\" + hex.substring(hex.length - 4);\n\t}\n\tfunction _toEscapedUtf8String(bytes, onError) {\n\t    return '\"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\n\t        if (codePoint < 256) {\n\t            switch (codePoint) {\n\t                case 8: return \"\\\\b\";\n\t                case 9: return \"\\\\t\";\n\t                case 10: return \"\\\\n\";\n\t                case 13: return \"\\\\r\";\n\t                case 34: return \"\\\\\\\"\";\n\t                case 92: return \"\\\\\\\\\";\n\t            }\n\t            if (codePoint >= 32 && codePoint < 127) {\n\t                return String.fromCharCode(codePoint);\n\t            }\n\t        }\n\t        if (codePoint <= 0xffff) {\n\t            return escapeChar(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n\t    }).join(\"\") + '\"';\n\t}\n\texports._toEscapedUtf8String = _toEscapedUtf8String;\n\tfunction _toUtf8String(codePoints) {\n\t    return codePoints.map(function (codePoint) {\n\t        if (codePoint <= 0xffff) {\n\t            return String.fromCharCode(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n\t    }).join(\"\");\n\t}\n\texports._toUtf8String = _toUtf8String;\n\tfunction toUtf8String(bytes, onError) {\n\t    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n\t}\n\texports.toUtf8String = toUtf8String;\n\tfunction toUtf8CodePoints(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    return getUtf8CodePoints(toUtf8Bytes(str, form));\n\t}\n\texports.toUtf8CodePoints = toUtf8CodePoints;\n\t});\n\n\tvar utf8$1 = unwrapExports(utf8);\n\tvar utf8_1 = utf8.UnicodeNormalizationForm;\n\tvar utf8_2 = utf8.Utf8ErrorReason;\n\tvar utf8_3 = utf8.Utf8ErrorFuncs;\n\tvar utf8_4 = utf8.toUtf8Bytes;\n\tvar utf8_5 = utf8._toEscapedUtf8String;\n\tvar utf8_6 = utf8._toUtf8String;\n\tvar utf8_7 = utf8.toUtf8String;\n\tvar utf8_8 = utf8.toUtf8CodePoints;\n\n\tvar bytes32 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tfunction formatBytes32String(text) {\n\t    // Get the bytes\n\t    var bytes = utf8.toUtf8Bytes(text);\n\t    // Check we have room for null-termination\n\t    if (bytes.length > 31) {\n\t        throw new Error(\"bytes32 string must be less than 32 bytes\");\n\t    }\n\t    // Zero-pad (implicitly null-terminates)\n\t    return lib$1.hexlify(lib$1.concat([bytes, lib$7.HashZero]).slice(0, 32));\n\t}\n\texports.formatBytes32String = formatBytes32String;\n\tfunction parseBytes32String(bytes) {\n\t    var data = lib$1.arrayify(bytes);\n\t    // Must be 32 bytes with a null-termination\n\t    if (data.length !== 32) {\n\t        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n\t    }\n\t    if (data[31] !== 0) {\n\t        throw new Error(\"invalid bytes32 string - no null terminator\");\n\t    }\n\t    // Find the null termination\n\t    var length = 31;\n\t    while (data[length - 1] === 0) {\n\t        length--;\n\t    }\n\t    // Determine the string value\n\t    return utf8.toUtf8String(data.slice(0, length));\n\t}\n\texports.parseBytes32String = parseBytes32String;\n\t});\n\n\tvar bytes32$1 = unwrapExports(bytes32);\n\tvar bytes32_1 = bytes32.formatBytes32String;\n\tvar bytes32_2 = bytes32.parseBytes32String;\n\n\tvar idna = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tfunction bytes2(data) {\n\t    if ((data.length % 4) !== 0) {\n\t        throw new Error(\"bad data\");\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < data.length; i += 4) {\n\t        result.push(parseInt(data.substring(i, i + 4), 16));\n\t    }\n\t    return result;\n\t}\n\tfunction createTable(data, func) {\n\t    if (!func) {\n\t        func = function (value) { return [parseInt(value, 16)]; };\n\t    }\n\t    var lo = 0;\n\t    var result = {};\n\t    data.split(\",\").forEach(function (pair) {\n\t        var comps = pair.split(\":\");\n\t        lo += parseInt(comps[0], 16);\n\t        result[lo] = func(comps[1]);\n\t    });\n\t    return result;\n\t}\n\tfunction createRangeTable(data) {\n\t    var hi = 0;\n\t    return data.split(\",\").map(function (v) {\n\t        var comps = v.split(\"-\");\n\t        if (comps.length === 1) {\n\t            comps[1] = \"0\";\n\t        }\n\t        else if (comps[1] === \"\") {\n\t            comps[1] = \"1\";\n\t        }\n\t        var lo = hi + parseInt(comps[0], 16);\n\t        hi = parseInt(comps[1], 16);\n\t        return { l: lo, h: hi };\n\t    });\n\t}\n\tfunction matchMap(value, ranges) {\n\t    var lo = 0;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        lo += range.l;\n\t        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n\t            if (range.e && range.e.indexOf(value - lo) !== -1) {\n\t                continue;\n\t            }\n\t            return range;\n\t        }\n\t    }\n\t    return null;\n\t}\n\tvar Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\t// @TODO: Make this relative...\n\tvar Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map(function (v) { return parseInt(v, 16); });\n\tvar Table_B_2_ranges = [\n\t    { h: 25, s: 32, l: 65 },\n\t    { h: 30, s: 32, e: [23], l: 127 },\n\t    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n\t    { h: 14, s: 1, l: 57, d: 2 },\n\t    { h: 44, s: 1, l: 17, d: 2 },\n\t    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n\t    { h: 16, s: 1, l: 68, d: 2 },\n\t    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n\t    { h: 26, s: 32, e: [17], l: 435 },\n\t    { h: 22, s: 1, l: 71, d: 2 },\n\t    { h: 15, s: 80, l: 40 },\n\t    { h: 31, s: 32, l: 16 },\n\t    { h: 32, s: 1, l: 80, d: 2 },\n\t    { h: 52, s: 1, l: 42, d: 2 },\n\t    { h: 12, s: 1, l: 55, d: 2 },\n\t    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n\t    { h: 14, s: 1, l: 48, d: 2 },\n\t    { h: 37, s: 48, l: 49 },\n\t    { h: 148, s: 1, l: 6351, d: 2 },\n\t    { h: 88, s: 1, l: 160, d: 2 },\n\t    { h: 15, s: 16, l: 704 },\n\t    { h: 25, s: 26, l: 854 },\n\t    { h: 25, s: 32, l: 55915 },\n\t    { h: 37, s: 40, l: 1247 },\n\t    { h: 25, s: -119711, l: 53248 },\n\t    { h: 25, s: -119763, l: 52 },\n\t    { h: 25, s: -119815, l: 52 },\n\t    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n\t    { h: 25, s: -119919, l: 52 },\n\t    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n\t    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n\t    { h: 25, s: -120075, l: 52 },\n\t    { h: 25, s: -120127, l: 52 },\n\t    { h: 25, s: -120179, l: 52 },\n\t    { h: 25, s: -120231, l: 52 },\n\t    { h: 25, s: -120283, l: 52 },\n\t    { h: 25, s: -120335, l: 52 },\n\t    { h: 24, s: -119543, e: [17], l: 56 },\n\t    { h: 24, s: -119601, e: [17], l: 58 },\n\t    { h: 24, s: -119659, e: [17], l: 58 },\n\t    { h: 24, s: -119717, e: [17], l: 58 },\n\t    { h: 24, s: -119775, e: [17], l: 58 }\n\t];\n\tvar Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\n\tvar Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\n\tvar Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\tvar Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\tfunction flatten(values) {\n\t    return values.reduce(function (accum, value) {\n\t        value.forEach(function (value) { accum.push(value); });\n\t        return accum;\n\t    }, []);\n\t}\n\tfunction _nameprepTableA1(codepoint) {\n\t    return !!matchMap(codepoint, Table_A_1_ranges);\n\t}\n\texports._nameprepTableA1 = _nameprepTableA1;\n\tfunction _nameprepTableB2(codepoint) {\n\t    var range = matchMap(codepoint, Table_B_2_ranges);\n\t    if (range) {\n\t        return [codepoint + range.s];\n\t    }\n\t    var codes = Table_B_2_lut_abs[codepoint];\n\t    if (codes) {\n\t        return codes;\n\t    }\n\t    var shift = Table_B_2_lut_rel[codepoint];\n\t    if (shift) {\n\t        return [codepoint + shift[0]];\n\t    }\n\t    var complex = Table_B_2_complex[codepoint];\n\t    if (complex) {\n\t        return complex;\n\t    }\n\t    return null;\n\t}\n\texports._nameprepTableB2 = _nameprepTableB2;\n\tfunction _nameprepTableC(codepoint) {\n\t    return !!matchMap(codepoint, Table_C_ranges);\n\t}\n\texports._nameprepTableC = _nameprepTableC;\n\tfunction nameprep(value) {\n\t    // This allows platforms with incomplete normalize to bypass\n\t    // it for very basic names which the built-in toLowerCase\n\t    // will certainly handle correctly\n\t    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n\t        return value.toLowerCase();\n\t    }\n\t    // Get the code points (keeping the current normalization)\n\t    var codes = utf8.toUtf8CodePoints(value);\n\t    codes = flatten(codes.map(function (code) {\n\t        // Substitute Table B.1 (Maps to Nothing)\n\t        if (Table_B_1_flags.indexOf(code) >= 0) {\n\t            return [];\n\t        }\n\t        if (code >= 0xfe00 && code <= 0xfe0f) {\n\t            return [];\n\t        }\n\t        // Substitute Table B.2 (Case Folding)\n\t        var codesTableB2 = _nameprepTableB2(code);\n\t        if (codesTableB2) {\n\t            return codesTableB2;\n\t        }\n\t        // No Substitution\n\t        return [code];\n\t    }));\n\t    // Normalize using form KC\n\t    codes = utf8.toUtf8CodePoints(utf8._toUtf8String(codes), utf8.UnicodeNormalizationForm.NFKC);\n\t    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableC(code)) {\n\t            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n\t        }\n\t    });\n\t    // Prohibit Unassigned Code Points (Table A.1)\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableA1(code)) {\n\t            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n\t        }\n\t    });\n\t    // IDNA extras\n\t    var name = utf8._toUtf8String(codes);\n\t    // IDNA: 4.2.3.1\n\t    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n\t        throw new Error(\"invalid hyphen\");\n\t    }\n\t    // IDNA: 4.2.4\n\t    if (name.length > 63) {\n\t        throw new Error(\"too long\");\n\t    }\n\t    return name;\n\t}\n\texports.nameprep = nameprep;\n\t});\n\n\tvar idna$1 = unwrapExports(idna);\n\tvar idna_1 = idna._nameprepTableA1;\n\tvar idna_2 = idna._nameprepTableB2;\n\tvar idna_3 = idna._nameprepTableC;\n\tvar idna_4 = idna.nameprep;\n\n\tvar lib$8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.formatBytes32String = bytes32.formatBytes32String;\n\texports.parseBytes32String = bytes32.parseBytes32String;\n\n\texports.nameprep = idna.nameprep;\n\n\texports._toEscapedUtf8String = utf8._toEscapedUtf8String;\n\texports.toUtf8Bytes = utf8.toUtf8Bytes;\n\texports.toUtf8CodePoints = utf8.toUtf8CodePoints;\n\texports.toUtf8String = utf8.toUtf8String;\n\texports.UnicodeNormalizationForm = utf8.UnicodeNormalizationForm;\n\texports.Utf8ErrorFuncs = utf8.Utf8ErrorFuncs;\n\texports.Utf8ErrorReason = utf8.Utf8ErrorReason;\n\t});\n\n\tvar index$8 = unwrapExports(lib$8);\n\tvar lib_1$8 = lib$8.formatBytes32String;\n\tvar lib_2$7 = lib$8.parseBytes32String;\n\tvar lib_3$6 = lib$8.nameprep;\n\tvar lib_4$5 = lib$8._toEscapedUtf8String;\n\tvar lib_5$5 = lib$8.toUtf8Bytes;\n\tvar lib_6$3 = lib$8.toUtf8CodePoints;\n\tvar lib_7$3 = lib$8.toUtf8String;\n\tvar lib_8$2 = lib$8.UnicodeNormalizationForm;\n\tvar lib_9$2 = lib$8.Utf8ErrorFuncs;\n\tvar lib_10$1 = lib$8.Utf8ErrorReason;\n\n\tvar string = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar StringCoder = /** @class */ (function (_super) {\n\t    __extends(StringCoder, _super);\n\t    function StringCoder(localName) {\n\t        return _super.call(this, \"string\", localName) || this;\n\t    }\n\t    StringCoder.prototype.encode = function (writer, value) {\n\t        return _super.prototype.encode.call(this, writer, lib$8.toUtf8Bytes(value));\n\t    };\n\t    StringCoder.prototype.decode = function (reader) {\n\t        return lib$8.toUtf8String(_super.prototype.decode.call(this, reader));\n\t    };\n\t    return StringCoder;\n\t}(bytes.DynamicBytesCoder));\n\texports.StringCoder = StringCoder;\n\t});\n\n\tvar string$1 = unwrapExports(string);\n\tvar string_1 = string.StringCoder;\n\n\tvar tuple = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar TupleCoder = /** @class */ (function (_super) {\n\t    __extends(TupleCoder, _super);\n\t    function TupleCoder(coders, localName) {\n\t        var _this = this;\n\t        var dynamic = false;\n\t        var types = [];\n\t        coders.forEach(function (coder) {\n\t            if (coder.dynamic) {\n\t                dynamic = true;\n\t            }\n\t            types.push(coder.type);\n\t        });\n\t        var type = (\"tuple(\" + types.join(\",\") + \")\");\n\t        _this = _super.call(this, \"tuple\", type, localName, dynamic) || this;\n\t        _this.coders = coders;\n\t        return _this;\n\t    }\n\t    TupleCoder.prototype.encode = function (writer, value) {\n\t        return array.pack(writer, this.coders, value);\n\t    };\n\t    TupleCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, array.unpack(reader, this.coders));\n\t    };\n\t    return TupleCoder;\n\t}(abstractCoder.Coder));\n\texports.TupleCoder = TupleCoder;\n\t});\n\n\tvar tuple$1 = unwrapExports(tuple);\n\tvar tuple_1 = tuple.TupleCoder;\n\n\tvar abiCoder = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\n\n\n\n\n\n\n\n\n\tvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n\tvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\tvar AbiCoder = /** @class */ (function () {\n\t    function AbiCoder(coerceFunc) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, AbiCoder);\n\t        lib$3.defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n\t    }\n\t    AbiCoder.prototype._getCoder = function (param) {\n\t        var _this = this;\n\t        switch (param.baseType) {\n\t            case \"address\":\n\t                return new address.AddressCoder(param.name);\n\t            case \"bool\":\n\t                return new boolean_1.BooleanCoder(param.name);\n\t            case \"string\":\n\t                return new string.StringCoder(param.name);\n\t            case \"bytes\":\n\t                return new bytes.BytesCoder(param.name);\n\t            case \"array\":\n\t                return new array.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n\t            case \"tuple\":\n\t                return new tuple.TupleCoder((param.components || []).map(function (component) {\n\t                    return _this._getCoder(component);\n\t                }), param.name);\n\t            case \"\":\n\t                return new _null.NullCoder(param.name);\n\t        }\n\t        // u?int[0-9]*\n\t        var match = param.type.match(paramTypeNumber);\n\t        if (match) {\n\t            var size = parseInt(match[2] || \"256\");\n\t            if (size === 0 || size > 256 || (size % 8) !== 0) {\n\t                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n\t            }\n\t            return new number.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n\t        }\n\t        // bytes[0-9]+\n\t        match = param.type.match(paramTypeBytes);\n\t        if (match) {\n\t            var size = parseInt(match[1]);\n\t            if (size === 0 || size > 32) {\n\t                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n\t            }\n\t            return new fixedBytes.FixedBytesCoder(size, param.name);\n\t        }\n\t        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n\t    };\n\t    AbiCoder.prototype._getWordSize = function () { return 32; };\n\t    AbiCoder.prototype._getReader = function (data) {\n\t        return new abstractCoder.Reader(data, this._getWordSize(), this.coerceFunc);\n\t    };\n\t    AbiCoder.prototype._getWriter = function () {\n\t        return new abstractCoder.Writer(this._getWordSize());\n\t    };\n\t    AbiCoder.prototype.encode = function (types, values) {\n\t        var _this = this;\n\t        if (types.length !== values.length) {\n\t            logger.throwError(\"types/values length mismatch\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                count: { types: types.length, values: values.length },\n\t                value: { types: types, values: values }\n\t            });\n\t        }\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = (new tuple.TupleCoder(coders, \"_\"));\n\t        var writer = this._getWriter();\n\t        coder.encode(writer, values);\n\t        return writer.data;\n\t    };\n\t    AbiCoder.prototype.decode = function (types, data) {\n\t        var _this = this;\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = new tuple.TupleCoder(coders, \"_\");\n\t        return coder.decode(this._getReader(lib$1.arrayify(data)));\n\t    };\n\t    return AbiCoder;\n\t}());\n\texports.AbiCoder = AbiCoder;\n\texports.defaultAbiCoder = new AbiCoder();\n\t});\n\n\tvar abiCoder$1 = unwrapExports(abiCoder);\n\tvar abiCoder_1 = abiCoder.AbiCoder;\n\tvar abiCoder_2 = abiCoder.defaultAbiCoder;\n\n\tvar _version$g = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"hash/5.0.0-beta.134\";\n\t});\n\n\tvar _version$h = unwrapExports(_version$g);\n\tvar _version_1$8 = _version$g.version;\n\n\tvar lib$9 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$g.version);\n\t///////////////////////////////\n\tvar Zeros = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\tvar Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\tfunction isValidName(name) {\n\t    try {\n\t        var comps = name.split(\".\");\n\t        for (var i = 0; i < comps.length; i++) {\n\t            if (lib$8.nameprep(comps[i]).length === 0) {\n\t                throw new Error(\"empty\");\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidName = isValidName;\n\tfunction namehash(name) {\n\t    if (typeof (name) !== \"string\") {\n\t        logger.throwArgumentError(\"invalid address - \" + String(name), \"name\", name);\n\t    }\n\t    var result = Zeros;\n\t    while (name.length) {\n\t        var partition = name.match(Partition);\n\t        var label = lib$8.toUtf8Bytes(lib$8.nameprep(partition[3]));\n\t        result = lib$4.keccak256(lib$1.concat([result, lib$4.keccak256(label)]));\n\t        name = partition[2] || \"\";\n\t    }\n\t    return lib$1.hexlify(result);\n\t}\n\texports.namehash = namehash;\n\tfunction id(text) {\n\t    return lib$4.keccak256(lib$8.toUtf8Bytes(text));\n\t}\n\texports.id = id;\n\texports.messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\tfunction hashMessage(message) {\n\t    if (typeof (message) === \"string\") {\n\t        message = lib$8.toUtf8Bytes(message);\n\t    }\n\t    return lib$4.keccak256(lib$1.concat([\n\t        lib$8.toUtf8Bytes(exports.messagePrefix),\n\t        lib$8.toUtf8Bytes(String(message.length)),\n\t        message\n\t    ]));\n\t}\n\texports.hashMessage = hashMessage;\n\t});\n\n\tvar index$9 = unwrapExports(lib$9);\n\tvar lib_1$9 = lib$9.isValidName;\n\tvar lib_2$8 = lib$9.namehash;\n\tvar lib_3$7 = lib$9.id;\n\tvar lib_4$6 = lib$9.messagePrefix;\n\tvar lib_5$6 = lib$9.hashMessage;\n\n\tvar _interface = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\texports.checkResultErrors = abstractCoder.checkResultErrors;\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tvar LogDescription = /** @class */ (function (_super) {\n\t    __extends(LogDescription, _super);\n\t    function LogDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return LogDescription;\n\t}(lib$3.Description));\n\texports.LogDescription = LogDescription;\n\tvar TransactionDescription = /** @class */ (function (_super) {\n\t    __extends(TransactionDescription, _super);\n\t    function TransactionDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return TransactionDescription;\n\t}(lib$3.Description));\n\texports.TransactionDescription = TransactionDescription;\n\tvar Indexed = /** @class */ (function (_super) {\n\t    __extends(Indexed, _super);\n\t    function Indexed() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    Indexed.isIndexed = function (value) {\n\t        return !!(value && value._isIndexed);\n\t    };\n\t    return Indexed;\n\t}(lib$3.Description));\n\texports.Indexed = Indexed;\n\tfunction wrapAccessError(property, error) {\n\t    var wrap = new Error(\"deferred error during ABI decoding triggered accessing \" + property);\n\t    wrap.error = error;\n\t    return wrap;\n\t}\n\t/*\n\tfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n\t    params.reduce((accum, param) => {\n\t        if (param.name) {\n\t            if (accum[param.name]) {\n\t                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n\t            }\n\t            accum[param.name] = true;\n\t        }\n\t        return accum;\n\t    }, <{ [ name: string ]: boolean }>{ });\n\t}\n\t*/\n\tvar Interface = /** @class */ (function () {\n\t    function Interface(fragments$1) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Interface);\n\t        var abi = [];\n\t        if (typeof (fragments$1) === \"string\") {\n\t            abi = JSON.parse(fragments$1);\n\t        }\n\t        else {\n\t            abi = fragments$1;\n\t        }\n\t        lib$3.defineReadOnly(this, \"fragments\", abi.map(function (fragment) {\n\t            return fragments.Fragment.from(fragment);\n\t        }).filter(function (fragment) { return (fragment != null); }));\n\t        lib$3.defineReadOnly(this, \"_abiCoder\", lib$3.getStatic((_newTarget), \"getAbiCoder\")());\n\t        lib$3.defineReadOnly(this, \"functions\", {});\n\t        lib$3.defineReadOnly(this, \"errors\", {});\n\t        lib$3.defineReadOnly(this, \"events\", {});\n\t        lib$3.defineReadOnly(this, \"structs\", {});\n\t        // Add all fragments by their signature\n\t        this.fragments.forEach(function (fragment) {\n\t            var bucket = null;\n\t            switch (fragment.type) {\n\t                case \"constructor\":\n\t                    if (_this.deploy) {\n\t                        logger.warn(\"duplicate definition - constructor\");\n\t                        return;\n\t                    }\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    lib$3.defineReadOnly(_this, \"deploy\", fragment);\n\t                    return;\n\t                case \"function\":\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n\t                    bucket = _this.functions;\n\t                    break;\n\t                case \"event\":\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    bucket = _this.events;\n\t                    break;\n\t                default:\n\t                    return;\n\t            }\n\t            var signature = fragment.format();\n\t            if (bucket[signature]) {\n\t                logger.warn(\"duplicate definition - \" + signature);\n\t                return;\n\t            }\n\t            bucket[signature] = fragment;\n\t        });\n\t        // If we do not have a constructor add a default\n\t        if (!this.deploy) {\n\t            lib$3.defineReadOnly(this, \"deploy\", fragments.ConstructorFragment.from({\n\t                payable: false,\n\t                type: \"constructor\"\n\t            }));\n\t        }\n\t        lib$3.defineReadOnly(this, \"_isInterface\", true);\n\t    }\n\t    Interface.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = fragments.FormatTypes.full;\n\t        }\n\t        if (format === fragments.FormatTypes.sighash) {\n\t            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n\t        }\n\t        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });\n\t        // We need to re-bundle the JSON fragments a bit\n\t        if (format === fragments.FormatTypes.json) {\n\t            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));\n\t        }\n\t        return abi;\n\t    };\n\t    // Sub-classes can override these to handle other blockchains\n\t    Interface.getAbiCoder = function () {\n\t        return abiCoder.defaultAbiCoder;\n\t    };\n\t    Interface.getAddress = function (address) {\n\t        return lib$6.getAddress(address);\n\t    };\n\t    Interface.getSighash = function (functionFragment) {\n\t        return lib$1.hexDataSlice(lib$9.id(functionFragment.format()), 0, 4);\n\t    };\n\t    Interface.getEventTopic = function (eventFragment) {\n\t        return lib$9.id(eventFragment.format());\n\t    };\n\t    // Find a function definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\n\t        if (lib$1.isHexString(nameOrSignatureOrSighash)) {\n\t            for (var name_1 in this.functions) {\n\t                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {\n\t                    return this.functions[name_1];\n\t                }\n\t            }\n\t            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n\t            var name_2 = nameOrSignatureOrSighash.trim();\n\t            var matching = Object.keys(this.functions).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_2); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError(\"no matching function\", \"name\", name_2);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError(\"multiple matching functions\", \"name\", name_2);\n\t            }\n\t            return this.functions[matching[0]];\n\t        }\n\t        // Normlize the signature and lookup the function\n\t        var result = this.functions[fragments.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n\t        }\n\t        return result;\n\t    };\n\t    // Find an event definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\n\t        if (lib$1.isHexString(nameOrSignatureOrTopic)) {\n\t            var topichash = nameOrSignatureOrTopic.toLowerCase();\n\t            for (var name_3 in this.events) {\n\t                if (topichash === this.getEventTopic(name_3)) {\n\t                    return this.events[name_3];\n\t                }\n\t            }\n\t            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n\t            var name_4 = nameOrSignatureOrTopic.trim();\n\t            var matching = Object.keys(this.events).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_4); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError(\"no matching event\", \"name\", name_4);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError(\"multiple matching events\", \"name\", name_4);\n\t            }\n\t            return this.events[matching[0]];\n\t        }\n\t        // Normlize the signature and lookup the function\n\t        var result = this.events[fragments.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n\t        }\n\t        return result;\n\t    };\n\t    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n\t    Interface.prototype.getSighash = function (functionFragment) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$3.getStatic(this.constructor, \"getSighash\")(functionFragment);\n\t    };\n\t    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n\t    Interface.prototype.getEventTopic = function (eventFragment) {\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        return lib$3.getStatic(this.constructor, \"getEventTopic\")(eventFragment);\n\t    };\n\t    Interface.prototype._decodeParams = function (params, data) {\n\t        return this._abiCoder.decode(params, data);\n\t    };\n\t    Interface.prototype._encodeParams = function (params, values) {\n\t        return this._abiCoder.encode(params, values);\n\t    };\n\t    Interface.prototype.encodeDeploy = function (values) {\n\t        return this._encodeParams(this.deploy.inputs, values || []);\n\t    };\n\t    // Decode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.decodeFunctionData = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = lib$1.arrayify(data);\n\t        if (lib$1.hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n\t            logger.throwArgumentError(\"data signature does not match function \" + functionFragment.name + \".\", \"data\", lib$1.hexlify(bytes));\n\t        }\n\t        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n\t    };\n\t    // Encode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.encodeFunctionData = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$1.hexlify(lib$1.concat([\n\t            this.getSighash(functionFragment),\n\t            this._encodeParams(functionFragment.inputs, values || [])\n\t        ]));\n\t    };\n\t    // Decode the result from a function call (e.g. from eth_call)\n\t    Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = lib$1.arrayify(data);\n\t        var reason = null;\n\t        var errorSignature = null;\n\t        switch (bytes.length % this._abiCoder._getWordSize()) {\n\t            case 0:\n\t                try {\n\t                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n\t                }\n\t                catch (error) { }\n\t                break;\n\t            case 4:\n\t                if (lib$1.hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n\t                    errorSignature = \"Error(string)\";\n\t                    reason = this._abiCoder.decode([\"string\"], bytes.slice(4))[0];\n\t                }\n\t                break;\n\t        }\n\t        return logger.throwError(\"call revert exception\", lib.Logger.errors.CALL_EXCEPTION, {\n\t            method: functionFragment.format(),\n\t            errorSignature: errorSignature,\n\t            errorArgs: [reason],\n\t            reason: reason\n\t        });\n\t    };\n\t    // Encode the result for a function call (e.g. for eth_call)\n\t    Interface.prototype.encodeFunctionResult = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$1.hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));\n\t    };\n\t    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n\t    Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (values.length > eventFragment.inputs.length) {\n\t            logger.throwError(\"too many arguments for \" + eventFragment.format(), lib.Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                argument: \"values\",\n\t                value: values\n\t            });\n\t        }\n\t        var topics = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        var encodeTopic = function (param, value) {\n\t            if (param.type === \"string\") {\n\t                return lib$9.id(value);\n\t            }\n\t            else if (param.type === \"bytes\") {\n\t                return lib$4.keccak256(lib$1.hexlify(value));\n\t            }\n\t            // Check addresses are valid\n\t            if (param.type === \"address\") {\n\t                _this._abiCoder.encode([\"address\"], [value]);\n\t            }\n\t            return lib$1.hexZeroPad(lib$1.hexlify(value), 32);\n\t        };\n\t        values.forEach(function (value, index) {\n\t            var param = eventFragment.inputs[index];\n\t            if (!param.indexed) {\n\t                if (value != null) {\n\t                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n\t                }\n\t                return;\n\t            }\n\t            if (value == null) {\n\t                topics.push(null);\n\t            }\n\t            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n\t                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n\t            }\n\t            else if (Array.isArray(value)) {\n\t                topics.push(value.map(function (value) { return encodeTopic(param, value); }));\n\t            }\n\t            else {\n\t                topics.push(encodeTopic(param, value));\n\t            }\n\t        });\n\t        // Trim off trailing nulls\n\t        while (topics.length && topics[topics.length - 1] === null) {\n\t            topics.pop();\n\t        }\n\t        return topics;\n\t    };\n\t    Interface.prototype.encodeEventLog = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        var topics = [];\n\t        var dataTypes = [];\n\t        var dataValues = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        if (values.length !== eventFragment.inputs.length) {\n\t            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n\t        }\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            var value = values[index];\n\t            if (param.indexed) {\n\t                if (param.type === \"string\") {\n\t                    topics.push(lib$9.id(value));\n\t                }\n\t                else if (param.type === \"bytes\") {\n\t                    topics.push(lib$4.keccak256(value));\n\t                }\n\t                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n\t                    // @TOOD\n\t                    throw new Error(\"not implemented\");\n\t                }\n\t                else {\n\t                    topics.push(_this._abiCoder.encode([param.type], [value]));\n\t                }\n\t            }\n\t            else {\n\t                dataTypes.push(param);\n\t                dataValues.push(value);\n\t            }\n\t        });\n\t        return {\n\t            data: this._abiCoder.encode(dataTypes, dataValues),\n\t            topics: topics\n\t        };\n\t    };\n\t    // Decode a filter for the event and the search criteria\n\t    Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (topics != null && !eventFragment.anonymous) {\n\t            var topicHash = this.getEventTopic(eventFragment);\n\t            if (!lib$1.isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n\t                logger.throwError(\"fragment/topic mismatch\", lib.Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n\t            }\n\t            topics = topics.slice(1);\n\t        }\n\t        var indexed = [];\n\t        var nonIndexed = [];\n\t        var dynamic = [];\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n\t                    indexed.push(fragments.ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n\t                    dynamic.push(true);\n\t                }\n\t                else {\n\t                    indexed.push(param);\n\t                    dynamic.push(false);\n\t                }\n\t            }\n\t            else {\n\t                nonIndexed.push(param);\n\t                dynamic.push(false);\n\t            }\n\t        });\n\t        var resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, lib$1.concat(topics)) : null;\n\t        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data);\n\t        var result = [];\n\t        var nonIndexedIndex = 0, indexedIndex = 0;\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (resultIndexed == null) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\t                }\n\t                else if (dynamic[index]) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\t                }\n\t                else {\n\t                    try {\n\t                        result[index] = resultIndexed[indexedIndex++];\n\t                    }\n\t                    catch (error) {\n\t                        result[index] = error;\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                try {\n\t                    result[index] = resultNonIndexed[nonIndexedIndex++];\n\t                }\n\t                catch (error) {\n\t                    result[index] = error;\n\t                }\n\t            }\n\t            // Add the keyword argument if named and safe\n\t            if (param.name && result[param.name] == null) {\n\t                var value_1 = result[index];\n\t                // Make error named values throw on access\n\t                if (value_1 instanceof Error) {\n\t                    Object.defineProperty(result, param.name, {\n\t                        get: function () { throw wrapAccessError(\"property \" + JSON.stringify(param.name), value_1); }\n\t                    });\n\t                }\n\t                else {\n\t                    result[param.name] = value_1;\n\t                }\n\t            }\n\t        });\n\t        var _loop_1 = function (i) {\n\t            var value = result[i];\n\t            if (value instanceof Error) {\n\t                Object.defineProperty(result, i, {\n\t                    get: function () { throw wrapAccessError(\"index \" + i, value); }\n\t                });\n\t            }\n\t        };\n\t        // Make all error indexed values throw on access\n\t        for (var i = 0; i < result.length; i++) {\n\t            _loop_1(i);\n\t        }\n\t        return Object.freeze(result);\n\t    };\n\t    // Given a transaction, find the matching function fragment (if any) and\n\t    // determine all its properties and call parameters\n\t    Interface.prototype.parseTransaction = function (tx) {\n\t        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n\t        if (!fragment) {\n\t            return null;\n\t        }\n\t        return new TransactionDescription({\n\t            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n\t            functionFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            sighash: this.getSighash(fragment),\n\t            value: lib$2.BigNumber.from(tx.value || \"0\"),\n\t        });\n\t    };\n\t    // Given an event log, find the matching event fragment (if any) and\n\t    // determine all its properties and values\n\t    Interface.prototype.parseLog = function (log) {\n\t        var fragment = this.getEvent(log.topics[0]);\n\t        if (!fragment || fragment.anonymous) {\n\t            return null;\n\t        }\n\t        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n\t        //        Probably not, because just because it is the only event in the ABI does\n\t        //        not mean we have the full ABI; maybe jsut a fragment?\n\t        return new LogDescription({\n\t            eventFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            topic: this.getEventTopic(fragment),\n\t            args: this.decodeEventLog(fragment, log.data, log.topics)\n\t        });\n\t    };\n\t    /*\n\t    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n\t        if (Interface.isInterface(value)) {\n\t            return value;\n\t        }\n\t        if (typeof(value) === \"string\") {\n\t            return new Interface(JSON.parse(value));\n\t        }\n\t        return new Interface(value);\n\t    }\n\t    */\n\t    Interface.isInterface = function (value) {\n\t        return !!(value && value._isInterface);\n\t    };\n\t    return Interface;\n\t}());\n\texports.Interface = Interface;\n\t});\n\n\tvar _interface$1 = unwrapExports(_interface);\n\tvar _interface_1 = _interface.checkResultErrors;\n\tvar _interface_2 = _interface.LogDescription;\n\tvar _interface_3 = _interface.TransactionDescription;\n\tvar _interface_4 = _interface.Indexed;\n\tvar _interface_5 = _interface.Interface;\n\n\tvar lib$a = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.ConstructorFragment = fragments.ConstructorFragment;\n\texports.EventFragment = fragments.EventFragment;\n\texports.FormatTypes = fragments.FormatTypes;\n\texports.Fragment = fragments.Fragment;\n\texports.FunctionFragment = fragments.FunctionFragment;\n\texports.ParamType = fragments.ParamType;\n\n\texports.AbiCoder = abiCoder.AbiCoder;\n\texports.defaultAbiCoder = abiCoder.defaultAbiCoder;\n\n\texports.checkResultErrors = _interface.checkResultErrors;\n\texports.Indexed = _interface.Indexed;\n\texports.Interface = _interface.Interface;\n\texports.LogDescription = _interface.LogDescription;\n\texports.TransactionDescription = _interface.TransactionDescription;\n\t});\n\n\tvar index$a = unwrapExports(lib$a);\n\tvar lib_1$a = lib$a.ConstructorFragment;\n\tvar lib_2$9 = lib$a.EventFragment;\n\tvar lib_3$8 = lib$a.FormatTypes;\n\tvar lib_4$7 = lib$a.Fragment;\n\tvar lib_5$7 = lib$a.FunctionFragment;\n\tvar lib_6$4 = lib$a.ParamType;\n\tvar lib_7$4 = lib$a.AbiCoder;\n\tvar lib_8$3 = lib$a.defaultAbiCoder;\n\tvar lib_9$3 = lib$a.checkResultErrors;\n\tvar lib_10$2 = lib$a.Indexed;\n\tvar lib_11$1 = lib$a.Interface;\n\tvar lib_12$1 = lib$a.LogDescription;\n\tvar lib_13$1 = lib$a.TransactionDescription;\n\n\tvar _version$i = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"abstract-provider/5.0.0-beta.142\";\n\t});\n\n\tvar _version$j = unwrapExports(_version$i);\n\tvar _version_1$9 = _version$i.version;\n\n\tvar lib$b = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$i.version);\n\t;\n\t;\n\t//export type CallTransactionable = {\n\t//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n\t//};\n\tvar ForkEvent = /** @class */ (function (_super) {\n\t    __extends(ForkEvent, _super);\n\t    function ForkEvent() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ForkEvent.isForkEvent = function (value) {\n\t        return !!(value && value._isForkEvent);\n\t    };\n\t    return ForkEvent;\n\t}(lib$3.Description));\n\texports.ForkEvent = ForkEvent;\n\tvar BlockForkEvent = /** @class */ (function (_super) {\n\t    __extends(BlockForkEvent, _super);\n\t    function BlockForkEvent(blockHash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(blockHash, 32)) {\n\t            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isBlockForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            blockHash: blockHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return BlockForkEvent;\n\t}(ForkEvent));\n\texports.BlockForkEvent = BlockForkEvent;\n\tvar TransactionForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionForkEvent, _super);\n\t    function TransactionForkEvent(hash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(hash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            hash: hash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionForkEvent;\n\t}(ForkEvent));\n\texports.TransactionForkEvent = TransactionForkEvent;\n\tvar TransactionOrderForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionOrderForkEvent, _super);\n\t    function TransactionOrderForkEvent(beforeHash, afterHash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(beforeHash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n\t        }\n\t        if (!lib$1.isHexString(afterHash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionOrderForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            beforeHash: beforeHash,\n\t            afterHash: afterHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionOrderForkEvent;\n\t}(ForkEvent));\n\texports.TransactionOrderForkEvent = TransactionOrderForkEvent;\n\t///////////////////////////////\n\t// Exported Abstracts\n\tvar Provider = /** @class */ (function () {\n\t    function Provider() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Provider);\n\t        lib$3.defineReadOnly(this, \"_isProvider\", true);\n\t    }\n\t    // Alias for \"on\"\n\t    Provider.prototype.addListener = function (eventName, listener) {\n\t        return this.on(eventName, listener);\n\t    };\n\t    // Alias for \"off\"\n\t    Provider.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    Provider.isProvider = function (value) {\n\t        return !!(value && value._isProvider);\n\t    };\n\t    return Provider;\n\t}());\n\texports.Provider = Provider;\n\t});\n\n\tvar index$b = unwrapExports(lib$b);\n\tvar lib_1$b = lib$b.ForkEvent;\n\tvar lib_2$a = lib$b.BlockForkEvent;\n\tvar lib_3$9 = lib$b.TransactionForkEvent;\n\tvar lib_4$8 = lib$b.TransactionOrderForkEvent;\n\tvar lib_5$8 = lib$b.Provider;\n\n\tvar _version$k = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"abstract-signer/5.0.0-beta.145\";\n\t});\n\n\tvar _version$l = unwrapExports(_version$k);\n\tvar _version_1$a = _version$k.version;\n\n\tvar lib$c = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$k.version);\n\tvar allowedTransactionKeys = [\n\t    \"chainId\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"nonce\", \"to\", \"value\"\n\t];\n\t// Sub-Class Notes:\n\t//  - A Signer MUST always make sure, that if present, the \"from\" field\n\t//    matches the Signer, before sending or signing a transaction\n\t//  - A Signer SHOULD always wrap private information (such as a private\n\t//    key or mnemonic) in a function, so that console.log does not leak\n\t//    the data\n\tvar Signer = /** @class */ (function () {\n\t    ///////////////////\n\t    // Sub-classes MUST call super\n\t    function Signer() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Signer);\n\t        lib$3.defineReadOnly(this, \"_isSigner\", true);\n\t    }\n\t    ///////////////////\n\t    // Sub-classes MAY override these\n\t    Signer.prototype.getBalance = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getBalance\");\n\t                        return [4 /*yield*/, this.provider.getBalance(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getTransactionCount = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getTransactionCount\");\n\t                        return [4 /*yield*/, this.provider.getTransactionCount(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates \"from\" if unspecified, and estimates the gas for the transation\n\t    Signer.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"estimateGas\");\n\t                        return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates \"from\" if unspecified, and calls with the transation\n\t    Signer.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"call\");\n\t                        return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.call(tx, blockTag)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates all fields in a transaction, signs it and sends it to the network\n\t    Signer.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        this._checkProvider(\"sendTransaction\");\n\t        return this.populateTransaction(transaction).then(function (tx) {\n\t            return _this.signTransaction(tx).then(function (signedTx) {\n\t                return _this.provider.sendTransaction(signedTx);\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getChainId = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getChainId\");\n\t                        return [4 /*yield*/, this.provider.getNetwork()];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [2 /*return*/, network.chainId];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getGasPrice\");\n\t                        return [4 /*yield*/, this.provider.getGasPrice()];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"resolveName\");\n\t                        return [4 /*yield*/, this.provider.resolveName(name)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Checks a transaction does not contain invalid keys and if\n\t    // no \"from\" is provided, populates it.\n\t    // - does NOT require a provider\n\t    // - adds \"from\" is not present\n\t    // - returns a COPY (safe to mutate the result)\n\t    // By default called from: (overriding these prevents it)\n\t    //   - call\n\t    //   - estimateGas\n\t    //   - populateTransaction (and therefor sendTransaction)\n\t    Signer.prototype.checkTransaction = function (transaction) {\n\t        for (var key in transaction) {\n\t            if (allowedTransactionKeys.indexOf(key) === -1) {\n\t                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n\t            }\n\t        }\n\t        var tx = lib$3.shallowCopy(transaction);\n\t        if (tx.from == null) {\n\t            tx.from = this.getAddress();\n\t        }\n\t        else {\n\t            // Make sure any provided address matches this signer\n\t            tx.from = Promise.all([\n\t                Promise.resolve(tx.from),\n\t                this.getAddress()\n\t            ]).then(function (result) {\n\t                if (result[0] !== result[1]) {\n\t                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n\t                }\n\t                return result[0];\n\t            });\n\t        }\n\t        return tx;\n\t    };\n\t    // Populates ALL keys for a transaction and checks that \"from\" matches\n\t    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n\t    // By default called from: (overriding these prevents it)\n\t    //   - sendTransaction\n\t    Signer.prototype.populateTransaction = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        if (tx.to != null) {\n\t                            tx.to = Promise.resolve(tx.to).then(function (to) { return _this.resolveName(to); });\n\t                        }\n\t                        if (tx.gasPrice == null) {\n\t                            tx.gasPrice = this.getGasPrice();\n\t                        }\n\t                        if (tx.nonce == null) {\n\t                            tx.nonce = this.getTransactionCount(\"pending\");\n\t                        }\n\t                        if (tx.gasLimit == null) {\n\t                            tx.gasLimit = this.estimateGas(tx).catch(function (error) {\n\t                                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t                                    error: error,\n\t                                    tx: tx\n\t                                });\n\t                            });\n\t                        }\n\t                        if (tx.chainId == null) {\n\t                            tx.chainId = this.getChainId();\n\t                        }\n\t                        else {\n\t                            tx.chainId = Promise.all([\n\t                                Promise.resolve(tx.chainId),\n\t                                this.getChainId()\n\t                            ]).then(function (results) {\n\t                                if (results[1] !== 0 && results[0] !== results[1]) {\n\t                                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n\t                                }\n\t                                return results[0];\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, lib$3.resolveProperties(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ///////////////////\n\t    // Sub-classes SHOULD leave these alone\n\t    Signer.prototype._checkProvider = function (operation) {\n\t        if (!this.provider) {\n\t            logger.throwError(\"missing provider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: (operation || \"_checkProvider\")\n\t            });\n\t        }\n\t    };\n\t    Signer.isSigner = function (value) {\n\t        return !!(value && value._isSigner);\n\t    };\n\t    return Signer;\n\t}());\n\texports.Signer = Signer;\n\tvar VoidSigner = /** @class */ (function (_super) {\n\t    __extends(VoidSigner, _super);\n\t    function VoidSigner(address, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, VoidSigner);\n\t        _this = _super.call(this) || this;\n\t        lib$3.defineReadOnly(_this, \"address\", address);\n\t        lib$3.defineReadOnly(_this, \"provider\", provider || null);\n\t        return _this;\n\t    }\n\t    VoidSigner.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    VoidSigner.prototype._fail = function (message, operation) {\n\t        return Promise.resolve().then(function () {\n\t            logger.throwError(message, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n\t        });\n\t    };\n\t    VoidSigner.prototype.signMessage = function (message) {\n\t        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n\t    };\n\t    VoidSigner.prototype.signTransaction = function (transaction) {\n\t        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n\t    };\n\t    VoidSigner.prototype.connect = function (provider) {\n\t        return new VoidSigner(this.address, provider);\n\t    };\n\t    return VoidSigner;\n\t}(Signer));\n\texports.VoidSigner = VoidSigner;\n\t});\n\n\tvar index$c = unwrapExports(lib$c);\n\tvar lib_1$c = lib$c.Signer;\n\tvar lib_2$b = lib$c.VoidSigner;\n\n\tvar _version$m = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"contracts/5.0.0-beta.156\";\n\t});\n\n\tvar _version$n = unwrapExports(_version$m);\n\tvar _version_1$b = _version$m.version;\n\n\tvar lib$d = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {\n\t    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\t    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n\t        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n\t            r[k] = a[j];\n\t    return r;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\t//import { AddressZero } from \"@ethersproject/constants\";\n\n\t// @TOOD remove dependences transactions\n\n\n\tvar logger = new lib.Logger(_version$m.version);\n\t;\n\t;\n\t///////////////////////////////\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tfunction resolveName(resolver, nameOrPromise) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var name;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0: return [4 /*yield*/, nameOrPromise];\n\t                case 1:\n\t                    name = _a.sent();\n\t                    // If it is already an address, just use it (after adding checksum)\n\t                    try {\n\t                        return [2 /*return*/, lib$6.getAddress(name)];\n\t                    }\n\t                    catch (error) { }\n\t                    if (!resolver) {\n\t                        logger.throwError(\"a provider or signer is needed to resolve ENS names\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: \"resolveName\"\n\t                        });\n\t                    }\n\t                    return [4 /*yield*/, resolver.resolveName(name)];\n\t                case 2: return [2 /*return*/, _a.sent()];\n\t            }\n\t        });\n\t    });\n\t}\n\t// Recursively replaces ENS names with promises to resolve the name and resolves all properties\n\tfunction resolveAddresses(resolver, value, paramType) {\n\t    if (Array.isArray(paramType)) {\n\t        return Promise.all(paramType.map(function (paramType, index) {\n\t            return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n\t        }));\n\t    }\n\t    if (paramType.type === \"address\") {\n\t        return resolveName(resolver, value);\n\t    }\n\t    if (paramType.type === \"tuple\") {\n\t        return resolveAddresses(resolver, value, paramType.components);\n\t    }\n\t    if (paramType.baseType === \"array\") {\n\t        if (!Array.isArray(value)) {\n\t            throw new Error(\"invalid value for array\");\n\t        }\n\t        return Promise.all(value.map(function (v) { return resolveAddresses(resolver, v, paramType.arrayChildren); }));\n\t    }\n\t    return Promise.resolve(value);\n\t}\n\tfunction populateTransaction(contract, fragment, args) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var overrides, resolved, tx, ro, roValue, leftovers;\n\t        var _this = this;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    overrides = {};\n\t                    if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n\t                        overrides = lib$3.shallowCopy(args.pop());\n\t                    }\n\t                    // Make sure the parameter count matches\n\t                    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\t                    // Populate \"from\" override (allow promises)\n\t                    if (contract.signer) {\n\t                        if (overrides.from) {\n\t                            // Contracts with a Signer are from the Signer's frame-of-reference;\n\t                            // but we allow overriding \"from\" if it matches the signer\n\t                            overrides.from = lib$3.resolveProperties({\n\t                                override: resolveName(contract.signer, overrides.from),\n\t                                signer: contract.signer.getAddress()\n\t                            }).then(function (check) { return __awaiter(_this, void 0, void 0, function () {\n\t                                return __generator(this, function (_a) {\n\t                                    if (lib$6.getAddress(check.signer) !== check.override) {\n\t                                        logger.throwError(\"Contract with a Signer cannot override from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                            operation: \"overrides.from\"\n\t                                        });\n\t                                    }\n\t                                    return [2 /*return*/, check.override];\n\t                                });\n\t                            }); });\n\t                        }\n\t                        else {\n\t                            overrides.from = contract.signer.getAddress();\n\t                        }\n\t                    }\n\t                    else if (overrides.from) {\n\t                        overrides.from = resolveName(contract.provider, overrides.from);\n\t                        //} else {\n\t                        // Contracts without a signer can override \"from\", and if\n\t                        // unspecified the zero address is used\n\t                        //overrides.from = AddressZero;\n\t                    }\n\t                    return [4 /*yield*/, lib$3.resolveProperties({\n\t                            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n\t                            address: contract.resolvedAddress,\n\t                            overrides: (lib$3.resolveProperties(overrides) || {})\n\t                        })];\n\t                case 1:\n\t                    resolved = _a.sent();\n\t                    tx = {\n\t                        data: contract.interface.encodeFunctionData(fragment, resolved.args),\n\t                        to: resolved.address\n\t                    };\n\t                    ro = resolved.overrides;\n\t                    // Populate simple overrides\n\t                    if (ro.nonce != null) {\n\t                        tx.nonce = lib$2.BigNumber.from(ro.nonce).toNumber();\n\t                    }\n\t                    if (ro.gasLimit != null) {\n\t                        tx.gasLimit = lib$2.BigNumber.from(ro.gasLimit);\n\t                    }\n\t                    if (ro.gasPrice != null) {\n\t                        tx.gasPrice = lib$2.BigNumber.from(ro.gasPrice);\n\t                    }\n\t                    if (ro.from != null) {\n\t                        tx.from = ro.from;\n\t                    }\n\t                    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n\t                    if (tx.gasLimit == null && fragment.gas != null) {\n\t                        tx.gasLimit = lib$2.BigNumber.from(fragment.gas).add(21000);\n\t                    }\n\t                    // Populate \"value\" override\n\t                    if (ro.value) {\n\t                        roValue = lib$2.BigNumber.from(ro.value);\n\t                        if (!roValue.isZero() && !fragment.payable) {\n\t                            logger.throwError(\"non-payable method cannot override value\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"overrides.value\",\n\t                                value: overrides.value\n\t                            });\n\t                        }\n\t                        tx.value = roValue;\n\t                    }\n\t                    // Remvoe the overrides\n\t                    delete overrides.nonce;\n\t                    delete overrides.gasLimit;\n\t                    delete overrides.gasPrice;\n\t                    delete overrides.from;\n\t                    delete overrides.value;\n\t                    leftovers = Object.keys(overrides).filter(function (key) { return (overrides[key] != null); });\n\t                    if (leftovers.length) {\n\t                        logger.throwError(\"cannot override \" + leftovers.map(function (l) { return JSON.stringify(l); }).join(\",\"), lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: \"overrides\",\n\t                            overrides: leftovers\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, tx];\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction buildPopulate(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, populateTransaction(contract, fragment, args)];\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildEstimate(contract, fragment) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!signerOrProvider) {\n\t                            logger.throwError(\"estimate require a provider or signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"estimateGas\"\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildCall(contract, fragment, collapseSimple) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockTag, overrides, tx, result, value;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        blockTag = undefined;\n\t                        if (!(args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\")) return [3 /*break*/, 3];\n\t                        overrides = lib$3.shallowCopy(args.pop());\n\t                        if (!(overrides.blockTag != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, overrides.blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        delete overrides.blockTag;\n\t                        args.push(overrides);\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 5];\n\t                        return [4 /*yield*/, contract._deployed(blockTag)];\n\t                    case 4:\n\t                        _a.sent();\n\t                        _a.label = 5;\n\t                    case 5: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 6:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.call(tx, blockTag)];\n\t                    case 7:\n\t                        result = _a.sent();\n\t                        try {\n\t                            value = contract.interface.decodeFunctionResult(fragment, result);\n\t                            if (collapseSimple && fragment.outputs.length === 1) {\n\t                                value = value[0];\n\t                            }\n\t                            return [2 /*return*/, value];\n\t                        }\n\t                        catch (error) {\n\t                            if (error.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                                error.address = contract.address;\n\t                                error.args = args;\n\t                                error.transaction = tx;\n\t                            }\n\t                            throw error;\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildSend(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var txRequest, tx, wait;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!contract.signer) {\n\t                            logger.throwError(\"sending a transaction requires a signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"sendTransaction\"\n\t                            });\n\t                        }\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, contract._deployed()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        _a.label = 2;\n\t                    case 2: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 3:\n\t                        txRequest = _a.sent();\n\t                        return [4 /*yield*/, contract.signer.sendTransaction(txRequest)];\n\t                    case 4:\n\t                        tx = _a.sent();\n\t                        wait = tx.wait.bind(tx);\n\t                        tx.wait = function (confirmations) {\n\t                            return wait(confirmations).then(function (receipt) {\n\t                                receipt.events = receipt.logs.map(function (log) {\n\t                                    var event = lib$3.deepCopy(log);\n\t                                    var parsed = null;\n\t                                    try {\n\t                                        parsed = contract.interface.parseLog(log);\n\t                                    }\n\t                                    catch (e) { }\n\t                                    // Successfully parsed the event log; include it\n\t                                    if (parsed) {\n\t                                        event.args = parsed.args;\n\t                                        event.decode = function (data, topics) {\n\t                                            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n\t                                        };\n\t                                        event.event = parsed.name;\n\t                                        event.eventSignature = parsed.signature;\n\t                                    }\n\t                                    // Useful operations\n\t                                    event.removeListener = function () { return contract.provider; };\n\t                                    event.getBlock = function () {\n\t                                        return contract.provider.getBlock(receipt.blockHash);\n\t                                    };\n\t                                    event.getTransaction = function () {\n\t                                        return contract.provider.getTransaction(receipt.transactionHash);\n\t                                    };\n\t                                    event.getTransactionReceipt = function () {\n\t                                        return Promise.resolve(receipt);\n\t                                    };\n\t                                    return event;\n\t                                });\n\t                                return receipt;\n\t                            });\n\t                        };\n\t                        return [2 /*return*/, tx];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildDefault(contract, fragment, collapseSimple) {\n\t    if (fragment.constant) {\n\t        return buildCall(contract, fragment, collapseSimple);\n\t    }\n\t    return buildSend(contract, fragment);\n\t}\n\tfunction getEventTag(filter) {\n\t    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n\t        return \"*\";\n\t    }\n\t    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            return topic.join(\"|\");\n\t        }\n\t        return topic;\n\t    }).join(\":\") : \"\");\n\t}\n\tvar RunningEvent = /** @class */ (function () {\n\t    function RunningEvent(tag, filter) {\n\t        lib$3.defineReadOnly(this, \"tag\", tag);\n\t        lib$3.defineReadOnly(this, \"filter\", filter);\n\t        this._listeners = [];\n\t    }\n\t    RunningEvent.prototype.addListener = function (listener, once) {\n\t        this._listeners.push({ listener: listener, once: once });\n\t    };\n\t    RunningEvent.prototype.removeListener = function (listener) {\n\t        var done = false;\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            if (done || item.listener !== listener) {\n\t                return true;\n\t            }\n\t            done = true;\n\t            return false;\n\t        });\n\t    };\n\t    RunningEvent.prototype.removeAllListeners = function () {\n\t        this._listeners = [];\n\t    };\n\t    RunningEvent.prototype.listeners = function () {\n\t        return this._listeners.map(function (i) { return i.listener; });\n\t    };\n\t    RunningEvent.prototype.listenerCount = function () {\n\t        return this._listeners.length;\n\t    };\n\t    RunningEvent.prototype.run = function (args) {\n\t        var _this = this;\n\t        var listenerCount = this.listenerCount();\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            var argsCopy = args.slice();\n\t            // Call the callback in the next event loop\n\t            setTimeout(function () {\n\t                item.listener.apply(_this, argsCopy);\n\t            }, 0);\n\t            // Reschedule it if it not \"once\"\n\t            return !(item.once);\n\t        });\n\t        return listenerCount;\n\t    };\n\t    RunningEvent.prototype.prepareEvent = function (event) {\n\t    };\n\t    // Returns the array that will be applied to an emit\n\t    RunningEvent.prototype.getEmit = function (event) {\n\t        return [event];\n\t    };\n\t    return RunningEvent;\n\t}());\n\tvar ErrorRunningEvent = /** @class */ (function (_super) {\n\t    __extends(ErrorRunningEvent, _super);\n\t    function ErrorRunningEvent() {\n\t        return _super.call(this, \"error\", null) || this;\n\t    }\n\t    return ErrorRunningEvent;\n\t}(RunningEvent));\n\t// @TODO Fragment should inherit Wildcard? and just override getEmit?\n\t//       or have a common abstract super class, with enough constructor\n\t//       options to configure both.\n\t// A Fragment Event will populate all the properties that Wildcard\n\t// will, and additioanlly dereference the arguments when emitting\n\tvar FragmentRunningEvent = /** @class */ (function (_super) {\n\t    __extends(FragmentRunningEvent, _super);\n\t    function FragmentRunningEvent(address, contractInterface, fragment, topics) {\n\t        var _this = this;\n\t        var filter = {\n\t            address: address\n\t        };\n\t        var topic = contractInterface.getEventTopic(fragment);\n\t        if (topics) {\n\t            if (topic !== topics[0]) {\n\t                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n\t            }\n\t            filter.topics = topics.slice();\n\t        }\n\t        else {\n\t            filter.topics = [topic];\n\t        }\n\t        _this = _super.call(this, getEventTag(filter), filter) || this;\n\t        lib$3.defineReadOnly(_this, \"address\", address);\n\t        lib$3.defineReadOnly(_this, \"interface\", contractInterface);\n\t        lib$3.defineReadOnly(_this, \"fragment\", fragment);\n\t        return _this;\n\t    }\n\t    FragmentRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        event.event = this.fragment.name;\n\t        event.eventSignature = this.fragment.format();\n\t        event.decode = function (data, topics) {\n\t            return _this.interface.decodeEventLog(_this.fragment, data, topics);\n\t        };\n\t        try {\n\t            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n\t        }\n\t        catch (error) {\n\t            event.args = null;\n\t            event.decodeError = error;\n\t        }\n\t    };\n\t    FragmentRunningEvent.prototype.getEmit = function (event) {\n\t        var errors = lib$a.checkResultErrors(event.args);\n\t        if (errors.length) {\n\t            throw errors[0].error;\n\t        }\n\t        var args = (event.args || []).slice();\n\t        args.push(event);\n\t        return args;\n\t    };\n\t    return FragmentRunningEvent;\n\t}(RunningEvent));\n\t// A Wildard Event will attempt to populate:\n\t//  - event            The name of the event name\n\t//  - eventSignature   The full signature of the event\n\t//  - decode           A function to decode data and topics\n\t//  - args             The decoded data and topics\n\tvar WildcardRunningEvent = /** @class */ (function (_super) {\n\t    __extends(WildcardRunningEvent, _super);\n\t    function WildcardRunningEvent(address, contractInterface) {\n\t        var _this = _super.call(this, \"*\", { address: address }) || this;\n\t        lib$3.defineReadOnly(_this, \"address\", address);\n\t        lib$3.defineReadOnly(_this, \"interface\", contractInterface);\n\t        return _this;\n\t    }\n\t    WildcardRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        try {\n\t            var parsed_1 = this.interface.parseLog(event);\n\t            event.event = parsed_1.name;\n\t            event.eventSignature = parsed_1.signature;\n\t            event.decode = function (data, topics) {\n\t                return _this.interface.decodeEventLog(parsed_1.eventFragment, data, topics);\n\t            };\n\t            event.args = parsed_1.args;\n\t        }\n\t        catch (error) {\n\t            // No matching event\n\t        }\n\t    };\n\t    return WildcardRunningEvent;\n\t}(RunningEvent));\n\tvar Contract = /** @class */ (function () {\n\t    function Contract(addressOrName, contractInterface, signerOrProvider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Contract);\n\t        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n\t        //address = getAddress(address);\n\t        lib$3.defineReadOnly(this, \"interface\", lib$3.getStatic((_newTarget), \"getInterface\")(contractInterface));\n\t        if (signerOrProvider == null) {\n\t            lib$3.defineReadOnly(this, \"provider\", null);\n\t            lib$3.defineReadOnly(this, \"signer\", null);\n\t        }\n\t        else if (lib$c.Signer.isSigner(signerOrProvider)) {\n\t            lib$3.defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n\t            lib$3.defineReadOnly(this, \"signer\", signerOrProvider);\n\t        }\n\t        else if (lib$b.Provider.isProvider(signerOrProvider)) {\n\t            lib$3.defineReadOnly(this, \"provider\", signerOrProvider);\n\t            lib$3.defineReadOnly(this, \"signer\", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n\t        }\n\t        lib$3.defineReadOnly(this, \"callStatic\", {});\n\t        lib$3.defineReadOnly(this, \"estimateGas\", {});\n\t        lib$3.defineReadOnly(this, \"functions\", {});\n\t        lib$3.defineReadOnly(this, \"populateTransaction\", {});\n\t        lib$3.defineReadOnly(this, \"filters\", {});\n\t        {\n\t            var uniqueFilters_1 = {};\n\t            Object.keys(this.interface.events).forEach(function (eventSignature) {\n\t                var event = _this.interface.events[eventSignature];\n\t                lib$3.defineReadOnly(_this.filters, eventSignature, function () {\n\t                    var args = [];\n\t                    for (var _i = 0; _i < arguments.length; _i++) {\n\t                        args[_i] = arguments[_i];\n\t                    }\n\t                    return {\n\t                        address: _this.address,\n\t                        topics: _this.interface.encodeFilterTopics(event, args)\n\t                    };\n\t                });\n\t                if (!uniqueFilters_1[event.name]) {\n\t                    uniqueFilters_1[event.name] = [];\n\t                }\n\t                uniqueFilters_1[event.name].push(eventSignature);\n\t            });\n\t            Object.keys(uniqueFilters_1).forEach(function (name) {\n\t                var filters = uniqueFilters_1[name];\n\t                if (filters.length === 1) {\n\t                    lib$3.defineReadOnly(_this.filters, name, _this.filters[filters[0]]);\n\t                }\n\t                else {\n\t                    logger.warn(\"Duplicate definition of \" + name + \" (\" + filters.join(\", \") + \")\");\n\t                }\n\t            });\n\t        }\n\t        lib$3.defineReadOnly(this, \"_runningEvents\", {});\n\t        lib$3.defineReadOnly(this, \"_wrappedEmits\", {});\n\t        lib$3.defineReadOnly(this, \"address\", addressOrName);\n\t        if (this.provider) {\n\t            lib$3.defineReadOnly(this, \"resolvedAddress\", this.provider.resolveName(addressOrName).then(function (address) {\n\t                if (address == null) {\n\t                    throw new Error(\"name not found\");\n\t                }\n\t                return address;\n\t            }).catch(function (error) {\n\t                console.log(\"ERROR: Cannot find Contract - \" + addressOrName);\n\t                throw error;\n\t            }));\n\t        }\n\t        else {\n\t            try {\n\t                lib$3.defineReadOnly(this, \"resolvedAddress\", Promise.resolve(lib$6.getAddress(addressOrName)));\n\t            }\n\t            catch (error) {\n\t                // Without a provider, we cannot use ENS names\n\t                logger.throwError(\"provider is required to use ENS name as contract address\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: \"new Contract\"\n\t                });\n\t            }\n\t        }\n\t        var uniqueNames = {};\n\t        var uniqueSignatures = {};\n\t        Object.keys(this.interface.functions).forEach(function (signature) {\n\t            var fragment = _this.interface.functions[signature];\n\t            // Check that the signature is unique; if not the ABI generation has\n\t            // not been cleaned or may be incorrectly generated\n\t            if (uniqueSignatures[signature]) {\n\t                logger.warn(\"Duplicate ABI entry for \" + JSON.stringify(name));\n\t                return;\n\t            }\n\t            uniqueSignatures[signature] = true;\n\t            // Track unique names; we only expose bare named functions if they\n\t            // are ambiguous\n\t            {\n\t                var name_1 = fragment.name;\n\t                if (!uniqueNames[name_1]) {\n\t                    uniqueNames[name_1] = [];\n\t                }\n\t                uniqueNames[name_1].push(signature);\n\t            }\n\t            if (_this[signature] == null) {\n\t                lib$3.defineReadOnly(_this, signature, buildDefault(_this, fragment, true));\n\t            }\n\t            // We do not collapse simple calls on this bucket, which allows\n\t            // frameworks to safely use this without introspection as well as\n\t            // allows decoding error recovery.\n\t            if (_this.functions[signature] == null) {\n\t                lib$3.defineReadOnly(_this.functions, signature, buildDefault(_this, fragment, false));\n\t            }\n\t            if (_this.callStatic[signature] == null) {\n\t                lib$3.defineReadOnly(_this.callStatic, signature, buildCall(_this, fragment, true));\n\t            }\n\t            if (_this.populateTransaction[signature] == null) {\n\t                lib$3.defineReadOnly(_this.populateTransaction, signature, buildPopulate(_this, fragment));\n\t            }\n\t            if (_this.estimateGas[signature] == null) {\n\t                lib$3.defineReadOnly(_this.estimateGas, signature, buildEstimate(_this, fragment));\n\t            }\n\t        });\n\t        Object.keys(uniqueNames).forEach(function (name) {\n\t            // Ambiguous names to not get attached as bare names\n\t            var signatures = uniqueNames[name];\n\t            if (signatures.length > 1) {\n\t                return;\n\t            }\n\t            var signature = signatures[0];\n\t            if (_this[name] == null) {\n\t                lib$3.defineReadOnly(_this, name, _this[signature]);\n\t            }\n\t            if (_this.functions[name] == null) {\n\t                lib$3.defineReadOnly(_this.functions, name, _this.functions[signature]);\n\t            }\n\t            if (_this.callStatic[name] == null) {\n\t                lib$3.defineReadOnly(_this.callStatic, name, _this.callStatic[signature]);\n\t            }\n\t            if (_this.populateTransaction[name] == null) {\n\t                lib$3.defineReadOnly(_this.populateTransaction, name, _this.populateTransaction[signature]);\n\t            }\n\t            if (_this.estimateGas[name] == null) {\n\t                lib$3.defineReadOnly(_this.estimateGas, name, _this.estimateGas[signature]);\n\t            }\n\t        });\n\t    }\n\t    Contract.getContractAddress = function (transaction) {\n\t        return lib$6.getContractAddress(transaction);\n\t    };\n\t    Contract.getInterface = function (contractInterface) {\n\t        if (lib$a.Interface.isInterface(contractInterface)) {\n\t            return contractInterface;\n\t        }\n\t        return new lib$a.Interface(contractInterface);\n\t    };\n\t    // @TODO: Allow timeout?\n\t    Contract.prototype.deployed = function () {\n\t        return this._deployed();\n\t    };\n\t    Contract.prototype._deployed = function (blockTag) {\n\t        var _this = this;\n\t        if (!this._deployedPromise) {\n\t            // If we were just deployed, we know the transaction we should occur in\n\t            if (this.deployTransaction) {\n\t                this._deployedPromise = this.deployTransaction.wait().then(function () {\n\t                    return _this;\n\t                });\n\t            }\n\t            else {\n\t                // @TODO: Once we allow a timeout to be passed in, we will wait\n\t                // up to that many blocks for getCode\n\t                // Otherwise, poll for our code to be deployed\n\t                this._deployedPromise = this.provider.getCode(this.address, blockTag).then(function (code) {\n\t                    if (code === \"0x\") {\n\t                        logger.throwError(\"contract not deployed\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            contractAddress: _this.address,\n\t                            operation: \"getDeployed\"\n\t                        });\n\t                    }\n\t                    return _this;\n\t                });\n\t            }\n\t        }\n\t        return this._deployedPromise;\n\t    };\n\t    // @TODO:\n\t    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\t    // @TODO:\n\t    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\t    Contract.prototype.fallback = function (overrides) {\n\t        var _this = this;\n\t        if (!this.signer) {\n\t            logger.throwError(\"sending a transactions require a signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n\t        }\n\t        var tx = lib$3.shallowCopy(overrides || {});\n\t        [\"from\", \"to\"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot override \" + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        tx.to = this.resolvedAddress;\n\t        return this.deployed().then(function () {\n\t            return _this.signer.sendTransaction(tx);\n\t        });\n\t    };\n\t    // Reconnect to a different signer or provider\n\t    Contract.prototype.connect = function (signerOrProvider) {\n\t        if (typeof (signerOrProvider) === \"string\") {\n\t            signerOrProvider = new lib$c.VoidSigner(signerOrProvider, this.provider);\n\t        }\n\t        var contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n\t        if (this.deployTransaction) {\n\t            lib$3.defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n\t        }\n\t        return contract;\n\t    };\n\t    // Re-attach to a different on-chain instance of this contract\n\t    Contract.prototype.attach = function (addressOrName) {\n\t        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n\t    };\n\t    Contract.isIndexed = function (value) {\n\t        return lib$a.Indexed.isIndexed(value);\n\t    };\n\t    Contract.prototype._normalizeRunningEvent = function (runningEvent) {\n\t        // Already have an instance of this event running; we can re-use it\n\t        if (this._runningEvents[runningEvent.tag]) {\n\t            return this._runningEvents[runningEvent.tag];\n\t        }\n\t        return runningEvent;\n\t    };\n\t    Contract.prototype._getRunningEvent = function (eventName) {\n\t        if (typeof (eventName) === \"string\") {\n\t            // Listen for \"error\" events (if your contract has an error event, include\n\t            // the full signature to bypass this special event keyword)\n\t            if (eventName === \"error\") {\n\t                return this._normalizeRunningEvent(new ErrorRunningEvent());\n\t            }\n\t            // Listen for any event that is registered\n\t            if (eventName === \"event\") {\n\t                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n\t            }\n\t            // Listen for any event\n\t            if (eventName === \"*\") {\n\t                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t            }\n\t            // Get the event Fragment (throws if ambiguous/unknown event)\n\t            var fragment = this.interface.getEvent(eventName);\n\t            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n\t        }\n\t        // We have topics to filter by...\n\t        if (eventName.topics && eventName.topics.length > 0) {\n\t            // Is it a known topichash? (throws if no matching topichash)\n\t            try {\n\t                var topic = eventName.topics[0];\n\t                if (typeof (topic) !== \"string\") {\n\t                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n\t                }\n\t                var fragment = this.interface.getEvent(topic);\n\t                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n\t            }\n\t            catch (error) { }\n\t            // Filter by the unknown topichash\n\t            var filter = {\n\t                address: this.address,\n\t                topics: eventName.topics\n\t            };\n\t            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n\t        }\n\t        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t    };\n\t    Contract.prototype._checkRunningEvents = function (runningEvent) {\n\t        if (runningEvent.listenerCount() === 0) {\n\t            delete this._runningEvents[runningEvent.tag];\n\t            // If we have a poller for this, remove it\n\t            var emit = this._wrappedEmits[runningEvent.tag];\n\t            if (emit) {\n\t                this.provider.off(runningEvent.filter, emit);\n\t                delete this._wrappedEmits[runningEvent.tag];\n\t            }\n\t        }\n\t    };\n\t    // Subclasses can override this to gracefully recover\n\t    // from parse errors if they wish\n\t    Contract.prototype._wrapEvent = function (runningEvent, log, listener) {\n\t        var _this = this;\n\t        var event = lib$3.deepCopy(log);\n\t        event.removeListener = function () {\n\t            if (!listener) {\n\t                return;\n\t            }\n\t            runningEvent.removeListener(listener);\n\t            _this._checkRunningEvents(runningEvent);\n\t        };\n\t        event.getBlock = function () { return _this.provider.getBlock(log.blockHash); };\n\t        event.getTransaction = function () { return _this.provider.getTransaction(log.transactionHash); };\n\t        event.getTransactionReceipt = function () { return _this.provider.getTransactionReceipt(log.transactionHash); };\n\t        // This may throw if the topics and data mismatch the signature\n\t        runningEvent.prepareEvent(event);\n\t        return event;\n\t    };\n\t    Contract.prototype._addEventListener = function (runningEvent, listener, once) {\n\t        var _this = this;\n\t        if (!this.provider) {\n\t            logger.throwError(\"events require a provider or a signer with a provider\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n\t        }\n\t        runningEvent.addListener(listener, once);\n\t        // Track this running event and its listeners (may already be there; but no hard in updating)\n\t        this._runningEvents[runningEvent.tag] = runningEvent;\n\t        // If we are not polling the provider, start polling\n\t        if (!this._wrappedEmits[runningEvent.tag]) {\n\t            var wrappedEmit = function (log) {\n\t                var event = _this._wrapEvent(runningEvent, log, listener);\n\t                // Try to emit the result for the parameterized event...\n\t                if (event.decodeError == null) {\n\t                    try {\n\t                        var args = runningEvent.getEmit(event);\n\t                        _this.emit.apply(_this, __spreadArrays([runningEvent.filter], args));\n\t                    }\n\t                    catch (error) {\n\t                        event.decodeError = error.error;\n\t                    }\n\t                }\n\t                // Always emit \"event\" for fragment-base events\n\t                if (runningEvent.filter != null) {\n\t                    _this.emit(\"event\", event);\n\t                }\n\t                // Emit \"error\" if there was an error\n\t                if (event.decodeError != null) {\n\t                    _this.emit(\"error\", event.decodeError, event);\n\t                }\n\t            };\n\t            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\t            // Special events, like \"error\" do not have a filter\n\t            if (runningEvent.filter != null) {\n\t                this.provider.on(runningEvent.filter, wrappedEmit);\n\t            }\n\t        }\n\t    };\n\t    Contract.prototype.queryFilter = function (event, fromBlockOrBlockhash, toBlock) {\n\t        var _this = this;\n\t        var runningEvent = this._getRunningEvent(event);\n\t        var filter = lib$3.shallowCopy(runningEvent.filter);\n\t        if (typeof (fromBlockOrBlockhash) === \"string\" && lib$1.isHexString(fromBlockOrBlockhash, 32)) {\n\t            if (toBlock != null) {\n\t                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n\t            }\n\t            filter.blockHash = fromBlockOrBlockhash;\n\t        }\n\t        else {\n\t            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n\t            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n\t        }\n\t        return this.provider.getLogs(filter).then(function (logs) {\n\t            return logs.map(function (log) { return _this._wrapEvent(runningEvent, log, null); });\n\t        });\n\t    };\n\t    Contract.prototype.on = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, false);\n\t        return this;\n\t    };\n\t    Contract.prototype.once = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, true);\n\t        return this;\n\t    };\n\t    Contract.prototype.emit = function (eventName) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        if (!this.provider) {\n\t            return false;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        var result = (runningEvent.run(args) > 0);\n\t        // May have drained all the \"once\" events; check for living events\n\t        this._checkRunningEvents(runningEvent);\n\t        return result;\n\t    };\n\t    Contract.prototype.listenerCount = function (eventName) {\n\t        if (!this.provider) {\n\t            return 0;\n\t        }\n\t        return this._getRunningEvent(eventName).listenerCount();\n\t    };\n\t    Contract.prototype.listeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return [];\n\t        }\n\t        if (eventName == null) {\n\t            var result_1 = [];\n\t            for (var tag in this._runningEvents) {\n\t                this._runningEvents[tag].listeners().forEach(function (listener) {\n\t                    result_1.push(listener);\n\t                });\n\t            }\n\t            return result_1;\n\t        }\n\t        return this._getRunningEvent(eventName).listeners();\n\t    };\n\t    Contract.prototype.removeAllListeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        if (eventName == null) {\n\t            for (var tag in this._runningEvents) {\n\t                var runningEvent_1 = this._runningEvents[tag];\n\t                runningEvent_1.removeAllListeners();\n\t                this._checkRunningEvents(runningEvent_1);\n\t            }\n\t            return this;\n\t        }\n\t        // Delete any listeners\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeAllListeners();\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    Contract.prototype.off = function (eventName, listener) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeListener(listener);\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    Contract.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    return Contract;\n\t}());\n\texports.Contract = Contract;\n\tvar ContractFactory = /** @class */ (function () {\n\t    function ContractFactory(contractInterface, bytecode, signer) {\n\t        var _newTarget = this.constructor;\n\t        var bytecodeHex = null;\n\t        if (typeof (bytecode) === \"string\") {\n\t            bytecodeHex = bytecode;\n\t        }\n\t        else if (lib$1.isBytes(bytecode)) {\n\t            bytecodeHex = lib$1.hexlify(bytecode);\n\t        }\n\t        else if (bytecode && typeof (bytecode.object) === \"string\") {\n\t            // Allow the bytecode object from the Solidity compiler\n\t            bytecodeHex = bytecode.object;\n\t        }\n\t        else {\n\t            // Crash in the next verification step\n\t            bytecodeHex = \"!\";\n\t        }\n\t        // Make sure it is 0x prefixed\n\t        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n\t            bytecodeHex = \"0x\" + bytecodeHex;\n\t        }\n\t        // Make sure the final result is valid bytecode\n\t        if (!lib$1.isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n\t            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n\t        }\n\t        // If we have a signer, make sure it is valid\n\t        if (signer && !lib$c.Signer.isSigner(signer)) {\n\t            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n\t        }\n\t        lib$3.defineReadOnly(this, \"bytecode\", bytecodeHex);\n\t        lib$3.defineReadOnly(this, \"interface\", lib$3.getStatic((_newTarget), \"getInterface\")(contractInterface));\n\t        lib$3.defineReadOnly(this, \"signer\", signer || null);\n\t    }\n\t    // @TODO: Future; rename to populteTransaction?\n\t    ContractFactory.prototype.getDeployTransaction = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        var tx = {};\n\t        // If we have 1 additional argument, we allow transaction overrides\n\t        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n\t            tx = lib$3.shallowCopy(args.pop());\n\t            for (var key in tx) {\n\t                if (!allowedTransactionKeys[key]) {\n\t                    throw new Error(\"unknown transaction override \" + key);\n\t                }\n\t            }\n\t        }\n\t        // Do not allow these to be overridden in a deployment transaction\n\t        [\"data\", \"from\", \"to\"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot override \" + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        // Make sure the call matches the constructor signature\n\t        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\t        // Set the data to the bytecode + the encoded constructor arguments\n\t        tx.data = lib$1.hexlify(lib$1.concat([\n\t            this.bytecode,\n\t            this.interface.encodeDeploy(args)\n\t        ]));\n\t        return tx;\n\t    };\n\t    ContractFactory.prototype.deploy = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var overrides, params, unsignedTx, tx, address, contract;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        overrides = {};\n\t                        // If 1 extra parameter was passed in, it contains overrides\n\t                        if (args.length === this.interface.deploy.inputs.length + 1) {\n\t                            overrides = args.pop();\n\t                        }\n\t                        // Make sure the call matches the constructor signature\n\t                        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\t                        return [4 /*yield*/, resolveAddresses(this.signer, args, this.interface.deploy.inputs)];\n\t                    case 1:\n\t                        params = _a.sent();\n\t                        params.push(overrides);\n\t                        unsignedTx = this.getDeployTransaction.apply(this, params);\n\t                        return [4 /*yield*/, this.signer.sendTransaction(unsignedTx)];\n\t                    case 2:\n\t                        tx = _a.sent();\n\t                        address = lib$3.getStatic(this.constructor, \"getContractAddress\")(tx);\n\t                        contract = lib$3.getStatic(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\t                        lib$3.defineReadOnly(contract, \"deployTransaction\", tx);\n\t                        return [2 /*return*/, contract];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ContractFactory.prototype.attach = function (address) {\n\t        return (this.constructor).getContract(address, this.interface, this.signer);\n\t    };\n\t    ContractFactory.prototype.connect = function (signer) {\n\t        return new (this.constructor)(this.interface, this.bytecode, signer);\n\t    };\n\t    ContractFactory.fromSolidity = function (compilerOutput, signer) {\n\t        if (compilerOutput == null) {\n\t            logger.throwError(\"missing compiler output\", lib.Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n\t        }\n\t        if (typeof (compilerOutput) === \"string\") {\n\t            compilerOutput = JSON.parse(compilerOutput);\n\t        }\n\t        var abi = compilerOutput.abi;\n\t        var bytecode = null;\n\t        if (compilerOutput.bytecode) {\n\t            bytecode = compilerOutput.bytecode;\n\t        }\n\t        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n\t            bytecode = compilerOutput.evm.bytecode;\n\t        }\n\t        return new this(abi, bytecode, signer);\n\t    };\n\t    ContractFactory.getInterface = function (contractInterface) {\n\t        return Contract.getInterface(contractInterface);\n\t    };\n\t    ContractFactory.getContractAddress = function (tx) {\n\t        return lib$6.getContractAddress(tx);\n\t    };\n\t    ContractFactory.getContract = function (address, contractInterface, signer) {\n\t        return new Contract(address, contractInterface, signer);\n\t    };\n\t    return ContractFactory;\n\t}());\n\texports.ContractFactory = ContractFactory;\n\t});\n\n\tvar index$d = unwrapExports(lib$d);\n\tvar lib_1$d = lib$d.Contract;\n\tvar lib_2$c = lib$d.ContractFactory;\n\n\tvar lib$e = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\t/**\n\t * var basex = require(\"base-x\");\n\t *\n\t * This implementation is heavily based on base-x. The main reason to\n\t * deviate was to prevent the dependency of Buffer.\n\t *\n\t * Contributors:\n\t *\n\t * base-x encoding\n\t * Forked from https://github.com/cryptocoinjs/bs58\n\t * Originally written by Mike Hearn for BitcoinJ\n\t * Copyright (c) 2011 Google Inc\n\t * Ported to JavaScript by Stefan Thomas\n\t * Merged Buffer refactorings from base58-native by Stephen Pair\n\t * Copyright (c) 2013 BitPay Inc\n\t *\n\t * The MIT License (MIT)\n\t *\n\t * Copyright base-x contributors (c) 2016\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a\n\t * copy of this software and associated documentation files (the \"Software\"),\n\t * to deal in the Software without restriction, including without limitation\n\t * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t * and/or sell copies of the Software, and to permit persons to whom the\n\t * Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n\t * IN THE SOFTWARE.\n\t *\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar BaseX = /** @class */ (function () {\n\t    function BaseX(alphabet) {\n\t        lib$3.defineReadOnly(this, \"alphabet\", alphabet);\n\t        lib$3.defineReadOnly(this, \"base\", alphabet.length);\n\t        lib$3.defineReadOnly(this, \"_alphabetMap\", {});\n\t        lib$3.defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\t        // pre-compute lookup table\n\t        for (var i = 0; i < alphabet.length; i++) {\n\t            this._alphabetMap[alphabet.charAt(i)] = i;\n\t        }\n\t    }\n\t    BaseX.prototype.encode = function (value) {\n\t        var source = lib$1.arrayify(value);\n\t        if (source.length === 0) {\n\t            return \"\";\n\t        }\n\t        var digits = [0];\n\t        for (var i = 0; i < source.length; ++i) {\n\t            var carry = source[i];\n\t            for (var j = 0; j < digits.length; ++j) {\n\t                carry += digits[j] << 8;\n\t                digits[j] = carry % this.base;\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t            while (carry > 0) {\n\t                digits.push(carry % this.base);\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t        }\n\t        var string = \"\";\n\t        // deal with leading zeros\n\t        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n\t            string += this._leader;\n\t        }\n\t        // convert digits to a string\n\t        for (var q = digits.length - 1; q >= 0; --q) {\n\t            string += this.alphabet[digits[q]];\n\t        }\n\t        return string;\n\t    };\n\t    BaseX.prototype.decode = function (value) {\n\t        if (typeof (value) !== \"string\") {\n\t            throw new TypeError(\"Expected String\");\n\t        }\n\t        var bytes = [];\n\t        if (value.length === 0) {\n\t            return new Uint8Array(bytes);\n\t        }\n\t        bytes.push(0);\n\t        for (var i = 0; i < value.length; i++) {\n\t            var byte = this._alphabetMap[value[i]];\n\t            if (byte === undefined) {\n\t                throw new Error(\"Non-base\" + this.base + \" character\");\n\t            }\n\t            var carry = byte;\n\t            for (var j = 0; j < bytes.length; ++j) {\n\t                carry += bytes[j] * this.base;\n\t                bytes[j] = carry & 0xff;\n\t                carry >>= 8;\n\t            }\n\t            while (carry > 0) {\n\t                bytes.push(carry & 0xff);\n\t                carry >>= 8;\n\t            }\n\t        }\n\t        // deal with leading zeros\n\t        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n\t            bytes.push(0);\n\t        }\n\t        return lib$1.arrayify(new Uint8Array(bytes.reverse()));\n\t    };\n\t    return BaseX;\n\t}());\n\texports.BaseX = BaseX;\n\tvar Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\n\texports.Base32 = Base32;\n\tvar Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\texports.Base58 = Base58;\n\t//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n\t//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n\t});\n\n\tvar index$e = unwrapExports(lib$e);\n\tvar lib_1$e = lib$e.BaseX;\n\tvar lib_2$d = lib$e.Base32;\n\tvar lib_3$a = lib$e.Base58;\n\n\tvar minimalisticAssert = assert;\n\n\tfunction assert(val, msg) {\n\t  if (!val)\n\t    throw new Error(msg || 'Assertion failed');\n\t}\n\n\tassert.equal = function assertEqual(l, r, msg) {\n\t  if (l != r)\n\t    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n\t};\n\n\tvar inherits_browser = createCommonjsModule(function (module) {\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      ctor.prototype = Object.create(superCtor.prototype, {\n\t        constructor: {\n\t          value: ctor,\n\t          enumerable: false,\n\t          writable: true,\n\t          configurable: true\n\t        }\n\t      });\n\t    }\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      var TempCtor = function () {};\n\t      TempCtor.prototype = superCtor.prototype;\n\t      ctor.prototype = new TempCtor();\n\t      ctor.prototype.constructor = ctor;\n\t    }\n\t  };\n\t}\n\t});\n\n\t'use strict';\n\n\n\n\n\tvar inherits_1 = inherits_browser;\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg === 'string') {\n\t    if (!enc) {\n\t      for (var i = 0; i < msg.length; i++) {\n\t        var c = msg.charCodeAt(i);\n\t        var hi = c >> 8;\n\t        var lo = c & 0xff;\n\t        if (hi)\n\t          res.push(hi, lo);\n\t        else\n\t          res.push(lo);\n\t      }\n\t    } else if (enc === 'hex') {\n\t      msg = msg.replace(/[^a-z0-9]+/ig, '');\n\t      if (msg.length % 2 !== 0)\n\t        msg = '0' + msg;\n\t      for (i = 0; i < msg.length; i += 2)\n\t        res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t    }\n\t  } else {\n\t    for (i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t  }\n\t  return res;\n\t}\n\tvar toArray_1 = toArray;\n\n\tfunction toHex(msg) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tvar toHex_1 = toHex;\n\n\tfunction htonl(w) {\n\t  var res = (w >>> 24) |\n\t            ((w >>> 8) & 0xff00) |\n\t            ((w << 8) & 0xff0000) |\n\t            ((w & 0xff) << 24);\n\t  return res >>> 0;\n\t}\n\tvar htonl_1 = htonl;\n\n\tfunction toHex32(msg, endian) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++) {\n\t    var w = msg[i];\n\t    if (endian === 'little')\n\t      w = htonl(w);\n\t    res += zero8(w.toString(16));\n\t  }\n\t  return res;\n\t}\n\tvar toHex32_1 = toHex32;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return '0' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero2_1 = zero2;\n\n\tfunction zero8(word) {\n\t  if (word.length === 7)\n\t    return '0' + word;\n\t  else if (word.length === 6)\n\t    return '00' + word;\n\t  else if (word.length === 5)\n\t    return '000' + word;\n\t  else if (word.length === 4)\n\t    return '0000' + word;\n\t  else if (word.length === 3)\n\t    return '00000' + word;\n\t  else if (word.length === 2)\n\t    return '000000' + word;\n\t  else if (word.length === 1)\n\t    return '0000000' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero8_1 = zero8;\n\n\tfunction join32(msg, start, end, endian) {\n\t  var len = end - start;\n\t  minimalisticAssert(len % 4 === 0);\n\t  var res = new Array(len / 4);\n\t  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n\t    var w;\n\t    if (endian === 'big')\n\t      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n\t    else\n\t      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n\t    res[i] = w >>> 0;\n\t  }\n\t  return res;\n\t}\n\tvar join32_1 = join32;\n\n\tfunction split32(msg, endian) {\n\t  var res = new Array(msg.length * 4);\n\t  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n\t    var m = msg[i];\n\t    if (endian === 'big') {\n\t      res[k] = m >>> 24;\n\t      res[k + 1] = (m >>> 16) & 0xff;\n\t      res[k + 2] = (m >>> 8) & 0xff;\n\t      res[k + 3] = m & 0xff;\n\t    } else {\n\t      res[k + 3] = m >>> 24;\n\t      res[k + 2] = (m >>> 16) & 0xff;\n\t      res[k + 1] = (m >>> 8) & 0xff;\n\t      res[k] = m & 0xff;\n\t    }\n\t  }\n\t  return res;\n\t}\n\tvar split32_1 = split32;\n\n\tfunction rotr32(w, b) {\n\t  return (w >>> b) | (w << (32 - b));\n\t}\n\tvar rotr32_1 = rotr32;\n\n\tfunction rotl32(w, b) {\n\t  return (w << b) | (w >>> (32 - b));\n\t}\n\tvar rotl32_1 = rotl32;\n\n\tfunction sum32(a, b) {\n\t  return (a + b) >>> 0;\n\t}\n\tvar sum32_1 = sum32;\n\n\tfunction sum32_3(a, b, c) {\n\t  return (a + b + c) >>> 0;\n\t}\n\tvar sum32_3_1 = sum32_3;\n\n\tfunction sum32_4(a, b, c, d) {\n\t  return (a + b + c + d) >>> 0;\n\t}\n\tvar sum32_4_1 = sum32_4;\n\n\tfunction sum32_5(a, b, c, d, e) {\n\t  return (a + b + c + d + e) >>> 0;\n\t}\n\tvar sum32_5_1 = sum32_5;\n\n\tfunction sum64(buf, pos, ah, al) {\n\t  var bh = buf[pos];\n\t  var bl = buf[pos + 1];\n\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  buf[pos] = hi >>> 0;\n\t  buf[pos + 1] = lo;\n\t}\n\tvar sum64_1 = sum64;\n\n\tfunction sum64_hi(ah, al, bh, bl) {\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_hi_1 = sum64_hi;\n\n\tfunction sum64_lo(ah, al, bh, bl) {\n\t  var lo = al + bl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_lo_1 = sum64_lo;\n\n\tfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_4_hi_1 = sum64_4_hi;\n\n\tfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var lo = al + bl + cl + dl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_4_lo_1 = sum64_4_lo;\n\n\tfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\t  lo = (lo + el) >>> 0;\n\t  carry += lo < el ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + eh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_5_hi_1 = sum64_5_hi;\n\n\tfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var lo = al + bl + cl + dl + el;\n\n\t  return lo >>> 0;\n\t}\n\tvar sum64_5_lo_1 = sum64_5_lo;\n\n\tfunction rotr64_hi(ah, al, num) {\n\t  var r = (al << (32 - num)) | (ah >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_hi_1 = rotr64_hi;\n\n\tfunction rotr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_lo_1 = rotr64_lo;\n\n\tfunction shr64_hi(ah, al, num) {\n\t  return ah >>> num;\n\t}\n\tvar shr64_hi_1 = shr64_hi;\n\n\tfunction shr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar shr64_lo_1 = shr64_lo;\n\n\tvar utils = {\n\t\tinherits: inherits_1,\n\t\ttoArray: toArray_1,\n\t\ttoHex: toHex_1,\n\t\thtonl: htonl_1,\n\t\ttoHex32: toHex32_1,\n\t\tzero2: zero2_1,\n\t\tzero8: zero8_1,\n\t\tjoin32: join32_1,\n\t\tsplit32: split32_1,\n\t\trotr32: rotr32_1,\n\t\trotl32: rotl32_1,\n\t\tsum32: sum32_1,\n\t\tsum32_3: sum32_3_1,\n\t\tsum32_4: sum32_4_1,\n\t\tsum32_5: sum32_5_1,\n\t\tsum64: sum64_1,\n\t\tsum64_hi: sum64_hi_1,\n\t\tsum64_lo: sum64_lo_1,\n\t\tsum64_4_hi: sum64_4_hi_1,\n\t\tsum64_4_lo: sum64_4_lo_1,\n\t\tsum64_5_hi: sum64_5_hi_1,\n\t\tsum64_5_lo: sum64_5_lo_1,\n\t\trotr64_hi: rotr64_hi_1,\n\t\trotr64_lo: rotr64_lo_1,\n\t\tshr64_hi: shr64_hi_1,\n\t\tshr64_lo: shr64_lo_1\n\t};\n\n\t'use strict';\n\n\n\n\n\tfunction BlockHash() {\n\t  this.pending = null;\n\t  this.pendingTotal = 0;\n\t  this.blockSize = this.constructor.blockSize;\n\t  this.outSize = this.constructor.outSize;\n\t  this.hmacStrength = this.constructor.hmacStrength;\n\t  this.padLength = this.constructor.padLength / 8;\n\t  this.endian = 'big';\n\n\t  this._delta8 = this.blockSize / 8;\n\t  this._delta32 = this.blockSize / 32;\n\t}\n\tvar BlockHash_1 = BlockHash;\n\n\tBlockHash.prototype.update = function update(msg, enc) {\n\t  // Convert message to array, pad it, and join into 32bit blocks\n\t  msg = utils.toArray(msg, enc);\n\t  if (!this.pending)\n\t    this.pending = msg;\n\t  else\n\t    this.pending = this.pending.concat(msg);\n\t  this.pendingTotal += msg.length;\n\n\t  // Enough data, try updating\n\t  if (this.pending.length >= this._delta8) {\n\t    msg = this.pending;\n\n\t    // Process pending data in blocks\n\t    var r = msg.length % this._delta8;\n\t    this.pending = msg.slice(msg.length - r, msg.length);\n\t    if (this.pending.length === 0)\n\t      this.pending = null;\n\n\t    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\t    for (var i = 0; i < msg.length; i += this._delta32)\n\t      this._update(msg, i, i + this._delta32);\n\t  }\n\n\t  return this;\n\t};\n\n\tBlockHash.prototype.digest = function digest(enc) {\n\t  this.update(this._pad());\n\t  minimalisticAssert(this.pending === null);\n\n\t  return this._digest(enc);\n\t};\n\n\tBlockHash.prototype._pad = function pad() {\n\t  var len = this.pendingTotal;\n\t  var bytes = this._delta8;\n\t  var k = bytes - ((len + this.padLength) % bytes);\n\t  var res = new Array(k + this.padLength);\n\t  res[0] = 0x80;\n\t  for (var i = 1; i < k; i++)\n\t    res[i] = 0;\n\n\t  // Append length\n\t  len <<= 3;\n\t  if (this.endian === 'big') {\n\t    for (var t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = len & 0xff;\n\t  } else {\n\t    res[i++] = len & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\n\t    for (t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\t  }\n\n\t  return res;\n\t};\n\n\tvar common = {\n\t\tBlockHash: BlockHash_1\n\t};\n\n\tvar _1 = {};\n\n\tvar _224 = {};\n\n\t'use strict';\n\n\n\tvar rotr32$1 = utils.rotr32;\n\n\tfunction ft_1(s, x, y, z) {\n\t  if (s === 0)\n\t    return ch32(x, y, z);\n\t  if (s === 1 || s === 3)\n\t    return p32(x, y, z);\n\t  if (s === 2)\n\t    return maj32(x, y, z);\n\t}\n\tvar ft_1_1 = ft_1;\n\n\tfunction ch32(x, y, z) {\n\t  return (x & y) ^ ((~x) & z);\n\t}\n\tvar ch32_1 = ch32;\n\n\tfunction maj32(x, y, z) {\n\t  return (x & y) ^ (x & z) ^ (y & z);\n\t}\n\tvar maj32_1 = maj32;\n\n\tfunction p32(x, y, z) {\n\t  return x ^ y ^ z;\n\t}\n\tvar p32_1 = p32;\n\n\tfunction s0_256(x) {\n\t  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n\t}\n\tvar s0_256_1 = s0_256;\n\n\tfunction s1_256(x) {\n\t  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n\t}\n\tvar s1_256_1 = s1_256;\n\n\tfunction g0_256(x) {\n\t  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);\n\t}\n\tvar g0_256_1 = g0_256;\n\n\tfunction g1_256(x) {\n\t  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);\n\t}\n\tvar g1_256_1 = g1_256;\n\n\tvar common$1 = {\n\t\tft_1: ft_1_1,\n\t\tch32: ch32_1,\n\t\tmaj32: maj32_1,\n\t\tp32: p32_1,\n\t\ts0_256: s0_256_1,\n\t\ts1_256: s1_256_1,\n\t\tg0_256: g0_256_1,\n\t\tg1_256: g1_256_1\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\tvar sum32$1 = utils.sum32;\n\tvar sum32_4$1 = utils.sum32_4;\n\tvar sum32_5$1 = utils.sum32_5;\n\tvar ch32$1 = common$1.ch32;\n\tvar maj32$1 = common$1.maj32;\n\tvar s0_256$1 = common$1.s0_256;\n\tvar s1_256$1 = common$1.s1_256;\n\tvar g0_256$1 = common$1.g0_256;\n\tvar g1_256$1 = common$1.g1_256;\n\n\tvar BlockHash$1 = common.BlockHash;\n\n\tvar sha256_K = [\n\t  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t];\n\n\tfunction SHA256() {\n\t  if (!(this instanceof SHA256))\n\t    return new SHA256();\n\n\t  BlockHash$1.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n\t    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n\t  ];\n\t  this.k = sha256_K;\n\t  this.W = new Array(64);\n\t}\n\tutils.inherits(SHA256, BlockHash$1);\n\tvar _256 = SHA256;\n\n\tSHA256.blockSize = 512;\n\tSHA256.outSize = 256;\n\tSHA256.hmacStrength = 192;\n\tSHA256.padLength = 64;\n\n\tSHA256.prototype._update = function _update(msg, start) {\n\t  var W = this.W;\n\n\t  for (var i = 0; i < 16; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i++)\n\t    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n\t  var a = this.h[0];\n\t  var b = this.h[1];\n\t  var c = this.h[2];\n\t  var d = this.h[3];\n\t  var e = this.h[4];\n\t  var f = this.h[5];\n\t  var g = this.h[6];\n\t  var h = this.h[7];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (i = 0; i < W.length; i++) {\n\t    var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n\t    var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));\n\t    h = g;\n\t    g = f;\n\t    f = e;\n\t    e = sum32$1(d, T1);\n\t    d = c;\n\t    c = b;\n\t    b = a;\n\t    a = sum32$1(T1, T2);\n\t  }\n\n\t  this.h[0] = sum32$1(this.h[0], a);\n\t  this.h[1] = sum32$1(this.h[1], b);\n\t  this.h[2] = sum32$1(this.h[2], c);\n\t  this.h[3] = sum32$1(this.h[3], d);\n\t  this.h[4] = sum32$1(this.h[4], e);\n\t  this.h[5] = sum32$1(this.h[5], f);\n\t  this.h[6] = sum32$1(this.h[6], g);\n\t  this.h[7] = sum32$1(this.h[7], h);\n\t};\n\n\tSHA256.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'big');\n\t  else\n\t    return utils.split32(this.h, 'big');\n\t};\n\n\tvar _384 = {};\n\n\t'use strict';\n\n\n\n\n\n\tvar rotr64_hi$1 = utils.rotr64_hi;\n\tvar rotr64_lo$1 = utils.rotr64_lo;\n\tvar shr64_hi$1 = utils.shr64_hi;\n\tvar shr64_lo$1 = utils.shr64_lo;\n\tvar sum64$1 = utils.sum64;\n\tvar sum64_hi$1 = utils.sum64_hi;\n\tvar sum64_lo$1 = utils.sum64_lo;\n\tvar sum64_4_hi$1 = utils.sum64_4_hi;\n\tvar sum64_4_lo$1 = utils.sum64_4_lo;\n\tvar sum64_5_hi$1 = utils.sum64_5_hi;\n\tvar sum64_5_lo$1 = utils.sum64_5_lo;\n\n\tvar BlockHash$2 = common.BlockHash;\n\n\tvar sha512_K = [\n\t  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n\t  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n\t  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n\t  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n\t  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n\t  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n\t  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n\t  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n\t  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n\t  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n\t  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n\t  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n\t  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n\t  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n\t  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n\t  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n\t  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n\t  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n\t  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n\t  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n\t  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n\t  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n\t  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n\t  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n\t  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n\t  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n\t  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n\t  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n\t  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n\t  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n\t  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n\t  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n\t  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n\t  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n\t  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n\t  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n\t  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n\t  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n\t  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n\t  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n\t];\n\n\tfunction SHA512() {\n\t  if (!(this instanceof SHA512))\n\t    return new SHA512();\n\n\t  BlockHash$2.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xf3bcc908,\n\t    0xbb67ae85, 0x84caa73b,\n\t    0x3c6ef372, 0xfe94f82b,\n\t    0xa54ff53a, 0x5f1d36f1,\n\t    0x510e527f, 0xade682d1,\n\t    0x9b05688c, 0x2b3e6c1f,\n\t    0x1f83d9ab, 0xfb41bd6b,\n\t    0x5be0cd19, 0x137e2179 ];\n\t  this.k = sha512_K;\n\t  this.W = new Array(160);\n\t}\n\tutils.inherits(SHA512, BlockHash$2);\n\tvar _512 = SHA512;\n\n\tSHA512.blockSize = 1024;\n\tSHA512.outSize = 512;\n\tSHA512.hmacStrength = 192;\n\tSHA512.padLength = 128;\n\n\tSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n\t  var W = this.W;\n\n\t  // 32 x 32bit words\n\t  for (var i = 0; i < 32; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i += 2) {\n\t    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n\t    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n\t    var c1_hi = W[i - 14];  // i - 7\n\t    var c1_lo = W[i - 13];\n\t    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n\t    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n\t    var c3_hi = W[i - 32];  // i - 16\n\t    var c3_lo = W[i - 31];\n\n\t    W[i] = sum64_4_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t    W[i + 1] = sum64_4_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t  }\n\t};\n\n\tSHA512.prototype._update = function _update(msg, start) {\n\t  this._prepareBlock(msg, start);\n\n\t  var W = this.W;\n\n\t  var ah = this.h[0];\n\t  var al = this.h[1];\n\t  var bh = this.h[2];\n\t  var bl = this.h[3];\n\t  var ch = this.h[4];\n\t  var cl = this.h[5];\n\t  var dh = this.h[6];\n\t  var dl = this.h[7];\n\t  var eh = this.h[8];\n\t  var el = this.h[9];\n\t  var fh = this.h[10];\n\t  var fl = this.h[11];\n\t  var gh = this.h[12];\n\t  var gl = this.h[13];\n\t  var hh = this.h[14];\n\t  var hl = this.h[15];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (var i = 0; i < W.length; i += 2) {\n\t    var c0_hi = hh;\n\t    var c0_lo = hl;\n\t    var c1_hi = s1_512_hi(eh, el);\n\t    var c1_lo = s1_512_lo(eh, el);\n\t    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n\t    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n\t    var c3_hi = this.k[i];\n\t    var c3_lo = this.k[i + 1];\n\t    var c4_hi = W[i];\n\t    var c4_lo = W[i + 1];\n\n\t    var T1_hi = sum64_5_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\t    var T1_lo = sum64_5_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\n\t    c0_hi = s0_512_hi(ah, al);\n\t    c0_lo = s0_512_lo(ah, al);\n\t    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n\t    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n\t    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\t    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\n\t    hh = gh;\n\t    hl = gl;\n\n\t    gh = fh;\n\t    gl = fl;\n\n\t    fh = eh;\n\t    fl = el;\n\n\t    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);\n\t    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);\n\n\t    dh = ch;\n\t    dl = cl;\n\n\t    ch = bh;\n\t    cl = bl;\n\n\t    bh = ah;\n\t    bl = al;\n\n\t    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t  }\n\n\t  sum64$1(this.h, 0, ah, al);\n\t  sum64$1(this.h, 2, bh, bl);\n\t  sum64$1(this.h, 4, ch, cl);\n\t  sum64$1(this.h, 6, dh, dl);\n\t  sum64$1(this.h, 8, eh, el);\n\t  sum64$1(this.h, 10, fh, fl);\n\t  sum64$1(this.h, 12, gh, gl);\n\t  sum64$1(this.h, 14, hh, hl);\n\t};\n\n\tSHA512.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'big');\n\t  else\n\t    return utils.split32(this.h, 'big');\n\t};\n\n\tfunction ch64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ ((~xh) & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ ((~xl) & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 28);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34\n\t  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 28);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34\n\t  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 14);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 18);\n\t  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 14);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 18);\n\t  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 1);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 8);\n\t  var c2_hi = shr64_hi$1(xh, xl, 7);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 1);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 8);\n\t  var c2_lo = shr64_lo$1(xh, xl, 7);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 19);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61\n\t  var c2_hi = shr64_hi$1(xh, xl, 6);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 19);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61\n\t  var c2_lo = shr64_lo$1(xh, xl, 6);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\t'use strict';\n\n\tvar sha1 = _1;\n\tvar sha224 = _224;\n\tvar sha256 = _256;\n\tvar sha384 = _384;\n\tvar sha512 = _512;\n\n\tvar sha = {\n\t\tsha1: sha1,\n\t\tsha224: sha224,\n\t\tsha256: sha256,\n\t\tsha384: sha384,\n\t\tsha512: sha512\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar rotl32$1 = utils.rotl32;\n\tvar sum32$2 = utils.sum32;\n\tvar sum32_3$1 = utils.sum32_3;\n\tvar sum32_4$2 = utils.sum32_4;\n\tvar BlockHash$3 = common.BlockHash;\n\n\tfunction RIPEMD160() {\n\t  if (!(this instanceof RIPEMD160))\n\t    return new RIPEMD160();\n\n\t  BlockHash$3.call(this);\n\n\t  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n\t  this.endian = 'little';\n\t}\n\tutils.inherits(RIPEMD160, BlockHash$3);\n\tvar ripemd160 = RIPEMD160;\n\n\tRIPEMD160.blockSize = 512;\n\tRIPEMD160.outSize = 160;\n\tRIPEMD160.hmacStrength = 192;\n\tRIPEMD160.padLength = 64;\n\n\tRIPEMD160.prototype._update = function update(msg, start) {\n\t  var A = this.h[0];\n\t  var B = this.h[1];\n\t  var C = this.h[2];\n\t  var D = this.h[3];\n\t  var E = this.h[4];\n\t  var Ah = A;\n\t  var Bh = B;\n\t  var Ch = C;\n\t  var Dh = D;\n\t  var Eh = E;\n\t  for (var j = 0; j < 80; j++) {\n\t    var T = sum32$2(\n\t      rotl32$1(\n\t        sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n\t        s[j]),\n\t      E);\n\t    A = E;\n\t    E = D;\n\t    D = rotl32$1(C, 10);\n\t    C = B;\n\t    B = T;\n\t    T = sum32$2(\n\t      rotl32$1(\n\t        sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n\t        sh[j]),\n\t      Eh);\n\t    Ah = Eh;\n\t    Eh = Dh;\n\t    Dh = rotl32$1(Ch, 10);\n\t    Ch = Bh;\n\t    Bh = T;\n\t  }\n\t  T = sum32_3$1(this.h[1], C, Dh);\n\t  this.h[1] = sum32_3$1(this.h[2], D, Eh);\n\t  this.h[2] = sum32_3$1(this.h[3], E, Ah);\n\t  this.h[3] = sum32_3$1(this.h[4], A, Bh);\n\t  this.h[4] = sum32_3$1(this.h[0], B, Ch);\n\t  this.h[0] = T;\n\t};\n\n\tRIPEMD160.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'little');\n\t  else\n\t    return utils.split32(this.h, 'little');\n\t};\n\n\tfunction f(j, x, y, z) {\n\t  if (j <= 15)\n\t    return x ^ y ^ z;\n\t  else if (j <= 31)\n\t    return (x & y) | ((~x) & z);\n\t  else if (j <= 47)\n\t    return (x | (~y)) ^ z;\n\t  else if (j <= 63)\n\t    return (x & z) | (y & (~z));\n\t  else\n\t    return x ^ (y | (~z));\n\t}\n\n\tfunction K(j) {\n\t  if (j <= 15)\n\t    return 0x00000000;\n\t  else if (j <= 31)\n\t    return 0x5a827999;\n\t  else if (j <= 47)\n\t    return 0x6ed9eba1;\n\t  else if (j <= 63)\n\t    return 0x8f1bbcdc;\n\t  else\n\t    return 0xa953fd4e;\n\t}\n\n\tfunction Kh(j) {\n\t  if (j <= 15)\n\t    return 0x50a28be6;\n\t  else if (j <= 31)\n\t    return 0x5c4dd124;\n\t  else if (j <= 47)\n\t    return 0x6d703ef3;\n\t  else if (j <= 63)\n\t    return 0x7a6d76e9;\n\t  else\n\t    return 0x00000000;\n\t}\n\n\tvar r = [\n\t  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n\t  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n\t  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n\t  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n\t];\n\n\tvar rh = [\n\t  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n\t  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n\t  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n\t  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n\t  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n\t];\n\n\tvar s = [\n\t  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n\t  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n\t  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n\t  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n\t  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n\t];\n\n\tvar sh = [\n\t  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n\t  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n\t  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n\t  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n\t  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n\t];\n\n\tvar ripemd = {\n\t\tripemd160: ripemd160\n\t};\n\n\t'use strict';\n\n\n\n\n\tfunction Hmac(hash, key, enc) {\n\t  if (!(this instanceof Hmac))\n\t    return new Hmac(hash, key, enc);\n\t  this.Hash = hash;\n\t  this.blockSize = hash.blockSize / 8;\n\t  this.outSize = hash.outSize / 8;\n\t  this.inner = null;\n\t  this.outer = null;\n\n\t  this._init(utils.toArray(key, enc));\n\t}\n\tvar hmac = Hmac;\n\n\tHmac.prototype._init = function init(key) {\n\t  // Shorten key, if needed\n\t  if (key.length > this.blockSize)\n\t    key = new this.Hash().update(key).digest();\n\t  minimalisticAssert(key.length <= this.blockSize);\n\n\t  // Add padding to key\n\t  for (var i = key.length; i < this.blockSize; i++)\n\t    key.push(0);\n\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x36;\n\t  this.inner = new this.Hash().update(key);\n\n\t  // 0x36 ^ 0x5c = 0x6a\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x6a;\n\t  this.outer = new this.Hash().update(key);\n\t};\n\n\tHmac.prototype.update = function update(msg, enc) {\n\t  this.inner.update(msg, enc);\n\t  return this;\n\t};\n\n\tHmac.prototype.digest = function digest(enc) {\n\t  this.outer.update(this.inner.digest());\n\t  return this.outer.digest(enc);\n\t};\n\n\tvar hash_1 = createCommonjsModule(function (module, exports) {\n\tvar hash = exports;\n\n\thash.utils = utils;\n\thash.common = common;\n\thash.sha = sha;\n\thash.ripemd = ripemd;\n\thash.hmac = hmac;\n\n\t// Proxy hash functions to the main object\n\thash.sha1 = hash.sha.sha1;\n\thash.sha256 = hash.sha.sha256;\n\thash.sha224 = hash.sha.sha224;\n\thash.sha384 = hash.sha.sha384;\n\thash.sha512 = hash.sha.sha512;\n\thash.ripemd160 = hash.ripemd.ripemd160;\n\t});\n\tvar hash_2 = hash_1.hmac;\n\tvar hash_3 = hash_1.ripemd160;\n\tvar hash_4 = hash_1.sha256;\n\tvar hash_5 = hash_1.sha512;\n\n\tvar _version$o = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"sha2/5.0.0-beta.137\";\n\t});\n\n\tvar _version$p = unwrapExports(_version$o);\n\tvar _version_1$c = _version$o.version;\n\n\tvar browser = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar hash = __importStar(hash_1);\n\n\n\n\tvar logger = new lib.Logger(_version$o.version);\n\tvar SupportedAlgorithm;\n\t(function (SupportedAlgorithm) {\n\t    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n\t    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n\t})(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));\n\t;\n\tfunction ripemd160(data) {\n\t    return \"0x\" + (hash.ripemd160().update(lib$1.arrayify(data)).digest(\"hex\"));\n\t}\n\texports.ripemd160 = ripemd160;\n\tfunction sha256(data) {\n\t    return \"0x\" + (hash.sha256().update(lib$1.arrayify(data)).digest(\"hex\"));\n\t}\n\texports.sha256 = sha256;\n\tfunction sha512(data) {\n\t    return \"0x\" + (hash.sha512().update(lib$1.arrayify(data)).digest(\"hex\"));\n\t}\n\texports.sha512 = sha512;\n\tfunction computeHmac(algorithm, key, data) {\n\t    if (!SupportedAlgorithm[algorithm]) {\n\t        logger.throwError(\"unsupported algorithm \" + algorithm, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"hmac\",\n\t            algorithm: algorithm\n\t        });\n\t    }\n\t    return \"0x\" + hash.hmac(hash[algorithm], lib$1.arrayify(key)).update(lib$1.arrayify(data)).digest(\"hex\");\n\t}\n\texports.computeHmac = computeHmac;\n\t});\n\n\tvar browser$1 = unwrapExports(browser);\n\tvar browser_1 = browser.SupportedAlgorithm;\n\tvar browser_2 = browser.ripemd160;\n\tvar browser_3 = browser.sha256;\n\tvar browser_4 = browser.sha512;\n\tvar browser_5 = browser.computeHmac;\n\n\tvar browser$2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tfunction pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n\t    password = lib$1.arrayify(password);\n\t    salt = lib$1.arrayify(salt);\n\t    var hLen;\n\t    var l = 1;\n\t    var DK = new Uint8Array(keylen);\n\t    var block1 = new Uint8Array(salt.length + 4);\n\t    block1.set(salt);\n\t    //salt.copy(block1, 0, 0, salt.length)\n\t    var r;\n\t    var T;\n\t    for (var i = 1; i <= l; i++) {\n\t        //block1.writeUInt32BE(i, salt.length)\n\t        block1[salt.length] = (i >> 24) & 0xff;\n\t        block1[salt.length + 1] = (i >> 16) & 0xff;\n\t        block1[salt.length + 2] = (i >> 8) & 0xff;\n\t        block1[salt.length + 3] = i & 0xff;\n\t        //let U = createHmac(password).update(block1).digest();\n\t        var U = lib$1.arrayify(browser.computeHmac(hashAlgorithm, password, block1));\n\t        if (!hLen) {\n\t            hLen = U.length;\n\t            T = new Uint8Array(hLen);\n\t            l = Math.ceil(keylen / hLen);\n\t            r = keylen - (l - 1) * hLen;\n\t        }\n\t        //U.copy(T, 0, 0, hLen)\n\t        T.set(U);\n\t        for (var j = 1; j < iterations; j++) {\n\t            //U = createHmac(password).update(U).digest();\n\t            U = lib$1.arrayify(browser.computeHmac(hashAlgorithm, password, U));\n\t            for (var k = 0; k < hLen; k++)\n\t                T[k] ^= U[k];\n\t        }\n\t        var destPos = (i - 1) * hLen;\n\t        var len = (i === l ? r : hLen);\n\t        //T.copy(DK, destPos, 0, len)\n\t        DK.set(lib$1.arrayify(T).slice(0, len), destPos);\n\t    }\n\t    return lib$1.hexlify(DK);\n\t}\n\texports.pbkdf2 = pbkdf2;\n\t});\n\n\tvar browser$3 = unwrapExports(browser$2);\n\tvar browser_1$1 = browser$2.pbkdf2;\n\n\tvar version = \"6.5.2\";\n\tvar _package = {\n\t\tversion: version\n\t};\n\n\tvar _package$1 = /*#__PURE__*/Object.freeze({\n\t\tversion: version,\n\t\t'default': _package\n\t});\n\n\tvar utils_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar utils = exports;\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg !== 'string') {\n\t    for (var i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t    return res;\n\t  }\n\t  if (enc === 'hex') {\n\t    msg = msg.replace(/[^a-z0-9]+/ig, '');\n\t    if (msg.length % 2 !== 0)\n\t      msg = '0' + msg;\n\t    for (var i = 0; i < msg.length; i += 2)\n\t      res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t  } else {\n\t    for (var i = 0; i < msg.length; i++) {\n\t      var c = msg.charCodeAt(i);\n\t      var hi = c >> 8;\n\t      var lo = c & 0xff;\n\t      if (hi)\n\t        res.push(hi, lo);\n\t      else\n\t        res.push(lo);\n\t    }\n\t  }\n\t  return res;\n\t}\n\tutils.toArray = toArray;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return '0' + word;\n\t  else\n\t    return word;\n\t}\n\tutils.zero2 = zero2;\n\n\tfunction toHex(msg) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tutils.toHex = toHex;\n\n\tutils.encode = function encode(arr, enc) {\n\t  if (enc === 'hex')\n\t    return toHex(arr);\n\t  else\n\t    return arr;\n\t};\n\t});\n\n\tvar utils_1$1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar utils = exports;\n\n\n\n\n\tutils.assert = minimalisticAssert;\n\tutils.toArray = utils_1.toArray;\n\tutils.zero2 = utils_1.zero2;\n\tutils.toHex = utils_1.toHex;\n\tutils.encode = utils_1.encode;\n\n\t// Represent num in a w-NAF form\n\tfunction getNAF(num, w, bits) {\n\t  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n\t  naf.fill(0);\n\n\t  var ws = 1 << (w + 1);\n\t  var k = num.clone();\n\n\t  for (var i = 0; i < naf.length; i++) {\n\t    var z;\n\t    var mod = k.andln(ws - 1);\n\t    if (k.isOdd()) {\n\t      if (mod > (ws >> 1) - 1)\n\t        z = (ws >> 1) - mod;\n\t      else\n\t        z = mod;\n\t      k.isubn(z);\n\t    } else {\n\t      z = 0;\n\t    }\n\n\t    naf[i] = z;\n\t    k.iushrn(1);\n\t  }\n\n\t  return naf;\n\t}\n\tutils.getNAF = getNAF;\n\n\t// Represent k1, k2 in a Joint Sparse Form\n\tfunction getJSF(k1, k2) {\n\t  var jsf = [\n\t    [],\n\t    []\n\t  ];\n\n\t  k1 = k1.clone();\n\t  k2 = k2.clone();\n\t  var d1 = 0;\n\t  var d2 = 0;\n\t  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\n\t    // First phase\n\t    var m14 = (k1.andln(3) + d1) & 3;\n\t    var m24 = (k2.andln(3) + d2) & 3;\n\t    if (m14 === 3)\n\t      m14 = -1;\n\t    if (m24 === 3)\n\t      m24 = -1;\n\t    var u1;\n\t    if ((m14 & 1) === 0) {\n\t      u1 = 0;\n\t    } else {\n\t      var m8 = (k1.andln(7) + d1) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m24 === 2)\n\t        u1 = -m14;\n\t      else\n\t        u1 = m14;\n\t    }\n\t    jsf[0].push(u1);\n\n\t    var u2;\n\t    if ((m24 & 1) === 0) {\n\t      u2 = 0;\n\t    } else {\n\t      var m8 = (k2.andln(7) + d2) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m14 === 2)\n\t        u2 = -m24;\n\t      else\n\t        u2 = m24;\n\t    }\n\t    jsf[1].push(u2);\n\n\t    // Second phase\n\t    if (2 * d1 === u1 + 1)\n\t      d1 = 1 - d1;\n\t    if (2 * d2 === u2 + 1)\n\t      d2 = 1 - d2;\n\t    k1.iushrn(1);\n\t    k2.iushrn(1);\n\t  }\n\n\t  return jsf;\n\t}\n\tutils.getJSF = getJSF;\n\n\tfunction cachedProperty(obj, name, computer) {\n\t  var key = '_' + name;\n\t  obj.prototype[name] = function cachedProperty() {\n\t    return this[key] !== undefined ? this[key] :\n\t           this[key] = computer.call(this);\n\t  };\n\t}\n\tutils.cachedProperty = cachedProperty;\n\n\tfunction parseBytes(bytes) {\n\t  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n\t                                     bytes;\n\t}\n\tutils.parseBytes = parseBytes;\n\n\tfunction intFromLE(bytes) {\n\t  return new bn(bytes, 'hex', 'le');\n\t}\n\tutils.intFromLE = intFromLE;\n\t});\n\n\tvar brorand = function(length) { var result = new Uint8Array(length); (commonjsGlobal.crypto || commonjsGlobal.msCrypto).getRandomValues(result); return result; };\n\n\t'use strict';\n\n\n\n\tvar getNAF = utils_1$1.getNAF;\n\tvar getJSF = utils_1$1.getJSF;\n\tvar assert$1 = utils_1$1.assert;\n\n\tfunction BaseCurve(type, conf) {\n\t  this.type = type;\n\t  this.p = new bn(conf.p, 16);\n\n\t  // Use Montgomery, when there is no fast reduction for the prime\n\t  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);\n\n\t  // Useful for many curves\n\t  this.zero = new bn(0).toRed(this.red);\n\t  this.one = new bn(1).toRed(this.red);\n\t  this.two = new bn(2).toRed(this.red);\n\n\t  // Curve configuration, optional\n\t  this.n = conf.n && new bn(conf.n, 16);\n\t  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n\t  // Temporary arrays\n\t  this._wnafT1 = new Array(4);\n\t  this._wnafT2 = new Array(4);\n\t  this._wnafT3 = new Array(4);\n\t  this._wnafT4 = new Array(4);\n\n\t  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n\t  // Generalized Greg Maxwell's trick\n\t  var adjustCount = this.n && this.p.div(this.n);\n\t  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n\t    this.redN = null;\n\t  } else {\n\t    this._maxwellTrick = true;\n\t    this.redN = this.n.toRed(this.red);\n\t  }\n\t}\n\tvar base = BaseCurve;\n\n\tBaseCurve.prototype.point = function point() {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBaseCurve.prototype.validate = function validate() {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n\t  assert$1(p.precomputed);\n\t  var doubles = p._getDoubles();\n\n\t  var naf = getNAF(k, 1, this._bitLength);\n\t  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n\t  I /= 3;\n\n\t  // Translate into more windowed form\n\t  var repr = [];\n\t  for (var j = 0; j < naf.length; j += doubles.step) {\n\t    var nafW = 0;\n\t    for (var k = j + doubles.step - 1; k >= j; k--)\n\t      nafW = (nafW << 1) + naf[k];\n\t    repr.push(nafW);\n\t  }\n\n\t  var a = this.jpoint(null, null, null);\n\t  var b = this.jpoint(null, null, null);\n\t  for (var i = I; i > 0; i--) {\n\t    for (var j = 0; j < repr.length; j++) {\n\t      var nafW = repr[j];\n\t      if (nafW === i)\n\t        b = b.mixedAdd(doubles.points[j]);\n\t      else if (nafW === -i)\n\t        b = b.mixedAdd(doubles.points[j].neg());\n\t    }\n\t    a = a.add(b);\n\t  }\n\t  return a.toP();\n\t};\n\n\tBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n\t  var w = 4;\n\n\t  // Precompute window\n\t  var nafPoints = p._getNAFPoints(w);\n\t  w = nafPoints.wnd;\n\t  var wnd = nafPoints.points;\n\n\t  // Get NAF form\n\t  var naf = getNAF(k, w, this._bitLength);\n\n\t  // Add `this`*(N+1) for every w-NAF index\n\t  var acc = this.jpoint(null, null, null);\n\t  for (var i = naf.length - 1; i >= 0; i--) {\n\t    // Count zeroes\n\t    for (var k = 0; i >= 0 && naf[i] === 0; i--)\n\t      k++;\n\t    if (i >= 0)\n\t      k++;\n\t    acc = acc.dblp(k);\n\n\t    if (i < 0)\n\t      break;\n\t    var z = naf[i];\n\t    assert$1(z !== 0);\n\t    if (p.type === 'affine') {\n\t      // J +- P\n\t      if (z > 0)\n\t        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n\t    } else {\n\t      // J +- J\n\t      if (z > 0)\n\t        acc = acc.add(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n\t    }\n\t  }\n\t  return p.type === 'affine' ? acc.toP() : acc;\n\t};\n\n\tBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n\t                                                       points,\n\t                                                       coeffs,\n\t                                                       len,\n\t                                                       jacobianResult) {\n\t  var wndWidth = this._wnafT1;\n\t  var wnd = this._wnafT2;\n\t  var naf = this._wnafT3;\n\n\t  // Fill all arrays\n\t  var max = 0;\n\t  for (var i = 0; i < len; i++) {\n\t    var p = points[i];\n\t    var nafPoints = p._getNAFPoints(defW);\n\t    wndWidth[i] = nafPoints.wnd;\n\t    wnd[i] = nafPoints.points;\n\t  }\n\n\t  // Comb small window NAFs\n\t  for (var i = len - 1; i >= 1; i -= 2) {\n\t    var a = i - 1;\n\t    var b = i;\n\t    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n\t      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n\t      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n\t      max = Math.max(naf[a].length, max);\n\t      max = Math.max(naf[b].length, max);\n\t      continue;\n\t    }\n\n\t    var comb = [\n\t      points[a], /* 1 */\n\t      null, /* 3 */\n\t      null, /* 5 */\n\t      points[b] /* 7 */\n\t    ];\n\n\t    // Try to avoid Projective points, if possible\n\t    if (points[a].y.cmp(points[b].y) === 0) {\n\t      comb[1] = points[a].add(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].add(points[b].neg());\n\t    } else {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    }\n\n\t    var index = [\n\t      -3, /* -1 -1 */\n\t      -1, /* -1 0 */\n\t      -5, /* -1 1 */\n\t      -7, /* 0 -1 */\n\t      0, /* 0 0 */\n\t      7, /* 0 1 */\n\t      5, /* 1 -1 */\n\t      1, /* 1 0 */\n\t      3  /* 1 1 */\n\t    ];\n\n\t    var jsf = getJSF(coeffs[a], coeffs[b]);\n\t    max = Math.max(jsf[0].length, max);\n\t    naf[a] = new Array(max);\n\t    naf[b] = new Array(max);\n\t    for (var j = 0; j < max; j++) {\n\t      var ja = jsf[0][j] | 0;\n\t      var jb = jsf[1][j] | 0;\n\n\t      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n\t      naf[b][j] = 0;\n\t      wnd[a] = comb;\n\t    }\n\t  }\n\n\t  var acc = this.jpoint(null, null, null);\n\t  var tmp = this._wnafT4;\n\t  for (var i = max; i >= 0; i--) {\n\t    var k = 0;\n\n\t    while (i >= 0) {\n\t      var zero = true;\n\t      for (var j = 0; j < len; j++) {\n\t        tmp[j] = naf[j][i] | 0;\n\t        if (tmp[j] !== 0)\n\t          zero = false;\n\t      }\n\t      if (!zero)\n\t        break;\n\t      k++;\n\t      i--;\n\t    }\n\t    if (i >= 0)\n\t      k++;\n\t    acc = acc.dblp(k);\n\t    if (i < 0)\n\t      break;\n\n\t    for (var j = 0; j < len; j++) {\n\t      var z = tmp[j];\n\t      var p;\n\t      if (z === 0)\n\t        continue;\n\t      else if (z > 0)\n\t        p = wnd[j][(z - 1) >> 1];\n\t      else if (z < 0)\n\t        p = wnd[j][(-z - 1) >> 1].neg();\n\n\t      if (p.type === 'affine')\n\t        acc = acc.mixedAdd(p);\n\t      else\n\t        acc = acc.add(p);\n\t    }\n\t  }\n\t  // Zeroify references\n\t  for (var i = 0; i < len; i++)\n\t    wnd[i] = null;\n\n\t  if (jacobianResult)\n\t    return acc;\n\t  else\n\t    return acc.toP();\n\t};\n\n\tfunction BasePoint(curve, type) {\n\t  this.curve = curve;\n\t  this.type = type;\n\t  this.precomputed = null;\n\t}\n\tBaseCurve.BasePoint = BasePoint;\n\n\tBasePoint.prototype.eq = function eq(/*other*/) {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBasePoint.prototype.validate = function validate() {\n\t  return this.curve.validate(this);\n\t};\n\n\tBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n\t  bytes = utils_1$1.toArray(bytes, enc);\n\n\t  var len = this.p.byteLength();\n\n\t  // uncompressed, hybrid-odd, hybrid-even\n\t  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n\t      bytes.length - 1 === 2 * len) {\n\t    if (bytes[0] === 0x06)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 0);\n\t    else if (bytes[0] === 0x07)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n\t    var res =  this.point(bytes.slice(1, 1 + len),\n\t                          bytes.slice(1 + len, 1 + 2 * len));\n\n\t    return res;\n\t  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n\t              bytes.length - 1 === len) {\n\t    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n\t  }\n\t  throw new Error('Unknown point format');\n\t};\n\n\tBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n\t  return this.encode(enc, true);\n\t};\n\n\tBasePoint.prototype._encode = function _encode(compact) {\n\t  var len = this.curve.p.byteLength();\n\t  var x = this.getX().toArray('be', len);\n\n\t  if (compact)\n\t    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n\t  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;\n\t};\n\n\tBasePoint.prototype.encode = function encode(enc, compact) {\n\t  return utils_1$1.encode(this._encode(compact), enc);\n\t};\n\n\tBasePoint.prototype.precompute = function precompute(power) {\n\t  if (this.precomputed)\n\t    return this;\n\n\t  var precomputed = {\n\t    doubles: null,\n\t    naf: null,\n\t    beta: null\n\t  };\n\t  precomputed.naf = this._getNAFPoints(8);\n\t  precomputed.doubles = this._getDoubles(4, power);\n\t  precomputed.beta = this._getBeta();\n\t  this.precomputed = precomputed;\n\n\t  return this;\n\t};\n\n\tBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n\t  if (!this.precomputed)\n\t    return false;\n\n\t  var doubles = this.precomputed.doubles;\n\t  if (!doubles)\n\t    return false;\n\n\t  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n\t};\n\n\tBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n\t  if (this.precomputed && this.precomputed.doubles)\n\t    return this.precomputed.doubles;\n\n\t  var doubles = [ this ];\n\t  var acc = this;\n\t  for (var i = 0; i < power; i += step) {\n\t    for (var j = 0; j < step; j++)\n\t      acc = acc.dbl();\n\t    doubles.push(acc);\n\t  }\n\t  return {\n\t    step: step,\n\t    points: doubles\n\t  };\n\t};\n\n\tBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n\t  if (this.precomputed && this.precomputed.naf)\n\t    return this.precomputed.naf;\n\n\t  var res = [ this ];\n\t  var max = (1 << wnd) - 1;\n\t  var dbl = max === 1 ? null : this.dbl();\n\t  for (var i = 1; i < max; i++)\n\t    res[i] = res[i - 1].add(dbl);\n\t  return {\n\t    wnd: wnd,\n\t    points: res\n\t  };\n\t};\n\n\tBasePoint.prototype._getBeta = function _getBeta() {\n\t  return null;\n\t};\n\n\tBasePoint.prototype.dblp = function dblp(k) {\n\t  var r = this;\n\t  for (var i = 0; i < k; i++)\n\t    r = r.dbl();\n\t  return r;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\tvar assert$2 = utils_1$1.assert;\n\n\tfunction ShortCurve(conf) {\n\t  base.call(this, 'short', conf);\n\n\t  this.a = new bn(conf.a, 16).toRed(this.red);\n\t  this.b = new bn(conf.b, 16).toRed(this.red);\n\t  this.tinv = this.two.redInvm();\n\n\t  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n\t  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n\t  // If the curve is endomorphic, precalculate beta and lambda\n\t  this.endo = this._getEndomorphism(conf);\n\t  this._endoWnafT1 = new Array(4);\n\t  this._endoWnafT2 = new Array(4);\n\t}\n\tinherits_browser(ShortCurve, base);\n\tvar short_1 = ShortCurve;\n\n\tShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n\t  // No efficient endomorphism\n\t  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n\t    return;\n\n\t  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n\t  var beta;\n\t  var lambda;\n\t  if (conf.beta) {\n\t    beta = new bn(conf.beta, 16).toRed(this.red);\n\t  } else {\n\t    var betas = this._getEndoRoots(this.p);\n\t    // Choose the smallest beta\n\t    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n\t    beta = beta.toRed(this.red);\n\t  }\n\t  if (conf.lambda) {\n\t    lambda = new bn(conf.lambda, 16);\n\t  } else {\n\t    // Choose the lambda that is matching selected beta\n\t    var lambdas = this._getEndoRoots(this.n);\n\t    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n\t      lambda = lambdas[0];\n\t    } else {\n\t      lambda = lambdas[1];\n\t      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n\t    }\n\t  }\n\n\t  // Get basis vectors, used for balanced length-two representation\n\t  var basis;\n\t  if (conf.basis) {\n\t    basis = conf.basis.map(function(vec) {\n\t      return {\n\t        a: new bn(vec.a, 16),\n\t        b: new bn(vec.b, 16)\n\t      };\n\t    });\n\t  } else {\n\t    basis = this._getEndoBasis(lambda);\n\t  }\n\n\t  return {\n\t    beta: beta,\n\t    lambda: lambda,\n\t    basis: basis\n\t  };\n\t};\n\n\tShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n\t  // Find roots of for x^2 + x + 1 in F\n\t  // Root = (-1 +- Sqrt(-3)) / 2\n\t  //\n\t  var red = num === this.p ? this.red : bn.mont(num);\n\t  var tinv = new bn(2).toRed(red).redInvm();\n\t  var ntinv = tinv.redNeg();\n\n\t  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n\t  var l1 = ntinv.redAdd(s).fromRed();\n\t  var l2 = ntinv.redSub(s).fromRed();\n\t  return [ l1, l2 ];\n\t};\n\n\tShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n\t  // aprxSqrt >= sqrt(this.n)\n\t  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n\t  // 3.74\n\t  // Run EGCD, until r(L + 1) < aprxSqrt\n\t  var u = lambda;\n\t  var v = this.n.clone();\n\t  var x1 = new bn(1);\n\t  var y1 = new bn(0);\n\t  var x2 = new bn(0);\n\t  var y2 = new bn(1);\n\n\t  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n\t  var a0;\n\t  var b0;\n\t  // First vector\n\t  var a1;\n\t  var b1;\n\t  // Second vector\n\t  var a2;\n\t  var b2;\n\n\t  var prevR;\n\t  var i = 0;\n\t  var r;\n\t  var x;\n\t  while (u.cmpn(0) !== 0) {\n\t    var q = v.div(u);\n\t    r = v.sub(q.mul(u));\n\t    x = x2.sub(q.mul(x1));\n\t    var y = y2.sub(q.mul(y1));\n\n\t    if (!a1 && r.cmp(aprxSqrt) < 0) {\n\t      a0 = prevR.neg();\n\t      b0 = x1;\n\t      a1 = r.neg();\n\t      b1 = x;\n\t    } else if (a1 && ++i === 2) {\n\t      break;\n\t    }\n\t    prevR = r;\n\n\t    v = u;\n\t    u = r;\n\t    x2 = x1;\n\t    x1 = x;\n\t    y2 = y1;\n\t    y1 = y;\n\t  }\n\t  a2 = r.neg();\n\t  b2 = x;\n\n\t  var len1 = a1.sqr().add(b1.sqr());\n\t  var len2 = a2.sqr().add(b2.sqr());\n\t  if (len2.cmp(len1) >= 0) {\n\t    a2 = a0;\n\t    b2 = b0;\n\t  }\n\n\t  // Normalize signs\n\t  if (a1.negative) {\n\t    a1 = a1.neg();\n\t    b1 = b1.neg();\n\t  }\n\t  if (a2.negative) {\n\t    a2 = a2.neg();\n\t    b2 = b2.neg();\n\t  }\n\n\t  return [\n\t    { a: a1, b: b1 },\n\t    { a: a2, b: b2 }\n\t  ];\n\t};\n\n\tShortCurve.prototype._endoSplit = function _endoSplit(k) {\n\t  var basis = this.endo.basis;\n\t  var v1 = basis[0];\n\t  var v2 = basis[1];\n\n\t  var c1 = v2.b.mul(k).divRound(this.n);\n\t  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n\t  var p1 = c1.mul(v1.a);\n\t  var p2 = c2.mul(v2.a);\n\t  var q1 = c1.mul(v1.b);\n\t  var q2 = c2.mul(v2.b);\n\n\t  // Calculate answer\n\t  var k1 = k.sub(p1).sub(p2);\n\t  var k2 = q1.add(q2).neg();\n\t  return { k1: k1, k2: k2 };\n\t};\n\n\tShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n\t  x = new bn(x, 16);\n\t  if (!x.red)\n\t    x = x.toRed(this.red);\n\n\t  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n\t  var y = y2.redSqrt();\n\t  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n\t    throw new Error('invalid point');\n\n\t  // XXX Is there any way to tell if the number is odd without converting it\n\t  // to non-red form?\n\t  var isOdd = y.fromRed().isOdd();\n\t  if (odd && !isOdd || !odd && isOdd)\n\t    y = y.redNeg();\n\n\t  return this.point(x, y);\n\t};\n\n\tShortCurve.prototype.validate = function validate(point) {\n\t  if (point.inf)\n\t    return true;\n\n\t  var x = point.x;\n\t  var y = point.y;\n\n\t  var ax = this.a.redMul(x);\n\t  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n\t  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n\t};\n\n\tShortCurve.prototype._endoWnafMulAdd =\n\t    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n\t  var npoints = this._endoWnafT1;\n\t  var ncoeffs = this._endoWnafT2;\n\t  for (var i = 0; i < points.length; i++) {\n\t    var split = this._endoSplit(coeffs[i]);\n\t    var p = points[i];\n\t    var beta = p._getBeta();\n\n\t    if (split.k1.negative) {\n\t      split.k1.ineg();\n\t      p = p.neg(true);\n\t    }\n\t    if (split.k2.negative) {\n\t      split.k2.ineg();\n\t      beta = beta.neg(true);\n\t    }\n\n\t    npoints[i * 2] = p;\n\t    npoints[i * 2 + 1] = beta;\n\t    ncoeffs[i * 2] = split.k1;\n\t    ncoeffs[i * 2 + 1] = split.k2;\n\t  }\n\t  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n\t  // Clean-up references to points and coefficients\n\t  for (var j = 0; j < i * 2; j++) {\n\t    npoints[j] = null;\n\t    ncoeffs[j] = null;\n\t  }\n\t  return res;\n\t};\n\n\tfunction Point(curve, x, y, isRed) {\n\t  base.BasePoint.call(this, curve, 'affine');\n\t  if (x === null && y === null) {\n\t    this.x = null;\n\t    this.y = null;\n\t    this.inf = true;\n\t  } else {\n\t    this.x = new bn(x, 16);\n\t    this.y = new bn(y, 16);\n\t    // Force redgomery representation when loading from JSON\n\t    if (isRed) {\n\t      this.x.forceRed(this.curve.red);\n\t      this.y.forceRed(this.curve.red);\n\t    }\n\t    if (!this.x.red)\n\t      this.x = this.x.toRed(this.curve.red);\n\t    if (!this.y.red)\n\t      this.y = this.y.toRed(this.curve.red);\n\t    this.inf = false;\n\t  }\n\t}\n\tinherits_browser(Point, base.BasePoint);\n\n\tShortCurve.prototype.point = function point(x, y, isRed) {\n\t  return new Point(this, x, y, isRed);\n\t};\n\n\tShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n\t  return Point.fromJSON(this, obj, red);\n\t};\n\n\tPoint.prototype._getBeta = function _getBeta() {\n\t  if (!this.curve.endo)\n\t    return;\n\n\t  var pre = this.precomputed;\n\t  if (pre && pre.beta)\n\t    return pre.beta;\n\n\t  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n\t  if (pre) {\n\t    var curve = this.curve;\n\t    var endoMul = function(p) {\n\t      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n\t    };\n\t    pre.beta = beta;\n\t    beta.precomputed = {\n\t      beta: null,\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(endoMul)\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(endoMul)\n\t      }\n\t    };\n\t  }\n\t  return beta;\n\t};\n\n\tPoint.prototype.toJSON = function toJSON() {\n\t  if (!this.precomputed)\n\t    return [ this.x, this.y ];\n\n\t  return [ this.x, this.y, this.precomputed && {\n\t    doubles: this.precomputed.doubles && {\n\t      step: this.precomputed.doubles.step,\n\t      points: this.precomputed.doubles.points.slice(1)\n\t    },\n\t    naf: this.precomputed.naf && {\n\t      wnd: this.precomputed.naf.wnd,\n\t      points: this.precomputed.naf.points.slice(1)\n\t    }\n\t  } ];\n\t};\n\n\tPoint.fromJSON = function fromJSON(curve, obj, red) {\n\t  if (typeof obj === 'string')\n\t    obj = JSON.parse(obj);\n\t  var res = curve.point(obj[0], obj[1], red);\n\t  if (!obj[2])\n\t    return res;\n\n\t  function obj2point(obj) {\n\t    return curve.point(obj[0], obj[1], red);\n\t  }\n\n\t  var pre = obj[2];\n\t  res.precomputed = {\n\t    beta: null,\n\t    doubles: pre.doubles && {\n\t      step: pre.doubles.step,\n\t      points: [ res ].concat(pre.doubles.points.map(obj2point))\n\t    },\n\t    naf: pre.naf && {\n\t      wnd: pre.naf.wnd,\n\t      points: [ res ].concat(pre.naf.points.map(obj2point))\n\t    }\n\t  };\n\t  return res;\n\t};\n\n\tPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return '<EC Point Infinity>';\n\t  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n\t      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n\t};\n\n\tPoint.prototype.isInfinity = function isInfinity() {\n\t  return this.inf;\n\t};\n\n\tPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.inf)\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.inf)\n\t    return this;\n\n\t  // P + P = 2P\n\t  if (this.eq(p))\n\t    return this.dbl();\n\n\t  // P + (-P) = O\n\t  if (this.neg().eq(p))\n\t    return this.curve.point(null, null);\n\n\t  // P + Q = O\n\t  if (this.x.cmp(p.x) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var c = this.y.redSub(p.y);\n\t  if (c.cmpn(0) !== 0)\n\t    c = c.redMul(this.x.redSub(p.x).redInvm());\n\t  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.dbl = function dbl() {\n\t  if (this.inf)\n\t    return this;\n\n\t  // 2P = O\n\t  var ys1 = this.y.redAdd(this.y);\n\t  if (ys1.cmpn(0) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var a = this.curve.a;\n\n\t  var x2 = this.x.redSqr();\n\t  var dyinv = ys1.redInvm();\n\t  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n\t  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.getX = function getX() {\n\t  return this.x.fromRed();\n\t};\n\n\tPoint.prototype.getY = function getY() {\n\t  return this.y.fromRed();\n\t};\n\n\tPoint.prototype.mul = function mul(k) {\n\t  k = new bn(k, 16);\n\t  if (this.isInfinity())\n\t    return this;\n\t  else if (this._hasDoubles(k))\n\t    return this.curve._fixedNafMul(this, k);\n\t  else if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n\t  else\n\t    return this.curve._wnafMul(this, k);\n\t};\n\n\tPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n\t};\n\n\tPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs, true);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n\t};\n\n\tPoint.prototype.eq = function eq(p) {\n\t  return this === p ||\n\t         this.inf === p.inf &&\n\t             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n\t};\n\n\tPoint.prototype.neg = function neg(_precompute) {\n\t  if (this.inf)\n\t    return this;\n\n\t  var res = this.curve.point(this.x, this.y.redNeg());\n\t  if (_precompute && this.precomputed) {\n\t    var pre = this.precomputed;\n\t    var negate = function(p) {\n\t      return p.neg();\n\t    };\n\t    res.precomputed = {\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(negate)\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(negate)\n\t      }\n\t    };\n\t  }\n\t  return res;\n\t};\n\n\tPoint.prototype.toJ = function toJ() {\n\t  if (this.inf)\n\t    return this.curve.jpoint(null, null, null);\n\n\t  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n\t  return res;\n\t};\n\n\tfunction JPoint(curve, x, y, z) {\n\t  base.BasePoint.call(this, curve, 'jacobian');\n\t  if (x === null && y === null && z === null) {\n\t    this.x = this.curve.one;\n\t    this.y = this.curve.one;\n\t    this.z = new bn(0);\n\t  } else {\n\t    this.x = new bn(x, 16);\n\t    this.y = new bn(y, 16);\n\t    this.z = new bn(z, 16);\n\t  }\n\t  if (!this.x.red)\n\t    this.x = this.x.toRed(this.curve.red);\n\t  if (!this.y.red)\n\t    this.y = this.y.toRed(this.curve.red);\n\t  if (!this.z.red)\n\t    this.z = this.z.toRed(this.curve.red);\n\n\t  this.zOne = this.z === this.curve.one;\n\t}\n\tinherits_browser(JPoint, base.BasePoint);\n\n\tShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n\t  return new JPoint(this, x, y, z);\n\t};\n\n\tJPoint.prototype.toP = function toP() {\n\t  if (this.isInfinity())\n\t    return this.curve.point(null, null);\n\n\t  var zinv = this.z.redInvm();\n\t  var zinv2 = zinv.redSqr();\n\t  var ax = this.x.redMul(zinv2);\n\t  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n\t  return this.curve.point(ax, ay);\n\t};\n\n\tJPoint.prototype.neg = function neg() {\n\t  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n\t};\n\n\tJPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 12M + 4S + 7A\n\t  var pz2 = p.z.redSqr();\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x.redMul(pz2);\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y.redMul(pz2.redMul(p.z));\n\t  var s2 = p.y.redMul(z2.redMul(this.z));\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(p.z).redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mixedAdd = function mixedAdd(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p.toJ();\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 8M + 3S + 7A\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x;\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y;\n\t  var s2 = p.y.redMul(z2).redMul(this.z);\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.dblp = function dblp(pow) {\n\t  if (pow === 0)\n\t    return this;\n\t  if (this.isInfinity())\n\t    return this;\n\t  if (!pow)\n\t    return this.dbl();\n\n\t  if (this.curve.zeroA || this.curve.threeA) {\n\t    var r = this;\n\t    for (var i = 0; i < pow; i++)\n\t      r = r.dbl();\n\t    return r;\n\t  }\n\n\t  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n\t  // N = 1 => 6M + 6S + 9A\n\t  var a = this.curve.a;\n\t  var tinv = this.curve.tinv;\n\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  // Reuse results\n\t  var jyd = jy.redAdd(jy);\n\t  for (var i = 0; i < pow; i++) {\n\t    var jx2 = jx.redSqr();\n\t    var jyd2 = jyd.redSqr();\n\t    var jyd4 = jyd2.redSqr();\n\t    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t    var t1 = jx.redMul(jyd2);\n\t    var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t    var t2 = t1.redISub(nx);\n\t    var dny = c.redMul(t2);\n\t    dny = dny.redIAdd(dny).redISub(jyd4);\n\t    var nz = jyd.redMul(jz);\n\t    if (i + 1 < pow)\n\t      jz4 = jz4.redMul(jyd4);\n\n\t    jx = nx;\n\t    jz = nz;\n\t    jyd = dny;\n\t  }\n\n\t  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n\t};\n\n\tJPoint.prototype.dbl = function dbl() {\n\t  if (this.isInfinity())\n\t    return this;\n\n\t  if (this.curve.zeroA)\n\t    return this._zeroDbl();\n\t  else if (this.curve.threeA)\n\t    return this._threeDbl();\n\t  else\n\t    return this._dbl();\n\t};\n\n\tJPoint.prototype._zeroDbl = function _zeroDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 14A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a; a = 0\n\t    var m = xx.redAdd(xx).redIAdd(xx);\n\t    // T = M ^ 2 - 2*S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\n\t    // 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2*Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-dbl-2009-l\n\t    // 2M + 5S + 13A\n\n\t    // A = X1^2\n\t    var a = this.x.redSqr();\n\t    // B = Y1^2\n\t    var b = this.y.redSqr();\n\t    // C = B^2\n\t    var c = b.redSqr();\n\t    // D = 2 * ((X1 + B)^2 - A - C)\n\t    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n\t    d = d.redIAdd(d);\n\t    // E = 3 * A\n\t    var e = a.redAdd(a).redIAdd(a);\n\t    // F = E^2\n\t    var f = e.redSqr();\n\n\t    // 8 * C\n\t    var c8 = c.redIAdd(c);\n\t    c8 = c8.redIAdd(c8);\n\t    c8 = c8.redIAdd(c8);\n\n\t    // X3 = F - 2 * D\n\t    nx = f.redISub(d).redISub(d);\n\t    // Y3 = E * (D - X3) - 8 * C\n\t    ny = e.redMul(d.redISub(nx)).redISub(c8);\n\t    // Z3 = 2 * Y1 * Z1\n\t    nz = this.y.redMul(this.z);\n\t    nz = nz.redIAdd(nz);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._threeDbl = function _threeDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 15A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a\n\t    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n\t    // T = M^2 - 2 * S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2 * Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n\t    // 3M + 5S\n\n\t    // delta = Z1^2\n\t    var delta = this.z.redSqr();\n\t    // gamma = Y1^2\n\t    var gamma = this.y.redSqr();\n\t    // beta = X1 * gamma\n\t    var beta = this.x.redMul(gamma);\n\t    // alpha = 3 * (X1 - delta) * (X1 + delta)\n\t    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n\t    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n\t    // X3 = alpha^2 - 8 * beta\n\t    var beta4 = beta.redIAdd(beta);\n\t    beta4 = beta4.redIAdd(beta4);\n\t    var beta8 = beta4.redAdd(beta4);\n\t    nx = alpha.redSqr().redISub(beta8);\n\t    // Z3 = (Y1 + Z1)^2 - gamma - delta\n\t    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n\t    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n\t    var ggamma8 = gamma.redSqr();\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._dbl = function _dbl() {\n\t  var a = this.curve.a;\n\n\t  // 4M + 6S + 10A\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  var jx2 = jx.redSqr();\n\t  var jy2 = jy.redSqr();\n\n\t  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t  var jxd4 = jx.redAdd(jx);\n\t  jxd4 = jxd4.redIAdd(jxd4);\n\t  var t1 = jxd4.redMul(jy2);\n\t  var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t  var t2 = t1.redISub(nx);\n\n\t  var jyd8 = jy2.redSqr();\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  var ny = c.redMul(t2).redISub(jyd8);\n\t  var nz = jy.redAdd(jy).redMul(jz);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.trpl = function trpl() {\n\t  if (!this.curve.zeroA)\n\t    return this.dbl().add(this);\n\n\t  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n\t  // 5M + 10S + ...\n\n\t  // XX = X1^2\n\t  var xx = this.x.redSqr();\n\t  // YY = Y1^2\n\t  var yy = this.y.redSqr();\n\t  // ZZ = Z1^2\n\t  var zz = this.z.redSqr();\n\t  // YYYY = YY^2\n\t  var yyyy = yy.redSqr();\n\t  // M = 3 * XX + a * ZZ2; a = 0\n\t  var m = xx.redAdd(xx).redIAdd(xx);\n\t  // MM = M^2\n\t  var mm = m.redSqr();\n\t  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n\t  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t  e = e.redIAdd(e);\n\t  e = e.redAdd(e).redIAdd(e);\n\t  e = e.redISub(mm);\n\t  // EE = E^2\n\t  var ee = e.redSqr();\n\t  // T = 16*YYYY\n\t  var t = yyyy.redIAdd(yyyy);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  // U = (M + E)^2 - MM - EE - T\n\t  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n\t  // X3 = 4 * (X1 * EE - 4 * YY * U)\n\t  var yyu4 = yy.redMul(u);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  var nx = this.x.redMul(ee).redISub(yyu4);\n\t  nx = nx.redIAdd(nx);\n\t  nx = nx.redIAdd(nx);\n\t  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n\t  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  // Z3 = (Z1 + E)^2 - ZZ - EE\n\t  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mul = function mul(k, kbase) {\n\t  k = new bn(k, kbase);\n\n\t  return this.curve._wnafMul(this, k);\n\t};\n\n\tJPoint.prototype.eq = function eq(p) {\n\t  if (p.type === 'affine')\n\t    return this.eq(p.toJ());\n\n\t  if (this === p)\n\t    return true;\n\n\t  // x1 * z2^2 == x2 * z1^2\n\t  var z2 = this.z.redSqr();\n\t  var pz2 = p.z.redSqr();\n\t  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n\t    return false;\n\n\t  // y1 * z2^3 == y2 * z1^3\n\t  var z3 = z2.redMul(this.z);\n\t  var pz3 = pz2.redMul(p.z);\n\t  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n\t};\n\n\tJPoint.prototype.eqXToP = function eqXToP(x) {\n\t  var zs = this.z.redSqr();\n\t  var rx = x.toRed(this.curve.red).redMul(zs);\n\t  if (this.x.cmp(rx) === 0)\n\t    return true;\n\n\t  var xc = x.clone();\n\t  var t = this.curve.redN.redMul(zs);\n\t  for (;;) {\n\t    xc.iadd(this.curve.n);\n\t    if (xc.cmp(this.curve.p) >= 0)\n\t      return false;\n\n\t    rx.redIAdd(t);\n\t    if (this.x.cmp(rx) === 0)\n\t      return true;\n\t  }\n\t};\n\n\tJPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return '<EC JPoint Infinity>';\n\t  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n\t      ' y: ' + this.y.toString(16, 2) +\n\t      ' z: ' + this.z.toString(16, 2) + '>';\n\t};\n\n\tJPoint.prototype.isInfinity = function isInfinity() {\n\t  // XXX This code assumes that zero is always zero in red\n\t  return this.z.cmpn(0) === 0;\n\t};\n\n\tvar mont = {};\n\n\tvar edwards = {};\n\n\tvar curve_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar curve = exports;\n\n\tcurve.base = base;\n\tcurve.short = short_1;\n\tcurve.mont = mont;\n\tcurve.edwards = edwards;\n\t});\n\n\tvar secp256k1 = undefined;\n\n\tvar curves_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar curves = exports;\n\n\n\n\n\n\tvar assert = utils_1$1.assert;\n\n\tfunction PresetCurve(options) {\n\t  if (options.type === 'short')\n\t    this.curve = new curve_1.short(options);\n\t  else if (options.type === 'edwards')\n\t    this.curve = new curve_1.edwards(options);\n\t  else\n\t    this.curve = new curve_1.mont(options);\n\t  this.g = this.curve.g;\n\t  this.n = this.curve.n;\n\t  this.hash = options.hash;\n\n\t  assert(this.g.validate(), 'Invalid curve');\n\t  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n\t}\n\tcurves.PresetCurve = PresetCurve;\n\n\tfunction defineCurve(name, options) {\n\t  Object.defineProperty(curves, name, {\n\t    configurable: true,\n\t    enumerable: true,\n\t    get: function() {\n\t      var curve = new PresetCurve(options);\n\t      Object.defineProperty(curves, name, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value: curve\n\t      });\n\t      return curve;\n\t    }\n\t  });\n\t}\n\n\tdefineCurve('p192', {\n\t  type: 'short',\n\t  prime: 'p192',\n\t  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n\t  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n\t  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n\t  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n\t    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'\n\t  ]\n\t});\n\n\tdefineCurve('p224', {\n\t  type: 'short',\n\t  prime: 'p224',\n\t  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n\t  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n\t  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n\t  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n\t    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'\n\t  ]\n\t});\n\n\tdefineCurve('p256', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n\t  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n\t  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n\t  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n\t    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'\n\t  ]\n\t});\n\n\tdefineCurve('p384', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'fffffffe ffffffff 00000000 00000000 ffffffff',\n\t  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'fffffffe ffffffff 00000000 00000000 fffffffc',\n\t  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n\t     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n\t  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n\t     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n\t  hash: hash_1.sha384,\n\t  gRed: false,\n\t  g: [\n\t    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n\t    '5502f25d bf55296c 3a545e38 72760ab7',\n\t    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n\t    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'\n\t  ]\n\t});\n\n\tdefineCurve('p521', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n\t  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n\t  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n\t     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n\t     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n\t  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n\t     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n\t  hash: hash_1.sha512,\n\t  gRed: false,\n\t  g: [\n\t    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n\t    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n\t    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n\t    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n\t    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n\t    '3fad0761 353c7086 a272c240 88be9476 9fd16650'\n\t  ]\n\t});\n\n\tdefineCurve('curve25519', {\n\t  type: 'mont',\n\t  prime: 'p25519',\n\t  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n\t  a: '76d06',\n\t  b: '1',\n\t  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '9'\n\t  ]\n\t});\n\n\tdefineCurve('ed25519', {\n\t  type: 'edwards',\n\t  prime: 'p25519',\n\t  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n\t  a: '-1',\n\t  c: '1',\n\t  // -121665 * (121666^(-1)) (mod P)\n\t  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n\t  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n\t    // 4/5\n\t    '6666666666666666666666666666666666666666666666666666666666666658'\n\t  ]\n\t});\n\n\tvar pre;\n\ttry {\n\t  pre = secp256k1;\n\t} catch (e) {\n\t  pre = undefined;\n\t}\n\n\tdefineCurve('secp256k1', {\n\t  type: 'short',\n\t  prime: 'k256',\n\t  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n\t  a: '0',\n\t  b: '7',\n\t  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n\t  h: '1',\n\t  hash: hash_1.sha256,\n\n\t  // Precomputed endomorphism\n\t  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n\t  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n\t  basis: [\n\t    {\n\t      a: '3086d221a7d46bcde86c90e49284eb15',\n\t      b: '-e4437ed6010e88286f547fa90abfe4c3'\n\t    },\n\t    {\n\t      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n\t      b: '3086d221a7d46bcde86c90e49284eb15'\n\t    }\n\t  ],\n\n\t  gRed: false,\n\t  g: [\n\t    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n\t    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n\t    pre\n\t  ]\n\t});\n\t});\n\n\t'use strict';\n\n\n\n\n\n\tfunction HmacDRBG(options) {\n\t  if (!(this instanceof HmacDRBG))\n\t    return new HmacDRBG(options);\n\t  this.hash = options.hash;\n\t  this.predResist = !!options.predResist;\n\n\t  this.outLen = this.hash.outSize;\n\t  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n\t  this._reseed = null;\n\t  this.reseedInterval = null;\n\t  this.K = null;\n\t  this.V = null;\n\n\t  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n\t  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n\t  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\t  this._init(entropy, nonce, pers);\n\t}\n\tvar hmacDrbg = HmacDRBG;\n\n\tHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n\t  var seed = entropy.concat(nonce).concat(pers);\n\n\t  this.K = new Array(this.outLen / 8);\n\t  this.V = new Array(this.outLen / 8);\n\t  for (var i = 0; i < this.V.length; i++) {\n\t    this.K[i] = 0x00;\n\t    this.V[i] = 0x01;\n\t  }\n\n\t  this._update(seed);\n\t  this._reseed = 1;\n\t  this.reseedInterval = 0x1000000000000;  // 2^48\n\t};\n\n\tHmacDRBG.prototype._hmac = function hmac() {\n\t  return new hash_1.hmac(this.hash, this.K);\n\t};\n\n\tHmacDRBG.prototype._update = function update(seed) {\n\t  var kmac = this._hmac()\n\t                 .update(this.V)\n\t                 .update([ 0x00 ]);\n\t  if (seed)\n\t    kmac = kmac.update(seed);\n\t  this.K = kmac.digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t  if (!seed)\n\t    return;\n\n\t  this.K = this._hmac()\n\t               .update(this.V)\n\t               .update([ 0x01 ])\n\t               .update(seed)\n\t               .digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t};\n\n\tHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n\t  // Optional entropy enc\n\t  if (typeof entropyEnc !== 'string') {\n\t    addEnc = add;\n\t    add = entropyEnc;\n\t    entropyEnc = null;\n\t  }\n\n\t  entropy = utils_1.toArray(entropy, entropyEnc);\n\t  add = utils_1.toArray(add, addEnc);\n\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n\t  this._update(entropy.concat(add || []));\n\t  this._reseed = 1;\n\t};\n\n\tHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n\t  if (this._reseed > this.reseedInterval)\n\t    throw new Error('Reseed is required');\n\n\t  // Optional encoding\n\t  if (typeof enc !== 'string') {\n\t    addEnc = add;\n\t    add = enc;\n\t    enc = null;\n\t  }\n\n\t  // Optional additional data\n\t  if (add) {\n\t    add = utils_1.toArray(add, addEnc || 'hex');\n\t    this._update(add);\n\t  }\n\n\t  var temp = [];\n\t  while (temp.length < len) {\n\t    this.V = this._hmac().update(this.V).digest();\n\t    temp = temp.concat(this.V);\n\t  }\n\n\t  var res = temp.slice(0, len);\n\t  this._update(add);\n\t  this._reseed++;\n\t  return utils_1.encode(res, enc);\n\t};\n\n\t'use strict';\n\n\n\n\tvar assert$3 = utils_1$1.assert;\n\n\tfunction KeyPair(ec, options) {\n\t  this.ec = ec;\n\t  this.priv = null;\n\t  this.pub = null;\n\n\t  // KeyPair(ec, { priv: ..., pub: ... })\n\t  if (options.priv)\n\t    this._importPrivate(options.priv, options.privEnc);\n\t  if (options.pub)\n\t    this._importPublic(options.pub, options.pubEnc);\n\t}\n\tvar key = KeyPair;\n\n\tKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n\t  if (pub instanceof KeyPair)\n\t    return pub;\n\n\t  return new KeyPair(ec, {\n\t    pub: pub,\n\t    pubEnc: enc\n\t  });\n\t};\n\n\tKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n\t  if (priv instanceof KeyPair)\n\t    return priv;\n\n\t  return new KeyPair(ec, {\n\t    priv: priv,\n\t    privEnc: enc\n\t  });\n\t};\n\n\tKeyPair.prototype.validate = function validate() {\n\t  var pub = this.getPublic();\n\n\t  if (pub.isInfinity())\n\t    return { result: false, reason: 'Invalid public key' };\n\t  if (!pub.validate())\n\t    return { result: false, reason: 'Public key is not a point' };\n\t  if (!pub.mul(this.ec.curve.n).isInfinity())\n\t    return { result: false, reason: 'Public key * N != O' };\n\n\t  return { result: true, reason: null };\n\t};\n\n\tKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n\t  // compact is optional argument\n\t  if (typeof compact === 'string') {\n\t    enc = compact;\n\t    compact = null;\n\t  }\n\n\t  if (!this.pub)\n\t    this.pub = this.ec.g.mul(this.priv);\n\n\t  if (!enc)\n\t    return this.pub;\n\n\t  return this.pub.encode(enc, compact);\n\t};\n\n\tKeyPair.prototype.getPrivate = function getPrivate(enc) {\n\t  if (enc === 'hex')\n\t    return this.priv.toString(16, 2);\n\t  else\n\t    return this.priv;\n\t};\n\n\tKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n\t  this.priv = new bn(key, enc || 16);\n\n\t  // Ensure that the priv won't be bigger than n, otherwise we may fail\n\t  // in fixed multiplication method\n\t  this.priv = this.priv.umod(this.ec.curve.n);\n\t};\n\n\tKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n\t  if (key.x || key.y) {\n\t    // Montgomery points only have an `x` coordinate.\n\t    // Weierstrass/Edwards points on the other hand have both `x` and\n\t    // `y` coordinates.\n\t    if (this.ec.curve.type === 'mont') {\n\t      assert$3(key.x, 'Need x coordinate');\n\t    } else if (this.ec.curve.type === 'short' ||\n\t               this.ec.curve.type === 'edwards') {\n\t      assert$3(key.x && key.y, 'Need both x and y coordinate');\n\t    }\n\t    this.pub = this.ec.curve.point(key.x, key.y);\n\t    return;\n\t  }\n\t  this.pub = this.ec.curve.decodePoint(key, enc);\n\t};\n\n\t// ECDH\n\tKeyPair.prototype.derive = function derive(pub) {\n\t  return pub.mul(this.priv).getX();\n\t};\n\n\t// ECDSA\n\tKeyPair.prototype.sign = function sign(msg, enc, options) {\n\t  return this.ec.sign(msg, this, enc, options);\n\t};\n\n\tKeyPair.prototype.verify = function verify(msg, signature) {\n\t  return this.ec.verify(msg, signature, this);\n\t};\n\n\tKeyPair.prototype.inspect = function inspect() {\n\t  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n\t         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar assert$4 = utils_1$1.assert;\n\n\tfunction Signature(options, enc) {\n\t  if (options instanceof Signature)\n\t    return options;\n\n\t  if (this._importDER(options, enc))\n\t    return;\n\n\t  assert$4(options.r && options.s, 'Signature without r or s');\n\t  this.r = new bn(options.r, 16);\n\t  this.s = new bn(options.s, 16);\n\t  if (options.recoveryParam === undefined)\n\t    this.recoveryParam = null;\n\t  else\n\t    this.recoveryParam = options.recoveryParam;\n\t}\n\tvar signature = Signature;\n\n\tfunction Position() {\n\t  this.place = 0;\n\t}\n\n\tfunction getLength(buf, p) {\n\t  var initial = buf[p.place++];\n\t  if (!(initial & 0x80)) {\n\t    return initial;\n\t  }\n\t  var octetLen = initial & 0xf;\n\t  var val = 0;\n\t  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n\t    val <<= 8;\n\t    val |= buf[off];\n\t  }\n\t  p.place = off;\n\t  return val;\n\t}\n\n\tfunction rmPadding(buf) {\n\t  var i = 0;\n\t  var len = buf.length - 1;\n\t  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n\t    i++;\n\t  }\n\t  if (i === 0) {\n\t    return buf;\n\t  }\n\t  return buf.slice(i);\n\t}\n\n\tSignature.prototype._importDER = function _importDER(data, enc) {\n\t  data = utils_1$1.toArray(data, enc);\n\t  var p = new Position();\n\t  if (data[p.place++] !== 0x30) {\n\t    return false;\n\t  }\n\t  var len = getLength(data, p);\n\t  if ((len + p.place) !== data.length) {\n\t    return false;\n\t  }\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var rlen = getLength(data, p);\n\t  var r = data.slice(p.place, rlen + p.place);\n\t  p.place += rlen;\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var slen = getLength(data, p);\n\t  if (data.length !== slen + p.place) {\n\t    return false;\n\t  }\n\t  var s = data.slice(p.place, slen + p.place);\n\t  if (r[0] === 0 && (r[1] & 0x80)) {\n\t    r = r.slice(1);\n\t  }\n\t  if (s[0] === 0 && (s[1] & 0x80)) {\n\t    s = s.slice(1);\n\t  }\n\n\t  this.r = new bn(r);\n\t  this.s = new bn(s);\n\t  this.recoveryParam = null;\n\n\t  return true;\n\t};\n\n\tfunction constructLength(arr, len) {\n\t  if (len < 0x80) {\n\t    arr.push(len);\n\t    return;\n\t  }\n\t  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n\t  arr.push(octets | 0x80);\n\t  while (--octets) {\n\t    arr.push((len >>> (octets << 3)) & 0xff);\n\t  }\n\t  arr.push(len);\n\t}\n\n\tSignature.prototype.toDER = function toDER(enc) {\n\t  var r = this.r.toArray();\n\t  var s = this.s.toArray();\n\n\t  // Pad values\n\t  if (r[0] & 0x80)\n\t    r = [ 0 ].concat(r);\n\t  // Pad values\n\t  if (s[0] & 0x80)\n\t    s = [ 0 ].concat(s);\n\n\t  r = rmPadding(r);\n\t  s = rmPadding(s);\n\n\t  while (!s[0] && !(s[1] & 0x80)) {\n\t    s = s.slice(1);\n\t  }\n\t  var arr = [ 0x02 ];\n\t  constructLength(arr, r.length);\n\t  arr = arr.concat(r);\n\t  arr.push(0x02);\n\t  constructLength(arr, s.length);\n\t  var backHalf = arr.concat(s);\n\t  var res = [ 0x30 ];\n\t  constructLength(res, backHalf.length);\n\t  res = res.concat(backHalf);\n\t  return utils_1$1.encode(res, enc);\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\tvar assert$5 = utils_1$1.assert;\n\n\n\n\n\tfunction EC(options) {\n\t  if (!(this instanceof EC))\n\t    return new EC(options);\n\n\t  // Shortcut `elliptic.ec(curve-name)`\n\t  if (typeof options === 'string') {\n\t    assert$5(curves_1.hasOwnProperty(options), 'Unknown curve ' + options);\n\n\t    options = curves_1[options];\n\t  }\n\n\t  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n\t  if (options instanceof curves_1.PresetCurve)\n\t    options = { curve: options };\n\n\t  this.curve = options.curve.curve;\n\t  this.n = this.curve.n;\n\t  this.nh = this.n.ushrn(1);\n\t  this.g = this.curve.g;\n\n\t  // Point on curve\n\t  this.g = options.curve.g;\n\t  this.g.precompute(options.curve.n.bitLength() + 1);\n\n\t  // Hash for function for DRBG\n\t  this.hash = options.hash || options.curve.hash;\n\t}\n\tvar ec = EC;\n\n\tEC.prototype.keyPair = function keyPair(options) {\n\t  return new key(this, options);\n\t};\n\n\tEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n\t  return key.fromPrivate(this, priv, enc);\n\t};\n\n\tEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n\t  return key.fromPublic(this, pub, enc);\n\t};\n\n\tEC.prototype.genKeyPair = function genKeyPair(options) {\n\t  if (!options)\n\t    options = {};\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || 'utf8',\n\t    entropy: options.entropy || brorand(this.hash.hmacStrength),\n\t    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n\t    nonce: this.n.toArray()\n\t  });\n\n\t  var bytes = this.n.byteLength();\n\t  var ns2 = this.n.sub(new bn(2));\n\t  do {\n\t    var priv = new bn(drbg.generate(bytes));\n\t    if (priv.cmp(ns2) > 0)\n\t      continue;\n\n\t    priv.iaddn(1);\n\t    return this.keyFromPrivate(priv);\n\t  } while (true);\n\t};\n\n\tEC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n\t  var delta = msg.byteLength() * 8 - this.n.bitLength();\n\t  if (delta > 0)\n\t    msg = msg.ushrn(delta);\n\t  if (!truncOnly && msg.cmp(this.n) >= 0)\n\t    return msg.sub(this.n);\n\t  else\n\t    return msg;\n\t};\n\n\tEC.prototype.sign = function sign(msg, key, enc, options) {\n\t  if (typeof enc === 'object') {\n\t    options = enc;\n\t    enc = null;\n\t  }\n\t  if (!options)\n\t    options = {};\n\n\t  key = this.keyFromPrivate(key, enc);\n\t  msg = this._truncateToN(new bn(msg, 16));\n\n\t  // Zero-extend key to provide enough entropy\n\t  var bytes = this.n.byteLength();\n\t  var bkey = key.getPrivate().toArray('be', bytes);\n\n\t  // Zero-extend nonce to have the same byte size as N\n\t  var nonce = msg.toArray('be', bytes);\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    entropy: bkey,\n\t    nonce: nonce,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || 'utf8'\n\t  });\n\n\t  // Number of bytes to generate\n\t  var ns1 = this.n.sub(new bn(1));\n\n\t  for (var iter = 0; true; iter++) {\n\t    var k = options.k ?\n\t        options.k(iter) :\n\t        new bn(drbg.generate(this.n.byteLength()));\n\t    k = this._truncateToN(k, true);\n\t    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n\t      continue;\n\n\t    var kp = this.g.mul(k);\n\t    if (kp.isInfinity())\n\t      continue;\n\n\t    var kpX = kp.getX();\n\t    var r = kpX.umod(this.n);\n\t    if (r.cmpn(0) === 0)\n\t      continue;\n\n\t    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n\t    s = s.umod(this.n);\n\t    if (s.cmpn(0) === 0)\n\t      continue;\n\n\t    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n\t                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n\t    // Use complement of `s`, if it is > `n / 2`\n\t    if (options.canonical && s.cmp(this.nh) > 0) {\n\t      s = this.n.sub(s);\n\t      recoveryParam ^= 1;\n\t    }\n\n\t    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n\t  }\n\t};\n\n\tEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n\t  msg = this._truncateToN(new bn(msg, 16));\n\t  key = this.keyFromPublic(key, enc);\n\t  signature$1 = new signature(signature$1, 'hex');\n\n\t  // Perform primitive values validation\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\t  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n\t    return false;\n\t  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n\t    return false;\n\n\t  // Validate signature\n\t  var sinv = s.invm(this.n);\n\t  var u1 = sinv.mul(msg).umod(this.n);\n\t  var u2 = sinv.mul(r).umod(this.n);\n\n\t  if (!this.curve._maxwellTrick) {\n\t    var p = this.g.mulAdd(u1, key.getPublic(), u2);\n\t    if (p.isInfinity())\n\t      return false;\n\n\t    return p.getX().umod(this.n).cmp(r) === 0;\n\t  }\n\n\t  // NOTE: Greg Maxwell's trick, inspired by:\n\t  // https://git.io/vad3K\n\n\t  var p = this.g.jmulAdd(u1, key.getPublic(), u2);\n\t  if (p.isInfinity())\n\t    return false;\n\n\t  // Compare `p.x` of Jacobian point with `r`,\n\t  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n\t  // inverse of `p.z^2`\n\t  return p.eqXToP(r);\n\t};\n\n\tEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n\t  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n\t  signature$1 = new signature(signature$1, enc);\n\n\t  var n = this.n;\n\t  var e = new bn(msg);\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\n\t  // A set LSB signifies that the y-coordinate is odd\n\t  var isYOdd = j & 1;\n\t  var isSecondKey = j >> 1;\n\t  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n\t    throw new Error('Unable to find sencond key candinate');\n\n\t  // 1.1. Let x = r + jn.\n\t  if (isSecondKey)\n\t    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n\t  else\n\t    r = this.curve.pointFromX(r, isYOdd);\n\n\t  var rInv = signature$1.r.invm(n);\n\t  var s1 = n.sub(e).mul(rInv).umod(n);\n\t  var s2 = s.mul(rInv).umod(n);\n\n\t  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n\t  //               Q = r^-1 (sR + -eG)\n\t  return this.g.mulAdd(s1, r, s2);\n\t};\n\n\tEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n\t  signature$1 = new signature(signature$1, enc);\n\t  if (signature$1.recoveryParam !== null)\n\t    return signature$1.recoveryParam;\n\n\t  for (var i = 0; i < 4; i++) {\n\t    var Qprime;\n\t    try {\n\t      Qprime = this.recoverPubKey(e, signature$1, i);\n\t    } catch (e) {\n\t      continue;\n\t    }\n\n\t    if (Qprime.eq(Q))\n\t      return i;\n\t  }\n\t  throw new Error('Unable to find valid recovery factor');\n\t};\n\n\tvar eddsa = {};\n\n\tvar require$$0$1 = getCjsExportFromNamespace(_package$1);\n\n\tvar elliptic_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar elliptic = exports;\n\n\telliptic.version = require$$0$1.version;\n\telliptic.utils = utils_1$1;\n\telliptic.rand = brorand;\n\telliptic.curve = curve_1;\n\telliptic.curves = curves_1;\n\n\t// Protocols\n\telliptic.ec = ec;\n\telliptic.eddsa = eddsa;\n\t});\n\tvar elliptic_2 = elliptic_1.ec;\n\n\tvar _version$q = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"signing-key/5.0.0-beta.136\";\n\t});\n\n\tvar _version$r = unwrapExports(_version$q);\n\tvar _version_1$d = _version$q.version;\n\n\tvar lib$f = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$q.version);\n\tvar _curve = null;\n\tfunction getCurve() {\n\t    if (!_curve) {\n\t        _curve = new elliptic_1.ec(\"secp256k1\");\n\t    }\n\t    return _curve;\n\t}\n\tvar SigningKey = /** @class */ (function () {\n\t    function SigningKey(privateKey) {\n\t        lib$3.defineReadOnly(this, \"curve\", \"secp256k1\");\n\t        lib$3.defineReadOnly(this, \"privateKey\", lib$1.hexlify(privateKey));\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        lib$3.defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n\t        lib$3.defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\t        lib$3.defineReadOnly(this, \"_isSigningKey\", true);\n\t    }\n\t    SigningKey.prototype._addPoint = function (other) {\n\t        var p0 = getCurve().keyFromPublic(lib$1.arrayify(this.publicKey));\n\t        var p1 = getCurve().keyFromPublic(lib$1.arrayify(other));\n\t        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n\t    };\n\t    SigningKey.prototype.signDigest = function (digest) {\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        var signature = keyPair.sign(lib$1.arrayify(digest), { canonical: true });\n\t        return lib$1.splitSignature({\n\t            recoveryParam: signature.recoveryParam,\n\t            r: lib$1.hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n\t            s: lib$1.hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n\t        });\n\t    };\n\t    SigningKey.prototype.computeSharedSecret = function (otherKey) {\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        var otherKeyPair = getCurve().keyFromPublic(lib$1.arrayify(computePublicKey(otherKey)));\n\t        return lib$1.hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n\t    };\n\t    SigningKey.isSigningKey = function (value) {\n\t        return !!(value && value._isSigningKey);\n\t    };\n\t    return SigningKey;\n\t}());\n\texports.SigningKey = SigningKey;\n\tfunction recoverPublicKey(digest, signature) {\n\t    var sig = lib$1.splitSignature(signature);\n\t    var rs = { r: lib$1.arrayify(sig.r), s: lib$1.arrayify(sig.s) };\n\t    return \"0x\" + getCurve().recoverPubKey(lib$1.arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n\t}\n\texports.recoverPublicKey = recoverPublicKey;\n\tfunction computePublicKey(key, compressed) {\n\t    var bytes = lib$1.arrayify(key);\n\t    if (bytes.length === 32) {\n\t        var signingKey = new SigningKey(bytes);\n\t        if (compressed) {\n\t            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n\t        }\n\t        return signingKey.publicKey;\n\t    }\n\t    else if (bytes.length === 33) {\n\t        if (compressed) {\n\t            return lib$1.hexlify(bytes);\n\t        }\n\t        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\t    }\n\t    else if (bytes.length === 65) {\n\t        if (!compressed) {\n\t            return lib$1.hexlify(bytes);\n\t        }\n\t        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n\t    }\n\t    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n\t}\n\texports.computePublicKey = computePublicKey;\n\t});\n\n\tvar index$f = unwrapExports(lib$f);\n\tvar lib_1$f = lib$f.SigningKey;\n\tvar lib_2$e = lib$f.recoverPublicKey;\n\tvar lib_3$b = lib$f.computePublicKey;\n\n\tvar _version$s = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"transactions/5.0.0-beta.136\";\n\t});\n\n\tvar _version$t = unwrapExports(_version$s);\n\tvar _version_1$e = _version$s.version;\n\n\tvar lib$g = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\tvar RLP = __importStar(lib$5);\n\n\n\n\tvar logger = new lib.Logger(_version$s.version);\n\t///////////////////////////////\n\tfunction handleAddress(value) {\n\t    if (value === \"0x\") {\n\t        return null;\n\t    }\n\t    return lib$6.getAddress(value);\n\t}\n\tfunction handleNumber(value) {\n\t    if (value === \"0x\") {\n\t        return lib$7.Zero;\n\t    }\n\t    return lib$2.BigNumber.from(value);\n\t}\n\tvar transactionFields = [\n\t    { name: \"nonce\", maxLength: 32, numeric: true },\n\t    { name: \"gasPrice\", maxLength: 32, numeric: true },\n\t    { name: \"gasLimit\", maxLength: 32, numeric: true },\n\t    { name: \"to\", length: 20 },\n\t    { name: \"value\", maxLength: 32, numeric: true },\n\t    { name: \"data\" },\n\t];\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tfunction computeAddress(key) {\n\t    var publicKey = lib$f.computePublicKey(key);\n\t    return lib$6.getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.hexDataSlice(publicKey, 1)), 12));\n\t}\n\texports.computeAddress = computeAddress;\n\tfunction recoverAddress(digest, signature) {\n\t    return computeAddress(lib$f.recoverPublicKey(lib$1.arrayify(digest), signature));\n\t}\n\texports.recoverAddress = recoverAddress;\n\tfunction serialize(transaction, signature) {\n\t    lib$3.checkProperties(transaction, allowedTransactionKeys);\n\t    var raw = [];\n\t    transactionFields.forEach(function (fieldInfo) {\n\t        var value = transaction[fieldInfo.name] || ([]);\n\t        var options = {};\n\t        if (fieldInfo.numeric) {\n\t            options.hexPad = \"left\";\n\t        }\n\t        value = lib$1.arrayify(lib$1.hexlify(value, options));\n\t        // Fixed-width field\n\t        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n\t            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n\t        }\n\t        // Variable-width (with a maximum)\n\t        if (fieldInfo.maxLength) {\n\t            value = lib$1.stripZeros(value);\n\t            if (value.length > fieldInfo.maxLength) {\n\t                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n\t            }\n\t        }\n\t        raw.push(lib$1.hexlify(value));\n\t    });\n\t    var chainId = 0;\n\t    if (transaction.chainId != null) {\n\t        // A chainId was provided; if non-zero we'll use EIP-155\n\t        chainId = transaction.chainId;\n\t        if (typeof (chainId) !== \"number\") {\n\t            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n\t        }\n\t    }\n\t    else if (signature && !lib$1.isBytesLike(signature) && signature.v > 28) {\n\t        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n\t        chainId = Math.floor((signature.v - 35) / 2);\n\t    }\n\t    // We have an EIP-155 transaction (chainId was specified and non-zero)\n\t    if (chainId !== 0) {\n\t        raw.push(lib$1.hexlify(chainId));\n\t        raw.push(\"0x\");\n\t        raw.push(\"0x\");\n\t    }\n\t    // Requesting an unsigned transation\n\t    if (!signature) {\n\t        return RLP.encode(raw);\n\t    }\n\t    // The splitSignature will ensure the transaction has a recoveryParam in the\n\t    // case that the signTransaction function only adds a v.\n\t    var sig = lib$1.splitSignature(signature);\n\t    // We pushed a chainId and null r, s on for hashing only; remove those\n\t    var v = 27 + sig.recoveryParam;\n\t    if (chainId !== 0) {\n\t        raw.pop();\n\t        raw.pop();\n\t        raw.pop();\n\t        v += chainId * 2 + 8;\n\t        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\t        if (sig.v > 28 && sig.v !== v) {\n\t            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n\t        }\n\t    }\n\t    else if (sig.v !== v) {\n\t        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n\t    }\n\t    raw.push(lib$1.hexlify(v));\n\t    raw.push(lib$1.stripZeros(lib$1.arrayify(sig.r)));\n\t    raw.push(lib$1.stripZeros(lib$1.arrayify(sig.s)));\n\t    return RLP.encode(raw);\n\t}\n\texports.serialize = serialize;\n\tfunction parse(rawTransaction) {\n\t    var transaction = RLP.decode(rawTransaction);\n\t    if (transaction.length !== 9 && transaction.length !== 6) {\n\t        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n\t    }\n\t    var tx = {\n\t        nonce: handleNumber(transaction[0]).toNumber(),\n\t        gasPrice: handleNumber(transaction[1]),\n\t        gasLimit: handleNumber(transaction[2]),\n\t        to: handleAddress(transaction[3]),\n\t        value: handleNumber(transaction[4]),\n\t        data: transaction[5],\n\t        chainId: 0\n\t    };\n\t    // Legacy unsigned transaction\n\t    if (transaction.length === 6) {\n\t        return tx;\n\t    }\n\t    try {\n\t        tx.v = lib$2.BigNumber.from(transaction[6]).toNumber();\n\t    }\n\t    catch (error) {\n\t        console.log(error);\n\t        return tx;\n\t    }\n\t    tx.r = lib$1.hexZeroPad(transaction[7], 32);\n\t    tx.s = lib$1.hexZeroPad(transaction[8], 32);\n\t    if (lib$2.BigNumber.from(tx.r).isZero() && lib$2.BigNumber.from(tx.s).isZero()) {\n\t        // EIP-155 unsigned transaction\n\t        tx.chainId = tx.v;\n\t        tx.v = 0;\n\t    }\n\t    else {\n\t        // Signed Tranasaction\n\t        tx.chainId = Math.floor((tx.v - 35) / 2);\n\t        if (tx.chainId < 0) {\n\t            tx.chainId = 0;\n\t        }\n\t        var recoveryParam = tx.v - 27;\n\t        var raw = transaction.slice(0, 6);\n\t        if (tx.chainId !== 0) {\n\t            raw.push(lib$1.hexlify(tx.chainId));\n\t            raw.push(\"0x\");\n\t            raw.push(\"0x\");\n\t            recoveryParam -= tx.chainId * 2 + 8;\n\t        }\n\t        var digest = lib$4.keccak256(RLP.encode(raw));\n\t        try {\n\t            tx.from = recoverAddress(digest, { r: lib$1.hexlify(tx.r), s: lib$1.hexlify(tx.s), recoveryParam: recoveryParam });\n\t        }\n\t        catch (error) {\n\t            console.log(error);\n\t        }\n\t        tx.hash = lib$4.keccak256(rawTransaction);\n\t    }\n\t    return tx;\n\t}\n\texports.parse = parse;\n\t});\n\n\tvar index$g = unwrapExports(lib$g);\n\tvar lib_1$g = lib$g.computeAddress;\n\tvar lib_2$f = lib$g.recoverAddress;\n\tvar lib_3$c = lib$g.serialize;\n\tvar lib_4$9 = lib$g.parse;\n\n\tvar _version$u = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"wordlists/5.0.0-beta.137\";\n\t});\n\n\tvar _version$v = unwrapExports(_version$u);\n\tvar _version_1$f = _version$u.version;\n\n\tvar wordlist = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// This gets overridden by rollup\n\tvar exportWordlist = false;\n\n\n\n\n\texports.logger = new lib.Logger(_version$u.version);\n\tvar Wordlist = /** @class */ (function () {\n\t    function Wordlist(locale) {\n\t        var _newTarget = this.constructor;\n\t        exports.logger.checkAbstract(_newTarget, Wordlist);\n\t        lib$3.defineReadOnly(this, \"locale\", locale);\n\t    }\n\t    // Subclasses may override this\n\t    Wordlist.prototype.split = function (mnemonic) {\n\t        return mnemonic.toLowerCase().split(/ +/g);\n\t    };\n\t    // Subclasses may override this\n\t    Wordlist.prototype.join = function (words) {\n\t        return words.join(\" \");\n\t    };\n\t    Wordlist.check = function (wordlist) {\n\t        var words = [];\n\t        for (var i = 0; i < 2048; i++) {\n\t            var word = wordlist.getWord(i);\n\t            if (i !== wordlist.getWordIndex(word)) {\n\t                return \"0x\";\n\t            }\n\t            words.push(word);\n\t        }\n\t        return lib$9.id(words.join(\"\\n\") + \"\\n\");\n\t    };\n\t    Wordlist.register = function (lang, name) {\n\t        if (!name) {\n\t            name = lang.locale;\n\t        }\n\t        if (exportWordlist) {\n\t            try {\n\t                var anyGlobal = window;\n\t                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n\t                    if (!anyGlobal._ethers.wordlists[name]) {\n\t                        lib$3.defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n\t                    }\n\t                }\n\t            }\n\t            catch (error) { }\n\t        }\n\t    };\n\t    return Wordlist;\n\t}());\n\texports.Wordlist = Wordlist;\n\t});\n\n\tvar wordlist$1 = unwrapExports(wordlist);\n\tvar wordlist_1 = wordlist.logger;\n\tvar wordlist_2 = wordlist.Wordlist;\n\n\tvar langEn_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tvar words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\tvar wordlist$1 = null;\n\tfunction loadWords(lang) {\n\t    if (wordlist$1 != null) {\n\t        return;\n\t    }\n\t    wordlist$1 = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\t    if (wordlist.Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n\t        wordlist$1 = null;\n\t        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n\t    }\n\t}\n\tvar LangEn = /** @class */ (function (_super) {\n\t    __extends(LangEn, _super);\n\t    function LangEn() {\n\t        return _super.call(this, \"en\") || this;\n\t    }\n\t    LangEn.prototype.getWord = function (index) {\n\t        loadWords(this);\n\t        return wordlist$1[index];\n\t    };\n\t    LangEn.prototype.getWordIndex = function (word) {\n\t        loadWords(this);\n\t        return wordlist$1.indexOf(word);\n\t    };\n\t    return LangEn;\n\t}(wordlist.Wordlist));\n\tvar langEn = new LangEn();\n\texports.langEn = langEn;\n\twordlist.Wordlist.register(langEn);\n\t});\n\n\tvar langEn = unwrapExports(langEn_1);\n\tvar langEn_2 = langEn_1.langEn;\n\n\tvar browser$4 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// Wordlists\n\t// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n\texports.Wordlist = wordlist.Wordlist;\n\n\tvar wordlists = { en: langEn_1.langEn };\n\texports.wordlists = wordlists;\n\t});\n\n\tvar browser$5 = unwrapExports(browser$4);\n\tvar browser_1$2 = browser$4.Wordlist;\n\tvar browser_2$1 = browser$4.wordlists;\n\n\tvar _version$w = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"hdnode/5.0.0-beta.140\";\n\t});\n\n\tvar _version$x = unwrapExports(_version$w);\n\tvar _version_1$g = _version$w.version;\n\n\tvar lib$h = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$w.version);\n\tvar N = lib$2.BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\t// \"Bitcoin seed\"\n\tvar MasterSecret = lib$8.toUtf8Bytes(\"Bitcoin seed\");\n\tvar HardenedBit = 0x80000000;\n\t// Returns a byte with the MSB bits set\n\tfunction getUpperMask(bits) {\n\t    return ((1 << bits) - 1) << (8 - bits);\n\t}\n\t// Returns a byte with the LSB bits set\n\tfunction getLowerMask(bits) {\n\t    return (1 << bits) - 1;\n\t}\n\tfunction bytes32(value) {\n\t    return lib$1.hexZeroPad(lib$1.hexlify(value), 32);\n\t}\n\tfunction base58check(data) {\n\t    return lib$e.Base58.encode(lib$1.concat([data, lib$1.hexDataSlice(browser.sha256(browser.sha256(data)), 0, 4)]));\n\t}\n\tfunction getWordlist(wordlist) {\n\t    if (wordlist == null) {\n\t        return browser$4.wordlists[\"en\"];\n\t    }\n\t    if (typeof (wordlist) === \"string\") {\n\t        var words = browser$4.wordlists[wordlist];\n\t        if (words == null) {\n\t            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n\t        }\n\t        return words;\n\t    }\n\t    return wordlist;\n\t}\n\tvar _constructorGuard = {};\n\texports.defaultPath = \"m/44'/60'/0'/0/0\";\n\t;\n\tvar HDNode = /** @class */ (function () {\n\t    /**\n\t     *  This constructor should not be called directly.\n\t     *\n\t     *  Please use:\n\t     *   - fromMnemonic\n\t     *   - fromSeed\n\t     */\n\t    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, HDNode);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error(\"HDNode constructor cannot be called directly\");\n\t        }\n\t        if (privateKey) {\n\t            var signingKey = new lib$f.SigningKey(privateKey);\n\t            lib$3.defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n\t            lib$3.defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n\t        }\n\t        else {\n\t            lib$3.defineReadOnly(this, \"privateKey\", null);\n\t            lib$3.defineReadOnly(this, \"publicKey\", lib$1.hexlify(publicKey));\n\t        }\n\t        lib$3.defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n\t        lib$3.defineReadOnly(this, \"fingerprint\", lib$1.hexDataSlice(browser.ripemd160(browser.sha256(this.publicKey)), 0, 4));\n\t        lib$3.defineReadOnly(this, \"address\", lib$g.computeAddress(this.publicKey));\n\t        lib$3.defineReadOnly(this, \"chainCode\", chainCode);\n\t        lib$3.defineReadOnly(this, \"index\", index);\n\t        lib$3.defineReadOnly(this, \"depth\", depth);\n\t        if (mnemonicOrPath == null) {\n\t            // From a source that does not preserve the path (e.g. extended keys)\n\t            lib$3.defineReadOnly(this, \"mnemonic\", null);\n\t            lib$3.defineReadOnly(this, \"path\", null);\n\t        }\n\t        else if (typeof (mnemonicOrPath) === \"string\") {\n\t            // From a source that does not preserve the mnemonic (e.g. neutered)\n\t            lib$3.defineReadOnly(this, \"mnemonic\", null);\n\t            lib$3.defineReadOnly(this, \"path\", mnemonicOrPath);\n\t        }\n\t        else {\n\t            // From a fully qualified source\n\t            lib$3.defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n\t            lib$3.defineReadOnly(this, \"path\", mnemonicOrPath.path);\n\t        }\n\t    }\n\t    Object.defineProperty(HDNode.prototype, \"extendedKey\", {\n\t        get: function () {\n\t            // We only support the mainnet values for now, but if anyone needs\n\t            // testnet values, let me know. I believe current senitment is that\n\t            // we should always use mainnet, and use BIP-44 to derive the network\n\t            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n\t            //   - Testnet: public=0x043587CF, private=0x04358394\n\t            if (this.depth >= 256) {\n\t                throw new Error(\"Depth too large!\");\n\t            }\n\t            return base58check(lib$1.concat([\n\t                ((this.privateKey != null) ? \"0x0488ADE4\" : \"0x0488B21E\"),\n\t                lib$1.hexlify(this.depth),\n\t                this.parentFingerprint,\n\t                lib$1.hexZeroPad(lib$1.hexlify(this.index), 4),\n\t                this.chainCode,\n\t                ((this.privateKey != null) ? lib$1.concat([\"0x00\", this.privateKey]) : this.publicKey),\n\t            ]));\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    HDNode.prototype.neuter = function () {\n\t        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n\t    };\n\t    HDNode.prototype._derive = function (index) {\n\t        if (index > 0xffffffff) {\n\t            throw new Error(\"invalid index - \" + String(index));\n\t        }\n\t        // Base path\n\t        var path = this.path;\n\t        if (path) {\n\t            path += \"/\" + (index & ~HardenedBit);\n\t        }\n\t        var data = new Uint8Array(37);\n\t        if (index & HardenedBit) {\n\t            if (!this.privateKey) {\n\t                throw new Error(\"cannot derive child of neutered node\");\n\t            }\n\t            // Data = 0x00 || ser_256(k_par)\n\t            data.set(lib$1.arrayify(this.privateKey), 1);\n\t            // Hardened path\n\t            if (path) {\n\t                path += \"'\";\n\t            }\n\t        }\n\t        else {\n\t            // Data = ser_p(point(k_par))\n\t            data.set(lib$1.arrayify(this.publicKey));\n\t        }\n\t        // Data += ser_32(i)\n\t        for (var i = 24; i >= 0; i -= 8) {\n\t            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n\t        }\n\t        var I = lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512, this.chainCode, data));\n\t        var IL = I.slice(0, 32);\n\t        var IR = I.slice(32);\n\t        // The private key\n\t        var ki = null;\n\t        // The public key\n\t        var Ki = null;\n\t        if (this.privateKey) {\n\t            ki = bytes32(lib$2.BigNumber.from(IL).add(this.privateKey).mod(N));\n\t        }\n\t        else {\n\t            var ek = new lib$f.SigningKey(lib$1.hexlify(IL));\n\t            Ki = ek._addPoint(this.publicKey);\n\t        }\n\t        var mnemonicOrPath = path;\n\t        var srcMnemonic = this.mnemonic;\n\t        if (srcMnemonic) {\n\t            mnemonicOrPath = Object.freeze({\n\t                phrase: srcMnemonic.phrase,\n\t                path: path,\n\t                locale: (srcMnemonic.locale || \"en\")\n\t            });\n\t        }\n\t        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n\t    };\n\t    HDNode.prototype.derivePath = function (path) {\n\t        var components = path.split(\"/\");\n\t        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n\t            throw new Error(\"invalid path - \" + path);\n\t        }\n\t        if (components[0] === \"m\") {\n\t            components.shift();\n\t        }\n\t        var result = this;\n\t        for (var i = 0; i < components.length; i++) {\n\t            var component = components[i];\n\t            if (component.match(/^[0-9]+'$/)) {\n\t                var index = parseInt(component.substring(0, component.length - 1));\n\t                if (index >= HardenedBit) {\n\t                    throw new Error(\"invalid path index - \" + component);\n\t                }\n\t                result = result._derive(HardenedBit + index);\n\t            }\n\t            else if (component.match(/^[0-9]+$/)) {\n\t                var index = parseInt(component);\n\t                if (index >= HardenedBit) {\n\t                    throw new Error(\"invalid path index - \" + component);\n\t                }\n\t                result = result._derive(index);\n\t            }\n\t            else {\n\t                throw new Error(\"invalid path component - \" + component);\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    HDNode._fromSeed = function (seed, mnemonic) {\n\t        var seedArray = lib$1.arrayify(seed);\n\t        if (seedArray.length < 16 || seedArray.length > 64) {\n\t            throw new Error(\"invalid seed\");\n\t        }\n\t        var I = lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\t        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n\t    };\n\t    HDNode.fromMnemonic = function (mnemonic, password, wordlist) {\n\t        // If a locale name was passed in, find the associated wordlist\n\t        wordlist = getWordlist(wordlist);\n\t        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n\t        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\t        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n\t            phrase: mnemonic,\n\t            path: \"m\",\n\t            locale: wordlist.locale\n\t        });\n\t    };\n\t    HDNode.fromSeed = function (seed) {\n\t        return HDNode._fromSeed(seed, null);\n\t    };\n\t    HDNode.fromExtendedKey = function (extendedKey) {\n\t        var bytes = lib$e.Base58.decode(extendedKey);\n\t        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n\t            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n\t        }\n\t        var depth = bytes[4];\n\t        var parentFingerprint = lib$1.hexlify(bytes.slice(5, 9));\n\t        var index = parseInt(lib$1.hexlify(bytes.slice(9, 13)).substring(2), 16);\n\t        var chainCode = lib$1.hexlify(bytes.slice(13, 45));\n\t        var key = bytes.slice(45, 78);\n\t        switch (lib$1.hexlify(bytes.slice(0, 4))) {\n\t            // Public Key\n\t            case \"0x0488b21e\":\n\t            case \"0x043587cf\":\n\t                return new HDNode(_constructorGuard, null, lib$1.hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\t            // Private Key\n\t            case \"0x0488ade4\":\n\t            case \"0x04358394 \":\n\t                if (key[0] !== 0) {\n\t                    break;\n\t                }\n\t                return new HDNode(_constructorGuard, lib$1.hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n\t        }\n\t        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n\t    };\n\t    return HDNode;\n\t}());\n\texports.HDNode = HDNode;\n\tfunction mnemonicToSeed(mnemonic, password) {\n\t    if (!password) {\n\t        password = \"\";\n\t    }\n\t    var salt = lib$8.toUtf8Bytes(\"mnemonic\" + password, lib$8.UnicodeNormalizationForm.NFKD);\n\t    return browser$2.pbkdf2(lib$8.toUtf8Bytes(mnemonic, lib$8.UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n\t}\n\texports.mnemonicToSeed = mnemonicToSeed;\n\tfunction mnemonicToEntropy(mnemonic, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    logger.checkNormalize();\n\t    var words = wordlist.split(mnemonic);\n\t    if ((words.length % 3) !== 0) {\n\t        throw new Error(\"invalid mnemonic\");\n\t    }\n\t    var entropy = lib$1.arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\t    var offset = 0;\n\t    for (var i = 0; i < words.length; i++) {\n\t        var index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n\t        if (index === -1) {\n\t            throw new Error(\"invalid mnemonic\");\n\t        }\n\t        for (var bit = 0; bit < 11; bit++) {\n\t            if (index & (1 << (10 - bit))) {\n\t                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n\t            }\n\t            offset++;\n\t        }\n\t    }\n\t    var entropyBits = 32 * words.length / 3;\n\t    var checksumBits = words.length / 3;\n\t    var checksumMask = getUpperMask(checksumBits);\n\t    var checksum = lib$1.arrayify(browser.sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\t    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n\t        throw new Error(\"invalid checksum\");\n\t    }\n\t    return lib$1.hexlify(entropy.slice(0, entropyBits / 8));\n\t}\n\texports.mnemonicToEntropy = mnemonicToEntropy;\n\tfunction entropyToMnemonic(entropy, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    entropy = lib$1.arrayify(entropy);\n\t    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n\t        throw new Error(\"invalid entropy\");\n\t    }\n\t    var indices = [0];\n\t    var remainingBits = 11;\n\t    for (var i = 0; i < entropy.length; i++) {\n\t        // Consume the whole byte (with still more to go)\n\t        if (remainingBits > 8) {\n\t            indices[indices.length - 1] <<= 8;\n\t            indices[indices.length - 1] |= entropy[i];\n\t            remainingBits -= 8;\n\t            // This byte will complete an 11-bit index\n\t        }\n\t        else {\n\t            indices[indices.length - 1] <<= remainingBits;\n\t            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\t            // Start the next word\n\t            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\t            remainingBits += 3;\n\t        }\n\t    }\n\t    // Compute the checksum bits\n\t    var checksumBits = entropy.length / 4;\n\t    var checksum = lib$1.arrayify(browser.sha256(entropy))[0] & getUpperMask(checksumBits);\n\t    // Shift the checksum into the word indices\n\t    indices[indices.length - 1] <<= checksumBits;\n\t    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\t    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\n\t}\n\texports.entropyToMnemonic = entropyToMnemonic;\n\tfunction isValidMnemonic(mnemonic, wordlist) {\n\t    try {\n\t        mnemonicToEntropy(mnemonic, wordlist);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidMnemonic = isValidMnemonic;\n\t});\n\n\tvar index$h = unwrapExports(lib$h);\n\tvar lib_1$h = lib$h.defaultPath;\n\tvar lib_2$g = lib$h.HDNode;\n\tvar lib_3$d = lib$h.mnemonicToSeed;\n\tvar lib_4$a = lib$h.mnemonicToEntropy;\n\tvar lib_5$9 = lib$h.entropyToMnemonic;\n\tvar lib_6$5 = lib$h.isValidMnemonic;\n\n\tvar _version$y = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"random/5.0.0-beta.136\";\n\t});\n\n\tvar _version$z = unwrapExports(_version$y);\n\tvar _version_1$h = _version$y.version;\n\n\tvar shuffle = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tfunction shuffled(array) {\n\t    array = array.slice();\n\t    for (var i = array.length - 1; i > 0; i--) {\n\t        var j = Math.floor(Math.random() * (i + 1));\n\t        var tmp = array[i];\n\t        array[i] = array[j];\n\t        array[j] = tmp;\n\t    }\n\t    return array;\n\t}\n\texports.shuffled = shuffled;\n\t});\n\n\tvar shuffle$1 = unwrapExports(shuffle);\n\tvar shuffle_1 = shuffle.shuffled;\n\n\tvar browser$6 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$y.version);\n\n\texports.shuffled = shuffle.shuffled;\n\tvar anyGlobal = null;\n\ttry {\n\t    anyGlobal = window;\n\t    if (anyGlobal == null) {\n\t        throw new Error(\"try next\");\n\t    }\n\t}\n\tcatch (error) {\n\t    try {\n\t        anyGlobal = commonjsGlobal;\n\t        if (anyGlobal == null) {\n\t            throw new Error(\"try next\");\n\t        }\n\t    }\n\t    catch (error) {\n\t        anyGlobal = {};\n\t    }\n\t}\n\tvar crypto = anyGlobal.crypto || anyGlobal.msCrypto;\n\tif (!crypto || !crypto.getRandomValues) {\n\t    logger.warn(\"WARNING: Missing strong random number source\");\n\t    crypto = {\n\t        getRandomValues: function (buffer) {\n\t            return logger.throwError(\"no secure random source avaialble\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"crypto.getRandomValues\"\n\t            });\n\t        }\n\t    };\n\t}\n\tfunction randomBytes(length) {\n\t    if (length <= 0 || length > 1024 || (length % 1)) {\n\t        logger.throwArgumentError(\"invalid length\", \"length\", length);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    crypto.getRandomValues(result);\n\t    return lib$1.arrayify(result);\n\t}\n\texports.randomBytes = randomBytes;\n\t;\n\t});\n\n\tvar browser$7 = unwrapExports(browser$6);\n\tvar browser_1$3 = browser$6.shuffled;\n\tvar browser_2$2 = browser$6.randomBytes;\n\n\tvar aesJs = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\n\t(function(root) {\n\n\t    function checkInt(value) {\n\t        return (parseInt(value) === value);\n\t    }\n\n\t    function checkInts(arrayish) {\n\t        if (!checkInt(arrayish.length)) { return false; }\n\n\t        for (var i = 0; i < arrayish.length; i++) {\n\t            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function coerceArray(arg, copy) {\n\n\t        // ArrayBuffer view\n\t        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {\n\n\t            if (copy) {\n\t                if (arg.slice) {\n\t                    arg = arg.slice();\n\t                } else {\n\t                    arg = Array.prototype.slice.call(arg);\n\t                }\n\t            }\n\n\t            return arg;\n\t        }\n\n\t        // It's an array; check it is a valid representation of a byte\n\t        if (Array.isArray(arg)) {\n\t            if (!checkInts(arg)) {\n\t                throw new Error('Array contains invalid value: ' + arg);\n\t            }\n\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n\t        if (checkInt(arg.length) && checkInts(arg)) {\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        throw new Error('unsupported array-like object');\n\t    }\n\n\t    function createArray(length) {\n\t        return new Uint8Array(length);\n\t    }\n\n\t    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {\n\t        if (sourceStart != null || sourceEnd != null) {\n\t            if (sourceArray.slice) {\n\t                sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n\t            } else {\n\t                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);\n\t            }\n\t        }\n\t        targetArray.set(sourceArray, targetStart);\n\t    }\n\n\n\n\t    var convertUtf8 = (function() {\n\t        function toBytes(text) {\n\t            var result = [], i = 0;\n\t            text = encodeURI(text);\n\t            while (i < text.length) {\n\t                var c = text.charCodeAt(i++);\n\n\t                // if it is a % sign, encode the following 2 bytes as a hex value\n\t                if (c === 37) {\n\t                    result.push(parseInt(text.substr(i, 2), 16));\n\t                    i += 2;\n\n\t                // otherwise, just the actual byte\n\t                } else {\n\t                    result.push(c);\n\t                }\n\t            }\n\n\t            return coerceArray(result);\n\t        }\n\n\t        function fromBytes(bytes) {\n\t            var result = [], i = 0;\n\n\t            while (i < bytes.length) {\n\t                var c = bytes[i];\n\n\t                if (c < 128) {\n\t                    result.push(String.fromCharCode(c));\n\t                    i++;\n\t                } else if (c > 191 && c < 224) {\n\t                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));\n\t                    i += 2;\n\t                } else {\n\t                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));\n\t                    i += 3;\n\t                }\n\t            }\n\n\t            return result.join('');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\t    var convertHex = (function() {\n\t        function toBytes(text) {\n\t            var result = [];\n\t            for (var i = 0; i < text.length; i += 2) {\n\t                result.push(parseInt(text.substr(i, 2), 16));\n\t            }\n\n\t            return result;\n\t        }\n\n\t        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\n\t        var Hex = '0123456789abcdef';\n\n\t        function fromBytes(bytes) {\n\t                var result = [];\n\t                for (var i = 0; i < bytes.length; i++) {\n\t                    var v = bytes[i];\n\t                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);\n\t                }\n\t                return result.join('');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\n\t    // Number of rounds by keysize\n\t    var numberOfRounds = {16: 10, 24: 12, 32: 14};\n\n\t    // Round constant words\n\t    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n\n\t    // S-box and Inverse S-box (S is for Substitution)\n\t    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\n\t    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n\n\t    // Transformations for encryption\n\t    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\n\t    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\n\t    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\n\t    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n\n\t    // Transformations for decryption\n\t    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\n\t    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\n\t    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\n\t    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n\n\t    // Transformations for decryption key expansion\n\t    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\n\t    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\n\t    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\n\t    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\n\n\t    function convertToInt32(bytes) {\n\t        var result = [];\n\t        for (var i = 0; i < bytes.length; i += 4) {\n\t            result.push(\n\t                (bytes[i    ] << 24) |\n\t                (bytes[i + 1] << 16) |\n\t                (bytes[i + 2] <<  8) |\n\t                 bytes[i + 3]\n\t            );\n\t        }\n\t        return result;\n\t    }\n\n\t    var AES = function(key) {\n\t        if (!(this instanceof AES)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        Object.defineProperty(this, 'key', {\n\t            value: coerceArray(key, true)\n\t        });\n\n\t        this._prepare();\n\t    };\n\n\n\t    AES.prototype._prepare = function() {\n\n\t        var rounds = numberOfRounds[this.key.length];\n\t        if (rounds == null) {\n\t            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');\n\t        }\n\n\t        // encryption round keys\n\t        this._Ke = [];\n\n\t        // decryption round keys\n\t        this._Kd = [];\n\n\t        for (var i = 0; i <= rounds; i++) {\n\t            this._Ke.push([0, 0, 0, 0]);\n\t            this._Kd.push([0, 0, 0, 0]);\n\t        }\n\n\t        var roundKeyCount = (rounds + 1) * 4;\n\t        var KC = this.key.length / 4;\n\n\t        // convert the key into ints\n\t        var tk = convertToInt32(this.key);\n\n\t        // copy values into round key arrays\n\t        var index;\n\t        for (var i = 0; i < KC; i++) {\n\t            index = i >> 2;\n\t            this._Ke[index][i % 4] = tk[i];\n\t            this._Kd[rounds - index][i % 4] = tk[i];\n\t        }\n\n\t        // key expansion (fips-197 section 5.2)\n\t        var rconpointer = 0;\n\t        var t = KC, tt;\n\t        while (t < roundKeyCount) {\n\t            tt = tk[KC - 1];\n\t            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n\t                      (S[(tt >>  8) & 0xFF] << 16) ^\n\t                      (S[ tt        & 0xFF] <<  8) ^\n\t                       S[(tt >> 24) & 0xFF]        ^\n\t                      (rcon[rconpointer] << 24));\n\t            rconpointer += 1;\n\n\t            // key expansion (for non-256 bit)\n\t            if (KC != 8) {\n\t                for (var i = 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\n\t            // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n\t            } else {\n\t                for (var i = 1; i < (KC / 2); i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t                tt = tk[(KC / 2) - 1];\n\n\t                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n\t                              (S[(tt >>  8) & 0xFF] <<  8) ^\n\t                              (S[(tt >> 16) & 0xFF] << 16) ^\n\t                              (S[(tt >> 24) & 0xFF] << 24));\n\n\t                for (var i = (KC / 2) + 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t            }\n\n\t            // copy values into round key arrays\n\t            var i = 0, r, c;\n\t            while (i < KC && t < roundKeyCount) {\n\t                r = t >> 2;\n\t                c = t % 4;\n\t                this._Ke[r][c] = tk[i];\n\t                this._Kd[rounds - r][c] = tk[i++];\n\t                t++;\n\t            }\n\t        }\n\n\t        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var c = 0; c < 4; c++) {\n\t                tt = this._Kd[r][c];\n\t                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n\t                                  U2[(tt >> 16) & 0xFF] ^\n\t                                  U3[(tt >>  8) & 0xFF] ^\n\t                                  U4[ tt        & 0xFF]);\n\t            }\n\t        }\n\t    };\n\n\t    AES.prototype.encrypt = function(plaintext) {\n\t        if (plaintext.length != 16) {\n\t            throw new Error('invalid plaintext size (must be 16 bytes)');\n\t        }\n\n\t        var rounds = this._Ke.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(plaintext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Ke[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^\n\t                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n\t                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T4[ t[(i + 3) % 4]        & 0xff] ^\n\t                        this._Ke[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Ke[rounds][i];\n\t            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\t    AES.prototype.decrypt = function(ciphertext) {\n\t        if (ciphertext.length != 16) {\n\t            throw new Error('invalid ciphertext size (must be 16 bytes)');\n\t        }\n\n\t        var rounds = this._Kd.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(ciphertext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Kd[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^\n\t                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n\t                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T8[ t[(i + 1) % 4]        & 0xff] ^\n\t                        this._Kd[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Kd[rounds][i];\n\t            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Electonic Codebook (ECB)\n\t     */\n\t    var ModeOfOperationECB = function(key) {\n\t        if (!(this instanceof ModeOfOperationECB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Electronic Code Block\";\n\t        this.name = \"ecb\";\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationECB.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\t            block = this._aes.encrypt(block);\n\t            copyArray(block, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\t            copyArray(block, plaintext, i);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Block Chaining (CBC)\n\t     */\n\t    var ModeOfOperationCBC = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationCBC)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Cipher Block Chaining\";\n\t        this.name = \"cbc\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 bytes)');\n\t        }\n\n\t        this._lastCipherblock = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                block[j] ^= this._lastCipherblock[j];\n\t            }\n\n\t            this._lastCipherblock = this._aes.encrypt(block);\n\t            copyArray(this._lastCipherblock, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];\n\t            }\n\n\t            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Feedback (CFB)\n\t     */\n\t    var ModeOfOperationCFB = function(key, iv, segmentSize) {\n\t        if (!(this instanceof ModeOfOperationCFB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Cipher Feedback\";\n\t        this.name = \"cfb\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 size)');\n\t        }\n\n\t        if (!segmentSize) { segmentSize = 1; }\n\n\t        this.segmentSize = segmentSize;\n\n\t        this._shiftRegister = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {\n\t        if ((plaintext.length % this.segmentSize) != 0) {\n\t            throw new Error('invalid plaintext size (must be segmentSize bytes)');\n\t        }\n\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < encrypted.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                encrypted[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {\n\t        if ((ciphertext.length % this.segmentSize) != 0) {\n\t            throw new Error('invalid ciphertext size (must be segmentSize bytes)');\n\t        }\n\n\t        var plaintext = coerceArray(ciphertext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < plaintext.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                plaintext[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\t    /**\n\t     *  Mode Of Operation - Output Feedback (OFB)\n\t     */\n\t    var ModeOfOperationOFB = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationOFB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Output Feedback\";\n\t        this.name = \"ofb\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 bytes)');\n\t        }\n\n\t        this._lastPrecipher = coerceArray(iv, true);\n\t        this._lastPrecipherIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._lastPrecipherIndex === 16) {\n\t                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);\n\t                this._lastPrecipherIndex = 0;\n\t            }\n\t            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;\n\n\n\t    /**\n\t     *  Counter object for CTR common mode of operation\n\t     */\n\t    var Counter = function(initialValue) {\n\t        if (!(this instanceof Counter)) {\n\t            throw Error('Counter must be instanitated with `new`');\n\t        }\n\n\t        // We allow 0, but anything false-ish uses the default 1\n\t        if (initialValue !== 0 && !initialValue) { initialValue = 1; }\n\n\t        if (typeof(initialValue) === 'number') {\n\t            this._counter = createArray(16);\n\t            this.setValue(initialValue);\n\n\t        } else {\n\t            this.setBytes(initialValue);\n\t        }\n\t    };\n\n\t    Counter.prototype.setValue = function(value) {\n\t        if (typeof(value) !== 'number' || parseInt(value) != value) {\n\t            throw new Error('invalid counter value (must be an integer)');\n\t        }\n\n\t        for (var index = 15; index >= 0; --index) {\n\t            this._counter[index] = value % 256;\n\t            value = value >> 8;\n\t        }\n\t    };\n\n\t    Counter.prototype.setBytes = function(bytes) {\n\t        bytes = coerceArray(bytes, true);\n\n\t        if (bytes.length != 16) {\n\t            throw new Error('invalid counter bytes size (must be 16 bytes)');\n\t        }\n\n\t        this._counter = bytes;\n\t    };\n\n\t    Counter.prototype.increment = function() {\n\t        for (var i = 15; i >= 0; i--) {\n\t            if (this._counter[i] === 255) {\n\t                this._counter[i] = 0;\n\t            } else {\n\t                this._counter[i]++;\n\t                break;\n\t            }\n\t        }\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Counter (CTR)\n\t     */\n\t    var ModeOfOperationCTR = function(key, counter) {\n\t        if (!(this instanceof ModeOfOperationCTR)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Counter\";\n\t        this.name = \"ctr\";\n\n\t        if (!(counter instanceof Counter)) {\n\t            counter = new Counter(counter);\n\t        }\n\n\t        this._counter = counter;\n\n\t        this._remainingCounter = null;\n\t        this._remainingCounterIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._remainingCounterIndex === 16) {\n\t                this._remainingCounter = this._aes.encrypt(this._counter._counter);\n\t                this._remainingCounterIndex = 0;\n\t                this._counter.increment();\n\t            }\n\t            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;\n\n\n\t    ///////////////////////\n\t    // Padding\n\n\t    // See:https://tools.ietf.org/html/rfc2315\n\t    function pkcs7pad(data) {\n\t        data = coerceArray(data, true);\n\t        var padder = 16 - (data.length % 16);\n\t        var result = createArray(data.length + padder);\n\t        copyArray(data, result);\n\t        for (var i = data.length; i < result.length; i++) {\n\t            result[i] = padder;\n\t        }\n\t        return result;\n\t    }\n\n\t    function pkcs7strip(data) {\n\t        data = coerceArray(data, true);\n\t        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }\n\n\t        var padder = data[data.length - 1];\n\t        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }\n\n\t        var length = data.length - padder;\n\t        for (var i = 0; i < padder; i++) {\n\t            if (data[length + i] !== padder) {\n\t                throw new Error('PKCS#7 invalid padding byte');\n\t            }\n\t        }\n\n\t        var result = createArray(length);\n\t        copyArray(data, result, 0, 0, length);\n\t        return result;\n\t    }\n\n\t    ///////////////////////\n\t    // Exporting\n\n\n\t    // The block cipher\n\t    var aesjs = {\n\t        AES: AES,\n\t        Counter: Counter,\n\n\t        ModeOfOperation: {\n\t            ecb: ModeOfOperationECB,\n\t            cbc: ModeOfOperationCBC,\n\t            cfb: ModeOfOperationCFB,\n\t            ofb: ModeOfOperationOFB,\n\t            ctr: ModeOfOperationCTR\n\t        },\n\n\t        utils: {\n\t            hex: convertHex,\n\t            utf8: convertUtf8\n\t        },\n\n\t        padding: {\n\t            pkcs7: {\n\t                pad: pkcs7pad,\n\t                strip: pkcs7strip\n\t            }\n\t        },\n\n\t        _arrayTest: {\n\t            coerceArray: coerceArray,\n\t            createArray: createArray,\n\t            copyArray: copyArray,\n\t        }\n\t    };\n\n\n\t    // node.js\n\t    if (true) {\n\t        module.exports = aesjs;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\n\t})(commonjsGlobal);\n\t});\n\n\tvar _version$A = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"json-wallets/5.0.0-beta.140\";\n\t});\n\n\tvar _version$B = unwrapExports(_version$A);\n\tvar _version_1$i = _version$A.version;\n\n\tvar utils$1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tfunction looseArrayify(hexString) {\n\t    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\n\t        hexString = '0x' + hexString;\n\t    }\n\t    return lib$1.arrayify(hexString);\n\t}\n\texports.looseArrayify = looseArrayify;\n\tfunction zpad(value, length) {\n\t    value = String(value);\n\t    while (value.length < length) {\n\t        value = '0' + value;\n\t    }\n\t    return value;\n\t}\n\texports.zpad = zpad;\n\tfunction getPassword(password) {\n\t    if (typeof (password) === 'string') {\n\t        return lib$8.toUtf8Bytes(password, lib$8.UnicodeNormalizationForm.NFKC);\n\t    }\n\t    return lib$1.arrayify(password);\n\t}\n\texports.getPassword = getPassword;\n\tfunction searchPath(object, path) {\n\t    var currentChild = object;\n\t    var comps = path.toLowerCase().split('/');\n\t    for (var i = 0; i < comps.length; i++) {\n\t        // Search for a child object with a case-insensitive matching key\n\t        var matchingChild = null;\n\t        for (var key in currentChild) {\n\t            if (key.toLowerCase() === comps[i]) {\n\t                matchingChild = currentChild[key];\n\t                break;\n\t            }\n\t        }\n\t        // Didn't find one. :'(\n\t        if (matchingChild === null) {\n\t            return null;\n\t        }\n\t        // Now check this child...\n\t        currentChild = matchingChild;\n\t    }\n\t    return currentChild;\n\t}\n\texports.searchPath = searchPath;\n\t});\n\n\tvar utils$2 = unwrapExports(utils$1);\n\tvar utils_1$2 = utils$1.looseArrayify;\n\tvar utils_2 = utils$1.zpad;\n\tvar utils_3 = utils$1.getPassword;\n\tvar utils_4 = utils$1.searchPath;\n\n\tvar crowdsale = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar aes_js_1 = __importDefault(aesJs);\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\n\tvar CrowdsaleAccount = /** @class */ (function (_super) {\n\t    __extends(CrowdsaleAccount, _super);\n\t    function CrowdsaleAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CrowdsaleAccount.prototype.isCrowdsaleAccount = function (value) {\n\t        return !!(value && value._isCrowdsaleAccount);\n\t    };\n\t    return CrowdsaleAccount;\n\t}(lib$3.Description));\n\texports.CrowdsaleAccount = CrowdsaleAccount;\n\t// See: https://github.com/ethereum/pyethsaletool\n\tfunction decrypt(json, password) {\n\t    var data = JSON.parse(json);\n\t    password = utils$1.getPassword(password);\n\t    // Ethereum Address\n\t    var ethaddr = lib$6.getAddress(utils$1.searchPath(data, \"ethaddr\"));\n\t    // Encrypted Seed\n\t    var encseed = utils$1.looseArrayify(utils$1.searchPath(data, \"encseed\"));\n\t    if (!encseed || (encseed.length % 16) !== 0) {\n\t        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n\t    }\n\t    var key = lib$1.arrayify(browser$2.pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\t    var iv = encseed.slice(0, 16);\n\t    var encryptedSeed = encseed.slice(16);\n\t    // Decrypt the seed\n\t    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);\n\t    var seed = aes_js_1.default.padding.pkcs7.strip(lib$1.arrayify(aesCbc.decrypt(encryptedSeed)));\n\t    // This wallet format is weird... Convert the binary encoded hex to a string.\n\t    var seedHex = \"\";\n\t    for (var i = 0; i < seed.length; i++) {\n\t        seedHex += String.fromCharCode(seed[i]);\n\t    }\n\t    var seedHexBytes = lib$8.toUtf8Bytes(seedHex);\n\t    var privateKey = lib$4.keccak256(seedHexBytes);\n\t    return new CrowdsaleAccount({\n\t        _isCrowdsaleAccount: true,\n\t        address: ethaddr,\n\t        privateKey: privateKey\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\t});\n\n\tvar crowdsale$1 = unwrapExports(crowdsale);\n\tvar crowdsale_1 = crowdsale.CrowdsaleAccount;\n\tvar crowdsale_2 = crowdsale.decrypt;\n\n\tvar inspect = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tfunction isCrowdsaleWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    return (data.encseed && data.ethaddr);\n\t}\n\texports.isCrowdsaleWallet = isCrowdsaleWallet;\n\tfunction isKeystoreWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n\t        return false;\n\t    }\n\t    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n\t    return true;\n\t}\n\texports.isKeystoreWallet = isKeystoreWallet;\n\t//export function isJsonWallet(json: string): boolean {\n\t//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n\t//}\n\tfunction getJsonWalletAddress(json) {\n\t    if (isCrowdsaleWallet(json)) {\n\t        try {\n\t            return lib$6.getAddress(JSON.parse(json).ethaddr);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    if (isKeystoreWallet(json)) {\n\t        try {\n\t            return lib$6.getAddress(JSON.parse(json).address);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    return null;\n\t}\n\texports.getJsonWalletAddress = getJsonWalletAddress;\n\t});\n\n\tvar inspect$1 = unwrapExports(inspect);\n\tvar inspect_1 = inspect.isCrowdsaleWallet;\n\tvar inspect_2 = inspect.isKeystoreWallet;\n\tvar inspect_3 = inspect.getJsonWalletAddress;\n\n\tvar scrypt = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\n\t(function(root) {\n\t    const MAX_VALUE = 0x7fffffff;\n\n\t    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n\t    // See: https://github.com/dchest/scrypt-async-js\n\t    function SHA256(m) {\n\t        const K = new Uint32Array([\n\t           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n\t           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n\t           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n\t           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n\t           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n\t           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n\t           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n\t           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n\t           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n\t           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t       ]);\n\n\t        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\n\t        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\n\t        const w = new Uint32Array(64);\n\n\t        function blocks(p) {\n\t            let off = 0, len = p.length;\n\t            while (len >= 64) {\n\t                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;\n\n\t                for (i = 0; i < 16; i++) {\n\t                    j = off + i*4;\n\t                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |\n\t                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);\n\t                }\n\n\t                for (i = 16; i < 64; i++) {\n\t                    u = w[i-2];\n\t                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);\n\n\t                    u = w[i-15];\n\t                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);\n\n\t                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;\n\t                }\n\n\t                for (i = 0; i < 64; i++) {\n\t                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^\n\t                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +\n\t                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n\n\t                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^\n\t                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n\n\t                    h = g;\n\t                    g = f;\n\t                    f = e;\n\t                    e = (d + t1) | 0;\n\t                    d = c;\n\t                    c = b;\n\t                    b = a;\n\t                    a = (t1 + t2) | 0;\n\t                }\n\n\t                h0 = (h0 + a) | 0;\n\t                h1 = (h1 + b) | 0;\n\t                h2 = (h2 + c) | 0;\n\t                h3 = (h3 + d) | 0;\n\t                h4 = (h4 + e) | 0;\n\t                h5 = (h5 + f) | 0;\n\t                h6 = (h6 + g) | 0;\n\t                h7 = (h7 + h) | 0;\n\n\t                off += 64;\n\t                len -= 64;\n\t            }\n\t        }\n\n\t        blocks(m);\n\n\t        let i, bytesLeft = m.length % 64,\n\t        bitLenHi = (m.length / 0x20000000) | 0,\n\t        bitLenLo = m.length << 3,\n\t        numZeros = (bytesLeft < 56) ? 56 : 120,\n\t        p = m.slice(m.length - bytesLeft, m.length);\n\n\t        p.push(0x80);\n\t        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }\n\t        p.push((bitLenHi >>> 24) & 0xff);\n\t        p.push((bitLenHi >>> 16) & 0xff);\n\t        p.push((bitLenHi >>> 8)  & 0xff);\n\t        p.push((bitLenHi >>> 0)  & 0xff);\n\t        p.push((bitLenLo >>> 24) & 0xff);\n\t        p.push((bitLenLo >>> 16) & 0xff);\n\t        p.push((bitLenLo >>> 8)  & 0xff);\n\t        p.push((bitLenLo >>> 0)  & 0xff);\n\n\t        blocks(p);\n\n\t        return [\n\t            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,\n\t            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,\n\t            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,\n\t            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,\n\t            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,\n\t            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,\n\t            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,\n\t            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff\n\t        ];\n\t    }\n\n\t    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n\t        // compress password if it's longer than hash block length\n\t        password = (password.length <= 64) ? password : SHA256(password);\n\n\t        const innerLen = 64 + salt.length + 4;\n\t        const inner = new Array(innerLen);\n\t        const outerKey = new Array(64);\n\n\t        let i;\n\t        let dk = [];\n\n\t        // inner = (password ^ ipad) || salt || counter\n\t        for (i = 0; i < 64; i++) { inner[i] = 0x36; }\n\t        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }\n\t        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }\n\t        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }\n\n\t        // outerKey = password ^ opad\n\t        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n\t        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n\t        // increments counter inside inner\n\t        function incrementCounter() {\n\t            for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n\t                inner[i]++;\n\t                if (inner[i] <= 0xff) return;\n\t                inner[i] = 0;\n\t            }\n\t        }\n\n\t        // output blocks = SHA256(outerKey || SHA256(inner)) ...\n\t        while (dkLen >= 32) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n\t            dkLen -= 32;\n\t        }\n\t        if (dkLen > 0) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n\t        }\n\n\t        return dk;\n\t    }\n\n\t    // The following is an adaptation of scryptsy\n\t    // See: https://www.npmjs.com/package/scryptsy\n\t    function blockmix_salsa8(BY, Yi, r, x, _X) {\n\t        let i;\n\n\t        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n\t        for (i = 0; i < 2 * r; i++) {\n\t            blockxor(BY, i * 16, _X, 16);\n\t            salsa20_8(_X, x);\n\t            arraycopy(_X, 0, BY, Yi + (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n\t        }\n\t    }\n\n\t    function R(a, b) {\n\t        return (a << b) | (a >>> (32 - b));\n\t    }\n\n\t    function salsa20_8(B, x) {\n\t        arraycopy(B, 0, x, 0, 16);\n\n\t        for (let i = 8; i > 0; i -= 2) {\n\t            x[ 4] ^= R(x[ 0] + x[12], 7);\n\t            x[ 8] ^= R(x[ 4] + x[ 0], 9);\n\t            x[12] ^= R(x[ 8] + x[ 4], 13);\n\t            x[ 0] ^= R(x[12] + x[ 8], 18);\n\t            x[ 9] ^= R(x[ 5] + x[ 1], 7);\n\t            x[13] ^= R(x[ 9] + x[ 5], 9);\n\t            x[ 1] ^= R(x[13] + x[ 9], 13);\n\t            x[ 5] ^= R(x[ 1] + x[13], 18);\n\t            x[14] ^= R(x[10] + x[ 6], 7);\n\t            x[ 2] ^= R(x[14] + x[10], 9);\n\t            x[ 6] ^= R(x[ 2] + x[14], 13);\n\t            x[10] ^= R(x[ 6] + x[ 2], 18);\n\t            x[ 3] ^= R(x[15] + x[11], 7);\n\t            x[ 7] ^= R(x[ 3] + x[15], 9);\n\t            x[11] ^= R(x[ 7] + x[ 3], 13);\n\t            x[15] ^= R(x[11] + x[ 7], 18);\n\t            x[ 1] ^= R(x[ 0] + x[ 3], 7);\n\t            x[ 2] ^= R(x[ 1] + x[ 0], 9);\n\t            x[ 3] ^= R(x[ 2] + x[ 1], 13);\n\t            x[ 0] ^= R(x[ 3] + x[ 2], 18);\n\t            x[ 6] ^= R(x[ 5] + x[ 4], 7);\n\t            x[ 7] ^= R(x[ 6] + x[ 5], 9);\n\t            x[ 4] ^= R(x[ 7] + x[ 6], 13);\n\t            x[ 5] ^= R(x[ 4] + x[ 7], 18);\n\t            x[11] ^= R(x[10] + x[ 9], 7);\n\t            x[ 8] ^= R(x[11] + x[10], 9);\n\t            x[ 9] ^= R(x[ 8] + x[11], 13);\n\t            x[10] ^= R(x[ 9] + x[ 8], 18);\n\t            x[12] ^= R(x[15] + x[14], 7);\n\t            x[13] ^= R(x[12] + x[15], 9);\n\t            x[14] ^= R(x[13] + x[12], 13);\n\t            x[15] ^= R(x[14] + x[13], 18);\n\t        }\n\n\t        for (let i = 0; i < 16; ++i) {\n\t            B[i] += x[i];\n\t        }\n\t    }\n\n\t    // naive approach... going back to loop unrolling may yield additional performance\n\t    function blockxor(S, Si, D, len) {\n\t        for (let i = 0; i < len; i++) {\n\t            D[i] ^= S[Si + i];\n\t        }\n\t    }\n\n\t    function arraycopy(src, srcPos, dest, destPos, length) {\n\t        while (length--) {\n\t            dest[destPos++] = src[srcPos++];\n\t        }\n\t    }\n\n\t    function checkBufferish(o) {\n\t        if (!o || typeof(o.length) !== 'number') { return false; }\n\n\t        for (let i = 0; i < o.length; i++) {\n\t            const v = o[i];\n\t            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function ensureInteger(value, name) {\n\t        if (typeof(value) !== \"number\" || (value % 1)) { throw new Error('invalid ' + name); }\n\t        return value;\n\t    }\n\n\t    // N = Cpu cost, r = Memory cost, p = parallelization cost\n\t    // callback(error, progress, key)\n\t    function _scrypt(password, salt, N, r, p, dkLen, callback) {\n\n\t        N = ensureInteger(N, 'N');\n\t        r = ensureInteger(r, 'r');\n\t        p = ensureInteger(p, 'p');\n\n\t        dkLen = ensureInteger(dkLen, 'dkLen');\n\n\t        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }\n\n\t        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }\n\t        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }\n\n\t        if (!checkBufferish(password)) {\n\t            throw new Error('password must be an array or buffer');\n\t        }\n\t        password = Array.prototype.slice.call(password);\n\n\t        if (!checkBufferish(salt)) {\n\t            throw new Error('salt must be an array or buffer');\n\t        }\n\t        salt = Array.prototype.slice.call(salt);\n\n\t        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n\t        const B = new Uint32Array(p * 32 * r);\n\t        for (let i = 0; i < B.length; i++) {\n\t            const j = i * 4;\n\t            B[i] = ((b[j + 3] & 0xff) << 24) |\n\t                   ((b[j + 2] & 0xff) << 16) |\n\t                   ((b[j + 1] & 0xff) << 8) |\n\t                   ((b[j + 0] & 0xff) << 0);\n\t        }\n\n\t        const XY = new Uint32Array(64 * r);\n\t        const V = new Uint32Array(32 * r * N);\n\n\t        const Yi = 32 * r;\n\n\t        // scratch space\n\t        const x = new Uint32Array(16);       // salsa20_8\n\t        const _X = new Uint32Array(16);      // blockmix_salsa8\n\n\t        const totalOps = p * N * 2;\n\t        let currentOp = 0;\n\t        let lastPercent10 = null;\n\n\t        // Set this to true to abandon the scrypt on the next step\n\t        let stop = false;\n\n\t        // State information\n\t        let state = 0;\n\t        let i0 = 0, i1;\n\t        let Bi;\n\n\t        // How many blockmix_salsa8 can we do per step?\n\t        const limit = callback ? parseInt(1000 / r): 0xffffffff;\n\n\t        // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n\t        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;\n\n\t        // This is really all I changed; making scryptsy a state machine so we occasionally\n\t        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n\t        const incrementalSMix = function() {\n\t            if (stop) {\n\t                return callback(new Error('cancelled'), currentOp / totalOps);\n\t            }\n\n\t            let steps;\n\n\t            switch (state) {\n\t                case 0:\n\t                    // for (var i = 0; i < p; i++)...\n\t                    Bi = i0 * 32 * r;\n\n\t                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1\n\n\t                    state = 1;                                         // Move to ROMix 2\n\t                    i1 = 0;\n\n\t                    // Fall through\n\n\t                case 1:\n\n\t                    // Run up to 1000 steps of the first inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                  // ROMix - 2\n\t                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);         // ROMix - 3\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    if (callback) {\n\t                        // Call the callback with the progress (optionally stopping us)\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    i1 = 0;                                          // Move to ROMix 6\n\t                    state = 2;\n\n\t                    // Fall through\n\n\t                case 2:\n\n\t                    // Run up to 1000 steps of the second inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                // ROMix - 6\n\t                        const offset = (2 * r - 1) * 16;             // ROMix - 7\n\t                        const j = XY[offset] & (N - 1);\n\t                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)...\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    // Call the callback with the progress (optionally stopping us)\n\t                    if (callback) {\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10\n\n\t                    // for (var i = 0; i < p; i++)...\n\t                    i0++;\n\t                    if (i0 < p) {\n\t                        state = 0;\n\t                        break;\n\t                    }\n\n\t                    b = [];\n\t                    for (let i = 0; i < B.length; i++) {\n\t                        b.push((B[i] >>  0) & 0xff);\n\t                        b.push((B[i] >>  8) & 0xff);\n\t                        b.push((B[i] >> 16) & 0xff);\n\t                        b.push((B[i] >> 24) & 0xff);\n\t                    }\n\n\t                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n\t                    // Send the result to the callback\n\t                    if (callback) { callback(null, 1.0, derivedKey); }\n\n\t                    // Done; don't break (which would reschedule)\n\t                    return derivedKey;\n\t            }\n\n\t            // Schedule the next steps\n\t            if (callback) { nextTick(incrementalSMix); }\n\t        };\n\n\t        // Run the smix state machine until completion\n\t        if (!callback) {\n\t            while (true) {\n\t                const derivedKey = incrementalSMix();\n\t                if (derivedKey != undefined) { return derivedKey; }\n\t            }\n\t        }\n\n\t        // Bootstrap the async incremental smix\n\t        incrementalSMix();\n\t    }\n\n\t    const lib = {\n\t        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {\n\t            return new Promise(function(resolve, reject) {\n\t                let lastProgress = 0;\n\t                if (progressCallback) { progressCallback(0); }\n\t                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {\n\t                    if (error) {\n\t                        reject(error);\n\t                    } else if (key) {\n\t                        if (progressCallback && lastProgress !== 1) {\n\t                            progressCallback(1);\n\t                        }\n\t                        resolve(new Uint8Array(key));\n\t                    } else if (progressCallback && progress !== lastProgress) {\n\t                        lastProgress = progress;\n\t                        return progressCallback(progress);\n\t                    }\n\t                });\n\t            });\n\t        },\n\t        syncScrypt: function(password, salt, N, r, p, dkLen) {\n\t            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n\t        }\n\t    };\n\n\t    // node.js\n\t    if (true) {\n\t       module.exports = lib;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\t})(commonjsGlobal);\n\t});\n\tvar scrypt_1 = scrypt.scrypt;\n\tvar scrypt_2 = scrypt.syncScrypt;\n\n\tvar rng;\n\n\tif (commonjsGlobal.crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  // Moderately fast, high quality\n\t  var _rnds8 = new Uint8Array(16);\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(_rnds8);\n\t    return _rnds8;\n\t  };\n\t}\n\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var  _rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\n\t    return _rnds;\n\t  };\n\t}\n\n\tvar rngBrowser = rng;\n\n\t//     uuid.js\n\t//\n\t//     Copyright (c) 2010-2012 Robert Kieffer\n\t//     MIT License - http://opensource.org/licenses/mit-license.php\n\n\t// Unique ID creation requires a high quality random # generator.  We feature\n\t// detect to determine the best RNG source, normalizing to a function that\n\t// returns 128-bits of randomness, since that's what's usually required\n\n\n\t// Maps for number <-> hex string conversion\n\tvar _byteToHex = [];\n\tvar _hexToByte = {};\n\tfor (var i = 0; i < 256; i++) {\n\t  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t  _hexToByte[_byteToHex[i]] = i;\n\t}\n\n\t// **`parse()` - Parse a UUID into it's component bytes**\n\tfunction parse(s, buf, offset) {\n\t  var i = (buf && offset) || 0, ii = 0;\n\n\t  buf = buf || [];\n\t  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n\t    if (ii < 16) { // Don't overflow!\n\t      buf[i + ii++] = _hexToByte[oct];\n\t    }\n\t  });\n\n\t  // Zero out remaining bytes if string was short\n\t  while (ii < 16) {\n\t    buf[i + ii++] = 0;\n\t  }\n\n\t  return buf;\n\t}\n\n\t// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n\tfunction unparse(buf, offset) {\n\t  var i = offset || 0, bth = _byteToHex;\n\t  return  bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\n\t// random #'s we need to init node and clockseq\n\tvar _seedBytes = rngBrowser();\n\n\t// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\tvar _nodeId = [\n\t  _seedBytes[0] | 0x01,\n\t  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t];\n\n\t// Per 4.2.2, randomize (14 bit) clockseq\n\tvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0, _lastNSecs = 0;\n\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\n\t  options = options || {};\n\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\n\t  // `node`\n\t  var node = options.node || _nodeId;\n\t  for (var n = 0; n < 6; n++) {\n\t    b[i + n] = node[n];\n\t  }\n\n\t  return buf ? buf : unparse(b);\n\t}\n\n\t// **`v4()` - Generate random UUID**\n\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v4(options, buf, offset) {\n\t  // Deprecated - 'format' argument, as supported in v1.2\n\t  var i = buf && offset || 0;\n\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\n\t  var rnds = options.random || (options.rng || rngBrowser)();\n\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ii++) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\n\t  return buf || unparse(rnds);\n\t}\n\n\t// Export public API\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\tuuid.parse = parse;\n\tuuid.unparse = unparse;\n\n\tvar uuid_1 = uuid;\n\n\tvar keystore = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar aes_js_1 = __importDefault(aesJs);\n\tvar scrypt$1 = __importStar(scrypt);\n\tvar uuid_1$1 = __importDefault(uuid_1);\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\t// Exported Types\n\tfunction hasMnemonic(value) {\n\t    return (value != null && value.mnemonic && value.mnemonic.phrase);\n\t}\n\tvar KeystoreAccount = /** @class */ (function (_super) {\n\t    __extends(KeystoreAccount, _super);\n\t    function KeystoreAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    KeystoreAccount.prototype.isKeystoreAccount = function (value) {\n\t        return !!(value && value._isKeystoreAccount);\n\t    };\n\t    return KeystoreAccount;\n\t}(lib$3.Description));\n\texports.KeystoreAccount = KeystoreAccount;\n\tfunction _decrypt(data, key, ciphertext) {\n\t    var cipher = utils$1.searchPath(data, \"crypto/cipher\");\n\t    if (cipher === \"aes-128-ctr\") {\n\t        var iv = utils$1.looseArrayify(utils$1.searchPath(data, \"crypto/cipherparams/iv\"));\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);\n\t        return lib$1.arrayify(aesCtr.decrypt(ciphertext));\n\t    }\n\t    return null;\n\t}\n\tfunction _getAccount(data, key) {\n\t    var ciphertext = utils$1.looseArrayify(utils$1.searchPath(data, \"crypto/ciphertext\"));\n\t    var computedMAC = lib$1.hexlify(lib$4.keccak256(lib$1.concat([key.slice(16, 32), ciphertext]))).substring(2);\n\t    if (computedMAC !== utils$1.searchPath(data, \"crypto/mac\").toLowerCase()) {\n\t        throw new Error(\"invalid password\");\n\t    }\n\t    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\t    if (!privateKey) {\n\t        logger.throwError(\"unsupported cipher\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"decrypt\"\n\t        });\n\t    }\n\t    var mnemonicKey = key.slice(32, 64);\n\t    var address = lib$g.computeAddress(privateKey);\n\t    if (data.address) {\n\t        var check = data.address.toLowerCase();\n\t        if (check.substring(0, 2) !== \"0x\") {\n\t            check = \"0x\" + check;\n\t        }\n\t        if (lib$6.getAddress(check) !== address) {\n\t            throw new Error(\"address mismatch\");\n\t        }\n\t    }\n\t    var account = {\n\t        _isKeystoreAccount: true,\n\t        address: address,\n\t        privateKey: lib$1.hexlify(privateKey)\n\t    };\n\t    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\t    if (utils$1.searchPath(data, \"x-ethers/version\") === \"0.1\") {\n\t        var mnemonicCiphertext = utils$1.looseArrayify(utils$1.searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n\t        var mnemonicIv = utils$1.looseArrayify(utils$1.searchPath(data, \"x-ethers/mnemonicCounter\"));\n\t        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t        var path = utils$1.searchPath(data, \"x-ethers/path\") || lib$h.defaultPath;\n\t        var locale = utils$1.searchPath(data, \"x-ethers/locale\") || \"en\";\n\t        var entropy = lib$1.arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\t        try {\n\t            var mnemonic = lib$h.entropyToMnemonic(entropy, locale);\n\t            var node = lib$h.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error(\"mnemonic mismatch\");\n\t            }\n\t            account.mnemonic = node.mnemonic;\n\t        }\n\t        catch (error) {\n\t            // If we don't have the locale wordlist installed to\n\t            // read this mnemonic, just bail and don't set the\n\t            // mnemonic\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n\t                throw error;\n\t            }\n\t        }\n\t    }\n\t    return new KeystoreAccount(account);\n\t}\n\tfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return lib$1.arrayify(browser$2.pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n\t    var passwordBytes = utils$1.getPassword(password);\n\t    var kdf = utils$1.searchPath(data, \"crypto/kdf\");\n\t    if (kdf && typeof (kdf) === \"string\") {\n\t        var throwError = function (name, value) {\n\t            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n\t        };\n\t        if (kdf.toLowerCase() === \"scrypt\") {\n\t            var salt = utils$1.looseArrayify(utils$1.searchPath(data, \"crypto/kdfparams/salt\"));\n\t            var N = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/n\"));\n\t            var r = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/r\"));\n\t            var p = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/p\"));\n\t            // Check for all required parameters\n\t            if (!N || !r || !p) {\n\t                throwError(\"kdf\", kdf);\n\t            }\n\t            // Make sure N is a power of 2\n\t            if ((N & (N - 1)) !== 0) {\n\t                throwError(\"N\", N);\n\t            }\n\t            var dkLen = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/dklen\"));\n\t            if (dkLen !== 32) {\n\t                throwError(\"dklen\", dkLen);\n\t            }\n\t            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\t        }\n\t        else if (kdf.toLowerCase() === \"pbkdf2\") {\n\t            var salt = utils$1.looseArrayify(utils$1.searchPath(data, \"crypto/kdfparams/salt\"));\n\t            var prfFunc = null;\n\t            var prf = utils$1.searchPath(data, \"crypto/kdfparams/prf\");\n\t            if (prf === \"hmac-sha256\") {\n\t                prfFunc = \"sha256\";\n\t            }\n\t            else if (prf === \"hmac-sha512\") {\n\t                prfFunc = \"sha512\";\n\t            }\n\t            else {\n\t                throwError(\"prf\", prf);\n\t            }\n\t            var count = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/c\"));\n\t            var dkLen = parseInt(utils$1.searchPath(data, \"crypto/kdfparams/dklen\"));\n\t            if (dkLen !== 32) {\n\t                throwError(\"dklen\", dkLen);\n\t            }\n\t            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n\t        }\n\t    }\n\t    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n\t}\n\tfunction decryptSync(json, password) {\n\t    var data = JSON.parse(json);\n\t    var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt$1.syncScrypt);\n\t    return _getAccount(data, key);\n\t}\n\texports.decryptSync = decryptSync;\n\tfunction decrypt(json, password, progressCallback) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var data, key;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    data = JSON.parse(json);\n\t                    return [4 /*yield*/, _computeKdfKey(data, password, pbkdf2, scrypt$1.scrypt, progressCallback)];\n\t                case 1:\n\t                    key = _a.sent();\n\t                    return [2 /*return*/, _getAccount(data, key)];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\tfunction encrypt(account, password, options, progressCallback) {\n\t    try {\n\t        // Check the address matches the private key\n\t        if (lib$6.getAddress(account.address) !== lib$g.computeAddress(account.privateKey)) {\n\t            throw new Error(\"address/privateKey mismatch\");\n\t        }\n\t        // Check the mnemonic (if any) matches the private key\n\t        if (hasMnemonic(account)) {\n\t            var mnemonic = account.mnemonic;\n\t            var node = lib$h.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || lib$h.defaultPath);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error(\"mnemonic mismatch\");\n\t            }\n\t        }\n\t    }\n\t    catch (e) {\n\t        return Promise.reject(e);\n\t    }\n\t    // The options are optional, so adjust the call as needed\n\t    if (typeof (options) === \"function\" && !progressCallback) {\n\t        progressCallback = options;\n\t        options = {};\n\t    }\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    var privateKey = lib$1.arrayify(account.privateKey);\n\t    var passwordBytes = utils$1.getPassword(password);\n\t    var entropy = null;\n\t    var path = null;\n\t    var locale = null;\n\t    if (hasMnemonic(account)) {\n\t        var srcMnemonic = account.mnemonic;\n\t        entropy = lib$1.arrayify(lib$h.mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n\t        path = srcMnemonic.path || lib$h.defaultPath;\n\t        locale = srcMnemonic.locale || \"en\";\n\t    }\n\t    var client = options.client;\n\t    if (!client) {\n\t        client = \"ethers.js\";\n\t    }\n\t    // Check/generate the salt\n\t    var salt = null;\n\t    if (options.salt) {\n\t        salt = lib$1.arrayify(options.salt);\n\t    }\n\t    else {\n\t        salt = browser$6.randomBytes(32);\n\t        ;\n\t    }\n\t    // Override initialization vector\n\t    var iv = null;\n\t    if (options.iv) {\n\t        iv = lib$1.arrayify(options.iv);\n\t        if (iv.length !== 16) {\n\t            throw new Error(\"invalid iv\");\n\t        }\n\t    }\n\t    else {\n\t        iv = browser$6.randomBytes(16);\n\t    }\n\t    // Override the uuid\n\t    var uuidRandom = null;\n\t    if (options.uuid) {\n\t        uuidRandom = lib$1.arrayify(options.uuid);\n\t        if (uuidRandom.length !== 16) {\n\t            throw new Error(\"invalid uuid\");\n\t        }\n\t    }\n\t    else {\n\t        uuidRandom = browser$6.randomBytes(16);\n\t    }\n\t    // Override the scrypt password-based key derivation function parameters\n\t    var N = (1 << 17), r = 8, p = 1;\n\t    if (options.scrypt) {\n\t        if (options.scrypt.N) {\n\t            N = options.scrypt.N;\n\t        }\n\t        if (options.scrypt.r) {\n\t            r = options.scrypt.r;\n\t        }\n\t        if (options.scrypt.p) {\n\t            p = options.scrypt.p;\n\t        }\n\t    }\n\t    // We take 64 bytes:\n\t    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n\t    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\t    return scrypt$1.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {\n\t        key = lib$1.arrayify(key);\n\t        // This will be used to encrypt the wallet (as per Web3 secret storage)\n\t        var derivedKey = key.slice(0, 16);\n\t        var macPrefix = key.slice(16, 32);\n\t        // This will be used to encrypt the mnemonic phrase (if any)\n\t        var mnemonicKey = key.slice(32, 64);\n\t        // Encrypt the private key\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n\t        var ciphertext = lib$1.arrayify(aesCtr.encrypt(privateKey));\n\t        // Compute the message authentication code, used to check the password\n\t        var mac = lib$4.keccak256(lib$1.concat([macPrefix, ciphertext]));\n\t        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\t        var data = {\n\t            address: account.address.substring(2).toLowerCase(),\n\t            id: uuid_1$1.default.v4({ random: uuidRandom }),\n\t            version: 3,\n\t            Crypto: {\n\t                cipher: \"aes-128-ctr\",\n\t                cipherparams: {\n\t                    iv: lib$1.hexlify(iv).substring(2),\n\t                },\n\t                ciphertext: lib$1.hexlify(ciphertext).substring(2),\n\t                kdf: \"scrypt\",\n\t                kdfparams: {\n\t                    salt: lib$1.hexlify(salt).substring(2),\n\t                    n: N,\n\t                    dklen: 32,\n\t                    p: p,\n\t                    r: r\n\t                },\n\t                mac: mac.substring(2)\n\t            }\n\t        };\n\t        // If we have a mnemonic, encrypt it into the JSON wallet\n\t        if (entropy) {\n\t            var mnemonicIv = browser$6.randomBytes(16);\n\t            var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t            var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t            var mnemonicCiphertext = lib$1.arrayify(mnemonicAesCtr.encrypt(entropy));\n\t            var now = new Date();\n\t            var timestamp = (now.getUTCFullYear() + \"-\" +\n\t                utils$1.zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n\t                utils$1.zpad(now.getUTCDate(), 2) + \"T\" +\n\t                utils$1.zpad(now.getUTCHours(), 2) + \"-\" +\n\t                utils$1.zpad(now.getUTCMinutes(), 2) + \"-\" +\n\t                utils$1.zpad(now.getUTCSeconds(), 2) + \".0Z\");\n\t            data[\"x-ethers\"] = {\n\t                client: client,\n\t                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n\t                mnemonicCounter: lib$1.hexlify(mnemonicIv).substring(2),\n\t                mnemonicCiphertext: lib$1.hexlify(mnemonicCiphertext).substring(2),\n\t                path: path,\n\t                locale: locale,\n\t                version: \"0.1\"\n\t            };\n\t        }\n\t        return JSON.stringify(data);\n\t    });\n\t}\n\texports.encrypt = encrypt;\n\t});\n\n\tvar keystore$1 = unwrapExports(keystore);\n\tvar keystore_1 = keystore.KeystoreAccount;\n\tvar keystore_2 = keystore.decryptSync;\n\tvar keystore_3 = keystore.decrypt;\n\tvar keystore_4 = keystore.encrypt;\n\n\tvar lib$i = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.decryptCrowdsale = crowdsale.decrypt;\n\n\texports.getJsonWalletAddress = inspect.getJsonWalletAddress;\n\texports.isCrowdsaleWallet = inspect.isCrowdsaleWallet;\n\texports.isKeystoreWallet = inspect.isKeystoreWallet;\n\n\texports.decryptKeystore = keystore.decrypt;\n\texports.decryptKeystoreSync = keystore.decryptSync;\n\texports.encryptKeystore = keystore.encrypt;\n\tfunction decryptJsonWallet(json, password, progressCallback) {\n\t    if (inspect.isCrowdsaleWallet(json)) {\n\t        if (progressCallback) {\n\t            progressCallback(0);\n\t        }\n\t        var account = crowdsale.decrypt(json, password);\n\t        if (progressCallback) {\n\t            progressCallback(1);\n\t        }\n\t        return Promise.resolve(account);\n\t    }\n\t    if (inspect.isKeystoreWallet(json)) {\n\t        return keystore.decrypt(json, password, progressCallback);\n\t    }\n\t    return Promise.reject(new Error(\"invalid JSON wallet\"));\n\t}\n\texports.decryptJsonWallet = decryptJsonWallet;\n\tfunction decryptJsonWalletSync(json, password) {\n\t    if (inspect.isCrowdsaleWallet(json)) {\n\t        return crowdsale.decrypt(json, password);\n\t    }\n\t    if (inspect.isKeystoreWallet(json)) {\n\t        return keystore.decryptSync(json, password);\n\t    }\n\t    throw new Error(\"invalid JSON wallet\");\n\t}\n\texports.decryptJsonWalletSync = decryptJsonWalletSync;\n\t});\n\n\tvar index$i = unwrapExports(lib$i);\n\tvar lib_1$i = lib$i.decryptCrowdsale;\n\tvar lib_2$h = lib$i.getJsonWalletAddress;\n\tvar lib_3$e = lib$i.isCrowdsaleWallet;\n\tvar lib_4$b = lib$i.isKeystoreWallet;\n\tvar lib_5$a = lib$i.decryptKeystore;\n\tvar lib_6$6 = lib$i.decryptKeystoreSync;\n\tvar lib_7$5 = lib$i.encryptKeystore;\n\tvar lib_8$4 = lib$i.decryptJsonWallet;\n\tvar lib_9$4 = lib$i.decryptJsonWalletSync;\n\n\tvar _version$C = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"wallet/5.0.0-beta.141\";\n\t});\n\n\tvar _version$D = unwrapExports(_version$C);\n\tvar _version_1$j = _version$C.version;\n\n\tvar lib$j = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$C.version);\n\tfunction isAccount(value) {\n\t    return (value != null && lib$1.isHexString(value.privateKey, 32) && value.address != null);\n\t}\n\tfunction hasMnemonic(value) {\n\t    var mnemonic = value.mnemonic;\n\t    return (mnemonic && mnemonic.phrase);\n\t}\n\tvar Wallet = /** @class */ (function (_super) {\n\t    __extends(Wallet, _super);\n\t    function Wallet(privateKey, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Wallet);\n\t        _this = _super.call(this) || this;\n\t        if (isAccount(privateKey)) {\n\t            var signingKey_1 = new lib$f.SigningKey(privateKey.privateKey);\n\t            lib$3.defineReadOnly(_this, \"_signingKey\", function () { return signingKey_1; });\n\t            lib$3.defineReadOnly(_this, \"address\", lib$g.computeAddress(_this.publicKey));\n\t            if (_this.address !== lib$6.getAddress(privateKey.address)) {\n\t                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n\t            }\n\t            if (hasMnemonic(privateKey)) {\n\t                var srcMnemonic_1 = privateKey.mnemonic;\n\t                lib$3.defineReadOnly(_this, \"_mnemonic\", function () { return ({\n\t                    phrase: srcMnemonic_1.phrase,\n\t                    path: srcMnemonic_1.path || lib$h.defaultPath,\n\t                    locale: srcMnemonic_1.locale || \"en\"\n\t                }); });\n\t                var mnemonic = _this.mnemonic;\n\t                var node = lib$h.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n\t                if (lib$g.computeAddress(node.privateKey) !== _this.address) {\n\t                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n\t                }\n\t            }\n\t            else {\n\t                lib$3.defineReadOnly(_this, \"_mnemonic\", function () { return null; });\n\t            }\n\t        }\n\t        else {\n\t            if (lib$f.SigningKey.isSigningKey(privateKey)) {\n\t                if (privateKey.curve !== \"secp256k1\") {\n\t                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n\t                }\n\t                lib$3.defineReadOnly(_this, \"_signingKey\", function () { return privateKey; });\n\t            }\n\t            else {\n\t                var signingKey_2 = new lib$f.SigningKey(privateKey);\n\t                lib$3.defineReadOnly(_this, \"_signingKey\", function () { return signingKey_2; });\n\t            }\n\t            lib$3.defineReadOnly(_this, \"_mnemonic\", function () { return null; });\n\t            lib$3.defineReadOnly(_this, \"address\", lib$g.computeAddress(_this.publicKey));\n\t        }\n\t        if (provider && !lib$b.Provider.isProvider(provider)) {\n\t            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n\t        }\n\t        lib$3.defineReadOnly(_this, \"provider\", provider || null);\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Wallet.prototype, \"mnemonic\", {\n\t        get: function () { return this._mnemonic(); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, \"privateKey\", {\n\t        get: function () { return this._signingKey().privateKey; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, \"publicKey\", {\n\t        get: function () { return this._signingKey().publicKey; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Wallet.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    Wallet.prototype.connect = function (provider) {\n\t        return new Wallet(this, provider);\n\t    };\n\t    Wallet.prototype.signTransaction = function (transaction) {\n\t        var _this = this;\n\t        return lib$3.resolveProperties(transaction).then(function (tx) {\n\t            if (tx.from != null) {\n\t                if (lib$6.getAddress(tx.from) !== _this.address) {\n\t                    throw new Error(\"transaction from address mismatch\");\n\t                }\n\t                delete tx.from;\n\t            }\n\t            var signature = _this._signingKey().signDigest(lib$4.keccak256(lib$g.serialize(tx)));\n\t            return lib$g.serialize(tx, signature);\n\t        });\n\t    };\n\t    Wallet.prototype.signMessage = function (message) {\n\t        return Promise.resolve(lib$1.joinSignature(this._signingKey().signDigest(lib$9.hashMessage(message))));\n\t    };\n\t    Wallet.prototype.encrypt = function (password, options, progressCallback) {\n\t        if (typeof (options) === \"function\" && !progressCallback) {\n\t            progressCallback = options;\n\t            options = {};\n\t        }\n\t        if (progressCallback && typeof (progressCallback) !== \"function\") {\n\t            throw new Error(\"invalid callback\");\n\t        }\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        return lib$i.encryptKeystore(this, password, options, progressCallback);\n\t    };\n\t    /**\n\t     *  Static methods to create Wallet instances.\n\t     */\n\t    Wallet.createRandom = function (options) {\n\t        var entropy = browser$6.randomBytes(16);\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        if (options.extraEntropy) {\n\t            entropy = lib$1.arrayify(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat([entropy, options.extraEntropy])), 0, 16));\n\t        }\n\t        var mnemonic = lib$h.entropyToMnemonic(entropy, options.locale);\n\t        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n\t    };\n\t    Wallet.fromEncryptedJson = function (json, password, progressCallback) {\n\t        return lib$i.decryptJsonWallet(json, password, progressCallback).then(function (account) {\n\t            return new Wallet(account);\n\t        });\n\t    };\n\t    Wallet.fromEncryptedJsonSync = function (json, password) {\n\t        return new Wallet(lib$i.decryptJsonWalletSync(json, password));\n\t    };\n\t    Wallet.fromMnemonic = function (mnemonic, path, wordlist) {\n\t        if (!path) {\n\t            path = lib$h.defaultPath;\n\t        }\n\t        return new Wallet(lib$h.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n\t    };\n\t    return Wallet;\n\t}(lib$c.Signer));\n\texports.Wallet = Wallet;\n\tfunction verifyMessage(message, signature) {\n\t    return lib$g.recoverAddress(lib$9.hashMessage(message), signature);\n\t}\n\texports.verifyMessage = verifyMessage;\n\t});\n\n\tvar index$j = unwrapExports(lib$j);\n\tvar lib_1$j = lib$j.Wallet;\n\tvar lib_2$i = lib$j.verifyMessage;\n\n\tvar _version$E = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"networks/5.0.0-beta.137\";\n\t});\n\n\tvar _version$F = unwrapExports(_version$E);\n\tvar _version_1$k = _version$E.version;\n\n\tvar lib$k = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$E.version);\n\tfunction ethDefaultProvider(network) {\n\t    return function (providers, options) {\n\t        if (options == null) {\n\t            options = {};\n\t        }\n\t        var providerList = [];\n\t        if (providers.InfuraProvider) {\n\t            try {\n\t                providerList.push(new providers.InfuraProvider(network, options.infura));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.EtherscanProvider) {\n\t            try {\n\t                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.AlchemyProvider) {\n\t            try {\n\t                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.CloudflareProvider) {\n\t            try {\n\t                providerList.push(new providers.CloudflareProvider(network));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providerList.length === 0) {\n\t            return null;\n\t        }\n\t        if (providers.FallbackProvider) {\n\t            var quorum = 1;\n\t            if (options.quorum != null) {\n\t                quorum = options.quorum;\n\t            }\n\t            else if (network === \"homestead\") {\n\t                quorum = 2;\n\t            }\n\t            return new providers.FallbackProvider(providerList, quorum);\n\t        }\n\t        return providerList[0];\n\t    };\n\t}\n\tfunction etcDefaultProvider(url, network) {\n\t    return function (providers, options) {\n\t        if (providers.JsonRpcProvider) {\n\t            return new providers.JsonRpcProvider(url, network);\n\t        }\n\t        return null;\n\t    };\n\t}\n\tvar homestead = {\n\t    chainId: 1,\n\t    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t    name: \"homestead\",\n\t    _defaultProvider: ethDefaultProvider(\"homestead\")\n\t};\n\tvar ropsten = {\n\t    chainId: 3,\n\t    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t    name: \"ropsten\",\n\t    _defaultProvider: ethDefaultProvider(\"ropsten\")\n\t};\n\tvar classicMordor = {\n\t    chainId: 63,\n\t    name: \"classicMordor\",\n\t    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n\t};\n\tvar networks = {\n\t    unspecified: {\n\t        chainId: 0,\n\t        name: \"unspecified\"\n\t    },\n\t    homestead: homestead,\n\t    mainnet: homestead,\n\t    morden: {\n\t        chainId: 2,\n\t        name: \"morden\"\n\t    },\n\t    ropsten: ropsten,\n\t    testnet: ropsten,\n\t    rinkeby: {\n\t        chainId: 4,\n\t        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t        name: \"rinkeby\",\n\t        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n\t    },\n\t    kovan: {\n\t        chainId: 42,\n\t        name: \"kovan\",\n\t        _defaultProvider: ethDefaultProvider(\"kovan\")\n\t    },\n\t    goerli: {\n\t        chainId: 5,\n\t        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t        name: \"goerli\",\n\t        _defaultProvider: ethDefaultProvider(\"goerli\")\n\t    },\n\t    // ETC (See: #351)\n\t    classic: {\n\t        chainId: 61,\n\t        name: \"classic\",\n\t        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/etc\", \"classic\")\n\t    },\n\t    classicMorden: {\n\t        chainId: 62,\n\t        name: \"classicMorden\",\n\t    },\n\t    classicMordor: classicMordor,\n\t    classicTestnet: classicMordor,\n\t    classicKotti: {\n\t        chainId: 6,\n\t        name: \"classicKotti\",\n\t        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/kotti\", \"classicKotti\")\n\t    },\n\t};\n\t/**\n\t *  getNetwork\n\t *\n\t *  Converts a named common networks or chain ID (network ID) to a Network\n\t *  and verifies a network is a valid Network..\n\t */\n\tfunction getNetwork(network) {\n\t    // No network (null)\n\t    if (network == null) {\n\t        return null;\n\t    }\n\t    if (typeof (network) === \"number\") {\n\t        for (var name_1 in networks) {\n\t            var standard_1 = networks[name_1];\n\t            if (standard_1.chainId === network) {\n\t                return {\n\t                    name: standard_1.name,\n\t                    chainId: standard_1.chainId,\n\t                    ensAddress: (standard_1.ensAddress || null),\n\t                    _defaultProvider: (standard_1._defaultProvider || null)\n\t                };\n\t            }\n\t        }\n\t        return {\n\t            chainId: network,\n\t            name: \"unknown\"\n\t        };\n\t    }\n\t    if (typeof (network) === \"string\") {\n\t        var standard_2 = networks[network];\n\t        if (standard_2 == null) {\n\t            return null;\n\t        }\n\t        return {\n\t            name: standard_2.name,\n\t            chainId: standard_2.chainId,\n\t            ensAddress: standard_2.ensAddress,\n\t            _defaultProvider: (standard_2._defaultProvider || null)\n\t        };\n\t    }\n\t    var standard = networks[network.name];\n\t    // Not a standard network; check that it is a valid network in general\n\t    if (!standard) {\n\t        if (typeof (network.chainId) !== \"number\") {\n\t            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n\t        }\n\t        return network;\n\t    }\n\t    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n\t    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n\t        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n\t    }\n\t    // Standard Network (allow overriding the ENS address)\n\t    return {\n\t        name: network.name,\n\t        chainId: standard.chainId,\n\t        ensAddress: (network.ensAddress || standard.ensAddress || null),\n\t        _defaultProvider: (network._defaultProvider || standard._defaultProvider || null)\n\t    };\n\t}\n\texports.getNetwork = getNetwork;\n\t});\n\n\tvar index$k = unwrapExports(lib$k);\n\tvar lib_1$k = lib$k.getNetwork;\n\n\tvar browser$8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tfunction decode(textData) {\n\t    textData = atob(textData);\n\t    var data = [];\n\t    for (var i = 0; i < textData.length; i++) {\n\t        data.push(textData.charCodeAt(i));\n\t    }\n\t    return lib$1.arrayify(data);\n\t}\n\texports.decode = decode;\n\tfunction encode(data) {\n\t    data = lib$1.arrayify(data);\n\t    var textData = \"\";\n\t    for (var i = 0; i < data.length; i++) {\n\t        textData += String.fromCharCode(data[i]);\n\t    }\n\t    return btoa(textData);\n\t}\n\texports.encode = encode;\n\t});\n\n\tvar browser$9 = unwrapExports(browser$8);\n\tvar browser_1$4 = browser$8.decode;\n\tvar browser_2$3 = browser$8.encode;\n\n\tvar _version$G = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"web/5.0.0-beta.142\";\n\t});\n\n\tvar _version$H = unwrapExports(_version$G);\n\tvar _version_1$l = _version$G.version;\n\n\tvar browserGeturl = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tfunction getUrl(href, options) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var request, response, body, headers;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    if (options == null) {\n\t                        options = {};\n\t                    }\n\t                    request = {\n\t                        method: (options.method || \"GET\"),\n\t                        headers: (options.headers || {}),\n\t                        body: (options.body || undefined),\n\t                        mode: \"cors\",\n\t                        cache: \"no-cache\",\n\t                        credentials: \"same-origin\",\n\t                        redirect: \"follow\",\n\t                        referrer: \"client\",\n\t                    };\n\t                    return [4 /*yield*/, fetch(href, request)];\n\t                case 1:\n\t                    response = _a.sent();\n\t                    return [4 /*yield*/, response.text()];\n\t                case 2:\n\t                    body = _a.sent();\n\t                    headers = {};\n\t                    if (response.headers.forEach) {\n\t                        response.headers.forEach(function (value, key) {\n\t                            headers[key.toLowerCase()] = value;\n\t                        });\n\t                    }\n\t                    else {\n\t                        ((response.headers).keys)().forEach(function (key) {\n\t                            headers[key.toLowerCase()] = response.headers.get(key);\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, {\n\t                            headers: headers,\n\t                            statusCode: response.status,\n\t                            statusMessage: response.statusText,\n\t                            body: body,\n\t                        }];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.getUrl = getUrl;\n\t});\n\n\tvar browserGeturl$1 = unwrapExports(browserGeturl);\n\tvar browserGeturl_1 = browserGeturl.getUrl;\n\n\tvar lib$l = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$G.version);\n\n\tfunction fetchJson(connection, json, processFunc) {\n\t    var headers = {};\n\t    var url = null;\n\t    // @TODO: Allow ConnectionInfo to override some of these values\n\t    var options = {\n\t        method: \"GET\",\n\t    };\n\t    var allow304 = false;\n\t    var timeout = 2 * 60 * 1000;\n\t    if (typeof (connection) === \"string\") {\n\t        url = connection;\n\t    }\n\t    else if (typeof (connection) === \"object\") {\n\t        if (connection == null || connection.url == null) {\n\t            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n\t        }\n\t        url = connection.url;\n\t        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n\t            timeout = connection.timeout;\n\t        }\n\t        if (connection.headers) {\n\t            for (var key in connection.headers) {\n\t                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n\t                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n\t                    allow304 = true;\n\t                }\n\t            }\n\t        }\n\t        if (connection.user != null && connection.password != null) {\n\t            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n\t                logger.throwError(\"basic authentication requires a secure https url\", lib.Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n\t            }\n\t            var authorization = connection.user + \":\" + connection.password;\n\t            headers[\"authorization\"] = {\n\t                key: \"Authorization\",\n\t                value: \"Basic \" + browser$8.encode(lib$8.toUtf8Bytes(authorization))\n\t            };\n\t        }\n\t    }\n\t    if (json) {\n\t        options.method = \"POST\";\n\t        options.body = json;\n\t        headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/json\" };\n\t    }\n\t    var flatHeaders = {};\n\t    Object.keys(headers).forEach(function (key) {\n\t        var header = headers[key];\n\t        flatHeaders[header.key] = header.value;\n\t    });\n\t    options.headers = flatHeaders;\n\t    var runningTimeout = (function () {\n\t        var timer = null;\n\t        var promise = new Promise(function (resolve, reject) {\n\t            if (timeout) {\n\t                timer = setTimeout(function () {\n\t                    if (timer == null) {\n\t                        return;\n\t                    }\n\t                    timer = null;\n\t                    reject(logger.makeError(\"timeout\", lib.Logger.errors.TIMEOUT, {\n\t                        requestBody: (options.body || null),\n\t                        requestMethod: options.method,\n\t                        timeout: timeout,\n\t                        url: url\n\t                    }));\n\t                }, timeout);\n\t            }\n\t        });\n\t        var cancel = function () {\n\t            if (timer == null) {\n\t                return;\n\t            }\n\t            clearTimeout(timer);\n\t            timer = null;\n\t        };\n\t        return { promise: promise, cancel: cancel };\n\t    })();\n\t    var runningFetch = (function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var response, error_1, body, json, error_2;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        response = null;\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, browserGeturl.getUrl(url, options)];\n\t                    case 2:\n\t                        response = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 3:\n\t                        error_1 = _a.sent();\n\t                        response = error_1.response;\n\t                        if (response == null) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError(\"missing response\", lib.Logger.errors.SERVER_ERROR, {\n\t                                requestBody: (options.body || null),\n\t                                requestMethod: options.method,\n\t                                serverError: error_1,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        return [3 /*break*/, 4];\n\t                    case 4:\n\t                        body = response.body;\n\t                        if (allow304 && response.statusCode === 304) {\n\t                            body = null;\n\t                        }\n\t                        else if (response.statusCode < 200 || response.statusCode >= 300) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError(\"bad response\", lib.Logger.errors.SERVER_ERROR, {\n\t                                status: response.statusCode,\n\t                                headers: response.headers,\n\t                                body: body,\n\t                                requestBody: (options.body || null),\n\t                                requestMethod: options.method,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        runningTimeout.cancel();\n\t                        json = null;\n\t                        if (body != null) {\n\t                            try {\n\t                                json = JSON.parse(body);\n\t                            }\n\t                            catch (error) {\n\t                                logger.throwError(\"invalid JSON\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    body: body,\n\t                                    error: error,\n\t                                    requestBody: (options.body || null),\n\t                                    requestMethod: options.method,\n\t                                    url: url\n\t                                });\n\t                            }\n\t                        }\n\t                        if (!processFunc) return [3 /*break*/, 8];\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        _a.trys.push([5, 7, , 8]);\n\t                        return [4 /*yield*/, processFunc(json, response)];\n\t                    case 6:\n\t                        json = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 7:\n\t                        error_2 = _a.sent();\n\t                        logger.throwError(\"processing response error\", lib.Logger.errors.SERVER_ERROR, {\n\t                            body: json,\n\t                            error: error_2,\n\t                            requestBody: (options.body || null),\n\t                            requestMethod: options.method,\n\t                            url: url\n\t                        });\n\t                        return [3 /*break*/, 8];\n\t                    case 8: return [2 /*return*/, json];\n\t                }\n\t            });\n\t        });\n\t    })();\n\t    return Promise.race([runningTimeout.promise, runningFetch]);\n\t}\n\texports.fetchJson = fetchJson;\n\tfunction poll(func, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    options = lib$3.shallowCopy(options);\n\t    if (options.floor == null) {\n\t        options.floor = 0;\n\t    }\n\t    if (options.ceiling == null) {\n\t        options.ceiling = 10000;\n\t    }\n\t    if (options.interval == null) {\n\t        options.interval = 250;\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t        var timer = null;\n\t        var done = false;\n\t        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n\t        var cancel = function () {\n\t            if (done) {\n\t                return false;\n\t            }\n\t            done = true;\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t            }\n\t            return true;\n\t        };\n\t        if (options.timeout) {\n\t            timer = setTimeout(function () {\n\t                if (cancel()) {\n\t                    reject(new Error(\"timeout\"));\n\t                }\n\t            }, options.timeout);\n\t        }\n\t        var retryLimit = options.retryLimit;\n\t        var attempt = 0;\n\t        function check() {\n\t            return func().then(function (result) {\n\t                // If we have a result, or are allowed null then we're done\n\t                if (result !== undefined) {\n\t                    if (cancel()) {\n\t                        resolve(result);\n\t                    }\n\t                }\n\t                else if (options.oncePoll) {\n\t                    options.oncePoll.once(\"poll\", check);\n\t                }\n\t                else if (options.onceBlock) {\n\t                    options.onceBlock.once(\"block\", check);\n\t                    // Otherwise, exponential back-off (up to 10s) our next request\n\t                }\n\t                else if (!done) {\n\t                    attempt++;\n\t                    if (attempt > retryLimit) {\n\t                        if (cancel()) {\n\t                            reject(new Error(\"retry limit reached\"));\n\t                        }\n\t                        return;\n\t                    }\n\t                    var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                    if (timeout < options.floor) {\n\t                        timeout = options.floor;\n\t                    }\n\t                    if (timeout > options.ceiling) {\n\t                        timeout = options.ceiling;\n\t                    }\n\t                    setTimeout(check, timeout);\n\t                }\n\t                return null;\n\t            }, function (error) {\n\t                if (cancel()) {\n\t                    reject(error);\n\t                }\n\t            });\n\t        }\n\t        check();\n\t    });\n\t}\n\texports.poll = poll;\n\t});\n\n\tvar index$l = unwrapExports(lib$l);\n\tvar lib_1$l = lib$l.fetchJson;\n\tvar lib_2$j = lib$l.poll;\n\n\tvar _version$I = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"providers/5.0.0-beta.171\";\n\t});\n\n\tvar _version$J = unwrapExports(_version$I);\n\tvar _version_1$m = _version$I.version;\n\n\tvar formatter = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar Formatter = /** @class */ (function () {\n\t    function Formatter() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, Formatter);\n\t        this.formats = this.getDefaultFormats();\n\t    }\n\t    Formatter.prototype.getDefaultFormats = function () {\n\t        var _this = this;\n\t        var formats = ({});\n\t        var address = this.address.bind(this);\n\t        var bigNumber = this.bigNumber.bind(this);\n\t        var blockTag = this.blockTag.bind(this);\n\t        var data = this.data.bind(this);\n\t        var hash = this.hash.bind(this);\n\t        var hex = this.hex.bind(this);\n\t        var number = this.number.bind(this);\n\t        var strictData = function (v) { return _this.data(v, true); };\n\t        formats.transaction = {\n\t            hash: hash,\n\t            blockHash: Formatter.allowNull(hash, null),\n\t            blockNumber: Formatter.allowNull(number, null),\n\t            transactionIndex: Formatter.allowNull(number, null),\n\t            confirmations: Formatter.allowNull(number, null),\n\t            from: address,\n\t            gasPrice: bigNumber,\n\t            gasLimit: bigNumber,\n\t            to: Formatter.allowNull(address, null),\n\t            value: bigNumber,\n\t            nonce: number,\n\t            data: data,\n\t            r: Formatter.allowNull(this.uint256),\n\t            s: Formatter.allowNull(this.uint256),\n\t            v: Formatter.allowNull(number),\n\t            creates: Formatter.allowNull(address, null),\n\t            raw: Formatter.allowNull(data),\n\t        };\n\t        formats.transactionRequest = {\n\t            from: Formatter.allowNull(address),\n\t            nonce: Formatter.allowNull(number),\n\t            gasLimit: Formatter.allowNull(bigNumber),\n\t            gasPrice: Formatter.allowNull(bigNumber),\n\t            to: Formatter.allowNull(address),\n\t            value: Formatter.allowNull(bigNumber),\n\t            data: Formatter.allowNull(strictData),\n\t        };\n\t        formats.receiptLog = {\n\t            transactionIndex: number,\n\t            blockNumber: number,\n\t            transactionHash: hash,\n\t            address: address,\n\t            topics: Formatter.arrayOf(hash),\n\t            data: data,\n\t            logIndex: number,\n\t            blockHash: hash,\n\t        };\n\t        formats.receipt = {\n\t            to: Formatter.allowNull(this.address, null),\n\t            from: Formatter.allowNull(this.address, null),\n\t            contractAddress: Formatter.allowNull(address, null),\n\t            transactionIndex: number,\n\t            root: Formatter.allowNull(hash),\n\t            gasUsed: bigNumber,\n\t            logsBloom: Formatter.allowNull(data),\n\t            blockHash: hash,\n\t            transactionHash: hash,\n\t            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n\t            blockNumber: number,\n\t            confirmations: Formatter.allowNull(number, null),\n\t            cumulativeGasUsed: bigNumber,\n\t            status: Formatter.allowNull(number)\n\t        };\n\t        formats.block = {\n\t            hash: hash,\n\t            parentHash: hash,\n\t            number: number,\n\t            timestamp: number,\n\t            nonce: Formatter.allowNull(hex),\n\t            difficulty: this.difficulty.bind(this),\n\t            gasLimit: bigNumber,\n\t            gasUsed: bigNumber,\n\t            miner: address,\n\t            extraData: data,\n\t            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\t        };\n\t        formats.blockWithTransactions = lib$3.shallowCopy(formats.block);\n\t        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\t        formats.filter = {\n\t            fromBlock: Formatter.allowNull(blockTag, undefined),\n\t            toBlock: Formatter.allowNull(blockTag, undefined),\n\t            blockHash: Formatter.allowNull(hash, undefined),\n\t            address: Formatter.allowNull(address, undefined),\n\t            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n\t        };\n\t        formats.filterLog = {\n\t            blockNumber: Formatter.allowNull(number),\n\t            blockHash: Formatter.allowNull(hash),\n\t            transactionIndex: number,\n\t            removed: Formatter.allowNull(this.boolean.bind(this)),\n\t            address: address,\n\t            data: Formatter.allowFalsish(data, \"0x\"),\n\t            topics: Formatter.arrayOf(hash),\n\t            transactionHash: hash,\n\t            logIndex: number,\n\t        };\n\t        return formats;\n\t    };\n\t    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n\t    // Strict! Used on input.\n\t    Formatter.prototype.number = function (number) {\n\t        return lib$2.BigNumber.from(number).toNumber();\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.bigNumber = function (value) {\n\t        return lib$2.BigNumber.from(value);\n\t    };\n\t    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n\t    Formatter.prototype.boolean = function (value) {\n\t        if (typeof (value) === \"boolean\") {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            value = value.toLowerCase();\n\t            if (value === \"true\") {\n\t                return true;\n\t            }\n\t            if (value === \"false\") {\n\t                return false;\n\t            }\n\t        }\n\t        throw new Error(\"invalid boolean - \" + value);\n\t    };\n\t    Formatter.prototype.hex = function (value, strict) {\n\t        if (typeof (value) === \"string\") {\n\t            if (!strict && value.substring(0, 2) !== \"0x\") {\n\t                value = \"0x\" + value;\n\t            }\n\t            if (lib$1.isHexString(value)) {\n\t                return value.toLowerCase();\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n\t    };\n\t    Formatter.prototype.data = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if ((result.length % 2) !== 0) {\n\t            throw new Error(\"invalid data; odd-length - \" + value);\n\t        }\n\t        return result;\n\t    };\n\t    // Requires an address\n\t    // Strict! Used on input.\n\t    Formatter.prototype.address = function (value) {\n\t        return lib$6.getAddress(value);\n\t    };\n\t    Formatter.prototype.callAddress = function (value) {\n\t        if (!lib$1.isHexString(value, 32)) {\n\t            return null;\n\t        }\n\t        var address = lib$6.getAddress(lib$1.hexDataSlice(value, 12));\n\t        return (address === lib$7.AddressZero) ? null : address;\n\t    };\n\t    Formatter.prototype.contractAddress = function (value) {\n\t        return lib$6.getContractAddress(value);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.blockTag = function (blockTag) {\n\t        if (blockTag == null) {\n\t            return \"latest\";\n\t        }\n\t        if (blockTag === \"earliest\") {\n\t            return \"0x0\";\n\t        }\n\t        if (blockTag === \"latest\" || blockTag === \"pending\") {\n\t            return blockTag;\n\t        }\n\t        if (typeof (blockTag) === \"number\" || lib$1.isHexString(blockTag)) {\n\t            return lib$1.hexValue(blockTag);\n\t        }\n\t        throw new Error(\"invalid blockTag\");\n\t    };\n\t    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n\t    Formatter.prototype.hash = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if (lib$1.hexDataLength(result) !== 32) {\n\t            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n\t        }\n\t        return result;\n\t    };\n\t    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n\t    Formatter.prototype.difficulty = function (value) {\n\t        if (value == null) {\n\t            return null;\n\t        }\n\t        var v = lib$2.BigNumber.from(value);\n\t        try {\n\t            return v.toNumber();\n\t        }\n\t        catch (error) { }\n\t        return null;\n\t    };\n\t    Formatter.prototype.uint256 = function (value) {\n\t        if (!lib$1.isHexString(value)) {\n\t            throw new Error(\"invalid uint256\");\n\t        }\n\t        return lib$1.hexZeroPad(value, 32);\n\t    };\n\t    Formatter.prototype._block = function (value, format) {\n\t        if (value.author != null && value.miner == null) {\n\t            value.miner = value.author;\n\t        }\n\t        return Formatter.check(format, value);\n\t    };\n\t    Formatter.prototype.block = function (value) {\n\t        return this._block(value, this.formats.block);\n\t    };\n\t    Formatter.prototype.blockWithTransactions = function (value) {\n\t        return this._block(value, this.formats.blockWithTransactions);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.transactionRequest = function (value) {\n\t        return Formatter.check(this.formats.transactionRequest, value);\n\t    };\n\t    Formatter.prototype.transactionResponse = function (transaction) {\n\t        // Rename gas to gasLimit\n\t        if (transaction.gas != null && transaction.gasLimit == null) {\n\t            transaction.gasLimit = transaction.gas;\n\t        }\n\t        // Some clients (TestRPC) do strange things like return 0x0 for the\n\t        // 0 address; correct this to be a real address\n\t        if (transaction.to && lib$2.BigNumber.from(transaction.to).isZero()) {\n\t            transaction.to = \"0x0000000000000000000000000000000000000000\";\n\t        }\n\t        // Rename input to data\n\t        if (transaction.input != null && transaction.data == null) {\n\t            transaction.data = transaction.input;\n\t        }\n\t        // If to and creates are empty, populate the creates from the transaction\n\t        if (transaction.to == null && transaction.creates == null) {\n\t            transaction.creates = this.contractAddress(transaction);\n\t        }\n\t        // @TODO: use transaction.serialize? Have to add support for including v, r, and s...\n\t        /*\n\t        if (!transaction.raw) {\n\t \n\t             // Very loose providers (e.g. TestRPC) do not provide a signature or raw\n\t             if (transaction.v && transaction.r && transaction.s) {\n\t                 let raw = [\n\t                     stripZeros(hexlify(transaction.nonce)),\n\t                     stripZeros(hexlify(transaction.gasPrice)),\n\t                     stripZeros(hexlify(transaction.gasLimit)),\n\t                     (transaction.to || \"0x\"),\n\t                     stripZeros(hexlify(transaction.value || \"0x\")),\n\t                     hexlify(transaction.data || \"0x\"),\n\t                     stripZeros(hexlify(transaction.v || \"0x\")),\n\t                     stripZeros(hexlify(transaction.r)),\n\t                     stripZeros(hexlify(transaction.s)),\n\t                 ];\n\t \n\t                 transaction.raw = rlpEncode(raw);\n\t             }\n\t         }\n\t         */\n\t        var result = Formatter.check(this.formats.transaction, transaction);\n\t        if (transaction.chainId != null) {\n\t            var chainId = transaction.chainId;\n\t            if (lib$1.isHexString(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        else {\n\t            var chainId = transaction.networkId;\n\t            // geth-etc returns chainId\n\t            if (chainId == null && result.v == null) {\n\t                chainId = transaction.chainId;\n\t            }\n\t            if (lib$1.isHexString(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            if (typeof (chainId) !== \"number\" && result.v != null) {\n\t                chainId = (result.v - 35) / 2;\n\t                if (chainId < 0) {\n\t                    chainId = 0;\n\t                }\n\t                chainId = parseInt(chainId);\n\t            }\n\t            if (typeof (chainId) !== \"number\") {\n\t                chainId = 0;\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        // 0x0000... should actually be null\n\t        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n\t            result.blockHash = null;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.transaction = function (value) {\n\t        return lib$g.parse(value);\n\t    };\n\t    Formatter.prototype.receiptLog = function (value) {\n\t        return Formatter.check(this.formats.receiptLog, value);\n\t    };\n\t    Formatter.prototype.receipt = function (value) {\n\t        var result = Formatter.check(this.formats.receipt, value);\n\t        if (value.status != null) {\n\t            result.byzantium = true;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.topics = function (value) {\n\t        var _this = this;\n\t        if (Array.isArray(value)) {\n\t            return value.map(function (v) { return _this.topics(v); });\n\t        }\n\t        else if (value != null) {\n\t            return this.hash(value, true);\n\t        }\n\t        return null;\n\t    };\n\t    Formatter.prototype.filter = function (value) {\n\t        return Formatter.check(this.formats.filter, value);\n\t    };\n\t    Formatter.prototype.filterLog = function (value) {\n\t        return Formatter.check(this.formats.filterLog, value);\n\t    };\n\t    Formatter.check = function (format, object) {\n\t        var result = {};\n\t        for (var key in format) {\n\t            try {\n\t                var value = format[key](object[key]);\n\t                if (value !== undefined) {\n\t                    result[key] = value;\n\t                }\n\t            }\n\t            catch (error) {\n\t                error.checkKey = key;\n\t                error.checkValue = object[key];\n\t                throw error;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    // if value is null-ish, nullValue is returned\n\t    Formatter.allowNull = function (format, nullValue) {\n\t        return (function (value) {\n\t            if (value == null) {\n\t                return nullValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // If value is false-ish, replaceValue is returned\n\t    Formatter.allowFalsish = function (format, replaceValue) {\n\t        return (function (value) {\n\t            if (!value) {\n\t                return replaceValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // Requires an Array satisfying check\n\t    Formatter.arrayOf = function (format) {\n\t        return (function (array) {\n\t            if (!Array.isArray(array)) {\n\t                throw new Error(\"not an array\");\n\t            }\n\t            var result = [];\n\t            array.forEach(function (value) {\n\t                result.push(format(value));\n\t            });\n\t            return result;\n\t        });\n\t    };\n\t    return Formatter;\n\t}());\n\texports.Formatter = Formatter;\n\t});\n\n\tvar formatter$1 = unwrapExports(formatter);\n\tvar formatter_1 = formatter.Formatter;\n\n\tvar baseProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t//////////////////////////////\n\t// Event Serializeing\n\tfunction checkTopic(topic) {\n\t    if (topic == null) {\n\t        return \"null\";\n\t    }\n\t    if (lib$1.hexDataLength(topic) !== 32) {\n\t        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n\t    }\n\t    return topic.toLowerCase();\n\t}\n\tfunction serializeTopics(topics) {\n\t    // Remove trailing null AND-topics; they are redundant\n\t    topics = topics.slice();\n\t    while (topics.length > 0 && topics[topics.length - 1] == null) {\n\t        topics.pop();\n\t    }\n\t    return topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            // Only track unique OR-topics\n\t            var unique_1 = {};\n\t            topic.forEach(function (topic) {\n\t                unique_1[checkTopic(topic)] = true;\n\t            });\n\t            // The order of OR-topics does not matter\n\t            var sorted = Object.keys(unique_1);\n\t            sorted.sort();\n\t            return sorted.join(\"|\");\n\t        }\n\t        else {\n\t            return checkTopic(topic);\n\t        }\n\t    }).join(\"&\");\n\t}\n\tfunction deserializeTopics(data) {\n\t    if (data === \"\") {\n\t        return [];\n\t    }\n\t    return data.split(/&/g).map(function (topic) {\n\t        if (topic === \"\") {\n\t            return [];\n\t        }\n\t        var comps = topic.split(\"|\").map(function (topic) {\n\t            return ((topic === \"null\") ? null : topic);\n\t        });\n\t        return ((comps.length === 1) ? comps[0] : comps);\n\t    });\n\t}\n\tfunction getEventTag(eventName) {\n\t    if (typeof (eventName) === \"string\") {\n\t        eventName = eventName.toLowerCase();\n\t        if (lib$1.hexDataLength(eventName) === 32) {\n\t            return \"tx:\" + eventName;\n\t        }\n\t        if (eventName.indexOf(\":\") === -1) {\n\t            return eventName;\n\t        }\n\t    }\n\t    else if (Array.isArray(eventName)) {\n\t        return \"filter:*:\" + serializeTopics(eventName);\n\t    }\n\t    else if (lib$b.ForkEvent.isForkEvent(eventName)) {\n\t        logger.warn(\"not implemented\");\n\t        throw new Error(\"not implemented\");\n\t    }\n\t    else if (eventName && typeof (eventName) === \"object\") {\n\t        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n\t    }\n\t    throw new Error(\"invalid event - \" + eventName);\n\t}\n\t//////////////////////////////\n\t// Helper Object\n\tfunction getTime() {\n\t    return (new Date()).getTime();\n\t}\n\tfunction stall(duration) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, duration);\n\t    });\n\t}\n\t//////////////////////////////\n\t// Provider Object\n\t/**\n\t *  EventType\n\t *   - \"block\"\n\t *   - \"poll\"\n\t *   - \"didPoll\"\n\t *   - \"pending\"\n\t *   - \"error\"\n\t *   - \"network\"\n\t *   - filter\n\t *   - topics array\n\t *   - transaction hash\n\t */\n\tvar PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\n\tvar Event = /** @class */ (function () {\n\t    function Event(tag, listener, once) {\n\t        lib$3.defineReadOnly(this, \"tag\", tag);\n\t        lib$3.defineReadOnly(this, \"listener\", listener);\n\t        lib$3.defineReadOnly(this, \"once\", once);\n\t    }\n\t    Object.defineProperty(Event.prototype, \"event\", {\n\t        get: function () {\n\t            switch (this.type) {\n\t                case \"tx\":\n\t                    return this.hash;\n\t                case \"filter\":\n\t                    return this.filter;\n\t            }\n\t            return this.tag;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"type\", {\n\t        get: function () {\n\t            return this.tag.split(\":\")[0];\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"hash\", {\n\t        get: function () {\n\t            var comps = this.tag.split(\":\");\n\t            if (comps[0] !== \"tx\") {\n\t                return null;\n\t            }\n\t            return comps[1];\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"filter\", {\n\t        get: function () {\n\t            var comps = this.tag.split(\":\");\n\t            if (comps[0] !== \"filter\") {\n\t                return null;\n\t            }\n\t            var address = comps[1];\n\t            var topics = deserializeTopics(comps[2]);\n\t            var filter = {};\n\t            if (topics.length > 0) {\n\t                filter.topics = topics;\n\t            }\n\t            if (address && address !== \"*\") {\n\t                filter.address = address;\n\t            }\n\t            return filter;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Event.prototype.pollable = function () {\n\t        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n\t    };\n\t    return Event;\n\t}());\n\texports.Event = Event;\n\tvar defaultFormatter = null;\n\tvar nextPollId = 1;\n\tvar BaseProvider = /** @class */ (function (_super) {\n\t    __extends(BaseProvider, _super);\n\t    /**\n\t     *  ready\n\t     *\n\t     *  A Promise<Network> that resolves only once the provider is ready.\n\t     *\n\t     *  Sub-classes that call the super with a network without a chainId\n\t     *  MUST set this. Standard named networks have a known chainId.\n\t     *\n\t     */\n\t    function BaseProvider(network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, lib$b.Provider);\n\t        _this = _super.call(this) || this;\n\t        // Events being listened to\n\t        _this._events = [];\n\t        _this._emitted = { block: -2 };\n\t        _this.formatter = _newTarget.getFormatter();\n\t        // If network is any, this Provider allows the underlying\n\t        // network to change dynamically, and we auto-detect the\n\t        // current network\n\t        lib$3.defineReadOnly(_this, \"anyNetwork\", (network === \"any\"));\n\t        if (_this.anyNetwork) {\n\t            network = _this.detectNetwork();\n\t        }\n\t        if (network instanceof Promise) {\n\t            _this._networkPromise = network;\n\t            // Squash any \"unhandled promise\" errors; that do not need to be handled\n\t            network.catch(function (error) { });\n\t            // Trigger initial network setting (async)\n\t            _this._ready();\n\t        }\n\t        else {\n\t            var knownNetwork = lib$3.getStatic((_newTarget), \"getNetwork\")(network);\n\t            if (knownNetwork) {\n\t                lib$3.defineReadOnly(_this, \"_network\", knownNetwork);\n\t                _this.emit(\"network\", knownNetwork, null);\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"invalid network\", \"network\", network);\n\t            }\n\t        }\n\t        _this._maxInternalBlockNumber = -1024;\n\t        _this._lastBlockNumber = -2;\n\t        _this._pollingInterval = 4000;\n\t        _this._fastQueryDate = 0;\n\t        return _this;\n\t    }\n\t    BaseProvider.prototype._ready = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, error_1;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(this._network == null)) return [3 /*break*/, 7];\n\t                        network = null;\n\t                        if (!this._networkPromise) return [3 /*break*/, 4];\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, this._networkPromise];\n\t                    case 2:\n\t                        network = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 3:\n\t                        error_1 = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 4:\n\t                        if (!(network == null)) return [3 /*break*/, 6];\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 5:\n\t                        network = _a.sent();\n\t                        _a.label = 6;\n\t                    case 6:\n\t                        // This should never happen; every Provider sub-class should have\n\t                        // suggested a network by here (or have thrown).\n\t                        if (!network) {\n\t                            logger.throwError(\"no network detected\", lib.Logger.errors.UNKNOWN_ERROR, {});\n\t                        }\n\t                        // Possible this call stacked so do not call defineReadOnly again\n\t                        if (this._network == null) {\n\t                            if (this.anyNetwork) {\n\t                                this._network = network;\n\t                            }\n\t                            else {\n\t                                lib$3.defineReadOnly(this, \"_network\", network);\n\t                            }\n\t                            this.emit(\"network\", network, null);\n\t                        }\n\t                        _a.label = 7;\n\t                    case 7: return [2 /*return*/, this._network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"ready\", {\n\t        // This will always return the most recently established network.\n\t        // For \"any\", this can change (a \"network\" event is emitted before\n\t        // any change is refelcted); otherwise this cannot change\n\t        get: function () {\n\t            return this._ready();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // @TODO: Remove this and just create a singleton formatter\n\t    BaseProvider.getFormatter = function () {\n\t        if (defaultFormatter == null) {\n\t            defaultFormatter = new formatter.Formatter();\n\t        }\n\t        return defaultFormatter;\n\t    };\n\t    // @TODO: Remove this and just use getNetwork\n\t    BaseProvider.getNetwork = function (network) {\n\t        return lib$k.getNetwork((network == null) ? \"homestead\" : network);\n\t    };\n\t    // Fetches the blockNumber, but will reuse any result that is less\n\t    // than maxAge old or has been requested since the last request\n\t    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var internalBlockNumber, result, reqTime, checkInternalBlockNumber;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.ready];\n\t                    case 1:\n\t                        _a.sent();\n\t                        internalBlockNumber = this._internalBlockNumber;\n\t                        if (!(maxAge > 0 && this._internalBlockNumber)) return [3 /*break*/, 3];\n\t                        return [4 /*yield*/, internalBlockNumber];\n\t                    case 2:\n\t                        result = _a.sent();\n\t                        if ((getTime() - result.respTime) <= maxAge) {\n\t                            return [2 /*return*/, result.blockNumber];\n\t                        }\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        reqTime = getTime();\n\t                        checkInternalBlockNumber = lib$3.resolveProperties({\n\t                            blockNumber: this.perform(\"getBlockNumber\", {}),\n\t                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })\n\t                        }).then(function (_a) {\n\t                            var blockNumber = _a.blockNumber, networkError = _a.networkError;\n\t                            if (networkError) {\n\t                                // Unremember this bad internal block number\n\t                                if (_this._internalBlockNumber === checkInternalBlockNumber) {\n\t                                    _this._internalBlockNumber = null;\n\t                                }\n\t                                throw networkError;\n\t                            }\n\t                            var respTime = getTime();\n\t                            blockNumber = lib$2.BigNumber.from(blockNumber).toNumber();\n\t                            if (blockNumber < _this._maxInternalBlockNumber) {\n\t                                blockNumber = _this._maxInternalBlockNumber;\n\t                            }\n\t                            _this._maxInternalBlockNumber = blockNumber;\n\t                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n\t                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };\n\t                        });\n\t                        this._internalBlockNumber = checkInternalBlockNumber;\n\t                        return [4 /*yield*/, checkInternalBlockNumber];\n\t                    case 4: return [2 /*return*/, (_a.sent()).blockNumber];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var pollId, runners, blockNumber, i;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        pollId = nextPollId++;\n\t                        runners = [];\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];\n\t                    case 1:\n\t                        blockNumber = _a.sent();\n\t                        this._setFastBlockNumber(blockNumber);\n\t                        // Emit a poll event after we have the latest (fast) block number\n\t                        this.emit(\"poll\", pollId, blockNumber);\n\t                        // If the block has not changed, meh.\n\t                        if (blockNumber === this._lastBlockNumber) {\n\t                            this.emit(\"didPoll\", pollId);\n\t                            return [2 /*return*/];\n\t                        }\n\t                        // First polling cycle, trigger a \"block\" events\n\t                        if (this._emitted.block === -2) {\n\t                            this._emitted.block = blockNumber - 1;\n\t                        }\n\t                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n\t                            logger.warn(\"network block skew detected; skipping block events\");\n\t                            this.emit(\"error\", logger.makeError(\"network block skew detected\", lib.Logger.errors.NETWORK_ERROR, {\n\t                                blockNumber: blockNumber,\n\t                                previousBlockNumber: this._emitted.block\n\t                            }));\n\t                            this.emit(\"block\", blockNumber);\n\t                        }\n\t                        else {\n\t                            // Notify all listener for each block that has passed\n\t                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {\n\t                                this.emit(\"block\", i);\n\t                            }\n\t                        }\n\t                        // The emitted block was updated, check for obsolete events\n\t                        if (this._emitted.block !== blockNumber) {\n\t                            this._emitted.block = blockNumber;\n\t                            Object.keys(this._emitted).forEach(function (key) {\n\t                                // The block event does not expire\n\t                                if (key === \"block\") {\n\t                                    return;\n\t                                }\n\t                                // The block we were at when we emitted this event\n\t                                var eventBlockNumber = _this._emitted[key];\n\t                                // We cannot garbage collect pending transactions or blocks here\n\t                                // They should be garbage collected by the Provider when setting\n\t                                // \"pending\" events\n\t                                if (eventBlockNumber === \"pending\") {\n\t                                    return;\n\t                                }\n\t                                // Evict any transaction hashes or block hashes over 12 blocks\n\t                                // old, since they should not return null anyways\n\t                                if (blockNumber - eventBlockNumber > 12) {\n\t                                    delete _this._emitted[key];\n\t                                }\n\t                            });\n\t                        }\n\t                        // First polling cycle\n\t                        if (this._lastBlockNumber === -2) {\n\t                            this._lastBlockNumber = blockNumber - 1;\n\t                        }\n\t                        // Find all transaction hashes we are waiting on\n\t                        this._events.forEach(function (event) {\n\t                            switch (event.type) {\n\t                                case \"tx\": {\n\t                                    var hash_2 = event.hash;\n\t                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {\n\t                                        if (!receipt || receipt.blockNumber == null) {\n\t                                            return null;\n\t                                        }\n\t                                        _this._emitted[\"t:\" + hash_2] = receipt.blockNumber;\n\t                                        _this.emit(hash_2, receipt);\n\t                                        return null;\n\t                                    }).catch(function (error) { _this.emit(\"error\", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                                case \"filter\": {\n\t                                    var filter_1 = event.filter;\n\t                                    filter_1.fromBlock = _this._lastBlockNumber + 1;\n\t                                    filter_1.toBlock = blockNumber;\n\t                                    var runner = _this.getLogs(filter_1).then(function (logs) {\n\t                                        if (logs.length === 0) {\n\t                                            return;\n\t                                        }\n\t                                        logs.forEach(function (log) {\n\t                                            _this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n\t                                            _this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\t                                            _this.emit(filter_1, log);\n\t                                        });\n\t                                    }).catch(function (error) { _this.emit(\"error\", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                            }\n\t                        });\n\t                        this._lastBlockNumber = blockNumber;\n\t                        // Once all events for this loop have been processed, emit \"didPoll\"\n\t                        Promise.all(runners).then(function () {\n\t                            _this.emit(\"didPoll\", pollId);\n\t                        });\n\t                        return [2 /*return*/, null];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Deprecated; do not use this\n\t    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        this._lastBlockNumber = blockNumber - 1;\n\t        if (this.polling) {\n\t            this.poll();\n\t        }\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"network\", {\n\t        get: function () {\n\t            return this._network;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // This method should query the network if the underlying network\n\t    // can change, such as when connected to a JSON-RPC backend\n\t    BaseProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, logger.throwError(\"provider does not support network detection\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                        operation: \"provider.detectNetwork\"\n\t                    })];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, currentNetwork, error;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.ready];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 2:\n\t                        currentNetwork = _a.sent();\n\t                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];\n\t                        if (!this.anyNetwork) return [3 /*break*/, 4];\n\t                        this._network = currentNetwork;\n\t                        // Reset all internal block number guards and caches\n\t                        this._lastBlockNumber = -2;\n\t                        this._fastBlockNumber = null;\n\t                        this._fastBlockNumberPromise = null;\n\t                        this._fastQueryDate = 0;\n\t                        this._emitted.block = -2;\n\t                        this._maxInternalBlockNumber = -1024;\n\t                        this._internalBlockNumber = null;\n\t                        // The \"network\" event MUST happen before this method resolves\n\t                        // so any events have a chance to unregister, so we stall an\n\t                        // additional event loop before returning from /this/ call\n\t                        this.emit(\"network\", currentNetwork, network);\n\t                        return [4 /*yield*/, stall(0)];\n\t                    case 3:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this._network];\n\t                    case 4:\n\t                        error = logger.makeError(\"underlying network changed\", lib.Logger.errors.NETWORK_ERROR, {\n\t                            event: \"changed\",\n\t                            network: network,\n\t                            detectedNetwork: currentNetwork\n\t                        });\n\t                        this.emit(\"error\", error);\n\t                        throw error;\n\t                    case 5: return [2 /*return*/, network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"blockNumber\", {\n\t        get: function () {\n\t            var _this = this;\n\t            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {\n\t                _this._setFastBlockNumber(blockNumber);\n\t            });\n\t            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, \"polling\", {\n\t        get: function () {\n\t            return (this._poller != null);\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (value && !this._poller) {\n\t                this._poller = setInterval(this.poll.bind(this), this.pollingInterval);\n\t                if (!this._bootstrapPoll) {\n\t                    this._bootstrapPoll = setTimeout(function () {\n\t                        _this.poll();\n\t                        // We block additional polls until the polling interval\n\t                        // is done, to prevent overwhelming the poll function\n\t                        _this._bootstrapPoll = setTimeout(function () {\n\t                            // If polling was disabled, something may require a poke\n\t                            // since starting the bootstrap poll and it was disabled\n\t                            if (!_this._poller) {\n\t                                _this.poll();\n\t                            }\n\t                            // Clear out the bootstrap so we can do another\n\t                            _this._bootstrapPoll = null;\n\t                        }, _this.pollingInterval);\n\t                    }, 0);\n\t                }\n\t            }\n\t            else if (!value && this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = null;\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, \"pollingInterval\", {\n\t        get: function () {\n\t            return this._pollingInterval;\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n\t                throw new Error(\"invalid polling interval\");\n\t            }\n\t            this._pollingInterval = value;\n\t            if (this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BaseProvider.prototype._getFastBlockNumber = function () {\n\t        var _this = this;\n\t        var now = getTime();\n\t        // Stale block number, request a newer value\n\t        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n\t            this._fastQueryDate = now;\n\t            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {\n\t                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {\n\t                    _this._fastBlockNumber = blockNumber;\n\t                }\n\t                return _this._fastBlockNumber;\n\t            });\n\t        }\n\t        return this._fastBlockNumberPromise;\n\t    };\n\t    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {\n\t        // Older block, maybe a stale request\n\t        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n\t            return;\n\t        }\n\t        // Update the time we updated the blocknumber\n\t        this._fastQueryDate = getTime();\n\t        // Newer block number, use  it\n\t        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n\t            this._fastBlockNumber = blockNumber;\n\t            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n\t        }\n\t    };\n\t    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var receipt;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (confirmations == null) {\n\t                            confirmations = 1;\n\t                        }\n\t                        return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        // Receipt is already good\n\t                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n\t                            return [2 /*return*/, receipt];\n\t                        }\n\t                        // Poll until the receipt is good...\n\t                        return [2 /*return*/, new Promise(function (resolve, reject) {\n\t                                var timer = null;\n\t                                var done = false;\n\t                                var handler = function (receipt) {\n\t                                    if (receipt.confirmations < confirmations) {\n\t                                        return;\n\t                                    }\n\t                                    if (timer) {\n\t                                        clearTimeout(timer);\n\t                                    }\n\t                                    if (done) {\n\t                                        return;\n\t                                    }\n\t                                    done = true;\n\t                                    _this.removeListener(transactionHash, handler);\n\t                                    resolve(receipt);\n\t                                };\n\t                                _this.on(transactionHash, handler);\n\t                                if (typeof (timeout) === \"number\" && timeout > 0) {\n\t                                    timer = setTimeout(function () {\n\t                                        if (done) {\n\t                                            return;\n\t                                        }\n\t                                        timer = null;\n\t                                        done = true;\n\t                                        _this.removeListener(transactionHash, handler);\n\t                                        reject(logger.makeError(\"timeout exceeded\", lib.Logger.errors.TIMEOUT, { timeout: timeout }));\n\t                                    }, timeout);\n\t                                    if (timer.unref) {\n\t                                        timer.unref();\n\t                                    }\n\t                                }\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlockNumber = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this._getInternalBlockNumber(0)];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform(\"getGasPrice\", {})];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform(\"getBalance\", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform(\"getTransactionCount\", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()]).toNumber()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform(\"getCode\", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag),\n\t                                position: Promise.resolve(position).then(function (p) { return lib$1.hexValue(p); })\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform(\"getStorageAt\", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // This should be called by any subclass wrapping a TransactionResponse\n\t    BaseProvider.prototype._wrapTransaction = function (tx, hash) {\n\t        var _this = this;\n\t        if (hash != null && lib$1.hexDataLength(hash) !== 32) {\n\t            throw new Error(\"invalid response - sendTransaction\");\n\t        }\n\t        var result = tx;\n\t        // Check the hash we expect is the same as the hash the server reported\n\t        if (hash != null && tx.hash !== hash) {\n\t            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", lib.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n\t        }\n\t        // @TODO: (confirmations? number, timeout? number)\n\t        result.wait = function (confirmations) { return __awaiter(_this, void 0, void 0, function () {\n\t            var receipt;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        // We know this transaction *must* exist (whether it gets mined is\n\t                        // another story), so setting an emitted value forces us to\n\t                        // wait even if the node returns null for the receipt\n\t                        if (confirmations !== 0) {\n\t                            this._emitted[\"t:\" + tx.hash] = \"pending\";\n\t                        }\n\t                        return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        if (receipt == null && confirmations === 0) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        // No longer pending, allow the polling loop to garbage collect this\n\t                        this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\t                        if (receipt.status === 0) {\n\t                            logger.throwError(\"transaction failed\", lib.Logger.errors.CALL_EXCEPTION, {\n\t                                transactionHash: tx.hash,\n\t                                transaction: tx,\n\t                                receipt: receipt\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, receipt];\n\t                }\n\t            });\n\t        }); };\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.sendTransaction = function (signedTransaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var hexTx, tx, hash, error_2;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return lib$1.hexlify(t); })];\n\t                    case 2:\n\t                        hexTx = _a.sent();\n\t                        tx = this.formatter.transaction(signedTransaction);\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        _a.trys.push([3, 5, , 6]);\n\t                        return [4 /*yield*/, this.perform(\"sendTransaction\", { signedTransaction: hexTx })];\n\t                    case 4:\n\t                        hash = _a.sent();\n\t                        return [2 /*return*/, this._wrapTransaction(tx, hash)];\n\t                    case 5:\n\t                        error_2 = _a.sent();\n\t                        error_2.transaction = tx;\n\t                        error_2.transactionHash = tx.hash;\n\t                        throw error_2;\n\t                    case 6: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getTransactionRequest = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var values, tx, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, transaction];\n\t                    case 1:\n\t                        values = _c.sent();\n\t                        tx = {};\n\t                        [\"from\", \"to\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });\n\t                        });\n\t                        [\"gasLimit\", \"gasPrice\", \"value\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? lib$2.BigNumber.from(v) : null); });\n\t                        });\n\t                        [\"data\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? lib$1.hexlify(v) : null); });\n\t                        });\n\t                        _b = (_a = this.formatter).transactionRequest;\n\t                        return [4 /*yield*/, lib$3.resolveProperties(tx)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getFilter = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var result, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, filter];\n\t                    case 1:\n\t                        filter = _c.sent();\n\t                        result = {};\n\t                        if (filter.address != null) {\n\t                            result.address = this._getAddress(filter.address);\n\t                        }\n\t                        [\"blockHash\", \"topics\"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = filter[key];\n\t                        });\n\t                        [\"fromBlock\", \"toBlock\"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = _this._getBlockTag(filter[key]);\n\t                        });\n\t                        _b = (_a = this.formatter).filter;\n\t                        return [4 /*yield*/, lib$3.resolveProperties(result)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                transaction: this._getTransactionRequest(transaction),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform(\"call\", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                transaction: this._getTransactionRequest(transaction)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform(\"estimateGas\", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getAddress = function (addressOrName) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.resolveName(addressOrName)];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        if (address == null) {\n\t                            logger.throwError(\"ENS name not configured\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"resolveName(\" + JSON.stringify(addressOrName) + \")\"\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, address];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber, params, _a, _b, _c, error_3;\n\t            var _this = this;\n\t            return __generator(this, function (_d) {\n\t                switch (_d.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _d.sent();\n\t                        return [4 /*yield*/, blockHashOrBlockTag];\n\t                    case 2:\n\t                        blockHashOrBlockTag = _d.sent();\n\t                        blockNumber = -128;\n\t                        params = {\n\t                            includeTransactions: !!includeTransactions\n\t                        };\n\t                        if (!lib$1.isHexString(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];\n\t                        params.blockHash = blockHashOrBlockTag;\n\t                        return [3 /*break*/, 6];\n\t                    case 3:\n\t                        _d.trys.push([3, 5, , 6]);\n\t                        _a = params;\n\t                        _c = (_b = this.formatter).blockTag;\n\t                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];\n\t                    case 4:\n\t                        _a.blockTag = _c.apply(_b, [_d.sent()]);\n\t                        if (lib$1.isHexString(params.blockTag)) {\n\t                            blockNumber = parseInt(params.blockTag.substring(2), 16);\n\t                        }\n\t                        return [3 /*break*/, 6];\n\t                    case 5:\n\t                        error_3 = _d.sent();\n\t                        logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n\t                        return [3 /*break*/, 6];\n\t                    case 6: return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                            var block, blockNumber_1, i, tx, confirmations;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0: return [4 /*yield*/, this.perform(\"getBlock\", params)];\n\t                                    case 1:\n\t                                        block = _a.sent();\n\t                                        // Block was not found\n\t                                        if (block == null) {\n\t                                            // For blockhashes, if we didn't say it existed, that blockhash may\n\t                                            // not exist. If we did see it though, perhaps from a log, we know\n\t                                            // it exists, and this node is just not caught up yet.\n\t                                            if (params.blockHash != null) {\n\t                                                if (this._emitted[\"b:\" + params.blockHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // For block tags, if we are asking for a future block, we return null\n\t                                            if (params.blockTag != null) {\n\t                                                if (blockNumber > this._emitted.block) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // Retry on the next block\n\t                                            return [2 /*return*/, undefined];\n\t                                        }\n\t                                        if (!includeTransactions) return [3 /*break*/, 8];\n\t                                        blockNumber_1 = null;\n\t                                        i = 0;\n\t                                        _a.label = 2;\n\t                                    case 2:\n\t                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];\n\t                                        tx = block.transactions[i];\n\t                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];\n\t                                        tx.confirmations = 0;\n\t                                        return [3 /*break*/, 6];\n\t                                    case 3:\n\t                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];\n\t                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];\n\t                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                    case 4:\n\t                                        blockNumber_1 = _a.sent();\n\t                                        _a.label = 5;\n\t                                    case 5:\n\t                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;\n\t                                        if (confirmations <= 0) {\n\t                                            confirmations = 1;\n\t                                        }\n\t                                        tx.confirmations = confirmations;\n\t                                        _a.label = 6;\n\t                                    case 6:\n\t                                        i++;\n\t                                        return [3 /*break*/, 2];\n\t                                    case 7: return [2 /*return*/, this.formatter.blockWithTransactions(block)];\n\t                                    case 8: return [2 /*return*/, this.formatter.block(block)];\n\t                                }\n\t                            });\n\t                        }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, false));\n\t    };\n\t    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, true));\n\t    };\n\t    BaseProvider.prototype.getTransaction = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, tx, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform(\"getTransaction\", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            tx = this.formatter.transactionResponse(result);\n\t                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            tx.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - tx.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            tx.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, receipt, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform(\"getTransactionReceipt\", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            // \"geth-etc\" returns receipts before they are ready\n\t                                            if (result.blockHash == null) {\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            receipt = this.formatter.receipt(result);\n\t                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            receipt.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - receipt.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            receipt.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, receipt];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getLogs = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, logs;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({ filter: this._getFilter(filter) })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getLogs\", params)];\n\t                    case 3:\n\t                        logs = _a.sent();\n\t                        logs.forEach(function (log) {\n\t                            if (log.removed == null) {\n\t                                log.removed = false;\n\t                            }\n\t                        });\n\t                        return [2 /*return*/, formatter.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getEtherPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this.perform(\"getEtherPrice\", {})];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlockTag = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        if (!(typeof (blockTag) === \"number\" && blockTag < 0)) return [3 /*break*/, 3];\n\t                        if (blockTag % 1) {\n\t                            logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n\t                        }\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                    case 2:\n\t                        blockNumber = _a.sent();\n\t                        blockNumber += blockTag;\n\t                        if (blockNumber < 0) {\n\t                            blockNumber = 0;\n\t                        }\n\t                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];\n\t                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getResolver = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, transaction, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        network = _c.sent();\n\t                        // No ENS...\n\t                        if (!network.ensAddress) {\n\t                            logger.throwError(\"network does not support ENS\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n\t                        }\n\t                        transaction = {\n\t                            to: network.ensAddress,\n\t                            data: (\"0x0178b8bf\" + lib$9.namehash(name).substring(2))\n\t                        };\n\t                        _b = (_a = this.formatter).callAddress;\n\t                        return [4 /*yield*/, this.call(transaction)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var resolverAddress, transaction, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, name];\n\t                    case 1:\n\t                        name = _c.sent();\n\t                        // If it is already an address, nothing to resolve\n\t                        try {\n\t                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];\n\t                        }\n\t                        catch (error) {\n\t                            // If is is a hexstring, the address is bad (See #694)\n\t                            if (lib$1.isHexString(name)) {\n\t                                throw error;\n\t                            }\n\t                        }\n\t                        if (typeof (name) !== \"string\") {\n\t                            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n\t                        }\n\t                        return [4 /*yield*/, this._getResolver(name)];\n\t                    case 2:\n\t                        resolverAddress = _c.sent();\n\t                        if (!resolverAddress) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        transaction = {\n\t                            to: resolverAddress,\n\t                            data: (\"0x3b3b57de\" + lib$9.namehash(name).substring(2))\n\t                        };\n\t                        _b = (_a = this.formatter).callAddress;\n\t                        return [4 /*yield*/, this.call(transaction)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.lookupAddress = function (address) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var reverseName, resolverAddress, bytes, _a, length, name, addr;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, address];\n\t                    case 1:\n\t                        address = _b.sent();\n\t                        address = this.formatter.address(address);\n\t                        reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\t                        return [4 /*yield*/, this._getResolver(reverseName)];\n\t                    case 2:\n\t                        resolverAddress = _b.sent();\n\t                        if (!resolverAddress) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        _a = lib$1.arrayify;\n\t                        return [4 /*yield*/, this.call({\n\t                                to: resolverAddress,\n\t                                data: (\"0x691f3431\" + lib$9.namehash(reverseName).substring(2))\n\t                            })];\n\t                    case 3:\n\t                        bytes = _a.apply(void 0, [_b.sent()]);\n\t                        // Strip off the dynamic string pointer (0x20)\n\t                        if (bytes.length < 32 || !lib$2.BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        bytes = bytes.slice(32);\n\t                        // Not a length-prefixed string\n\t                        if (bytes.length < 32) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        length = lib$2.BigNumber.from(bytes.slice(0, 32)).toNumber();\n\t                        bytes = bytes.slice(32);\n\t                        // Length longer than available data\n\t                        if (length > bytes.length) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        name = lib$8.toUtf8String(bytes.slice(0, length));\n\t                        return [4 /*yield*/, this.resolveName(name)];\n\t                    case 4:\n\t                        addr = _b.sent();\n\t                        if (addr != address) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, name];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.perform = function (method, params) {\n\t        return logger.throwError(method + \" not implemented\", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t    };\n\t    BaseProvider.prototype._startEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._stopEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {\n\t        var event = new Event(getEventTag(eventName), listener, once);\n\t        this._events.push(event);\n\t        this._startEvent(event);\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.on = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, false);\n\t    };\n\t    BaseProvider.prototype.once = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, true);\n\t    };\n\t    BaseProvider.prototype.emit = function (eventName) {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        var result = false;\n\t        var stopped = [];\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag) {\n\t                return true;\n\t            }\n\t            setTimeout(function () {\n\t                event.listener.apply(_this, args);\n\t            }, 0);\n\t            result = true;\n\t            if (event.once) {\n\t                stopped.push(event);\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.listenerCount = function (eventName) {\n\t        if (!eventName) {\n\t            return this._events.length;\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events.filter(function (event) {\n\t            return (event.tag === eventTag);\n\t        }).length;\n\t    };\n\t    BaseProvider.prototype.listeners = function (eventName) {\n\t        if (eventName == null) {\n\t            return this._events.map(function (event) { return event.listener; });\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events\n\t            .filter(function (event) { return (event.tag === eventTag); })\n\t            .map(function (event) { return event.listener; });\n\t    };\n\t    BaseProvider.prototype.off = function (eventName, listener) {\n\t        var _this = this;\n\t        if (listener == null) {\n\t            return this.removeAllListeners(eventName);\n\t        }\n\t        var stopped = [];\n\t        var found = false;\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag || event.listener != listener) {\n\t                return true;\n\t            }\n\t            if (found) {\n\t                return true;\n\t            }\n\t            found = true;\n\t            stopped.push(event);\n\t            return false;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.removeAllListeners = function (eventName) {\n\t        var _this = this;\n\t        var stopped = [];\n\t        if (eventName == null) {\n\t            stopped = this._events;\n\t            this._events = [];\n\t        }\n\t        else {\n\t            var eventTag_1 = getEventTag(eventName);\n\t            this._events = this._events.filter(function (event) {\n\t                if (event.tag !== eventTag_1) {\n\t                    return true;\n\t                }\n\t                stopped.push(event);\n\t                return false;\n\t            });\n\t        }\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    return BaseProvider;\n\t}(lib$b.Provider));\n\texports.BaseProvider = BaseProvider;\n\t});\n\n\tvar baseProvider$1 = unwrapExports(baseProvider);\n\tvar baseProvider_1 = baseProvider.Event;\n\tvar baseProvider_2 = baseProvider.BaseProvider;\n\n\tvar jsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tfunction timer(timeout) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, timeout);\n\t    });\n\t}\n\tfunction getResult(payload) {\n\t    if (payload.error) {\n\t        // @TODO: not any\n\t        var error = new Error(payload.error.message);\n\t        error.code = payload.error.code;\n\t        error.data = payload.error.data;\n\t        throw error;\n\t    }\n\t    return payload.result;\n\t}\n\tfunction getLowerCase(value) {\n\t    if (value) {\n\t        return value.toLowerCase();\n\t    }\n\t    return value;\n\t}\n\tvar _constructorGuard = {};\n\tvar JsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(JsonRpcSigner, _super);\n\t    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcSigner);\n\t        _this = _super.call(this) || this;\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n\t        }\n\t        lib$3.defineReadOnly(_this, \"provider\", provider);\n\t        if (addressOrIndex == null) {\n\t            addressOrIndex = 0;\n\t        }\n\t        if (typeof (addressOrIndex) === \"string\") {\n\t            lib$3.defineReadOnly(_this, \"_address\", _this.provider.formatter.address(addressOrIndex));\n\t            lib$3.defineReadOnly(_this, \"_index\", null);\n\t        }\n\t        else if (typeof (addressOrIndex) === \"number\") {\n\t            lib$3.defineReadOnly(_this, \"_index\", addressOrIndex);\n\t            lib$3.defineReadOnly(_this, \"_address\", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n\t        }\n\t        return _this;\n\t    }\n\t    JsonRpcSigner.prototype.connect = function (provider) {\n\t        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"connect\"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.connectUnchecked = function () {\n\t        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n\t    };\n\t    JsonRpcSigner.prototype.getAddress = function () {\n\t        var _this = this;\n\t        if (this._address) {\n\t            return Promise.resolve(this._address);\n\t        }\n\t        return this.provider.send(\"eth_accounts\", []).then(function (accounts) {\n\t            if (accounts.length <= _this._index) {\n\t                logger.throwError(\"unknown account #\" + _this._index, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: \"getAddress\"\n\t                });\n\t            }\n\t            return _this.provider.formatter.address(accounts[_this._index]);\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {\n\t        var _this = this;\n\t        transaction = lib$3.shallowCopy(transaction);\n\t        var fromAddress = this.getAddress().then(function (address) {\n\t            if (address) {\n\t                address = address.toLowerCase();\n\t            }\n\t            return address;\n\t        });\n\t        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n\t        // wishes to use this, it is easy to specify explicitly, otherwise\n\t        // we look it up for them.\n\t        if (transaction.gasLimit == null) {\n\t            var estimate = lib$3.shallowCopy(transaction);\n\t            estimate.from = fromAddress;\n\t            transaction.gasLimit = this.provider.estimateGas(estimate);\n\t        }\n\t        return lib$3.resolveProperties({\n\t            tx: lib$3.resolveProperties(transaction),\n\t            sender: fromAddress\n\t        }).then(function (_a) {\n\t            var tx = _a.tx, sender = _a.sender;\n\t            if (tx.from != null) {\n\t                if (tx.from.toLowerCase() !== sender) {\n\t                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n\t                }\n\t            }\n\t            else {\n\t                tx.from = sender;\n\t            }\n\t            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });\n\t            return _this.provider.send(\"eth_sendTransaction\", [hexTx]).then(function (hash) {\n\t                return hash;\n\t            }, function (error) {\n\t                if (error.responseText) {\n\t                    // See: JsonRpcProvider.sendTransaction (@TODO: Expose a ._throwError??)\n\t                    if (error.responseText.indexOf(\"insufficient funds\") >= 0) {\n\t                        logger.throwError(\"insufficient funds\", lib.Logger.errors.INSUFFICIENT_FUNDS, {\n\t                            transaction: tx\n\t                        });\n\t                    }\n\t                    if (error.responseText.indexOf(\"nonce too low\") >= 0) {\n\t                        logger.throwError(\"nonce has already been used\", lib.Logger.errors.NONCE_EXPIRED, {\n\t                            transaction: tx\n\t                        });\n\t                    }\n\t                    if (error.responseText.indexOf(\"replacement transaction underpriced\") >= 0) {\n\t                        logger.throwError(\"replacement fee too low\", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {\n\t                            transaction: tx\n\t                        });\n\t                    }\n\t                }\n\t                throw error;\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signTransaction = function (transaction) {\n\t        return logger.throwError(\"signing transactions is unsupported\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"signTransaction\"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n\t            return lib$l.poll(function () {\n\t                return _this.provider.getTransaction(hash).then(function (tx) {\n\t                    if (tx === null) {\n\t                        return undefined;\n\t                    }\n\t                    return _this.provider._wrapTransaction(tx, hash);\n\t                });\n\t            }, { onceBlock: _this.provider }).catch(function (error) {\n\t                error.transactionHash = hash;\n\t                throw error;\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signMessage = function (message) {\n\t        var _this = this;\n\t        var data = ((typeof (message) === \"string\") ? lib$8.toUtf8Bytes(message) : message);\n\t        return this.getAddress().then(function (address) {\n\t            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n\t            return _this.provider.send(\"eth_sign\", [address.toLowerCase(), lib$1.hexlify(data)]);\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.unlock = function (password) {\n\t        var provider = this.provider;\n\t        return this.getAddress().then(function (address) {\n\t            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n\t        });\n\t    };\n\t    return JsonRpcSigner;\n\t}(lib$c.Signer));\n\texports.JsonRpcSigner = JsonRpcSigner;\n\tvar UncheckedJsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(UncheckedJsonRpcSigner, _super);\n\t    function UncheckedJsonRpcSigner() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n\t            return {\n\t                hash: hash,\n\t                nonce: null,\n\t                gasLimit: null,\n\t                gasPrice: null,\n\t                data: null,\n\t                value: null,\n\t                chainId: null,\n\t                confirmations: 0,\n\t                from: null,\n\t                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }\n\t            };\n\t        });\n\t    };\n\t    return UncheckedJsonRpcSigner;\n\t}(JsonRpcSigner));\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tvar JsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(JsonRpcProvider, _super);\n\t    function JsonRpcProvider(url, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcProvider);\n\t        var networkOrReady = network;\n\t        // The network is unknown, query the JSON-RPC for it\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(function (network) {\n\t                        resolve(network);\n\t                    }, function (error) {\n\t                        reject(error);\n\t                    });\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Default URL\n\t        if (!url) {\n\t            url = lib$3.getStatic(_this.constructor, \"defaultUrl\")();\n\t        }\n\t        if (typeof (url) === \"string\") {\n\t            lib$3.defineReadOnly(_this, \"connection\", Object.freeze({\n\t                url: url\n\t            }));\n\t        }\n\t        else {\n\t            lib$3.defineReadOnly(_this, \"connection\", Object.freeze(lib$3.shallowCopy(url)));\n\t        }\n\t        _this._nextId = 42;\n\t        return _this;\n\t    }\n\t    JsonRpcProvider.defaultUrl = function () {\n\t        return \"http:/\\/localhost:8545\";\n\t    };\n\t    JsonRpcProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var chainId, error_1, error_2, getNetwork;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, timer(0)];\n\t                    case 1:\n\t                        _a.sent();\n\t                        chainId = null;\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        _a.trys.push([2, 4, , 9]);\n\t                        return [4 /*yield*/, this.send(\"eth_chainId\", [])];\n\t                    case 3:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 9];\n\t                    case 4:\n\t                        error_1 = _a.sent();\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        _a.trys.push([5, 7, , 8]);\n\t                        return [4 /*yield*/, this.send(\"net_version\", [])];\n\t                    case 6:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 7:\n\t                        error_2 = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 8: return [3 /*break*/, 9];\n\t                    case 9:\n\t                        if (chainId != null) {\n\t                            getNetwork = lib$3.getStatic(this.constructor, \"getNetwork\");\n\t                            try {\n\t                                return [2 /*return*/, getNetwork(lib$2.BigNumber.from(chainId).toNumber())];\n\t                            }\n\t                            catch (error) {\n\t                                return [2 /*return*/, logger.throwError(\"could not detect network\", lib.Logger.errors.NETWORK_ERROR, {\n\t                                        chainId: chainId,\n\t                                        serverError: error\n\t                                    })];\n\t                            }\n\t                        }\n\t                        return [2 /*return*/, logger.throwError(\"could not detect network\", lib.Logger.errors.NETWORK_ERROR)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {\n\t        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n\t    };\n\t    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {\n\t        return this.getSigner(addressOrIndex).connectUnchecked();\n\t    };\n\t    JsonRpcProvider.prototype.listAccounts = function () {\n\t        var _this = this;\n\t        return this.send(\"eth_accounts\", []).then(function (accounts) {\n\t            return accounts.map(function (a) { return _this.formatter.address(a); });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (this._nextId++),\n\t            jsonrpc: \"2.0\"\n\t        };\n\t        this.emit(\"debug\", {\n\t            action: \"request\",\n\t            request: lib$3.deepCopy(request),\n\t            provider: this\n\t        });\n\t        return lib$l.fetchJson(this.connection, JSON.stringify(request), getResult).then(function (result) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                request: request,\n\t                response: result,\n\t                provider: _this\n\t            });\n\t            return result;\n\t        }, function (error) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                error: error,\n\t                request: request,\n\t                provider: _this\n\t            });\n\t            throw error;\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.prepareRequest = function (method, params) {\n\t        switch (method) {\n\t            case \"getBlockNumber\":\n\t                return [\"eth_blockNumber\", []];\n\t            case \"getGasPrice\":\n\t                return [\"eth_gasPrice\", []];\n\t            case \"getBalance\":\n\t                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getTransactionCount\":\n\t                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getCode\":\n\t                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getStorageAt\":\n\t                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n\t            case \"sendTransaction\":\n\t                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n\t            case \"getBlock\":\n\t                if (params.blockTag) {\n\t                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n\t                }\n\t                else if (params.blockHash) {\n\t                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n\t                }\n\t                return null;\n\t            case \"getTransaction\":\n\t                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n\t            case \"getTransactionReceipt\":\n\t                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n\t            case \"call\": {\n\t                var hexlifyTransaction = lib$3.getStatic(this.constructor, \"hexlifyTransaction\");\n\t                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n\t            }\n\t            case \"estimateGas\": {\n\t                var hexlifyTransaction = lib$3.getStatic(this.constructor, \"hexlifyTransaction\");\n\t                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n\t            }\n\t            case \"getLogs\":\n\t                if (params.filter && params.filter.address != null) {\n\t                    params.filter.address = getLowerCase(params.filter.address);\n\t                }\n\t                return [\"eth_getLogs\", [params.filter]];\n\t            default:\n\t                break;\n\t        }\n\t        return null;\n\t    };\n\t    JsonRpcProvider.prototype.perform = function (method, params) {\n\t        var args = this.prepareRequest(method, params);\n\t        if (args == null) {\n\t            logger.throwError(method + \" not implemented\", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t        }\n\t        // We need a little extra logic to process errors from sendTransaction\n\t        if (method === \"sendTransaction\") {\n\t            return this.send(args[0], args[1]).catch(function (error) {\n\t                if (error.responseText) {\n\t                    // \"insufficient funds for gas * price + value\"\n\t                    if (error.responseText.indexOf(\"insufficient funds\") > 0) {\n\t                        logger.throwError(\"insufficient funds\", lib.Logger.errors.INSUFFICIENT_FUNDS, {});\n\t                    }\n\t                    // \"nonce too low\"\n\t                    if (error.responseText.indexOf(\"nonce too low\") > 0) {\n\t                        logger.throwError(\"nonce has already been used\", lib.Logger.errors.NONCE_EXPIRED, {});\n\t                    }\n\t                    // \"replacement transaction underpriced\"\n\t                    if (error.responseText.indexOf(\"replacement transaction underpriced\") > 0) {\n\t                        logger.throwError(\"replacement fee too low\", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {});\n\t                    }\n\t                }\n\t                throw error;\n\t            });\n\t        }\n\t        return this.send(args[0], args[1]);\n\t    };\n\t    JsonRpcProvider.prototype._startEvent = function (event) {\n\t        if (event.tag === \"pending\") {\n\t            this._startPending();\n\t        }\n\t        _super.prototype._startEvent.call(this, event);\n\t    };\n\t    JsonRpcProvider.prototype._startPending = function () {\n\t        if (this._pendingFilter != null) {\n\t            return;\n\t        }\n\t        var self = this;\n\t        var pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n\t        this._pendingFilter = pendingFilter;\n\t        pendingFilter.then(function (filterId) {\n\t            function poll() {\n\t                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        return null;\n\t                    }\n\t                    var seq = Promise.resolve();\n\t                    hashes.forEach(function (hash) {\n\t                        // @TODO: This should be garbage collected at some point... How? When?\n\t                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n\t                        seq = seq.then(function () {\n\t                            return self.getTransaction(hash).then(function (tx) {\n\t                                self.emit(\"pending\", tx);\n\t                                return null;\n\t                            });\n\t                        });\n\t                    });\n\t                    return seq.then(function () {\n\t                        return timer(1000);\n\t                    });\n\t                }).then(function () {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        self.send(\"eth_uninstallFilter\", [filterId]);\n\t                        return;\n\t                    }\n\t                    setTimeout(function () { poll(); }, 0);\n\t                    return null;\n\t                }).catch(function (error) { });\n\t            }\n\t            poll();\n\t            return filterId;\n\t        }).catch(function (error) { });\n\t    };\n\t    JsonRpcProvider.prototype._stopEvent = function (event) {\n\t        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n\t            this._pendingFilter = null;\n\t        }\n\t        _super.prototype._stopEvent.call(this, event);\n\t    };\n\t    // Convert an ethers.js transaction into a JSON-RPC transaction\n\t    //  - gasLimit => gas\n\t    //  - All values hexlified\n\t    //  - All numeric values zero-striped\n\t    //  - All addresses are lowercased\n\t    // NOTE: This allows a TransactionRequest, but all values should be resolved\n\t    //       before this is called\n\t    // @TODO: This will likely be removed in future versions and prepareRequest\n\t    //        will be the preferred method for this.\n\t    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {\n\t        // Check only allowed properties are given\n\t        var allowed = lib$3.shallowCopy(allowedTransactionKeys);\n\t        if (allowExtra) {\n\t            for (var key in allowExtra) {\n\t                if (allowExtra[key]) {\n\t                    allowed[key] = true;\n\t                }\n\t            }\n\t        }\n\t        lib$3.checkProperties(transaction, allowed);\n\t        var result = {};\n\t        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n\t        [\"gasLimit\", \"gasPrice\", \"nonce\", \"value\"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            var value = lib$1.hexValue(transaction[key]);\n\t            if (key === \"gasLimit\") {\n\t                key = \"gas\";\n\t            }\n\t            result[key] = value;\n\t        });\n\t        [\"from\", \"to\", \"data\"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            result[key] = lib$1.hexlify(transaction[key]);\n\t        });\n\t        return result;\n\t    };\n\t    return JsonRpcProvider;\n\t}(baseProvider.BaseProvider));\n\texports.JsonRpcProvider = JsonRpcProvider;\n\t});\n\n\tvar jsonRpcProvider$1 = unwrapExports(jsonRpcProvider);\n\tvar jsonRpcProvider_1 = jsonRpcProvider.JsonRpcSigner;\n\tvar jsonRpcProvider_2 = jsonRpcProvider.JsonRpcProvider;\n\n\tvar urlJsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar UrlJsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(UrlJsonRpcProvider, _super);\n\t    function UrlJsonRpcProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);\n\t        // Normalize the Network and API Key\n\t        network = lib$3.getStatic((_newTarget), \"getNetwork\")(network);\n\t        apiKey = lib$3.getStatic((_newTarget), \"getApiKey\")(apiKey);\n\t        var connection = lib$3.getStatic((_newTarget), \"getUrl\")(network, apiKey);\n\t        _this = _super.call(this, connection, network) || this;\n\t        if (typeof (apiKey) === \"string\") {\n\t            lib$3.defineReadOnly(_this, \"apiKey\", apiKey);\n\t        }\n\t        else if (apiKey != null) {\n\t            Object.keys(apiKey).forEach(function (key) {\n\t                lib$3.defineReadOnly(_this, key, apiKey[key]);\n\t            });\n\t        }\n\t        return _this;\n\t    }\n\t    UrlJsonRpcProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this.network];\n\t            });\n\t        });\n\t    };\n\t    UrlJsonRpcProvider.prototype._startPending = function () {\n\t        logger.warn(\"WARNING: API provider does not support pending filters\");\n\t    };\n\t    UrlJsonRpcProvider.prototype.getSigner = function (address) {\n\t        return logger.throwError(\"API provider does not support signing\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n\t    };\n\t    UrlJsonRpcProvider.prototype.listAccounts = function () {\n\t        return Promise.resolve([]);\n\t    };\n\t    // Return a defaultApiKey if null, otherwise validate the API key\n\t    UrlJsonRpcProvider.getApiKey = function (apiKey) {\n\t        return apiKey;\n\t    };\n\t    // Returns the url or connection for the given network and API key. The\n\t    // API key will have been sanitized by the getApiKey first, so any validation\n\t    // or transformations can be done there.\n\t    UrlJsonRpcProvider.getUrl = function (network, apiKey) {\n\t        return logger.throwError(\"not implemented; sub-classes must override getUrl\", lib.Logger.errors.NOT_IMPLEMENTED, {\n\t            operation: \"getUrl\"\n\t        });\n\t    };\n\t    return UrlJsonRpcProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.UrlJsonRpcProvider = UrlJsonRpcProvider;\n\t});\n\n\tvar urlJsonRpcProvider$1 = unwrapExports(urlJsonRpcProvider);\n\tvar urlJsonRpcProvider_1 = urlJsonRpcProvider.UrlJsonRpcProvider;\n\n\tvar alchemyProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// This key was provided to ethers.js by Alchemy to be used by the\n\t// default provider, but it is recommended that for your own\n\t// production environments, that you acquire your own API key at:\n\t//   https://dashboard.alchemyapi.io\n\tvar defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\n\tvar AlchemyProvider = /** @class */ (function (_super) {\n\t    __extends(AlchemyProvider, _super);\n\t    function AlchemyProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    AlchemyProvider.getApiKey = function (apiKey) {\n\t        if (apiKey == null) {\n\t            return defaultApiKey;\n\t        }\n\t        if (apiKey && typeof (apiKey) !== \"string\") {\n\t            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        return apiKey;\n\t    };\n\t    AlchemyProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"eth-mainnet.alchemyapi.io/jsonrpc/\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"eth-ropsten.alchemyapi.io/jsonrpc/\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"eth-rinkeby.alchemyapi.io/jsonrpc/\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"eth-goerli.alchemyapi.io/jsonrpc/\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"eth-kovan.alchemyapi.io/jsonrpc/\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return (\"https:/\" + \"/\" + host + apiKey);\n\t    };\n\t    return AlchemyProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.AlchemyProvider = AlchemyProvider;\n\t});\n\n\tvar alchemyProvider$1 = unwrapExports(alchemyProvider);\n\tvar alchemyProvider_1 = alchemyProvider.AlchemyProvider;\n\n\tvar cloudflareProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar CloudflareProvider = /** @class */ (function (_super) {\n\t    __extends(CloudflareProvider, _super);\n\t    function CloudflareProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CloudflareProvider.getApiKey = function (apiKey) {\n\t        if (apiKey != null) {\n\t            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n\t        }\n\t        return null;\n\t    };\n\t    CloudflareProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"https://cloudflare-eth.com/\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return host;\n\t    };\n\t    CloudflareProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var block;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === \"getBlockNumber\")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, _super.prototype.perform.call(this, \"getBlock\", { blockTag: \"latest\" })];\n\t                    case 1:\n\t                        block = _a.sent();\n\t                        return [2 /*return*/, block.number];\n\t                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return CloudflareProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.CloudflareProvider = CloudflareProvider;\n\t});\n\n\tvar cloudflareProvider$1 = unwrapExports(cloudflareProvider);\n\tvar cloudflareProvider_1 = cloudflareProvider.CloudflareProvider;\n\n\tvar etherscanProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// The transaction has already been sanitized by the calls in Provider\n\tfunction getTransactionString(transaction) {\n\t    var result = [];\n\t    for (var key in transaction) {\n\t        if (transaction[key] == null) {\n\t            continue;\n\t        }\n\t        var value = lib$1.hexlify(transaction[key]);\n\t        if ({ gasLimit: true, gasPrice: true, nonce: true, value: true }[key]) {\n\t            value = lib$1.hexValue(value);\n\t        }\n\t        result.push(key + \"=\" + value);\n\t    }\n\t    return result.join(\"&\");\n\t}\n\tfunction getResult(result) {\n\t    // getLogs, getHistory have weird success responses\n\t    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n\t        return result.result;\n\t    }\n\t    if (result.status != 1 || result.message != \"OK\") {\n\t        // @TODO: not any\n\t        var error = new Error(\"invalid response\");\n\t        error.result = JSON.stringify(result);\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\tfunction getJsonResult(result) {\n\t    if (result.jsonrpc != \"2.0\") {\n\t        // @TODO: not any\n\t        var error = new Error(\"invalid response\");\n\t        error.result = JSON.stringify(result);\n\t        throw error;\n\t    }\n\t    if (result.error) {\n\t        // @TODO: not any\n\t        var error = new Error(result.error.message || \"unknown error\");\n\t        if (result.error.code) {\n\t            error.code = result.error.code;\n\t        }\n\t        if (result.error.data) {\n\t            error.data = result.error.data;\n\t        }\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\t// The blockTag was normalized as a string by the Provider pre-perform operations\n\tfunction checkLogTag(blockTag) {\n\t    if (blockTag === \"pending\") {\n\t        throw new Error(\"pending not supported\");\n\t    }\n\t    if (blockTag === \"latest\") {\n\t        return blockTag;\n\t    }\n\t    return parseInt(blockTag.substring(2), 16);\n\t}\n\tvar defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\tvar EtherscanProvider = /** @class */ (function (_super) {\n\t    __extends(EtherscanProvider, _super);\n\t    function EtherscanProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, EtherscanProvider);\n\t        _this = _super.call(this, network) || this;\n\t        var name = \"invalid\";\n\t        if (_this.network) {\n\t            name = _this.network.name;\n\t        }\n\t        var baseUrl = null;\n\t        switch (name) {\n\t            case \"homestead\":\n\t                baseUrl = \"https://api.etherscan.io\";\n\t                break;\n\t            case \"ropsten\":\n\t                baseUrl = \"https://api-ropsten.etherscan.io\";\n\t                break;\n\t            case \"rinkeby\":\n\t                baseUrl = \"https://api-rinkeby.etherscan.io\";\n\t                break;\n\t            case \"kovan\":\n\t                baseUrl = \"https://api-kovan.etherscan.io\";\n\t                break;\n\t            case \"goerli\":\n\t                baseUrl = \"https://api-goerli.etherscan.io\";\n\t                break;\n\t            default:\n\t                throw new Error(\"unsupported network\");\n\t        }\n\t        lib$3.defineReadOnly(_this, \"baseUrl\", baseUrl);\n\t        lib$3.defineReadOnly(_this, \"apiKey\", apiKey || defaultApiKey);\n\t        return _this;\n\t    }\n\t    EtherscanProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this.network];\n\t            });\n\t        });\n\t    };\n\t    EtherscanProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var url, apiKey, get, _a, transaction, transaction, topic0, logs, txs, i, log, tx, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0:\n\t                        url = this.baseUrl;\n\t                        apiKey = \"\";\n\t                        if (this.apiKey) {\n\t                            apiKey += \"&apikey=\" + this.apiKey;\n\t                        }\n\t                        get = function (url, procFunc) { return __awaiter(_this, void 0, void 0, function () {\n\t                            var result;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0:\n\t                                        this.emit(\"debug\", {\n\t                                            action: \"request\",\n\t                                            request: url,\n\t                                            provider: this\n\t                                        });\n\t                                        return [4 /*yield*/, lib$l.fetchJson(url, null, procFunc || getJsonResult)];\n\t                                    case 1:\n\t                                        result = _a.sent();\n\t                                        this.emit(\"debug\", {\n\t                                            action: \"response\",\n\t                                            request: url,\n\t                                            response: lib$3.deepCopy(result),\n\t                                            provider: this\n\t                                        });\n\t                                        return [2 /*return*/, result];\n\t                                }\n\t                            });\n\t                        }); };\n\t                        _a = method;\n\t                        switch (_a) {\n\t                            case \"getBlockNumber\": return [3 /*break*/, 1];\n\t                            case \"getGasPrice\": return [3 /*break*/, 2];\n\t                            case \"getBalance\": return [3 /*break*/, 3];\n\t                            case \"getTransactionCount\": return [3 /*break*/, 4];\n\t                            case \"getCode\": return [3 /*break*/, 5];\n\t                            case \"getStorageAt\": return [3 /*break*/, 6];\n\t                            case \"sendTransaction\": return [3 /*break*/, 7];\n\t                            case \"getBlock\": return [3 /*break*/, 8];\n\t                            case \"getTransaction\": return [3 /*break*/, 9];\n\t                            case \"getTransactionReceipt\": return [3 /*break*/, 10];\n\t                            case \"call\": return [3 /*break*/, 11];\n\t                            case \"estimateGas\": return [3 /*break*/, 12];\n\t                            case \"getLogs\": return [3 /*break*/, 13];\n\t                            case \"getEtherPrice\": return [3 /*break*/, 20];\n\t                        }\n\t                        return [3 /*break*/, 22];\n\t                    case 1:\n\t                        url += \"/api?module=proxy&action=eth_blockNumber\" + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 2:\n\t                        url += \"/api?module=proxy&action=eth_gasPrice\" + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 3:\n\t                        // Returns base-10 result\n\t                        url += \"/api?module=account&action=balance&address=\" + params.address;\n\t                        url += \"&tag=\" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url, getResult)];\n\t                    case 4:\n\t                        url += \"/api?module=proxy&action=eth_getTransactionCount&address=\" + params.address;\n\t                        url += \"&tag=\" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 5:\n\t                        url += \"/api?module=proxy&action=eth_getCode&address=\" + params.address;\n\t                        url += \"&tag=\" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url, getJsonResult)];\n\t                    case 6:\n\t                        url += \"/api?module=proxy&action=eth_getStorageAt&address=\" + params.address;\n\t                        url += \"&position=\" + params.position;\n\t                        url += \"&tag=\" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url, getJsonResult)];\n\t                    case 7:\n\t                        url += \"/api?module=proxy&action=eth_sendRawTransaction&hex=\" + params.signedTransaction;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url).catch(function (error) {\n\t                                if (error.responseText) {\n\t                                    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n\t                                    if (error.responseText.toLowerCase().indexOf(\"insufficient funds\") >= 0) {\n\t                                        logger.throwError(\"insufficient funds\", lib.Logger.errors.INSUFFICIENT_FUNDS, {});\n\t                                    }\n\t                                    // \"Transaction with the same hash was already imported.\"\n\t                                    if (error.responseText.indexOf(\"same hash was already imported\") >= 0) {\n\t                                        logger.throwError(\"nonce has already been used\", lib.Logger.errors.NONCE_EXPIRED, {});\n\t                                    }\n\t                                    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n\t                                    if (error.responseText.indexOf(\"another transaction with same nonce\") >= 0) {\n\t                                        logger.throwError(\"replacement fee too low\", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {});\n\t                                    }\n\t                                }\n\t                                throw error;\n\t                            })];\n\t                    case 8:\n\t                        if (params.blockTag) {\n\t                            url += \"/api?module=proxy&action=eth_getBlockByNumber&tag=\" + params.blockTag;\n\t                            if (params.includeTransactions) {\n\t                                url += \"&boolean=true\";\n\t                            }\n\t                            else {\n\t                                url += \"&boolean=false\";\n\t                            }\n\t                            url += apiKey;\n\t                            return [2 /*return*/, get(url)];\n\t                        }\n\t                        throw new Error(\"getBlock by blockHash not implemented\");\n\t                    case 9:\n\t                        url += \"/api?module=proxy&action=eth_getTransactionByHash&txhash=\" + params.transactionHash;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 10:\n\t                        url += \"/api?module=proxy&action=eth_getTransactionReceipt&txhash=\" + params.transactionHash;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 11:\n\t                        {\n\t                            transaction = getTransactionString(params.transaction);\n\t                            if (transaction) {\n\t                                transaction = \"&\" + transaction;\n\t                            }\n\t                            url += \"/api?module=proxy&action=eth_call\" + transaction;\n\t                            //url += \"&tag=\" + params.blockTag + apiKey;\n\t                            if (params.blockTag !== \"latest\") {\n\t                                throw new Error(\"EtherscanProvider does not support blockTag for call\");\n\t                            }\n\t                            url += apiKey;\n\t                            return [2 /*return*/, get(url)];\n\t                        }\n\t                        _c.label = 12;\n\t                    case 12:\n\t                        {\n\t                            transaction = getTransactionString(params.transaction);\n\t                            if (transaction) {\n\t                                transaction = \"&\" + transaction;\n\t                            }\n\t                            url += \"/api?module=proxy&action=eth_estimateGas&\" + transaction;\n\t                            url += apiKey;\n\t                            return [2 /*return*/, get(url)];\n\t                        }\n\t                        _c.label = 13;\n\t                    case 13:\n\t                        url += \"/api?module=logs&action=getLogs\";\n\t                        if (params.filter.fromBlock) {\n\t                            url += \"&fromBlock=\" + checkLogTag(params.filter.fromBlock);\n\t                        }\n\t                        if (params.filter.toBlock) {\n\t                            url += \"&toBlock=\" + checkLogTag(params.filter.toBlock);\n\t                        }\n\t                        if (params.filter.address) {\n\t                            url += \"&address=\" + params.filter.address;\n\t                        }\n\t                        // @TODO: We can handle slightly more complicated logs using the logs API\n\t                        if (params.filter.topics && params.filter.topics.length > 0) {\n\t                            if (params.filter.topics.length > 1) {\n\t                                logger.throwError(\"unsupported topic count\", lib.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n\t                            }\n\t                            if (params.filter.topics.length === 1) {\n\t                                topic0 = params.filter.topics[0];\n\t                                if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n\t                                    logger.throwError(\"unsupported topic format\", lib.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n\t                                }\n\t                                url += \"&topic0=\" + topic0;\n\t                            }\n\t                        }\n\t                        url += apiKey;\n\t                        return [4 /*yield*/, get(url, getResult)];\n\t                    case 14:\n\t                        logs = _c.sent();\n\t                        txs = {};\n\t                        i = 0;\n\t                        _c.label = 15;\n\t                    case 15:\n\t                        if (!(i < logs.length)) return [3 /*break*/, 19];\n\t                        log = logs[i];\n\t                        if (log.blockHash != null) {\n\t                            return [3 /*break*/, 18];\n\t                        }\n\t                        if (!(txs[log.transactionHash] == null)) return [3 /*break*/, 17];\n\t                        return [4 /*yield*/, this.getTransaction(log.transactionHash)];\n\t                    case 16:\n\t                        tx = _c.sent();\n\t                        if (tx) {\n\t                            txs[log.transactionHash] = tx.blockHash;\n\t                        }\n\t                        _c.label = 17;\n\t                    case 17:\n\t                        log.blockHash = txs[log.transactionHash];\n\t                        _c.label = 18;\n\t                    case 18:\n\t                        i++;\n\t                        return [3 /*break*/, 15];\n\t                    case 19: return [2 /*return*/, logs];\n\t                    case 20:\n\t                        if (this.network.name !== \"homestead\") {\n\t                            return [2 /*return*/, 0.0];\n\t                        }\n\t                        url += \"/api?module=stats&action=ethprice\";\n\t                        url += apiKey;\n\t                        _b = parseFloat;\n\t                        return [4 /*yield*/, get(url, getResult)];\n\t                    case 21: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];\n\t                    case 22: return [3 /*break*/, 23];\n\t                    case 23: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // @TODO: Allow startBlock and endBlock to be Promises\n\t    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {\n\t        var _this = this;\n\t        var url = this.baseUrl;\n\t        var apiKey = \"\";\n\t        if (this.apiKey) {\n\t            apiKey += \"&apikey=\" + this.apiKey;\n\t        }\n\t        if (startBlock == null) {\n\t            startBlock = 0;\n\t        }\n\t        if (endBlock == null) {\n\t            endBlock = 99999999;\n\t        }\n\t        return this.resolveName(addressOrName).then(function (address) {\n\t            url += \"/api?module=account&action=txlist&address=\" + address;\n\t            url += \"&startblock=\" + startBlock;\n\t            url += \"&endblock=\" + endBlock;\n\t            url += \"&sort=asc\" + apiKey;\n\t            _this.emit(\"debug\", {\n\t                action: \"request\",\n\t                request: url,\n\t                provider: _this\n\t            });\n\t            return lib$l.fetchJson(url, null, getResult).then(function (result) {\n\t                _this.emit(\"debug\", {\n\t                    action: \"response\",\n\t                    request: url,\n\t                    response: lib$3.deepCopy(result),\n\t                    provider: _this\n\t                });\n\t                var output = [];\n\t                result.forEach(function (tx) {\n\t                    [\"contractAddress\", \"to\"].forEach(function (key) {\n\t                        if (tx[key] == \"\") {\n\t                            delete tx[key];\n\t                        }\n\t                    });\n\t                    if (tx.creates == null && tx.contractAddress != null) {\n\t                        tx.creates = tx.contractAddress;\n\t                    }\n\t                    var item = _this.formatter.transactionResponse(tx);\n\t                    if (tx.timeStamp) {\n\t                        item.timestamp = parseInt(tx.timeStamp);\n\t                    }\n\t                    output.push(item);\n\t                });\n\t                return output;\n\t            });\n\t        });\n\t    };\n\t    return EtherscanProvider;\n\t}(baseProvider.BaseProvider));\n\texports.EtherscanProvider = EtherscanProvider;\n\t});\n\n\tvar etherscanProvider$1 = unwrapExports(etherscanProvider);\n\tvar etherscanProvider_1 = etherscanProvider.EtherscanProvider;\n\n\tvar fallbackProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tfunction now() { return (new Date()).getTime(); }\n\t// Returns to network as long as all agree, or null if any is null.\n\t// Throws an error if any two networks do not match.\n\tfunction checkNetworks(networks) {\n\t    var result = null;\n\t    for (var i = 0; i < networks.length; i++) {\n\t        var network = networks[i];\n\t        // Null! We do not know our network; bail.\n\t        if (network == null) {\n\t            return null;\n\t        }\n\t        if (result) {\n\t            // Make sure the network matches the previous networks\n\t            if (!(result.name === network.name && result.chainId === network.chainId &&\n\t                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\t                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n\t            }\n\t        }\n\t        else {\n\t            result = network;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction median(values, maxDelta) {\n\t    values = values.slice().sort();\n\t    var middle = Math.floor(values.length / 2);\n\t    // Odd length; take the middle\n\t    if (values.length % 2) {\n\t        return values[middle];\n\t    }\n\t    // Even length; take the average of the two middle\n\t    var a = values[middle - 1], b = values[middle];\n\t    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n\t        return null;\n\t    }\n\t    return (a + b) / 2;\n\t}\n\tfunction serialize(value) {\n\t    if (value === null) {\n\t        return \"null\";\n\t    }\n\t    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n\t        return JSON.stringify(value);\n\t    }\n\t    else if (typeof (value) === \"string\") {\n\t        return value;\n\t    }\n\t    else if (lib$2.BigNumber.isBigNumber(value)) {\n\t        return value.toString();\n\t    }\n\t    else if (Array.isArray(value)) {\n\t        return JSON.stringify(value.map(function (i) { return serialize(i); }));\n\t    }\n\t    else if (typeof (value) === \"object\") {\n\t        var keys = Object.keys(value);\n\t        keys.sort();\n\t        return \"{\" + keys.map(function (key) {\n\t            var v = value[key];\n\t            if (typeof (v) === \"function\") {\n\t                v = \"[function]\";\n\t            }\n\t            else {\n\t                v = serialize(v);\n\t            }\n\t            return JSON.stringify(key) + \":\" + v;\n\t        }).join(\",\") + \"}\";\n\t    }\n\t    throw new Error(\"unknown value type: \" + typeof (value));\n\t}\n\t// Next request ID to use for emitting debug info\n\tvar nextRid = 1;\n\t;\n\tfunction stall(duration) {\n\t    var cancel = null;\n\t    var timer = null;\n\t    var promise = (new Promise(function (resolve) {\n\t        cancel = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t            resolve();\n\t        };\n\t        timer = setTimeout(cancel, duration);\n\t    }));\n\t    var wait = function (func) {\n\t        promise = promise.then(func);\n\t        return promise;\n\t    };\n\t    function getPromise() {\n\t        return promise;\n\t    }\n\t    return { cancel: cancel, getPromise: getPromise, wait: wait };\n\t}\n\t;\n\tfunction exposeDebugConfig(config, now) {\n\t    var result = {\n\t        provider: config.provider,\n\t        weight: config.weight\n\t    };\n\t    if (config.start) {\n\t        result.start = config.start;\n\t    }\n\t    if (now) {\n\t        result.duration = (now - config.start);\n\t    }\n\t    if (config.done) {\n\t        if (config.error) {\n\t            result.error = config.error;\n\t        }\n\t        else {\n\t            result.result = config.result || null;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction normalizedTally(normalize, quorum) {\n\t    return function (configs) {\n\t        // Count the votes for each result\n\t        var tally = {};\n\t        configs.forEach(function (c) {\n\t            var value = normalize(c.result);\n\t            if (!tally[value]) {\n\t                tally[value] = { count: 0, result: c.result };\n\t            }\n\t            tally[value].count++;\n\t        });\n\t        // Check for a quorum on any given result\n\t        var keys = Object.keys(tally);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            var check = tally[keys[i]];\n\t            if (check.count >= quorum) {\n\t                return check.result;\n\t            }\n\t        }\n\t        // No quroum\n\t        return undefined;\n\t    };\n\t}\n\tfunction getProcessFunc(provider, method, params) {\n\t    var normalize = serialize;\n\t    switch (method) {\n\t        case \"getBlockNumber\":\n\t            // Return the median value, unless there is (median + 1) is also\n\t            // present, in which case that is probably true and the median\n\t            // is going to be stale soon. In the event of a malicious node,\n\t            // the lie will be true soon enough.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                // Get the median block number\n\t                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);\n\t                if (blockNumber == null) {\n\t                    return undefined;\n\t                }\n\t                blockNumber = Math.ceil(blockNumber);\n\t                // If the next block height is present, its prolly safe to use\n\t                if (values.indexOf(blockNumber + 1) >= 0) {\n\t                    blockNumber++;\n\t                }\n\t                // Don't ever roll back the blockNumber\n\t                if (blockNumber >= provider._highestBlockNumber) {\n\t                    provider._highestBlockNumber = blockNumber;\n\t                }\n\t                return provider._highestBlockNumber;\n\t            };\n\t        case \"getGasPrice\":\n\t            // Return the middle (round index up) value, similar to median\n\t            // but do not average even entries and choose the higher.\n\t            // Malicious actors must compromise 50% of the nodes to lie.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                values.sort();\n\t                return values[Math.floor(values.length / 2)];\n\t            };\n\t        case \"getEtherPrice\":\n\t            // Returns the median price. Malicious actors must compromise at\n\t            // least 50% of the nodes to lie (in a meaningful way).\n\t            return function (configs) {\n\t                return median(configs.map(function (c) { return c.result; }));\n\t            };\n\t        // No additional normalizing required; serialize is enough\n\t        case \"getBalance\":\n\t        case \"getTransactionCount\":\n\t        case \"getCode\":\n\t        case \"getStorageAt\":\n\t        case \"call\":\n\t        case \"estimateGas\":\n\t        case \"getLogs\":\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case \"getTransaction\":\n\t        case \"getTransactionReceipt\":\n\t            normalize = function (tx) {\n\t                if (tx == null) {\n\t                    return null;\n\t                }\n\t                tx = lib$3.shallowCopy(tx);\n\t                tx.confirmations = -1;\n\t                return serialize(tx);\n\t            };\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case \"getBlock\":\n\t            // We drop the confirmations from transactions as it is approximate\n\t            if (params.includeTransactions) {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    block = lib$3.shallowCopy(block);\n\t                    block.transactions = block.transactions.map(function (tx) {\n\t                        tx = lib$3.shallowCopy(tx);\n\t                        tx.confirmations = -1;\n\t                        return tx;\n\t                    });\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            else {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            break;\n\t        default:\n\t            throw new Error(\"unknown method: \" + method);\n\t    }\n\t    // Return the result if and only if the expected quorum is\n\t    // satisfied and agreed upon for the final result.\n\t    return normalizedTally(normalize, provider.quorum);\n\t}\n\t// If we are doing a blockTag query, we need to make sure the backend is\n\t// caught up to the FallbackProvider, before sending a request to it.\n\tfunction waitForSync(config, blockNumber) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider;\n\t        return __generator(this, function (_a) {\n\t            provider = (config.provider);\n\t            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n\t                return [2 /*return*/, provider];\n\t            }\n\t            return [2 /*return*/, lib$l.poll(function () {\n\t                    return new Promise(function (resolve, reject) {\n\t                        setTimeout(function () {\n\t                            // We are synced\n\t                            if (provider.blockNumber >= blockNumber) {\n\t                                return resolve(provider);\n\t                            }\n\t                            // We're done; just quit\n\t                            if (config.cancelled) {\n\t                                return resolve(null);\n\t                            }\n\t                            // Try again, next block\n\t                            return resolve(undefined);\n\t                        }, 0);\n\t                    });\n\t                }, { oncePoll: provider })];\n\t        });\n\t    });\n\t}\n\tfunction getRunner(config, currentBlockNumber, method, params) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider, _a, filter;\n\t        return __generator(this, function (_b) {\n\t            switch (_b.label) {\n\t                case 0:\n\t                    provider = config.provider;\n\t                    _a = method;\n\t                    switch (_a) {\n\t                        case \"getBlockNumber\": return [3 /*break*/, 1];\n\t                        case \"getGasPrice\": return [3 /*break*/, 1];\n\t                        case \"getEtherPrice\": return [3 /*break*/, 2];\n\t                        case \"getBalance\": return [3 /*break*/, 3];\n\t                        case \"getTransactionCount\": return [3 /*break*/, 3];\n\t                        case \"getCode\": return [3 /*break*/, 3];\n\t                        case \"getStorageAt\": return [3 /*break*/, 6];\n\t                        case \"getBlock\": return [3 /*break*/, 9];\n\t                        case \"call\": return [3 /*break*/, 12];\n\t                        case \"estimateGas\": return [3 /*break*/, 12];\n\t                        case \"getTransaction\": return [3 /*break*/, 15];\n\t                        case \"getTransactionReceipt\": return [3 /*break*/, 15];\n\t                        case \"getLogs\": return [3 /*break*/, 16];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 1: return [2 /*return*/, provider[method]()];\n\t                case 2:\n\t                    if (provider.getEtherPrice) {\n\t                        return [2 /*return*/, provider.getEtherPrice()];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 3:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 5];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 4:\n\t                    provider = _b.sent();\n\t                    _b.label = 5;\n\t                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || \"latest\")];\n\t                case 6:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 8];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 7:\n\t                    provider = _b.sent();\n\t                    _b.label = 8;\n\t                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\")];\n\t                case 9:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 11];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 10:\n\t                    provider = _b.sent();\n\t                    _b.label = 11;\n\t                case 11: return [2 /*return*/, provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash)];\n\t                case 12:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 14];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 13:\n\t                    provider = _b.sent();\n\t                    _b.label = 14;\n\t                case 14: return [2 /*return*/, provider[method](params.transaction)];\n\t                case 15: return [2 /*return*/, provider[method](params.transactionHash)];\n\t                case 16:\n\t                    filter = params.filter;\n\t                    if (!((filter.fromBlock && lib$1.isHexString(filter.fromBlock)) || (filter.toBlock && lib$1.isHexString(filter.toBlock)))) return [3 /*break*/, 18];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 17:\n\t                    provider = _b.sent();\n\t                    _b.label = 18;\n\t                case 18: return [2 /*return*/, provider.getLogs(filter)];\n\t                case 19: return [2 /*return*/, logger.throwError(\"unknown method error\", lib.Logger.errors.UNKNOWN_ERROR, {\n\t                        method: method,\n\t                        params: params\n\t                    })];\n\t            }\n\t        });\n\t    });\n\t}\n\tvar FallbackProvider = /** @class */ (function (_super) {\n\t    __extends(FallbackProvider, _super);\n\t    function FallbackProvider(providers, quorum) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, FallbackProvider);\n\t        if (providers.length === 0) {\n\t            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n\t        }\n\t        var providerConfigs = providers.map(function (configOrProvider, index) {\n\t            if (lib$b.Provider.isProvider(configOrProvider)) {\n\t                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: 750, priority: 1 });\n\t            }\n\t            var config = lib$3.shallowCopy(configOrProvider);\n\t            if (config.priority == null) {\n\t                config.priority = 1;\n\t            }\n\t            if (config.stallTimeout == null) {\n\t                config.stallTimeout = 750;\n\t            }\n\t            if (config.weight == null) {\n\t                config.weight = 1;\n\t            }\n\t            var weight = config.weight;\n\t            if (weight % 1 || weight > 512 || weight < 1) {\n\t                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\" + index + \"].weight\", weight);\n\t            }\n\t            return Object.freeze(config);\n\t        });\n\t        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t        if (quorum == null) {\n\t            quorum = total / 2;\n\t        }\n\t        else if (quorum > total) {\n\t            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n\t        }\n\t        // Are all providers' networks are known\n\t        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));\n\t        // Not all networks are known; we must stall\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(resolve, reject);\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Preserve a copy, so we do not get mutated\n\t        lib$3.defineReadOnly(_this, \"providerConfigs\", Object.freeze(providerConfigs));\n\t        lib$3.defineReadOnly(_this, \"quorum\", quorum);\n\t        _this._highestBlockNumber = -1;\n\t        return _this;\n\t    }\n\t    FallbackProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var networks;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];\n\t                    case 1:\n\t                        networks = _a.sent();\n\t                        return [2 /*return*/, checkNetworks(networks)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    FallbackProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === \"sendTransaction\")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {\n\t                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n\t                                    return result.hash;\n\t                                }, function (error) {\n\t                                    return error;\n\t                                });\n\t                            }))];\n\t                    case 1:\n\t                        results = _a.sent();\n\t                        // Any success is good enough (other errors are likely \"already seen\" errors\n\t                        for (i_1 = 0; i_1 < results.length; i_1++) {\n\t                            result = results[i_1];\n\t                            if (typeof (result) === \"string\") {\n\t                                return [2 /*return*/, result];\n\t                            }\n\t                        }\n\t                        // They were all an error; pick the first error\n\t                        throw results[0];\n\t                    case 2:\n\t                        if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) return [3 /*break*/, 4];\n\t                        return [4 /*yield*/, this.getBlockNumber()];\n\t                    case 3:\n\t                        _a.sent();\n\t                        _a.label = 4;\n\t                    case 4:\n\t                        processFunc = getProcessFunc(this, method, params);\n\t                        configs = browser$6.shuffled(this.providerConfigs.map(lib$3.shallowCopy));\n\t                        configs.sort(function (a, b) { return (a.priority - b.priority); });\n\t                        currentBlockNumber = this._highestBlockNumber;\n\t                        i = 0;\n\t                        first = true;\n\t                        _loop_1 = function () {\n\t                            var t0, inflightWeight, _loop_2, waiting, results, result;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0:\n\t                                        t0 = now();\n\t                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })\n\t                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t                                        _loop_2 = function () {\n\t                                            var config = configs[i++];\n\t                                            var rid = nextRid++;\n\t                                            config.start = now();\n\t                                            config.staller = stall(config.stallTimeout);\n\t                                            config.staller.wait(function () { config.staller = null; });\n\t                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n\t                                                config.done = true;\n\t                                                config.result = result;\n\t                                                if (_this.listenerCount(\"debug\")) {\n\t                                                    _this.emit(\"debug\", {\n\t                                                        action: \"request\",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            }, function (error) {\n\t                                                config.done = true;\n\t                                                config.error = error;\n\t                                                if (_this.listenerCount(\"debug\")) {\n\t                                                    _this.emit(\"debug\", {\n\t                                                        action: \"request\",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            });\n\t                                            if (this_1.listenerCount(\"debug\")) {\n\t                                                this_1.emit(\"debug\", {\n\t                                                    action: \"request\",\n\t                                                    rid: rid,\n\t                                                    backend: exposeDebugConfig(config, null),\n\t                                                    request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                    provider: this_1\n\t                                                });\n\t                                            }\n\t                                            inflightWeight += config.weight;\n\t                                        };\n\t                                        // Start running enough to meet quorum\n\t                                        while (inflightWeight < this_1.quorum && i < configs.length) {\n\t                                            _loop_2();\n\t                                        }\n\t                                        waiting = [];\n\t                                        configs.forEach(function (c) {\n\t                                            if (c.done || !c.runner) {\n\t                                                return;\n\t                                            }\n\t                                            waiting.push(c.runner);\n\t                                            if (c.staller) {\n\t                                                waiting.push(c.staller.getPromise());\n\t                                            }\n\t                                        });\n\t                                        if (!waiting.length) return [3 /*break*/, 2];\n\t                                        return [4 /*yield*/, Promise.race(waiting)];\n\t                                    case 1:\n\t                                        _a.sent();\n\t                                        _a.label = 2;\n\t                                    case 2:\n\t                                        results = configs.filter(function (c) { return (c.done && c.error == null); });\n\t                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];\n\t                                        result = processFunc(results);\n\t                                        if (result !== undefined) {\n\t                                            // Shut down any stallers\n\t                                            configs.forEach(function (c) {\n\t                                                if (c.staller) {\n\t                                                    c.staller.cancel();\n\t                                                }\n\t                                                c.cancelled = true;\n\t                                            });\n\t                                            return [2 /*return*/, { value: result }];\n\t                                        }\n\t                                        if (!!first) return [3 /*break*/, 4];\n\t                                        return [4 /*yield*/, stall(100).getPromise()];\n\t                                    case 3:\n\t                                        _a.sent();\n\t                                        _a.label = 4;\n\t                                    case 4:\n\t                                        first = false;\n\t                                        _a.label = 5;\n\t                                    case 5:\n\t                                        // All configs have run to completion; we will never get more data\n\t                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {\n\t                                            return [2 /*return*/, \"break\"];\n\t                                        }\n\t                                        return [2 /*return*/];\n\t                                }\n\t                            });\n\t                        };\n\t                        this_1 = this;\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (false) {}\n\t                        return [5 /*yield**/, _loop_1()];\n\t                    case 6:\n\t                        state_1 = _a.sent();\n\t                        if (typeof state_1 === \"object\")\n\t                            return [2 /*return*/, state_1.value];\n\t                        if (state_1 === \"break\")\n\t                            return [3 /*break*/, 7];\n\t                        return [3 /*break*/, 5];\n\t                    case 7:\n\t                        // Shut down any stallers; shouldn't be any\n\t                        configs.forEach(function (c) {\n\t                            if (c.staller) {\n\t                                c.staller.cancel();\n\t                            }\n\t                            c.cancelled = true;\n\t                        });\n\t                        return [2 /*return*/, logger.throwError(\"failed to meet quorum\", lib.Logger.errors.SERVER_ERROR, {\n\t                                method: method,\n\t                                params: params,\n\t                                //results: configs.map((c) => c.result),\n\t                                //errors: configs.map((c) => c.error),\n\t                                results: configs.map(function (c) { return exposeDebugConfig(c); }),\n\t                                provider: this\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return FallbackProvider;\n\t}(baseProvider.BaseProvider));\n\texports.FallbackProvider = FallbackProvider;\n\t});\n\n\tvar fallbackProvider$1 = unwrapExports(fallbackProvider);\n\tvar fallbackProvider_1 = fallbackProvider.FallbackProvider;\n\n\t\"use strict\";\n\tvar IpcProvider = null;\n\n\tvar browserIpcProvider = {\n\t\tIpcProvider: IpcProvider\n\t};\n\n\tvar browserWs = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tvar WS = null;\n\ttry {\n\t    WS = WebSocket;\n\t    if (WS == null) {\n\t        throw new Error(\"inject please\");\n\t    }\n\t}\n\tcatch (error) {\n\t    var logger_2 = new lib.Logger(_version$I.version);\n\t    WS = function () {\n\t        logger_2.throwError(\"WebSockets not supported in this environment\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"new WebSocket()\"\n\t        });\n\t    };\n\t}\n\tmodule.exports = WS;\n\t});\n\n\tvar browserWs$1 = unwrapExports(browserWs);\n\n\tvar websocketProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar ws_1 = __importDefault(browserWs);\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t/**\n\t *  Notes:\n\t *\n\t *  This provider differs a bit from the polling providers. One main\n\t *  difference is how it handles consistency. The polling providers\n\t *  will stall responses to ensure a consistent state, while this\n\t *  WebSocket provider assumes the connected backend will manage this.\n\t *\n\t *  For example, if a polling provider emits an event which indicats\n\t *  the event occurred in blockhash XXX, a call to fetch that block by\n\t *  its hash XXX, if not present will retry until it is present. This\n\t *  can occur when querying a pool of nodes that are mildly out of sync\n\t *  with each other.\n\t */\n\tvar NextId = 1;\n\t// For more info about the Real-time Event API see:\n\t//   https://geth.ethereum.org/docs/rpc/pubsub\n\tvar WebSocketProvider = /** @class */ (function (_super) {\n\t    __extends(WebSocketProvider, _super);\n\t    function WebSocketProvider(url, network) {\n\t        var _this = this;\n\t        // This will be added in the future; please open an issue to expedite\n\t        if (network === \"any\") {\n\t            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"network:any\"\n\t            });\n\t        }\n\t        _this = _super.call(this, url, network) || this;\n\t        _this._pollingInterval = -1;\n\t        lib$3.defineReadOnly(_this, \"_websocket\", new ws_1.default(_this.connection.url));\n\t        lib$3.defineReadOnly(_this, \"_requests\", {});\n\t        lib$3.defineReadOnly(_this, \"_subs\", {});\n\t        lib$3.defineReadOnly(_this, \"_subIds\", {});\n\t        // Stall sending requests until the socket is open...\n\t        _this._wsReady = false;\n\t        _this._websocket.onopen = function () {\n\t            _this._wsReady = true;\n\t            Object.keys(_this._requests).forEach(function (id) {\n\t                _this._websocket.send(_this._requests[id].payload);\n\t            });\n\t        };\n\t        _this._websocket.onmessage = function (messageEvent) {\n\t            var data = messageEvent.data;\n\t            var result = JSON.parse(data);\n\t            if (result.id != null) {\n\t                var id = String(result.id);\n\t                var request = _this._requests[id];\n\t                delete _this._requests[id];\n\t                if (result.result !== undefined) {\n\t                    request.callback(null, result.result);\n\t                }\n\t                else {\n\t                    if (result.error) {\n\t                        var error = new Error(result.error.message || \"unknown error\");\n\t                        lib$3.defineReadOnly(error, \"code\", result.error.code || null);\n\t                        lib$3.defineReadOnly(error, \"response\", data);\n\t                        request.callback(error, undefined);\n\t                    }\n\t                    else {\n\t                        request.callback(new Error(\"unknown error\"), undefined);\n\t                    }\n\t                }\n\t            }\n\t            else if (result.method === \"eth_subscription\") {\n\t                // Subscription...\n\t                var sub = _this._subs[result.params.subscription];\n\t                if (sub) {\n\t                    //this.emit.apply(this,                  );\n\t                    sub.processFunc(result.params.result);\n\t                }\n\t            }\n\t            else {\n\t                console.warn(\"this should not happen\");\n\t            }\n\t        };\n\t        // This Provider does not actually poll, but we want to trigger\n\t        // poll events for things that depend on them (like stalling for\n\t        // block and transaction lookups)\n\t        var fauxPoll = setInterval(function () {\n\t            _this.emit(\"poll\");\n\t        }, 1000);\n\t        if (fauxPoll.unref) {\n\t            fauxPoll.unref();\n\t        }\n\t        return _this;\n\t    }\n\t    Object.defineProperty(WebSocketProvider.prototype, \"pollingInterval\", {\n\t        get: function () {\n\t            return 0;\n\t        },\n\t        set: function (value) {\n\t            logger.throwError(\"cannot set polling interval on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setPollingInterval\"\n\t            });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        logger.throwError(\"cannot reset events block on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"resetEventBlock\"\n\t        });\n\t    };\n\t    WebSocketProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, null];\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(WebSocketProvider.prototype, \"polling\", {\n\t        set: function (value) {\n\t            if (!value) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot set polling on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setPolling\"\n\t            });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var rid = NextId++;\n\t        return new Promise(function (resolve, reject) {\n\t            function callback(error, result) {\n\t                if (error) {\n\t                    return reject(error);\n\t                }\n\t                return resolve(result);\n\t            }\n\t            var payload = JSON.stringify({\n\t                method: method,\n\t                params: params,\n\t                id: rid,\n\t                jsonrpc: \"2.0\"\n\t            });\n\t            _this._requests[String(rid)] = { callback: callback, payload: payload };\n\t            if (_this._wsReady) {\n\t                _this._websocket.send(payload);\n\t            }\n\t        });\n\t    };\n\t    WebSocketProvider.defaultUrl = function () {\n\t        return \"ws:/\\/localhost:8546\";\n\t    };\n\t    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var subIdPromise, subId;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        subIdPromise = this._subIds[tag];\n\t                        if (subIdPromise == null) {\n\t                            subIdPromise = Promise.all(param).then(function (param) {\n\t                                return _this.send(\"eth_subscribe\", param);\n\t                            });\n\t                            this._subIds[tag] = subIdPromise;\n\t                        }\n\t                        return [4 /*yield*/, subIdPromise];\n\t                    case 1:\n\t                        subId = _a.sent();\n\t                        this._subs[subId] = { tag: tag, processFunc: processFunc };\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    WebSocketProvider.prototype._startEvent = function (event) {\n\t        var _this = this;\n\t        switch (event.type) {\n\t            case \"block\":\n\t                this._subscribe(\"block\", [\"newHeads\"], function (result) {\n\t                    var blockNumber = lib$2.BigNumber.from(result.number).toNumber();\n\t                    _this._emitted.block = blockNumber;\n\t                    _this.emit(\"block\", blockNumber);\n\t                });\n\t                break;\n\t            case \"pending\":\n\t                this._subscribe(\"pending\", [\"newPendingTransactions\"], function (result) {\n\t                    _this.emit(\"pending\", result);\n\t                });\n\t                break;\n\t            case \"filter\":\n\t                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], function (result) {\n\t                    if (result.removed == null) {\n\t                        result.removed = false;\n\t                    }\n\t                    _this.emit(event.filter, _this.formatter.filterLog(result));\n\t                });\n\t                break;\n\t            case \"tx\": {\n\t                var emitReceipt_1 = function (event) {\n\t                    var hash = event.hash;\n\t                    _this.getTransactionReceipt(hash).then(function (receipt) {\n\t                        if (!receipt) {\n\t                            return;\n\t                        }\n\t                        _this.emit(hash, receipt);\n\t                    });\n\t                };\n\t                // In case it is already mined\n\t                emitReceipt_1(event);\n\t                // To keep things simple, we start up a single newHeads subscription\n\t                // to keep an eye out for transactions we are watching for.\n\t                // Starting a subscription for an event (i.e. \"tx\") that is already\n\t                // running is (basically) a nop.\n\t                this._subscribe(\"tx\", [\"newHeads\"], function (result) {\n\t                    _this._events.filter(function (e) { return (e.type === \"tx\"); }).forEach(emitReceipt_1);\n\t                });\n\t                break;\n\t            }\n\t            // Nothing is needed\n\t            case \"debug\":\n\t            case \"poll\":\n\t            case \"willPoll\":\n\t            case \"didPoll\":\n\t            case \"error\":\n\t                break;\n\t            default:\n\t                console.log(\"unhandled:\", event);\n\t                break;\n\t        }\n\t    };\n\t    WebSocketProvider.prototype._stopEvent = function (event) {\n\t        var _this = this;\n\t        var tag = event.tag;\n\t        if (event.type === \"tx\") {\n\t            // There are remaining transaction event listeners\n\t            if (this._events.filter(function (e) { return (e.type === \"tx\"); }).length) {\n\t                return;\n\t            }\n\t            tag = \"tx\";\n\t        }\n\t        else if (this.listenerCount(event.event)) {\n\t            // There are remaining event listeners\n\t            return;\n\t        }\n\t        var subId = this._subIds[tag];\n\t        if (!subId) {\n\t            return;\n\t        }\n\t        delete this._subIds[tag];\n\t        subId.then(function (subId) {\n\t            if (!_this._subs[subId]) {\n\t                return;\n\t            }\n\t            delete _this._subs[subId];\n\t            _this.send(\"eth_unsubscribe\", [subId]);\n\t        });\n\t    };\n\t    return WebSocketProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.WebSocketProvider = WebSocketProvider;\n\t});\n\n\tvar websocketProvider$1 = unwrapExports(websocketProvider);\n\tvar websocketProvider_1 = websocketProvider.WebSocketProvider;\n\n\tvar infuraProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar defaultProjectId = \"84842078b09946638c03157f83405213\";\n\tvar InfuraProvider = /** @class */ (function (_super) {\n\t    __extends(InfuraProvider, _super);\n\t    function InfuraProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    InfuraProvider.getWebSocketProvider = function (network, apiKey) {\n\t        var provider = new InfuraProvider(network, apiKey);\n\t        var connection = provider.connection;\n\t        if (connection.password) {\n\t            logger.throwError(\"INFURA WebSocket project secrets unsupported\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"InfuraProvider.getWebSocketProvider()\"\n\t            });\n\t        }\n\t        var url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n\t        return new websocketProvider.WebSocketProvider(url, network);\n\t    };\n\t    InfuraProvider.getApiKey = function (apiKey) {\n\t        var apiKeyObj = {\n\t            apiKey: defaultProjectId,\n\t            projectId: defaultProjectId,\n\t            projectSecret: null\n\t        };\n\t        if (apiKey == null) {\n\t            return apiKeyObj;\n\t        }\n\t        if (typeof (apiKey) === \"string\") {\n\t            apiKeyObj.projectId = apiKey;\n\t        }\n\t        else if (apiKey.projectSecret != null) {\n\t            if (typeof (apiKey.projectId) !== \"string\") {\n\t                logger.throwArgumentError(\"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n\t            }\n\t            if (typeof (apiKey.projectSecret) !== \"string\") {\n\t                logger.throwArgumentError(\"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\t            }\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t            apiKeyObj.projectSecret = apiKey.projectSecret;\n\t        }\n\t        else if (apiKey.projectId) {\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t        }\n\t        apiKeyObj.apiKey = apiKeyObj.projectId;\n\t        return apiKeyObj;\n\t    };\n\t    InfuraProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"mainnet.infura.io\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"ropsten.infura.io\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"rinkeby.infura.io\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"kovan.infura.io\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"goerli.infura.io\";\n\t                break;\n\t            default:\n\t                logger.throwError(\"unsupported network\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"network\",\n\t                    value: network\n\t                });\n\t        }\n\t        var connection = {\n\t            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId)\n\t        };\n\t        if (apiKey.projectSecret != null) {\n\t            connection.user = \"\";\n\t            connection.password = apiKey.projectSecret;\n\t        }\n\t        return connection;\n\t    };\n\t    return InfuraProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.InfuraProvider = InfuraProvider;\n\t});\n\n\tvar infuraProvider$1 = unwrapExports(infuraProvider);\n\tvar infuraProvider_1 = infuraProvider.InfuraProvider;\n\n\tvar nodesmithProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t// Special API key provided by Nodesmith for ethers.js\n\tvar defaultApiKey = \"ETHERS_JS_SHARED\";\n\tvar NodesmithProvider = /** @class */ (function (_super) {\n\t    __extends(NodesmithProvider, _super);\n\t    function NodesmithProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    NodesmithProvider.getApiKey = function (apiKey) {\n\t        if (apiKey && typeof (apiKey) !== \"string\") {\n\t            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        return apiKey || defaultApiKey;\n\t    };\n\t    NodesmithProvider.getUrl = function (network, apiKey) {\n\t        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return (host + \"?apiKey=\" + apiKey);\n\t    };\n\t    return NodesmithProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.NodesmithProvider = NodesmithProvider;\n\t});\n\n\tvar nodesmithProvider$1 = unwrapExports(nodesmithProvider);\n\tvar nodesmithProvider_1 = nodesmithProvider.NodesmithProvider;\n\n\tvar web3Provider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar _nextId = 1;\n\tfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n\t    return function (method, params) {\n\t        // Metamask complains about eth_sign (and on some versions hangs)\n\t        if (method == \"eth_sign\" && provider.isMetaMask) {\n\t            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n\t            method = \"personal_sign\";\n\t            params = [params[1], params[0]];\n\t        }\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (_nextId++),\n\t            jsonrpc: \"2.0\"\n\t        };\n\t        return new Promise(function (resolve, reject) {\n\t            sendFunc(request, function (error, result) {\n\t                if (error) {\n\t                    return reject(error);\n\t                }\n\t                if (result.error) {\n\t                    var error_1 = new Error(result.error.message);\n\t                    error_1.code = result.error.code;\n\t                    error_1.data = result.error.data;\n\t                    return reject(error_1);\n\t                }\n\t                resolve(result.result);\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildEip1193Fetcher(provider) {\n\t    return function (method, params) {\n\t        if (params == null) {\n\t            params = [];\n\t        }\n\t        // Metamask complains about eth_sign (and on some versions hangs)\n\t        if (method == \"eth_sign\" && provider.isMetaMask) {\n\t            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n\t            method = \"personal_sign\";\n\t            params = [params[1], params[0]];\n\t        }\n\t        return provider.request({ method: method, params: params });\n\t    };\n\t}\n\tvar Web3Provider = /** @class */ (function (_super) {\n\t    __extends(Web3Provider, _super);\n\t    function Web3Provider(provider, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Web3Provider);\n\t        if (provider == null) {\n\t            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n\t        }\n\t        var path = null;\n\t        var jsonRpcFetchFunc = null;\n\t        var subprovider = null;\n\t        if (typeof (provider) === \"function\") {\n\t            path = \"unknown:\";\n\t            jsonRpcFetchFunc = provider;\n\t        }\n\t        else {\n\t            path = provider.host || provider.path || \"\";\n\t            if (!path && provider.isMetaMask) {\n\t                path = \"metamask\";\n\t            }\n\t            subprovider = provider;\n\t            if (provider.request) {\n\t                if (path === \"\") {\n\t                    path = \"eip-1193:\";\n\t                }\n\t                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n\t            }\n\t            else if (provider.sendAsync) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n\t            }\n\t            else if (provider.send) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n\t            }\n\t            if (!path) {\n\t                path = \"unknown:\";\n\t            }\n\t        }\n\t        _this = _super.call(this, path, network) || this;\n\t        lib$3.defineReadOnly(_this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n\t        lib$3.defineReadOnly(_this, \"provider\", subprovider);\n\t        return _this;\n\t    }\n\t    Web3Provider.prototype.send = function (method, params) {\n\t        return this.jsonRpcFetchFunc(method, params);\n\t    };\n\t    return Web3Provider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.Web3Provider = Web3Provider;\n\t});\n\n\tvar web3Provider$1 = unwrapExports(web3Provider);\n\tvar web3Provider_1 = web3Provider.Web3Provider;\n\n\tvar lib$m = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.Provider = lib$b.Provider;\n\n\texports.getNetwork = lib$k.getNetwork;\n\n\texports.BaseProvider = baseProvider.BaseProvider;\n\n\texports.AlchemyProvider = alchemyProvider.AlchemyProvider;\n\n\texports.CloudflareProvider = cloudflareProvider.CloudflareProvider;\n\n\texports.EtherscanProvider = etherscanProvider.EtherscanProvider;\n\n\texports.FallbackProvider = fallbackProvider.FallbackProvider;\n\n\texports.IpcProvider = browserIpcProvider.IpcProvider;\n\n\texports.InfuraProvider = infuraProvider.InfuraProvider;\n\n\texports.JsonRpcProvider = jsonRpcProvider.JsonRpcProvider;\n\texports.JsonRpcSigner = jsonRpcProvider.JsonRpcSigner;\n\n\texports.NodesmithProvider = nodesmithProvider.NodesmithProvider;\n\n\texports.Web3Provider = web3Provider.Web3Provider;\n\n\texports.WebSocketProvider = websocketProvider.WebSocketProvider;\n\n\texports.Formatter = formatter.Formatter;\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t////////////////////////\n\t// Helper Functions\n\tfunction getDefaultProvider(network, options) {\n\t    if (network == null) {\n\t        network = \"homestead\";\n\t    }\n\t    var n = lib$k.getNetwork(network);\n\t    if (!n || !n._defaultProvider) {\n\t        logger.throwError(\"unsupported getDefaultProvider network\", lib.Logger.errors.NETWORK_ERROR, {\n\t            operation: \"getDefaultProvider\",\n\t            network: network\n\t        });\n\t    }\n\t    return n._defaultProvider({\n\t        FallbackProvider: fallbackProvider.FallbackProvider,\n\t        AlchemyProvider: alchemyProvider.AlchemyProvider,\n\t        CloudflareProvider: cloudflareProvider.CloudflareProvider,\n\t        EtherscanProvider: etherscanProvider.EtherscanProvider,\n\t        InfuraProvider: infuraProvider.InfuraProvider,\n\t        JsonRpcProvider: jsonRpcProvider.JsonRpcProvider,\n\t        NodesmithProvider: nodesmithProvider.NodesmithProvider,\n\t        Web3Provider: web3Provider.Web3Provider,\n\t        IpcProvider: browserIpcProvider.IpcProvider,\n\t    }, options);\n\t}\n\texports.getDefaultProvider = getDefaultProvider;\n\t});\n\n\tvar index$m = unwrapExports(lib$m);\n\tvar lib_1$m = lib$m.Provider;\n\tvar lib_2$k = lib$m.getNetwork;\n\tvar lib_3$f = lib$m.BaseProvider;\n\tvar lib_4$c = lib$m.AlchemyProvider;\n\tvar lib_5$b = lib$m.CloudflareProvider;\n\tvar lib_6$7 = lib$m.EtherscanProvider;\n\tvar lib_7$6 = lib$m.FallbackProvider;\n\tvar lib_8$5 = lib$m.IpcProvider;\n\tvar lib_9$5 = lib$m.InfuraProvider;\n\tvar lib_10$3 = lib$m.JsonRpcProvider;\n\tvar lib_11$2 = lib$m.JsonRpcSigner;\n\tvar lib_12$2 = lib$m.NodesmithProvider;\n\tvar lib_13$2 = lib$m.Web3Provider;\n\tvar lib_14$1 = lib$m.WebSocketProvider;\n\tvar lib_15$1 = lib$m.Formatter;\n\tvar lib_16$1 = lib$m.getDefaultProvider;\n\n\tvar lib$n = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\tvar regexBytes = new RegExp(\"^bytes([0-9]+)$\");\n\tvar regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\n\tvar regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\tvar Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\tfunction _pack(type, value, isArray) {\n\t    switch (type) {\n\t        case \"address\":\n\t            if (isArray) {\n\t                return lib$1.zeroPad(value, 32);\n\t            }\n\t            return lib$1.arrayify(value);\n\t        case \"string\":\n\t            return lib$8.toUtf8Bytes(value);\n\t        case \"bytes\":\n\t            return lib$1.arrayify(value);\n\t        case \"bool\":\n\t            value = (value ? \"0x01\" : \"0x00\");\n\t            if (isArray) {\n\t                return lib$1.zeroPad(value, 32);\n\t            }\n\t            return lib$1.arrayify(value);\n\t    }\n\t    var match = type.match(regexNumber);\n\t    if (match) {\n\t        //let signed = (match[1] === \"int\")\n\t        var size = parseInt(match[2] || \"256\");\n\t        if ((size % 8 != 0) || size === 0 || size > 256) {\n\t            throw new Error(\"invalid number type - \" + type);\n\t        }\n\t        if (isArray) {\n\t            size = 256;\n\t        }\n\t        value = lib$2.BigNumber.from(value).toTwos(size);\n\t        return lib$1.zeroPad(value, size / 8);\n\t    }\n\t    match = type.match(regexBytes);\n\t    if (match) {\n\t        var size = parseInt(match[1]);\n\t        if (String(size) != match[1] || size === 0 || size > 32) {\n\t            throw new Error(\"invalid number type - \" + type);\n\t        }\n\t        if (lib$1.arrayify(value).byteLength !== size) {\n\t            throw new Error(\"invalid value for \" + type);\n\t        }\n\t        if (isArray) {\n\t            return lib$1.arrayify((value + Zeros).substring(0, 66));\n\t        }\n\t        return value;\n\t    }\n\t    match = type.match(regexArray);\n\t    if (match && Array.isArray(value)) {\n\t        var baseType_1 = match[1];\n\t        var count = parseInt(match[2] || String(value.length));\n\t        if (count != value.length) {\n\t            throw new Error(\"invalid value for \" + type);\n\t        }\n\t        var result_1 = [];\n\t        value.forEach(function (value) {\n\t            result_1.push(_pack(baseType_1, value, true));\n\t        });\n\t        return lib$1.concat(result_1);\n\t    }\n\t    throw new Error(\"unknown type - \" + type);\n\t}\n\t// @TODO: Array Enum\n\tfunction pack(types, values) {\n\t    if (types.length != values.length) {\n\t        throw new Error(\"type/value count mismatch\");\n\t    }\n\t    var tight = [];\n\t    types.forEach(function (type, index) {\n\t        tight.push(_pack(type, values[index]));\n\t    });\n\t    return lib$1.hexlify(lib$1.concat(tight));\n\t}\n\texports.pack = pack;\n\tfunction keccak256(types, values) {\n\t    return lib$4.keccak256(pack(types, values));\n\t}\n\texports.keccak256 = keccak256;\n\tfunction sha256(types, values) {\n\t    return browser.sha256(pack(types, values));\n\t}\n\texports.sha256 = sha256;\n\t});\n\n\tvar index$n = unwrapExports(lib$n);\n\tvar lib_1$n = lib$n.pack;\n\tvar lib_2$l = lib$n.keccak256;\n\tvar lib_3$g = lib$n.sha256;\n\n\tvar _version$K = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"units/5.0.0-beta.133\";\n\t});\n\n\tvar _version$L = unwrapExports(_version$K);\n\tvar _version_1$n = _version$K.version;\n\n\tvar lib$o = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$K.version);\n\tvar names = [\n\t    \"wei\",\n\t    \"kwei\",\n\t    \"mwei\",\n\t    \"gwei\",\n\t    \"szabo\",\n\t    \"finney\",\n\t    \"ether\",\n\t];\n\t// Some environments have issues with RegEx that contain back-tracking, so we cannot\n\t// use them.\n\tfunction commify(value) {\n\t    var comps = String(value).split(\".\");\n\t    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n\t        logger.throwArgumentError(\"invalid value\", \"value\", value);\n\t    }\n\t    // Make sure we have at least one whole digit (0 if none)\n\t    var whole = comps[0];\n\t    var negative = \"\";\n\t    if (whole.substring(0, 1) === \"-\") {\n\t        negative = \"-\";\n\t        whole = whole.substring(1);\n\t    }\n\t    // Make sure we have at least 1 whole digit with no leading zeros\n\t    while (whole.substring(0, 1) === \"0\") {\n\t        whole = whole.substring(1);\n\t    }\n\t    if (whole === \"\") {\n\t        whole = \"0\";\n\t    }\n\t    var suffix = \"\";\n\t    if (comps.length === 2) {\n\t        suffix = \".\" + (comps[1] || \"0\");\n\t    }\n\t    var formatted = [];\n\t    while (whole.length) {\n\t        if (whole.length <= 3) {\n\t            formatted.unshift(whole);\n\t            break;\n\t        }\n\t        else {\n\t            var index = whole.length - 3;\n\t            formatted.unshift(whole.substring(index));\n\t            whole = whole.substring(0, index);\n\t        }\n\t    }\n\t    return negative + formatted.join(\",\") + suffix;\n\t}\n\texports.commify = commify;\n\tfunction formatUnits(value, unitName) {\n\t    if (typeof (unitName) === \"string\") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return lib$2.formatFixed(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.formatUnits = formatUnits;\n\tfunction parseUnits(value, unitName) {\n\t    if (typeof (unitName) === \"string\") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return lib$2.parseFixed(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.parseUnits = parseUnits;\n\tfunction formatEther(wei) {\n\t    return formatUnits(wei, 18);\n\t}\n\texports.formatEther = formatEther;\n\tfunction parseEther(ether) {\n\t    return parseUnits(ether, 18);\n\t}\n\texports.parseEther = parseEther;\n\t});\n\n\tvar index$o = unwrapExports(lib$o);\n\tvar lib_1$o = lib$o.commify;\n\tvar lib_2$m = lib$o.formatUnits;\n\tvar lib_3$h = lib$o.parseUnits;\n\tvar lib_4$d = lib$o.formatEther;\n\tvar lib_5$c = lib$o.parseEther;\n\n\tvar utils$3 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.AbiCoder = lib$a.AbiCoder;\n\texports.checkResultErrors = lib$a.checkResultErrors;\n\texports.defaultAbiCoder = lib$a.defaultAbiCoder;\n\texports.EventFragment = lib$a.EventFragment;\n\texports.FormatTypes = lib$a.FormatTypes;\n\texports.Fragment = lib$a.Fragment;\n\texports.FunctionFragment = lib$a.FunctionFragment;\n\texports.Indexed = lib$a.Indexed;\n\texports.Interface = lib$a.Interface;\n\texports.LogDescription = lib$a.LogDescription;\n\texports.ParamType = lib$a.ParamType;\n\texports.TransactionDescription = lib$a.TransactionDescription;\n\n\texports.getAddress = lib$6.getAddress;\n\texports.getCreate2Address = lib$6.getCreate2Address;\n\texports.getContractAddress = lib$6.getContractAddress;\n\texports.getIcapAddress = lib$6.getIcapAddress;\n\texports.isAddress = lib$6.isAddress;\n\tvar base64 = __importStar(browser$8);\n\texports.base64 = base64;\n\n\texports.arrayify = lib$1.arrayify;\n\texports.concat = lib$1.concat;\n\texports.hexDataSlice = lib$1.hexDataSlice;\n\texports.hexDataLength = lib$1.hexDataLength;\n\texports.hexlify = lib$1.hexlify;\n\texports.hexStripZeros = lib$1.hexStripZeros;\n\texports.hexValue = lib$1.hexValue;\n\texports.hexZeroPad = lib$1.hexZeroPad;\n\texports.isBytes = lib$1.isBytes;\n\texports.isBytesLike = lib$1.isBytesLike;\n\texports.isHexString = lib$1.isHexString;\n\texports.joinSignature = lib$1.joinSignature;\n\texports.zeroPad = lib$1.zeroPad;\n\texports.splitSignature = lib$1.splitSignature;\n\texports.stripZeros = lib$1.stripZeros;\n\n\texports.hashMessage = lib$9.hashMessage;\n\texports.id = lib$9.id;\n\texports.isValidName = lib$9.isValidName;\n\texports.namehash = lib$9.namehash;\n\n\texports.defaultPath = lib$h.defaultPath;\n\texports.entropyToMnemonic = lib$h.entropyToMnemonic;\n\texports.HDNode = lib$h.HDNode;\n\texports.isValidMnemonic = lib$h.isValidMnemonic;\n\texports.mnemonicToEntropy = lib$h.mnemonicToEntropy;\n\texports.mnemonicToSeed = lib$h.mnemonicToSeed;\n\n\texports.getJsonWalletAddress = lib$i.getJsonWalletAddress;\n\n\texports.keccak256 = lib$4.keccak256;\n\n\texports.Logger = lib.Logger;\n\n\texports.computeHmac = browser.computeHmac;\n\texports.ripemd160 = browser.ripemd160;\n\texports.sha256 = browser.sha256;\n\texports.sha512 = browser.sha512;\n\n\texports.solidityKeccak256 = lib$n.keccak256;\n\texports.solidityPack = lib$n.pack;\n\texports.soliditySha256 = lib$n.sha256;\n\n\texports.randomBytes = browser$6.randomBytes;\n\texports.shuffled = browser$6.shuffled;\n\n\texports.checkProperties = lib$3.checkProperties;\n\texports.deepCopy = lib$3.deepCopy;\n\texports.defineReadOnly = lib$3.defineReadOnly;\n\texports.getStatic = lib$3.getStatic;\n\texports.resolveProperties = lib$3.resolveProperties;\n\texports.shallowCopy = lib$3.shallowCopy;\n\tvar RLP = __importStar(lib$5);\n\texports.RLP = RLP;\n\n\texports.computePublicKey = lib$f.computePublicKey;\n\texports.recoverPublicKey = lib$f.recoverPublicKey;\n\texports.SigningKey = lib$f.SigningKey;\n\n\texports.formatBytes32String = lib$8.formatBytes32String;\n\texports.nameprep = lib$8.nameprep;\n\texports.parseBytes32String = lib$8.parseBytes32String;\n\texports._toEscapedUtf8String = lib$8._toEscapedUtf8String;\n\texports.toUtf8Bytes = lib$8.toUtf8Bytes;\n\texports.toUtf8CodePoints = lib$8.toUtf8CodePoints;\n\texports.toUtf8String = lib$8.toUtf8String;\n\texports.Utf8ErrorFuncs = lib$8.Utf8ErrorFuncs;\n\n\texports.computeAddress = lib$g.computeAddress;\n\texports.parseTransaction = lib$g.parse;\n\texports.recoverAddress = lib$g.recoverAddress;\n\texports.serializeTransaction = lib$g.serialize;\n\n\texports.commify = lib$o.commify;\n\texports.formatEther = lib$o.formatEther;\n\texports.parseEther = lib$o.parseEther;\n\texports.formatUnits = lib$o.formatUnits;\n\texports.parseUnits = lib$o.parseUnits;\n\n\texports.verifyMessage = lib$j.verifyMessage;\n\n\texports.fetchJson = lib$l.fetchJson;\n\texports.poll = lib$l.poll;\n\t////////////////////////\n\t// Enums\n\tvar sha2_2 = browser;\n\texports.SupportedAlgorithm = sha2_2.SupportedAlgorithm;\n\tvar strings_2 = lib$8;\n\texports.UnicodeNormalizationForm = strings_2.UnicodeNormalizationForm;\n\texports.Utf8ErrorReason = strings_2.Utf8ErrorReason;\n\t});\n\n\tvar utils$4 = unwrapExports(utils$3);\n\tvar utils_1$3 = utils$3.AbiCoder;\n\tvar utils_2$1 = utils$3.checkResultErrors;\n\tvar utils_3$1 = utils$3.defaultAbiCoder;\n\tvar utils_4$1 = utils$3.EventFragment;\n\tvar utils_5 = utils$3.FormatTypes;\n\tvar utils_6 = utils$3.Fragment;\n\tvar utils_7 = utils$3.FunctionFragment;\n\tvar utils_8 = utils$3.Indexed;\n\tvar utils_9 = utils$3.Interface;\n\tvar utils_10 = utils$3.LogDescription;\n\tvar utils_11 = utils$3.ParamType;\n\tvar utils_12 = utils$3.TransactionDescription;\n\tvar utils_13 = utils$3.getAddress;\n\tvar utils_14 = utils$3.getCreate2Address;\n\tvar utils_15 = utils$3.getContractAddress;\n\tvar utils_16 = utils$3.getIcapAddress;\n\tvar utils_17 = utils$3.isAddress;\n\tvar utils_18 = utils$3.base64;\n\tvar utils_19 = utils$3.arrayify;\n\tvar utils_20 = utils$3.concat;\n\tvar utils_21 = utils$3.hexDataSlice;\n\tvar utils_22 = utils$3.hexDataLength;\n\tvar utils_23 = utils$3.hexlify;\n\tvar utils_24 = utils$3.hexStripZeros;\n\tvar utils_25 = utils$3.hexValue;\n\tvar utils_26 = utils$3.hexZeroPad;\n\tvar utils_27 = utils$3.isBytes;\n\tvar utils_28 = utils$3.isBytesLike;\n\tvar utils_29 = utils$3.isHexString;\n\tvar utils_30 = utils$3.joinSignature;\n\tvar utils_31 = utils$3.zeroPad;\n\tvar utils_32 = utils$3.splitSignature;\n\tvar utils_33 = utils$3.stripZeros;\n\tvar utils_34 = utils$3.hashMessage;\n\tvar utils_35 = utils$3.id;\n\tvar utils_36 = utils$3.isValidName;\n\tvar utils_37 = utils$3.namehash;\n\tvar utils_38 = utils$3.defaultPath;\n\tvar utils_39 = utils$3.entropyToMnemonic;\n\tvar utils_40 = utils$3.HDNode;\n\tvar utils_41 = utils$3.isValidMnemonic;\n\tvar utils_42 = utils$3.mnemonicToEntropy;\n\tvar utils_43 = utils$3.mnemonicToSeed;\n\tvar utils_44 = utils$3.getJsonWalletAddress;\n\tvar utils_45 = utils$3.keccak256;\n\tvar utils_46 = utils$3.Logger;\n\tvar utils_47 = utils$3.computeHmac;\n\tvar utils_48 = utils$3.ripemd160;\n\tvar utils_49 = utils$3.sha256;\n\tvar utils_50 = utils$3.sha512;\n\tvar utils_51 = utils$3.solidityKeccak256;\n\tvar utils_52 = utils$3.solidityPack;\n\tvar utils_53 = utils$3.soliditySha256;\n\tvar utils_54 = utils$3.randomBytes;\n\tvar utils_55 = utils$3.shuffled;\n\tvar utils_56 = utils$3.checkProperties;\n\tvar utils_57 = utils$3.deepCopy;\n\tvar utils_58 = utils$3.defineReadOnly;\n\tvar utils_59 = utils$3.getStatic;\n\tvar utils_60 = utils$3.resolveProperties;\n\tvar utils_61 = utils$3.shallowCopy;\n\tvar utils_62 = utils$3.RLP;\n\tvar utils_63 = utils$3.computePublicKey;\n\tvar utils_64 = utils$3.recoverPublicKey;\n\tvar utils_65 = utils$3.SigningKey;\n\tvar utils_66 = utils$3.formatBytes32String;\n\tvar utils_67 = utils$3.nameprep;\n\tvar utils_68 = utils$3.parseBytes32String;\n\tvar utils_69 = utils$3._toEscapedUtf8String;\n\tvar utils_70 = utils$3.toUtf8Bytes;\n\tvar utils_71 = utils$3.toUtf8CodePoints;\n\tvar utils_72 = utils$3.toUtf8String;\n\tvar utils_73 = utils$3.Utf8ErrorFuncs;\n\tvar utils_74 = utils$3.computeAddress;\n\tvar utils_75 = utils$3.parseTransaction;\n\tvar utils_76 = utils$3.recoverAddress;\n\tvar utils_77 = utils$3.serializeTransaction;\n\tvar utils_78 = utils$3.commify;\n\tvar utils_79 = utils$3.formatEther;\n\tvar utils_80 = utils$3.parseEther;\n\tvar utils_81 = utils$3.formatUnits;\n\tvar utils_82 = utils$3.parseUnits;\n\tvar utils_83 = utils$3.verifyMessage;\n\tvar utils_84 = utils$3.fetchJson;\n\tvar utils_85 = utils$3.poll;\n\tvar utils_86 = utils$3.SupportedAlgorithm;\n\tvar utils_87 = utils$3.UnicodeNormalizationForm;\n\tvar utils_88 = utils$3.Utf8ErrorReason;\n\n\tvar _version$M = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = \"ethers/5.0.0-beta.192\";\n\t});\n\n\tvar _version$N = unwrapExports(_version$M);\n\tvar _version_1$o = _version$M.version;\n\n\tvar ethers = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.Contract = lib$d.Contract;\n\texports.ContractFactory = lib$d.ContractFactory;\n\n\texports.BigNumber = lib$2.BigNumber;\n\texports.FixedNumber = lib$2.FixedNumber;\n\n\texports.Signer = lib$c.Signer;\n\texports.VoidSigner = lib$c.VoidSigner;\n\n\texports.Wallet = lib$j.Wallet;\n\tvar constants = __importStar(lib$7);\n\texports.constants = constants;\n\tvar providers = __importStar(lib$m);\n\texports.providers = providers;\n\tvar providers_1 = lib$m;\n\texports.getDefaultProvider = providers_1.getDefaultProvider;\n\n\texports.Wordlist = browser$4.Wordlist;\n\texports.wordlists = browser$4.wordlists;\n\tvar utils = __importStar(utils$3);\n\texports.utils = utils;\n\n\texports.errors = lib.ErrorCode;\n\t////////////////////////\n\t// Compile-Time Constants\n\t// This is generated by \"npm run dist\"\n\n\texports.version = _version$M.version;\n\tvar logger = new lib.Logger(_version$M.version);\n\texports.logger = logger;\n\t});\n\n\tvar ethers$1 = unwrapExports(ethers);\n\tvar ethers_1 = ethers.Contract;\n\tvar ethers_2 = ethers.ContractFactory;\n\tvar ethers_3 = ethers.BigNumber;\n\tvar ethers_4 = ethers.FixedNumber;\n\tvar ethers_5 = ethers.Signer;\n\tvar ethers_6 = ethers.VoidSigner;\n\tvar ethers_7 = ethers.Wallet;\n\tvar ethers_8 = ethers.constants;\n\tvar ethers_9 = ethers.providers;\n\tvar ethers_10 = ethers.getDefaultProvider;\n\tvar ethers_11 = ethers.Wordlist;\n\tvar ethers_12 = ethers.wordlists;\n\tvar ethers_13 = ethers.utils;\n\tvar ethers_14 = ethers.errors;\n\tvar ethers_15 = ethers.version;\n\tvar ethers_16 = ethers.logger;\n\n\tvar lib$p = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result[\"default\"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// To modify this file, you must update ./admin/cmds/update-exports.js\n\tvar ethers$1 = __importStar(ethers);\n\texports.ethers = ethers$1;\n\ttry {\n\t    var anyGlobal = window;\n\t    if (anyGlobal._ethers == null) {\n\t        anyGlobal._ethers = ethers$1;\n\t    }\n\t}\n\tcatch (error) { }\n\tvar ethers_1 = ethers;\n\texports.Signer = ethers_1.Signer;\n\texports.Wallet = ethers_1.Wallet;\n\texports.VoidSigner = ethers_1.VoidSigner;\n\texports.getDefaultProvider = ethers_1.getDefaultProvider;\n\texports.providers = ethers_1.providers;\n\texports.Contract = ethers_1.Contract;\n\texports.ContractFactory = ethers_1.ContractFactory;\n\texports.BigNumber = ethers_1.BigNumber;\n\texports.FixedNumber = ethers_1.FixedNumber;\n\texports.constants = ethers_1.constants;\n\texports.errors = ethers_1.errors;\n\texports.logger = ethers_1.logger;\n\texports.utils = ethers_1.utils;\n\texports.wordlists = ethers_1.wordlists;\n\t////////////////////////\n\t// Compile-Time Constants\n\texports.version = ethers_1.version;\n\texports.Wordlist = ethers_1.Wordlist;\n\t});\n\n\tvar index$p = unwrapExports(lib$p);\n\tvar lib_1$p = lib$p.ethers;\n\tvar lib_2$n = lib$p.Signer;\n\tvar lib_3$i = lib$p.Wallet;\n\tvar lib_4$e = lib$p.VoidSigner;\n\tvar lib_5$d = lib$p.getDefaultProvider;\n\tvar lib_6$8 = lib$p.providers;\n\tvar lib_7$7 = lib$p.Contract;\n\tvar lib_8$6 = lib$p.ContractFactory;\n\tvar lib_9$6 = lib$p.BigNumber;\n\tvar lib_10$4 = lib$p.FixedNumber;\n\tvar lib_11$3 = lib$p.constants;\n\tvar lib_12$3 = lib$p.errors;\n\tvar lib_13$3 = lib$p.logger;\n\tvar lib_14$2 = lib$p.utils;\n\tvar lib_15$2 = lib$p.wordlists;\n\tvar lib_16$2 = lib$p.version;\n\tvar lib_17 = lib$p.Wordlist;\n\n\texports.BigNumber = lib_9$6;\n\texports.Contract = lib_7$7;\n\texports.ContractFactory = lib_8$6;\n\texports.FixedNumber = lib_10$4;\n\texports.Signer = lib_2$n;\n\texports.VoidSigner = lib_4$e;\n\texports.Wallet = lib_3$i;\n\texports.Wordlist = lib_17;\n\texports.constants = lib_11$3;\n\texports.default = index$p;\n\texports.errors = lib_12$3;\n\texports.ethers = lib_1$p;\n\texports.getDefaultProvider = lib_5$d;\n\texports.logger = lib_13$3;\n\texports.providers = lib_6$8;\n\texports.utils = lib_14$2;\n\texports.version = lib_16$2;\n\texports.wordlists = lib_15$2;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJzL2Rpc3QvZXRoZXJzLnVtZC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDc0Q7QUFDdkQsQ0FBQyw0QkFBNEI7O0FBRTdCLHVIQUF1SCxxQkFBTSxtQkFBbUIscUJBQU07O0FBRXRKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBOztBQUVBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsTUFBd0I7QUFDNUIsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsdURBQXVEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBEQUEwRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpQkFBaUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcseURBQXlELHFDQUFxQztBQUMxTTtBQUNBO0FBQ0EseUVBQXlFLGlCQUFpQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhOzs7QUFHN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0I7QUFDdkUsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhOzs7O0FBSTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFrRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSx5Q0FBeUM7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSw2QkFBNkI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlEQUFpRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBDQUEwQztBQUN0RyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSw4QkFBOEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBDQUEwQztBQUN0RyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwwRUFBMEUsOEJBQThCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMENBQTBDO0FBQ3RHLDhEQUE4RCwyQ0FBMkM7QUFDekcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsOEJBQThCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLCtCQUErQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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REFBMEQsdUJBQXVCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsa0RBQWtEO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0RBQWtEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxVQUFVLGNBQWM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLGlEQUFpRDtBQUNqRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QixxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjOztBQUVkLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7Ozs7Ozs7Ozs7Ozs7QUFhN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxjQUFjLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3hGLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTtBQUNGLGdEQUFnRCxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7QUFlN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxzQkFBc0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLDBFQUEwRSxvQkFBb0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHNCQUFzQjtBQUNoRztBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7OztBQUc3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTs7Ozs7Ozs7O0FBUzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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VjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQjtBQUNwSSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RiwyQkFBMkI7QUFDcEgsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsMkNBQTJDO0FBQ3pLO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLDBCQUEwQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsMEJBQTBCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsMkNBQTJDO0FBQ25JLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4Q0FBOEM7QUFDdEksMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHVDQUF1QztBQUMvSCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LFdBQVcsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN2RCxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7Ozs7OztBQU03RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBMEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILDhCQUE4QjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCxnQkFBZ0I7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFV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RTtBQUNGLGdEQUFnRCxhQUFhOzs7O0FBSTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTs7QUFFN0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7Ozs7OztBQU03RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhOzs7O0FBSTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9kaXN0L2V0aGVycy51bWQuanM/ZTZhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZXRoZXJzID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cdGZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSByb2xsdXAtcGx1Z2luLWNvbW1vbmpzJyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0XHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdFx0cmV0dXJuIG4gJiYgblsnZGVmYXVsdCddIHx8IG47XG5cdH1cblxuXHR2YXIgX25vZGVSZXNvbHZlX2VtcHR5ID0ge307XG5cblx0dmFyIF9ub2RlUmVzb2x2ZV9lbXB0eSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdCdkZWZhdWx0JzogX25vZGVSZXNvbHZlX2VtcHR5XG5cdH0pO1xuXG5cdHZhciByZXF1aXJlJCQwID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShfbm9kZVJlc29sdmVfZW1wdHkkMSk7XG5cblx0dmFyIGJuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgICd1c2Ugc3RyaWN0JztcblxuXHQgIC8vIFV0aWxzXG5cdCAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuXHQgICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0ICB9XG5cblx0ICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuXHQgIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG5cdCAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHQgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG5cdCAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuXHQgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgIH1cblxuXHQgIC8vIEJOXG5cblx0ICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICB0aGlzLndvcmRzID0gbnVsbDtcblx0ICAgIHRoaXMubGVuZ3RoID0gMDtcblxuXHQgICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcblx0ICAgIHRoaXMucmVkID0gbnVsbDtcblxuXHQgICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG5cdCAgICAgICAgZW5kaWFuID0gYmFzZTtcblx0ICAgICAgICBiYXNlID0gMTA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcblx0ICB9IGVsc2Uge1xuXHQgICAgZXhwb3J0cy5CTiA9IEJOO1xuXHQgIH1cblxuXHQgIEJOLkJOID0gQk47XG5cdCAgQk4ud29yZFNpemUgPSAyNjtcblxuXHQgIHZhciBCdWZmZXI7XG5cdCAgdHJ5IHtcblx0ICAgIEJ1ZmZlciA9IHJlcXVpcmUkJDAuQnVmZmVyO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICB9XG5cblx0ICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG5cdCAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG5cdCAgfTtcblxuXHQgIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcblx0ICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcblx0ICAgIHJldHVybiByaWdodDtcblx0ICB9O1xuXG5cdCAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuXHQgICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuXHQgICAgcmV0dXJuIHJpZ2h0O1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcblx0ICAgICAgYmFzZSA9IDE2O1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG5cdCAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IDE2KSB7XG5cdCAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIG51bWJlciA9IC1udW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcblx0ICAgICAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAyO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgMVxuXHQgICAgICBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuXHQgICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcblx0ICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuXHQgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gWyAwIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIHZhciBvZmYgPSAwO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuXHQgICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG5cdCAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuXHQgICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcblx0ICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0ICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG9mZiArPSAyNDtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBqKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByIDw8PSA0O1xuXG5cdCAgICAgIC8vICdhJyAtICdmJ1xuXHQgICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG5cdCAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cblx0ICAgICAgLy8gJ0EnIC0gJ0YnXG5cdCAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG5cdCAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciB8PSBjICYgMHhmO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG5cdCAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuXHQgICAgdmFyIG9mZiA9IDA7XG5cdCAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuXHQgICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgaisrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG5cdCAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByICo9IG11bDtcblxuXHQgICAgICAvLyAnYSdcblx0ICAgICAgaWYgKGMgPj0gNDkpIHtcblx0ICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuXHQgICAgICAvLyAnQSdcblx0ICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG5cdCAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciArPSBjO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcblx0ICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuXHQgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuXHQgICAgdGhpcy5sZW5ndGggPSAxO1xuXG5cdCAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2Vcblx0ICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuXHQgICAgICBsaW1iTGVuKys7XG5cdCAgICB9XG5cdCAgICBsaW1iTGVuLS07XG5cdCAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cblx0ICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcblx0ICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG5cdCAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG5cdCAgICB2YXIgd29yZCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG5cdCAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kICE9PSAwKSB7XG5cdCAgICAgIHZhciBwb3cgPSAxO1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG5cdCAgICAgICAgcG93ICo9IGJhc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmltdWxuKHBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcblx0ICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgfVxuXHQgICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuXHQgICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuXHQgICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG5cdCAgICB0aGlzLmNvcHkocik7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubGVuZ3RoLS07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG5cdCAgICAvLyAtMCA9IDBcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+Jztcblx0ICB9O1xuXG5cdCAgLypcblxuXHQgIHZhciB6ZXJvcyA9IFtdO1xuXHQgIHZhciBncm91cFNpemVzID0gW107XG5cdCAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuXHQgIHZhciBzID0gJyc7XG5cdCAgdmFyIGkgPSAtMTtcblx0ICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcblx0ICAgIHplcm9zW2ldID0gcztcblx0ICAgIHMgKz0gJzAnO1xuXHQgIH1cblx0ICBncm91cFNpemVzWzBdID0gMDtcblx0ICBncm91cFNpemVzWzFdID0gMDtcblx0ICBncm91cEJhc2VzWzBdID0gMDtcblx0ICBncm91cEJhc2VzWzFdID0gMDtcblx0ICB2YXIgYmFzZSA9IDIgLSAxO1xuXHQgIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcblx0ICAgIHZhciBncm91cFNpemUgPSAwO1xuXHQgICAgdmFyIGdyb3VwQmFzZSA9IDE7XG5cdCAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuXHQgICAgICBncm91cEJhc2UgKj0gYmFzZTtcblx0ICAgICAgZ3JvdXBTaXplICs9IDE7XG5cdCAgICB9XG5cdCAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuXHQgICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcblx0ICB9XG5cblx0ICAqL1xuXG5cdCAgdmFyIHplcm9zID0gW1xuXHQgICAgJycsXG5cdCAgICAnMCcsXG5cdCAgICAnMDAnLFxuXHQgICAgJzAwMCcsXG5cdCAgICAnMDAwMCcsXG5cdCAgICAnMDAwMDAnLFxuXHQgICAgJzAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcblx0ICBdO1xuXG5cdCAgdmFyIGdyb3VwU2l6ZXMgPSBbXG5cdCAgICAwLCAwLFxuXHQgICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuXHQgICAgOCwgNywgNywgNywgNywgNiwgNixcblx0ICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG5cdCAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuXHQgICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuXHQgIF07XG5cblx0ICB2YXIgZ3JvdXBCYXNlcyA9IFtcblx0ICAgIDAsIDAsXG5cdCAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcblx0ICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG5cdCAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG5cdCAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcblx0ICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG5cdCAgXTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG5cdCAgICBiYXNlID0gYmFzZSB8fCAxMDtcblx0ICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG5cdCAgICB2YXIgb3V0O1xuXHQgICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG5cdCAgICAgIG91dCA9ICcnO1xuXHQgICAgICB2YXIgb2ZmID0gMDtcblx0ICAgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuXHQgICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvZmYgKz0gMjtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcblx0ICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcblx0ICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG5cdCAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuXHQgICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcblx0ICAgICAgb3V0ID0gJyc7XG5cdCAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgICBjLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcblx0ICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG5cdCAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSByICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuXHQgICAgICAgIG91dCA9ICcwJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG5cdCAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuXHQgICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG5cdCAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcblx0ICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcblx0ICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG5cdCAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG5cdCAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cdCAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuXHQgICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuXHQgICAgdmFyIGIsIGk7XG5cdCAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG5cdCAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXNbaV0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuXHQgICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuXHQgICAgICAgIHEuaXVzaHJuKDgpO1xuXG5cdCAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcblx0ICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcblx0ICAgICAgICBxLml1c2hybig4KTtcblxuXHQgICAgICAgIHJlc1tpXSA9IGI7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBpZiAoTWF0aC5jbHozMikge1xuXHQgICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG5cdCAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcblx0ICAgICAgdmFyIHQgPSB3O1xuXHQgICAgICB2YXIgciA9IDA7XG5cdCAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuXHQgICAgICAgIHIgKz0gMTM7XG5cdCAgICAgICAgdCA+Pj49IDEzO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4NDApIHtcblx0ICAgICAgICByICs9IDc7XG5cdCAgICAgICAgdCA+Pj49IDc7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHQgPj0gMHg4KSB7XG5cdCAgICAgICAgciArPSA0O1xuXHQgICAgICAgIHQgPj4+PSA0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4MDIpIHtcblx0ICAgICAgICByICs9IDI7XG5cdCAgICAgICAgdCA+Pj49IDI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHIgKyB0O1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG5cdCAgICAvLyBTaG9ydC1jdXRcblx0ICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cblx0ICAgIHZhciB0ID0gdztcblx0ICAgIHZhciByID0gMDtcblx0ICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcblx0ICAgICAgciArPSAxMztcblx0ICAgICAgdCA+Pj49IDEzO1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcblx0ICAgICAgciArPSA3O1xuXHQgICAgICB0ID4+Pj0gNztcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcblx0ICAgICAgciArPSA0O1xuXHQgICAgICB0ID4+Pj0gNDtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcblx0ICAgICAgciArPSAyO1xuXHQgICAgICB0ID4+Pj0gMjtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcblx0ICAgICAgcisrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cblx0ICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcblx0ICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuXHQgICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuXHQgICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG5cdCAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG5cdCAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcblx0ICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuXHQgICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHc7XG5cdCAgfVxuXG5cdCAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuXHQgIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG5cdCAgICAgIHIgKz0gYjtcblx0ICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuXHQgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcblx0ICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuXHQgICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcblx0ICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG5cdCAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG5cdCAgICB2YXIgYTtcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcyAhPT0gYSkge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuXHQgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuXHQgIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cblx0ICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG5cdCAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG5cdCAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIGJ5dGVzTmVlZGVkLS07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG5cdCAgfTtcblxuXHQgIC8vIFNldCBgYml0YCBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG5cdCAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cblx0ICAgIGlmICh2YWwpIHtcblx0ICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuXHQgICAgdmFyIHI7XG5cblx0ICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcblx0ICAgIHZhciBhLCBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcblx0ICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcblx0ICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG5cdCAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG5cdCAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuXHQgICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuXHQgICAgaWYgKGNtcCA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEgPiBiXG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmIChjbXAgPiAwKSB7XG5cdCAgICAgIGEgPSB0aGlzO1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IG51bTtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gciA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSByID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuXHQgICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG5cdCAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG5cdCAgICBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcblx0ICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG5cdCAgICBvdXQubGVuZ3RoID0gbGVuO1xuXHQgICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuXHQgICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG5cdCAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIHIgPSBhICogYjtcblxuXHQgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG5cdCAgICBvdXQud29yZHNbMF0gPSBsbztcblxuXHQgICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuXHQgICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG5cdCAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG5cdCAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG5cdCAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuXHQgICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcblx0ICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuXHQgICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG5cdCAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuXHQgICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuXHQgICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgfVxuXHQgICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG5cdCAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQubGVuZ3RoLS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9XG5cblx0ICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuXHQgIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcblx0ICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuXHQgIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHM7XG5cdCAgICB2YXIgbyA9IG91dC53b3Jkcztcblx0ICAgIHZhciBjID0gMDtcblx0ICAgIHZhciBsbztcblx0ICAgIHZhciBtaWQ7XG5cdCAgICB2YXIgaGk7XG5cdCAgICB2YXIgYTAgPSBhWzBdIHwgMDtcblx0ICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG5cdCAgICB2YXIgYTEgPSBhWzFdIHwgMDtcblx0ICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG5cdCAgICB2YXIgYTIgPSBhWzJdIHwgMDtcblx0ICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG5cdCAgICB2YXIgYTMgPSBhWzNdIHwgMDtcblx0ICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG5cdCAgICB2YXIgYTQgPSBhWzRdIHwgMDtcblx0ICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG5cdCAgICB2YXIgYTUgPSBhWzVdIHwgMDtcblx0ICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG5cdCAgICB2YXIgYTYgPSBhWzZdIHwgMDtcblx0ICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG5cdCAgICB2YXIgYTcgPSBhWzddIHwgMDtcblx0ICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG5cdCAgICB2YXIgYTggPSBhWzhdIHwgMDtcblx0ICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG5cdCAgICB2YXIgYTkgPSBhWzldIHwgMDtcblx0ICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG5cdCAgICB2YXIgYjAgPSBiWzBdIHwgMDtcblx0ICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG5cdCAgICB2YXIgYjEgPSBiWzFdIHwgMDtcblx0ICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG5cdCAgICB2YXIgYjIgPSBiWzJdIHwgMDtcblx0ICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG5cdCAgICB2YXIgYjMgPSBiWzNdIHwgMDtcblx0ICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG5cdCAgICB2YXIgYjQgPSBiWzRdIHwgMDtcblx0ICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG5cdCAgICB2YXIgYjUgPSBiWzVdIHwgMDtcblx0ICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG5cdCAgICB2YXIgYjYgPSBiWzZdIHwgMDtcblx0ICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG5cdCAgICB2YXIgYjcgPSBiWzddIHwgMDtcblx0ICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG5cdCAgICB2YXIgYjggPSBiWzhdIHwgMDtcblx0ICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG5cdCAgICB2YXIgYjkgPSBiWzldIHwgMDtcblx0ICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gMTk7XG5cdCAgICAvKiBrID0gMCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG5cdCAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzAgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuXHQgICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcblx0ICAgIHcxICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAyICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcblx0ICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG5cdCAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzMgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuXHQgICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcblx0ICAgIHc0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA1ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcblx0ICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG5cdCAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzYgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuXHQgICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcblx0ICAgIHc3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA4ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcblx0ICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3OCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gOSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzkgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEwICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzExICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTIgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEzICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTUgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE2ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxOCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG5cdCAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTggJj0gMHgzZmZmZmZmO1xuXHQgICAgb1swXSA9IHcwO1xuXHQgICAgb1sxXSA9IHcxO1xuXHQgICAgb1syXSA9IHcyO1xuXHQgICAgb1szXSA9IHczO1xuXHQgICAgb1s0XSA9IHc0O1xuXHQgICAgb1s1XSA9IHc1O1xuXHQgICAgb1s2XSA9IHc2O1xuXHQgICAgb1s3XSA9IHc3O1xuXHQgICAgb1s4XSA9IHc4O1xuXHQgICAgb1s5XSA9IHc5O1xuXHQgICAgb1sxMF0gPSB3MTA7XG5cdCAgICBvWzExXSA9IHcxMTtcblx0ICAgIG9bMTJdID0gdzEyO1xuXHQgICAgb1sxM10gPSB3MTM7XG5cdCAgICBvWzE0XSA9IHcxNDtcblx0ICAgIG9bMTVdID0gdzE1O1xuXHQgICAgb1sxNl0gPSB3MTY7XG5cdCAgICBvWzE3XSA9IHcxNztcblx0ICAgIG9bMThdID0gdzE4O1xuXHQgICAgaWYgKGMgIT09IDApIHtcblx0ICAgICAgb1sxOV0gPSBjO1xuXHQgICAgICBvdXQubGVuZ3RoKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3V0O1xuXHQgIH07XG5cblx0ICAvLyBQb2x5ZmlsbCBjb21iXG5cdCAgaWYgKCFNYXRoLmltdWwpIHtcblx0ICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgdmFyIGhuY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG5cdCAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcblx0ICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcblx0ICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG5cdCAgICAgIGhuY2FycnkgPSAwO1xuXHQgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG5cdCAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcblx0ICAgICAgICB2YXIgaSA9IGsgLSBqO1xuXHQgICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG5cdCAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHZhciByID0gYSAqIGI7XG5cblx0ICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcblx0ICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG5cdCAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuXHQgICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcblx0ICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuXHQgICAgICB9XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuXHQgICAgICBjYXJyeSA9IG5jYXJyeTtcblx0ICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dC5sZW5ndGgtLTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG5cdCAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuXHQgICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG5cdCAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG5cdCAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcblx0ICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cblx0ICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG5cdCAgICB0aGlzLnggPSB4O1xuXHQgICAgdGhpcy55ID0geTtcblx0ICB9XG5cblx0ICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuXHQgICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuXHQgIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuXHQgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG5cdCAgICB2YXIgcmIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcblx0ICAgICAgeCA+Pj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJiO1xuXHQgIH07XG5cblx0ICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcblx0ICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cblx0ICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuXHQgICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuXHQgICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG5cdCAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcblx0ICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cblx0ICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcblx0ICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuXHQgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuXHQgICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcblx0ICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuXHQgICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG5cdCAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuXHQgICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuXHQgICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG5cdCAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG5cdCAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG5cdCAgICAgICAgICBybyA9IHJ4O1xuXG5cdCAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cblx0ICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG5cdCAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuXHQgICAgICAgICAgaWYgKGogIT09IGwpIHtcblx0ICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG5cdCAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG5cdCAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG5cdCAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcblx0ICAgIHZhciBvZGQgPSBOICYgMTtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuXHQgICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcblx0ICAgICAgdmFyIHQgPSByd3NbaV07XG5cblx0ICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG5cdCAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuXHQgICAgICB0ID0gaXdzW2ldO1xuXG5cdCAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcblx0ICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcblx0ICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcblx0ICAgICAgICBjYXJyeTtcblxuXHQgICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cblx0ICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcblx0ICAgICAgICBjYXJyeSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd3M7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuXHQgICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuXHQgICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcblx0ICAgIH1cblxuXHQgICAgLy8gUGFkIHdpdGggemVyb2VzXG5cdCAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG5cdCAgICAgIHJ3c1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuXHQgICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcGhbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcGg7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcblx0ICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuXHQgICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuXHQgICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cblx0ICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG5cdCAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuXHQgICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG5cdCAgICBybXdzLmxlbmd0aCA9IE47XG5cblx0ICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcblx0ICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cblx0ICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcblx0ICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuXHQgICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuXHQgICAgICByd3N0W2ldID0gcng7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuXHQgICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcblx0ICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuXHQgICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuXHQgICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcblx0ICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuXHQgIH07XG5cblx0ICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG5cdCAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcblx0ICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG5cdCAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcblx0ICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cblx0ICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cblx0ICAgIC8vIENhcnJ5XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcblx0ICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcblx0ICAgICAgY2FycnkgPj49IDI2O1xuXHQgICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG5cdCAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gYHRoaXNgICogYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG5cdCAgfTtcblxuXHQgIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG5cdCAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcblx0ICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuXHQgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuXHQgICAgdmFyIHJlcyA9IHRoaXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuXHQgICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuXHQgICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcblx0ICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cblx0ICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXHQgICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcblx0ICAgIHZhciBpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgY2FycnkgPSAwO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcblx0ICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcblx0ICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjYXJyeSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzICE9PSAwKSB7XG5cdCAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmxlbmd0aCArPSBzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuXHQgICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG5cdCAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG5cdCAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuXHQgIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgaDtcblx0ICAgIGlmIChoaW50KSB7XG5cdCAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaCA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcblx0ICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuXHQgICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cblx0ICAgIGggLT0gcztcblx0ICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuXHQgICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuXHQgICAgaWYgKG1hc2tlZFdvcmRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzID09PSAwKSB7XG5cdCAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuXHQgICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcblx0ICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG5cdCAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuXHQgICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnRcblx0ICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtcmlnaHRcblx0ICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcblx0ICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXQgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG5cdCAgICB2YXIgcSA9IDEgPDwgcjtcblxuXHQgICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG5cdCAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cblx0ICAgIHJldHVybiAhISh3ICYgcSk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG5cdCAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyICE9PSAwKSB7XG5cdCAgICAgIHMrKztcblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuXHQgIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cdCAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cblx0ICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuXHQgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaXN1Ym4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBZGQgd2l0aG91dCBjaGVja3Ncblx0ICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcblx0ICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG5cdCAgICAvLyBDYXJyeVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuXHQgICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cdCAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblx0ICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaWFkZG4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBDYXJyeVxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuXHQgICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcblx0ICAgIHZhciBpO1xuXG5cdCAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuXHQgICAgdmFyIHc7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG5cdCAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcblx0ICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuXHQgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcblx0ICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcblx0ICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuXHQgICAgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuXHQgICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIHZhciBiID0gbnVtO1xuXG5cdCAgICAvLyBOb3JtYWxpemVcblx0ICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcblx0ICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuXHQgICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcblx0ICAgICAgYS5pdXNobG4oc2hpZnQpO1xuXHQgICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG5cdCAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG5cdCAgICB2YXIgcTtcblxuXHQgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG5cdCAgICAgIHEubGVuZ3RoID0gbSArIDE7XG5cdCAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBxLndvcmRzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG5cdCAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBhID0gZGlmZjtcblx0ICAgICAgaWYgKHEpIHtcblx0ICAgICAgICBxLndvcmRzW21dID0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG5cdCAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuXHQgICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuXHQgICAgICAvLyAoMHg3ZmZmZmZmKVxuXHQgICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG5cdCAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcblx0ICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBxai0tO1xuXHQgICAgICAgIGEubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuXHQgICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAocSkge1xuXHQgICAgICAgIHEud29yZHNbal0gPSBxajtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHEpIHtcblx0ICAgICAgcS5zdHJpcCgpO1xuXHQgICAgfVxuXHQgICAgYS5zdHJpcCgpO1xuXG5cdCAgICAvLyBEZW5vcm1hbGl6ZVxuXHQgICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZGl2OiBxIHx8IG51bGwsXG5cdCAgICAgIG1vZDogYVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcblx0ICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cblx0ICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG5cdCAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcblx0ICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG5cdCAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBuZXcgQk4oMCksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4oMClcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRpdiwgbW9kLCByZXM7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcblx0ICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG5cdCAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcblx0ICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgICBtb2QuaWFkZChudW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiByZXMubW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcblx0ICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuXHQgICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IHJlcy5kaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cblx0ICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuXHQgICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogbmV3IEJOKDApLFxuXHQgICAgICAgIG1vZDogdGhpc1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuXHQgICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgICBtb2Q6IG51bGxcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogbnVsbCxcblx0ICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcblx0ICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuXHQgICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuXHQgICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cblx0ICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG5cdCAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcblx0ICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcblx0ICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG5cdCAgICAvLyBSb3VuZCBkb3duXG5cdCAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIC8vIFJvdW5kIHVwXG5cdCAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXHQgICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cblx0ICAgIHZhciBhY2MgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGFjYztcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG5cdCAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuXHQgICAgICBjYXJyeSA9IHcgJSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuXHQgICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuXHQgICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuXHQgICAgdmFyIHggPSB0aGlzO1xuXHQgICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cblx0ICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHggPSB4LnVtb2QocCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4ID0geC5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBICogeCArIEIgKiB5ID0geFxuXHQgICAgdmFyIEEgPSBuZXcgQk4oMSk7XG5cdCAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuXHQgICAgLy8gQyAqIHggKyBEICogeSA9IHlcblx0ICAgIHZhciBDID0gbmV3IEJOKDApO1xuXHQgICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cblx0ICAgIHZhciBnID0gMDtcblxuXHQgICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuXHQgICAgICB4Lml1c2hybigxKTtcblx0ICAgICAgeS5pdXNocm4oMSk7XG5cdCAgICAgICsrZztcblx0ICAgIH1cblxuXHQgICAgdmFyIHlwID0geS5jbG9uZSgpO1xuXHQgICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG5cdCAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgeC5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEEuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEIuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEEuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgQi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgeS5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEMuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEQuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEMuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgRC5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHguY21wKHkpID49IDApIHtcblx0ICAgICAgICB4LmlzdWIoeSk7XG5cdCAgICAgICAgQS5pc3ViKEMpO1xuXHQgICAgICAgIEIuaXN1YihEKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB5LmlzdWIoeCk7XG5cdCAgICAgICAgQy5pc3ViKEEpO1xuXHQgICAgICAgIEQuaXN1YihCKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBhOiBDLFxuXHQgICAgICBiOiBELFxuXHQgICAgICBnY2Q6IHkuaXVzaGxuKGcpXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcblx0ICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcblx0ICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuXHQgIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcblx0ICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cblx0ICAgIHZhciBhID0gdGhpcztcblx0ICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG5cdCAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBhID0gYS51bW9kKHApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IGEuY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuXHQgICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG5cdCAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cblx0ICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgYS5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4MS5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgYi5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4Mi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcblx0ICAgICAgICBhLmlzdWIoYik7XG5cdCAgICAgICAgeDEuaXN1Yih4Mik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYi5pc3ViKGEpO1xuXHQgICAgICAgIHgyLmlzdWIoeDEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgIHJlcyA9IHgxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzID0geDI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQocCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuXHQgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG5cdCAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuXHQgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuXHQgICAgYS5uZWdhdGl2ZSA9IDA7XG5cdCAgICBiLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG5cdCAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuXHQgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgYi5pdXNocm4oMSk7XG5cdCAgICB9XG5cblx0ICAgIGRvIHtcblx0ICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcblx0ICAgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuXHQgICAgICAgIGIuaXVzaHJuKDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHIgPSBhLmNtcChiKTtcblx0ICAgICAgaWYgKHIgPCAwKSB7XG5cdCAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG5cdCAgICAgICAgdmFyIHQgPSBhO1xuXHQgICAgICAgIGEgPSBiO1xuXHQgICAgICAgIGIgPSB0O1xuXHQgICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBhLmlzdWIoYik7XG5cdCAgICB9IHdoaWxlICh0cnVlKTtcblxuXHQgICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG5cdCAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cblx0ICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcblx0ICB9O1xuXG5cdCAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuXHQgIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG5cdCAgICB2YXIgciA9IGJpdCAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcblx0ICAgIHZhciBxID0gMSA8PCByO1xuXG5cdCAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcblx0ICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcblx0ICAgIHZhciBjYXJyeSA9IHE7XG5cdCAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdyArPSBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+PiAyNjtcblx0ICAgICAgdyAmPSAweDNmZmZmZmY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmVzID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIG51bSA9IC1udW07XG5cdCAgICAgIH1cblxuXHQgICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcblx0ICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuXHQgIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuXHQgIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcblx0ICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cblx0ICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG5cdCAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcblx0ICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cblx0ICAgIHZhciByZXMgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG5cdCAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcblx0ICAgICAgaWYgKGEgPCBiKSB7XG5cdCAgICAgICAgcmVzID0gLTE7XG5cdCAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcblx0ICAgICAgICByZXMgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcblx0ICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cblx0ICAvL1xuXHQgIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG5cdCAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG5cdCAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgdGhpcy5yZWQgPSBjdHg7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFNxdWFyZSByb290IG92ZXIgcFxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG5cdCAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuXHQgIHZhciBwcmltZXMgPSB7XG5cdCAgICBrMjU2OiBudWxsLFxuXHQgICAgcDIyNDogbnVsbCxcblx0ICAgIHAxOTI6IG51bGwsXG5cdCAgICBwMjU1MTk6IG51bGxcblx0ICB9O1xuXG5cdCAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG5cdCAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG5cdCAgICAvLyBQID0gMiBeIE4gLSBLXG5cdCAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcblx0ICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcblx0ICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cblx0ICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG5cdCAgfVxuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG5cdCAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuXHQgICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuXHQgICAgcmV0dXJuIHRtcDtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG5cdCAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG5cdCAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG5cdCAgICB2YXIgciA9IG51bTtcblx0ICAgIHZhciBybGVuO1xuXG5cdCAgICBkbyB7XG5cdCAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuXHQgICAgICByID0gdGhpcy5pbXVsSyhyKTtcblx0ICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG5cdCAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuXHQgICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cblx0ICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcblx0ICAgIGlmIChjbXAgPT09IDApIHtcblx0ICAgICAgci53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHIubGVuZ3RoID0gMTtcblx0ICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuXHQgICAgICByLmlzdWIodGhpcy5wKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHIuc3RyaXAoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuXHQgICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBLMjU2ICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAnazI1NicsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG5cdCAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuXHQgICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcblx0ICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cblx0ICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuXHQgICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcblx0ICAgIH1cblx0ICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cblx0ICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuXHQgICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuXHQgICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcblx0ICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cblx0ICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG5cdCAgICAgIHByZXYgPSBuZXh0O1xuXHQgICAgfVxuXHQgICAgcHJldiA+Pj49IDIyO1xuXHQgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG5cdCAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuXHQgICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnB1dC5sZW5ndGggLT0gOTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cblx0ICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG5cdCAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcblx0ICAgIG51bS5sZW5ndGggKz0gMjtcblxuXHQgICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIGxvICs9IHcgKiAweDNkMTtcblx0ICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG5cdCAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cblx0ICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgIG51bS5sZW5ndGgtLTtcblx0ICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgICBudW0ubGVuZ3RoLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudW07XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIFAyMjQgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdwMjI0Jyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cblx0ICBmdW5jdGlvbiBQMTkyICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAncDE5MicsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG5cdCAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcblx0ICAgIC8vIDIgXiAyNTUgLSAxOVxuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICcyNTUxOScsXG5cdCAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuXHQgIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICAvLyBLID0gMHgxM1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcblx0ICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG5cdCAgICAgIGhpID4+Pj0gMjY7XG5cblx0ICAgICAgbnVtLndvcmRzW2ldID0gbG87XG5cdCAgICAgIGNhcnJ5ID0gaGk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudW07XG5cdCAgfTtcblxuXHQgIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuXHQgIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG5cdCAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuXHQgICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuXHQgICAgdmFyIHByaW1lO1xuXHQgICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcblx0ICAgIH1cblx0ICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG5cdCAgICByZXR1cm4gcHJpbWU7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG5cdCAgLy9cblx0ICBmdW5jdGlvbiBSZWQgKG0pIHtcblx0ICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuXHQgICAgICB0aGlzLm0gPSBwcmltZS5wO1xuXHQgICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcblx0ICAgICAgdGhpcy5tID0gbTtcblx0ICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG5cdCAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG5cdCAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuXHQgICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcblx0ICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuXHQgICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcblx0ICAgIGlmIChhLmlzWmVybygpKSB7XG5cdCAgICAgIHJldHVybiBhLmNsb25lKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmFkZChiKTtcblx0ICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMuaXN1Yih0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG5cdCAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzLmlzdWIodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5zdWIoYik7XG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcblx0ICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcblx0ICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cblx0ICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuXHQgICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuXHQgICAgLy8gRmFzdCBjYXNlXG5cdCAgICBpZiAobW9kMyA9PT0gMykge1xuXHQgICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcblx0ICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcblx0ICAgIC8vXG5cdCAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuXHQgICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcblx0ICAgIHZhciBzID0gMDtcblx0ICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG5cdCAgICAgIHMrKztcblx0ICAgICAgcS5pdXNocm4oMSk7XG5cdCAgICB9XG5cdCAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG5cdCAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cblx0ICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG5cdCAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cblx0ICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuXHQgICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG5cdCAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cblx0ICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcblx0ICAgICAgei5yZWRJQWRkKG5PbmUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuXHQgICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcblx0ICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG5cdCAgICB2YXIgbSA9IHM7XG5cdCAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuXHQgICAgICB2YXIgdG1wID0gdDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG5cdCAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuXHQgICAgICB9XG5cdCAgICAgIGFzc2VydChpIDwgbSk7XG5cdCAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuXHQgICAgICByID0gci5yZWRNdWwoYik7XG5cdCAgICAgIGMgPSBiLnJlZFNxcigpO1xuXHQgICAgICB0ID0gdC5yZWRNdWwoYyk7XG5cdCAgICAgIG0gPSBpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuXHQgICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG5cdCAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuXHQgICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuXHQgICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuXHQgICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuXHQgICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgd25kWzFdID0gYTtcblx0ICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzID0gd25kWzBdO1xuXHQgICAgdmFyIGN1cnJlbnQgPSAwO1xuXHQgICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG5cdCAgICBpZiAoc3RhcnQgPT09IDApIHtcblx0ICAgICAgc3RhcnQgPSAyNjtcblx0ICAgIH1cblxuXHQgICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuXHQgICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuXHQgICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG5cdCAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG5cdCAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuXHQgICAgICAgICAgY3VycmVudExlbiA9IDA7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdXJyZW50IDw8PSAxO1xuXHQgICAgICAgIGN1cnJlbnQgfD0gYml0O1xuXHQgICAgICAgIGN1cnJlbnRMZW4rKztcblx0ICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cblx0ICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG5cdCAgICAgICAgY3VycmVudExlbiA9IDA7XG5cdCAgICAgICAgY3VycmVudCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgc3RhcnQgPSAyNjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuXHQgICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG5cdCAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcblx0ICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcblx0ICAgIHJlcy5yZWQgPSBudWxsO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy9cblx0ICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcblx0ICAvL1xuXG5cdCAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuXHQgICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIE1vbnQgKG0pIHtcblx0ICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG5cdCAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuXHQgICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuXHQgICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG5cdCAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG5cdCAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cblx0ICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcblx0ICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG5cdCAgfVxuXHQgIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cblx0ICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcblx0ICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG5cdCAgICByLnJlZCA9IG51bGw7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcblx0ICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcblx0ICAgICAgYS53b3Jkc1swXSA9IDA7XG5cdCAgICAgIGEubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuIGE7XG5cdCAgICB9XG5cblx0ICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuXHQgICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcblx0ICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcblx0ICAgIHZhciByZXMgPSB1O1xuXG5cdCAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuXHQgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuXHQgICAgdmFyIHQgPSBhLm11bChiKTtcblx0ICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG5cdCAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG5cdCAgICB2YXIgcmVzID0gdTtcblx0ICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG5cdCAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuXHQgICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuXHQgICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXHR9KSgnb2JqZWN0JyA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCBjb21tb25qc0dsb2JhbCk7XG5cdH0pO1xuXHR2YXIgYm5fMSA9IGJuLkJOO1xuXG5cdHZhciBfdmVyc2lvbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJsb2dnZXIvNS4wLjAtYmV0YS4xMzdcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDEgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uKTtcblx0dmFyIF92ZXJzaW9uXzEgPSBfdmVyc2lvbi52ZXJzaW9uO1xuXG5cdHZhciBsaWIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5cdHZhciBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG5cdHZhciBMb2dMZXZlbHMgPSB7IGRlYnVnOiAxLCBcImRlZmF1bHRcIjogMiwgaW5mbzogMiwgd2FybmluZzogMywgZXJyb3I6IDQsIG9mZjogNSB9O1xuXHR2YXIgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcblxuXHR2YXIgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5cdGZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIG1pc3NpbmdfMSA9IFtdO1xuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG5cdCAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaChmdW5jdGlvbiAoZm9ybSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgbWlzc2luZ18xLnB1c2goZm9ybSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAobWlzc2luZ18xLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFwiICsgbWlzc2luZ18xLmpvaW4oXCIsIFwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcblx0dmFyIExvZ0xldmVsO1xuXHQoZnVuY3Rpb24gKExvZ0xldmVsKSB7XG5cdCAgICBMb2dMZXZlbFtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuXHQgICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG5cdCAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcblx0ICAgIExvZ0xldmVsW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG5cdCAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG5cdH0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XG5cdHZhciBFcnJvckNvZGU7XG5cdChmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBHZW5lcmljIEVycm9yc1xuXHQgICAgLy8gVW5rbm93biBFcnJvclxuXHQgICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuXHQgICAgLy8gTm90IEltcGxlbWVudGVkXG5cdCAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuXHQgICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG5cdCAgICAvLyAgIC0gb3BlcmF0aW9uXG5cdCAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuXHQgICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG5cdCAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG5cdCAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuXHQgICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcblx0ICAgIC8vIFRpbWVvdXRcblx0ICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcblx0ICAgIC8vIEJ1ZmZlciBPdmVycnVuXG5cdCAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcblx0ICAgIC8vIE51bWVyaWMgRmF1bHRcblx0ICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcblx0ICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcblx0ICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuXHQgICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG5cdCAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3Ncblx0ICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuXHQgICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuXHQgICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG5cdCAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcblx0ICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcblx0ICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcblx0ICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcblx0ICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuXHQgICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuXHQgICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG5cdCAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG5cdCAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcblx0ICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG5cdCAgICAvLyBDYWxsIGV4Y2VwdGlvblxuXHQgICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuXHQgICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG5cdCAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cblx0ICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcblx0ICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuXHQgICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG5cdCAgICAvLyBJbnN1ZmZpY2llbiBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG5cdCAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcblx0ICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG5cdCAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuXHQgICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG5cdCAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuXHQgICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG5cdH0pKEVycm9yQ29kZSA9IGV4cG9ydHMuRXJyb3JDb2RlIHx8IChleHBvcnRzLkVycm9yQ29kZSA9IHt9KSk7XG5cdDtcblx0dmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIExvZ2dlcih2ZXJzaW9uKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuXHQgICAgICAgICAgICB3cml0YWJsZTogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsb2dMZXZlbCwgYXJncykge1xuXHQgICAgICAgIHZhciBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcblx0ICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG5cdCAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWNvZGUpIHtcblx0ICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFwYXJhbXMpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZXNzYWdlRGV0YWlscyA9IFtdO1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKFwiY29kZT1cIiArIGNvZGUpO1xuXHQgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goXCJ2ZXJzaW9uPVwiICsgdGhpcy52ZXJzaW9uKTtcblx0ICAgICAgICB2YXIgcmVhc29uID0gbWVzc2FnZTtcblx0ICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG5cdCAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG5cdCAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLnRocm93QXJndW1lbnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuXHQgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrTm9ybWFsaXplID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrU2FmZVVpbnQ1MyA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrQXJndW1lbnRDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuXHQgICAgICAgIGlmIChtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG5cdCAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG5cdCAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrTmV3ID0gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuXHQgICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5jaGVja0Fic3RyYWN0ID0gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuXHQgICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5nbG9iYWxMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG5cdCAgICAgICAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgTG9nZ2VyKF92ZXJzaW9uLnZlcnNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIuc2V0Q2Vuc29yc2hpcCA9IGZ1bmN0aW9uIChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcblx0ICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG5cdCAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuXHQgICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobG9nTGV2ZWwpIHtcblx0ICAgICAgICB2YXIgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWxdO1xuXHQgICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIExvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIuZXJyb3JzID0gRXJyb3JDb2RlO1xuXHQgICAgTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuXHQgICAgcmV0dXJuIExvZ2dlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG5cdH0pO1xuXG5cdHZhciBpbmRleCA9IHVud3JhcEV4cG9ydHMobGliKTtcblx0dmFyIGxpYl8xID0gbGliLkxvZ0xldmVsO1xuXHR2YXIgbGliXzIgPSBsaWIuRXJyb3JDb2RlO1xuXHR2YXIgbGliXzMgPSBsaWIuTG9nZ2VyO1xuXG5cdHZhciBfdmVyc2lvbiQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImJ5dGVzLzUuMC4wLWJldGEuMTM4XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQzID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiQyKTtcblx0dmFyIF92ZXJzaW9uXzEkMSA9IF92ZXJzaW9uJDIudmVyc2lvbjtcblxuXHR2YXIgbGliJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kMi52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcblx0ICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG5cdH1cblx0ZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcblx0ICAgIGlmIChhcnJheS5zbGljZSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0ICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5LCBhcmdzKSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBhcnJheTtcblx0fVxuXHRmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICgoaXNIZXhTdHJpbmcodmFsdWUpICYmICEodmFsdWUubGVuZ3RoICUgMikpIHx8IGlzQnl0ZXModmFsdWUpKTtcblx0fVxuXHRleHBvcnRzLmlzQnl0ZXNMaWtlID0gaXNCeXRlc0xpa2U7XG5cdGZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHYgPSB2YWx1ZVtpXTtcblx0ICAgICAgICBpZiAodiA8IDAgfHwgdiA+PSAyNTYgfHwgKHYgJSAxKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcblx0ZnVuY3Rpb24gYXJyYXlpZnkodmFsdWUsIG9wdGlvbnMpIHtcblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG5cdCAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuXHQgICAgICAgICAgICAgICAgaGV4ID0gXCIweDBcIiArIGhleC5zdWJzdHJpbmcoMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuXHQgICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0fVxuXHRleHBvcnRzLmFycmF5aWZ5ID0gYXJyYXlpZnk7XG5cdGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuXHQgICAgdmFyIG9iamVjdHMgPSBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGFycmF5aWZ5KGl0ZW0pOyB9KTtcblx0ICAgIHZhciBsZW5ndGggPSBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGl0ZW0pIHsgcmV0dXJuIChhY2N1bSArIGl0ZW0ubGVuZ3RoKTsgfSwgMCk7XG5cdCAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblx0ICAgIG9iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChvZmZzZXQsIG9iamVjdCkge1xuXHQgICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuXHQgICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuXHQgICAgfSwgMCk7XG5cdCAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcblx0ZnVuY3Rpb24gc3RyaXBaZXJvcyh2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcblx0ICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG5cdCAgICB2YXIgc3RhcnQgPSAwO1xuXHQgICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG5cdCAgICAgICAgc3RhcnQrKztcblx0ICAgIH1cblx0ICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuXHQgICAgaWYgKHN0YXJ0KSB7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKHN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5zdHJpcFplcm9zID0gc3RyaXBaZXJvcztcblx0ZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcblx0ICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMuemVyb1BhZCA9IHplcm9QYWQ7XG5cdGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcblx0dmFyIEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblx0ZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIik7XG5cdCAgICAgICAgdmFyIGhleCA9IFwiXCI7XG5cdCAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGhleCA9IEhleENoYXJhY3RlcnNbdmFsdWUgJiAweDBmXSArIGhleDtcblx0ICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4MDBcIjtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiMHhcIjtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdmFsdWVbaV07XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHR9XG5cdGV4cG9ydHMuaGV4bGlmeSA9IGhleGxpZnk7XG5cdC8qXG5cdGZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG5cdCAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggJSAyICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0Ki9cblx0ZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG5cdCAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuXHR9XG5cdGV4cG9ydHMuaGV4RGF0YUxlbmd0aCA9IGhleERhdGFMZW5ndGg7XG5cdGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuXHQgICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcblx0ICAgIH1cblx0ICAgIG9mZnNldCA9IDIgKyAyICogb2Zmc2V0O1xuXHQgICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG5cdH1cblx0ZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBoZXhEYXRhU2xpY2U7XG5cdGZ1bmN0aW9uIGhleENvbmNhdChpdGVtcykge1xuXHQgICAgdmFyIHJlc3VsdCA9IFwiMHhcIjtcblx0ICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICByZXN1bHQgKz0gaGV4bGlmeShpdGVtKS5zdWJzdHJpbmcoMik7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5oZXhDb25jYXQgPSBoZXhDb25jYXQ7XG5cdGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG5cdCAgICB2YXIgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcblx0ICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCIweDBcIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cmltbWVkO1xuXHR9XG5cdGV4cG9ydHMuaGV4VmFsdWUgPSBoZXhWYWx1ZTtcblx0ZnVuY3Rpb24gaGV4U3RyaXBaZXJvcyh2YWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgdmFyIG9mZnNldCA9IDA7XG5cdCAgICB3aGlsZSAob2Zmc2V0IDwgdmFsdWUubGVuZ3RoICYmIHZhbHVlW29mZnNldF0gPT09IFwiMFwiKSB7XG5cdCAgICAgICAgb2Zmc2V0Kys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKG9mZnNldCk7XG5cdH1cblx0ZXhwb3J0cy5oZXhTdHJpcFplcm9zID0gaGV4U3RyaXBaZXJvcztcblx0ZnVuY3Rpb24gaGV4WmVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcblx0ICAgIH1cblx0ICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLmhleFplcm9QYWQgPSBoZXhaZXJvUGFkO1xuXHRmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgcjogXCIweFwiLFxuXHQgICAgICAgIHM6IFwiMHhcIixcblx0ICAgICAgICBfdnM6IFwiMHhcIixcblx0ICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuXHQgICAgICAgIHY6IDBcblx0ICAgIH07XG5cdCAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNjUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZzsgbXVzdCBiZSA2NSBieXRlc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcblx0ICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcblx0ICAgICAgICByZXN1bHQucyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG5cdCAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG5cdCAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuXHQgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuXHQgICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuXHQgICAgICAgIGlmIChyZXN1bHQudiA8IDI3KSB7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG5cdCAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzWzMyXSB8PSAweDgwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG5cdCAgICAgICAgcmVzdWx0LnMgPSBzaWduYXR1cmUucztcblx0ICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuXHQgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgcmVzdWx0Ll92cyA9IHNpZ25hdHVyZS5fdnM7XG5cdCAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cblx0ICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cblx0ICAgICAgICBpZiAocmVzdWx0Ll92cyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciB2c18xID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuXHQgICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2c18xKTtcblx0ICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuXHQgICAgICAgICAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9ICgodnNfMVswXSA+PSAxMjgpID8gMSA6IDApO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtICE9PSByZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSBzXG5cdCAgICAgICAgICAgIHZzXzFbMF0gJj0gMHg3Zjtcblx0ICAgICAgICAgICAgdmFyIHMgPSBoZXhsaWZ5KHZzXzEpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcblx0ICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtICE9PSAoMSAtIChyZXN1bHQudiAlIDIpKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnIgPT0gbnVsbCB8fCAhaXNIZXhTdHJpbmcocmVzdWx0LnIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCB8fCAhaXNIZXhTdHJpbmcocmVzdWx0LnMpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG5cdCAgICAgICAgaWYgKHZzWzBdID49IDEyOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuXHQgICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX3ZzID0gaGV4bGlmeSh2cyk7XG5cdCAgICAgICAgaWYgKHJlc3VsdC5fdnMpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSBfdnNcblx0ICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnNwbGl0U2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmU7XG5cdGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG5cdCAgICBzaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuXHQgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcblx0ICAgICAgICBzaWduYXR1cmUucixcblx0ICAgICAgICBzaWduYXR1cmUucyxcblx0ICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuXHQgICAgXSkpO1xuXHR9XG5cdGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGpvaW5TaWduYXR1cmU7XG5cdH0pO1xuXG5cdHZhciBpbmRleCQxID0gdW53cmFwRXhwb3J0cyhsaWIkMSk7XG5cdHZhciBsaWJfMSQxID0gbGliJDEuaXNCeXRlc0xpa2U7XG5cdHZhciBsaWJfMiQxID0gbGliJDEuaXNCeXRlcztcblx0dmFyIGxpYl8zJDEgPSBsaWIkMS5hcnJheWlmeTtcblx0dmFyIGxpYl80ID0gbGliJDEuY29uY2F0O1xuXHR2YXIgbGliXzUgPSBsaWIkMS5zdHJpcFplcm9zO1xuXHR2YXIgbGliXzYgPSBsaWIkMS56ZXJvUGFkO1xuXHR2YXIgbGliXzcgPSBsaWIkMS5pc0hleFN0cmluZztcblx0dmFyIGxpYl84ID0gbGliJDEuaGV4bGlmeTtcblx0dmFyIGxpYl85ID0gbGliJDEuaGV4RGF0YUxlbmd0aDtcblx0dmFyIGxpYl8xMCA9IGxpYiQxLmhleERhdGFTbGljZTtcblx0dmFyIGxpYl8xMSA9IGxpYiQxLmhleENvbmNhdDtcblx0dmFyIGxpYl8xMiA9IGxpYiQxLmhleFZhbHVlO1xuXHR2YXIgbGliXzEzID0gbGliJDEuaGV4U3RyaXBaZXJvcztcblx0dmFyIGxpYl8xNCA9IGxpYiQxLmhleFplcm9QYWQ7XG5cdHZhciBsaWJfMTUgPSBsaWIkMS5zcGxpdFNpZ25hdHVyZTtcblx0dmFyIGxpYl8xNiA9IGxpYiQxLmpvaW5TaWduYXR1cmU7XG5cblx0dmFyIF92ZXJzaW9uJDQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYmlnbnVtYmVyLzUuMC4wLWJldGEuMTM5XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQ1ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiQ0KTtcblx0dmFyIF92ZXJzaW9uXzEkMiA9IF92ZXJzaW9uJDQudmVyc2lvbjtcblxuXHR2YXIgYmlnbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvKipcblx0ICogIEJpZ051bWJlclxuXHQgKlxuXHQgKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcblx0ICogIGJlY2F1c2UgaXQgaXMgdXNlZCBieSBlbGxpcHRpYywgc28gaXQgaXMgcmVxdWlyZWQgcmVnYXJkbGVzLlxuXHQgKlxuXHQgKi9cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kNC52ZXJzaW9uKTtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5cdGZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG5cdCAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmICh2YWx1ZSAlIDEpID09PSAwKSB8fFxuXHQgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHx8XG5cdCAgICAgICAgbGliJDEuaXNIZXhTdHJpbmcodmFsdWUpIHx8XG5cdCAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB8fFxuXHQgICAgICAgIGxpYiQxLmlzQnl0ZXModmFsdWUpKTtcblx0fVxuXHRleHBvcnRzLmlzQmlnTnVtYmVyaXNoID0gaXNCaWdOdW1iZXJpc2g7XG5cdHZhciBCaWdOdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCaWdOdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBCaWdOdW1iZXIpO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2hleCA9IGhleDtcblx0ICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgbyA9IEJpZ051bWJlci5mcm9tKG90aGVyKTtcblx0ICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24gYnkgemVyb1wiLCBcImRpdlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgbW9kdWxvIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1vZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudW1vZCh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICdhbmQnIG5lZ2F0aXZlIHZhbHVlc1wiLCBcImFuZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYW5kKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgJ29yJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJvclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykub3IodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgJ3hvcicgbmVnYXRpdmUgdmFsdWVzXCIsIFwieG9yXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS54b3IodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1hc2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgbWFzayBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJtYXNrXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IHNoaWZ0IG5lZ2F0aXZlIHZhbHVlc1wiLCBcInNobFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hsbih2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuc2hyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IHNoaWZ0IG5lZ2F0aXZlIHZhbHVlc1wiLCBcInNoclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5lcSh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0KHRvQk4ob3RoZXIpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0KHRvQk4ob3RoZXIpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0ZSh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5faGV4WzBdID09PSBcIi1cIik7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuaXNaZXJvKCk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBMb3RzIG9mIHBlb3BsZSBleHBlY3QgdGhpcywgd2hpY2ggd2UgZG8gbm90IHN1cHBvcnQsIHNvIGNoZWNrXG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlcnNcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b1N0cmluZygxMCk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b0hleFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvLT8weFswLTlhLWZdKy9pKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleChuZXcgYm4uQk4odmFsdWUpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5kZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsaWIkMS5pc0J5dGVzKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20obGliJDEuaGV4bGlmeSh2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUuX2hleCAmJiBsaWIkMS5pc0hleFN0cmluZyh2YWx1ZS5faGV4KSkge1xuXHQgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUuX2hleCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZS50b0hleFN0cmluZykge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCaWdOdW1iZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuXHQvLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcblx0ZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcblx0ICAgIC8vIEZvciBCTiwgY2FsbCBvbiB0aGUgaGV4IHN0cmluZ1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuXHQgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbmVnYXRpdmUgc2lnblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgIC8vIENhbm5vdCBoYXZlIG11bGl0cGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG5cdCAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENhbGwgdG9IZXggb24gdGhlIHBvc2l0aXZlIGNvbXBvbmVudFxuXHQgICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuXHQgICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcblx0ICAgICAgICBpZiAodmFsdWUgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTmVnYXRlIHRoZSB2YWx1ZVxuXHQgICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gQWRkIGEgXCIweFwiIHByZWZpeCBpZiBtaXNzaW5nXG5cdCAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gTm9ybWFsaXplIHplcm9cblx0ICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG5cdCAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIC8vIFRyaW0gdG8gc21hbGxlc3QgZXZlbi1sZW5ndGggc3RyaW5nXG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpIHtcblx0ICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xuXHR9XG5cdGZ1bmN0aW9uIHRvQk4odmFsdWUpIHtcblx0ICAgIHZhciBoZXggPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcblx0ICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG5cdCAgICAgICAgcmV0dXJuIChuZXcgYm4uQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBibi5CTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG5cdH1cblx0ZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuXHQgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgbGliLkxvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcblx0fVxuXHR9KTtcblxuXHR2YXIgYmlnbnVtYmVyJDEgPSB1bndyYXBFeHBvcnRzKGJpZ251bWJlcik7XG5cdHZhciBiaWdudW1iZXJfMSA9IGJpZ251bWJlci5pc0JpZ051bWJlcmlzaDtcblx0dmFyIGJpZ251bWJlcl8yID0gYmlnbnVtYmVyLkJpZ051bWJlcjtcblxuXHR2YXIgZml4ZWRudW1iZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ0LnZlcnNpb24pO1xuXG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgWmVybyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSgwKTtcblx0dmFyIE5lZ2F0aXZlT25lID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKC0xKTtcblx0ZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuXHQgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBsaWIuTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xuXHR9XG5cdC8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcblx0dmFyIHplcm9zID0gXCIwXCI7XG5cdHdoaWxlICh6ZXJvcy5sZW5ndGggPCAyNTYpIHtcblx0ICAgIHplcm9zICs9IHplcm9zO1xuXHR9XG5cdC8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcblx0ZnVuY3Rpb24gZ2V0TXVsdGlwbGllcihkZWNpbWFscykge1xuXHQgICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZGVjaW1hbHMpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSA9PT0gXCJudW1iZXJcIiAmJiBkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDw9IDI1NiAmJiAhKGRlY2ltYWxzICUgMSkpIHtcblx0ICAgICAgICByZXR1cm4gKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuXHR9XG5cdGZ1bmN0aW9uIGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuXHQgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcblx0ICAgICAgICBkZWNpbWFscyA9IDA7XG5cdCAgICB9XG5cdCAgICB2YXIgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuXHQgICAgLy8gTWFrZSBzdXJlIHdlaSBpcyBhIGJpZyBudW1iZXIgKGNvbnZlcnQgYXMgbmVjZXNzYXJ5KVxuXHQgICAgdmFsdWUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gdmFsdWUubHQoWmVybyk7XG5cdCAgICBpZiAobmVnYXRpdmUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLm11bChOZWdhdGl2ZU9uZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZnJhY3Rpb24gPSB2YWx1ZS5tb2QobXVsdGlwbGllcikudG9TdHJpbmcoKTtcblx0ICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBmcmFjdGlvbiA9IFwiMFwiICsgZnJhY3Rpb247XG5cdCAgICB9XG5cdCAgICAvLyBTdHJpcCB0cmFpbmluZyAwXG5cdCAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdO1xuXHQgICAgdmFyIHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG5cdCAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLmZvcm1hdEZpeGVkID0gZm9ybWF0Rml4ZWQ7XG5cdGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG5cdCAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eLT9bMC05LixdKyQvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAobXVsdGlwbGllci5sZW5ndGggLSAxID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cblx0ICAgIHZhciBuZWdhdGl2ZSA9ICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlID09PSBcIi5cIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgLy8gU3BsaXQgaXQgaW50byBhIHdob2xlIGFuZCBmcmFjdGlvbmFsIHBhcnRcblx0ICAgIHZhciBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgdmFyIHdob2xlID0gY29tcHNbMF0sIGZyYWN0aW9uID0gY29tcHNbMV07XG5cdCAgICBpZiAoIXdob2xlKSB7XG5cdCAgICAgICAgd2hvbGUgPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIGlmICghZnJhY3Rpb24pIHtcblx0ICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgLy8gUHJldmVudCB1bmRlcmZsb3dcblx0ICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICB0aHJvd0ZhdWx0KFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLCBcInVuZGVyZmxvd1wiLCBcInBhcnNlRml4ZWRcIik7XG5cdCAgICB9XG5cdCAgICAvLyBGdWxseSBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9zIHRvIGdldCB0byB3ZWlcblx0ICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIHZhciB3aG9sZVZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHdob2xlKTtcblx0ICAgIHZhciBmcmFjdGlvblZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcblx0ICAgIHZhciB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdlaTtcblx0fVxuXHRleHBvcnRzLnBhcnNlRml4ZWQgPSBwYXJzZUZpeGVkO1xuXHR2YXIgRml4ZWRGb3JtYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGaXhlZEZvcm1hdChjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuXHQgICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuXHQgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblx0ICAgICAgICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcblx0ICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgRml4ZWRGb3JtYXQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpeGVkRm9ybWF0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNpZ25lZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHdpZHRoID0gMTI4O1xuXHQgICAgICAgIHZhciBkZWNpbWFscyA9IDE4O1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG5cdCAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcblx0ICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uIChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZVtrZXldKSAhPT0gdHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2YWx1ZVtrZXldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcblx0ICAgICAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzID4gODApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChkZWNpbWFscyB0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGaXhlZEZvcm1hdDtcblx0fSgpKTtcblx0ZXhwb3J0cy5GaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0O1xuXHR2YXIgRml4ZWROdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGaXhlZE51bWJlcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZpeGVkTnVtYmVyKTtcblx0ICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0ICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLl9pc0ZpeGVkTnVtYmVyID0gdHJ1ZTtcblx0ICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLl9jaGVja0Zvcm1hdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIGlmICh0aGlzLmZvcm1hdC5uYW1lICE9PSBvdGhlci5mb3JtYXQubmFtZSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuYWRkVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLmFkZChiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuc3ViVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLnN1YihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUubXVsVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5kaXZVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG5cdCAgICAgICAgdmFyIGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKS5kaXYoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86IFN1cHBvcnQgb3RoZXIgcm91bmRpbmcgYWxnb3JpdGhtc1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKGRlY2ltYWxzKSB7XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGVjaW1hbHMgPCAwIHx8IGRlY2ltYWxzID4gODAgfHwgKGRlY2ltYWxzICUgMSkpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBjb3VudFwiLCBcImRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gcmFuZ2UsIHdlJ3JlIGRvbmVcblx0ICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuXHQgICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEJ1bXAgdGhlIHZhbHVlIHVwIGJ5IHRoZSAwLjAwLi4uMDAwNVxuXHQgICAgICAgIHZhciBidW1wID0gXCIwLlwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSArIFwiNVwiO1xuXHQgICAgICAgIGNvbXBzID0gdGhpcy5hZGRVbnNhZmUoRml4ZWROdW1iZXIuZnJvbVN0cmluZyhidW1wLCB0aGlzLmZvcm1hdCkpLl92YWx1ZS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgLy8gTm93IGl0IGlzIHNhZmUgdG8gdHJ1bmNhdGVcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhjb21wc1swXSArIFwiLlwiICsgY29tcHNbMV0uc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgpIHtcblx0ICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAod2lkdGggJSA4KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGUgd2lkdGhcIiwgXCJ3aWR0aFwiLCB3aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBoZXggPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odGhpcy5faGV4KS5mcm9tVHdvcyh0aGlzLmZvcm1hdC53aWR0aCkudG9Ud29zKHdpZHRoKS50b0hleFN0cmluZygpO1xuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhaZXJvUGFkKGhleCwgd2lkdGggLyA4KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9VbnNhZmVGbG9hdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSwgZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxzLCBmb3JtYXQpIHtcblx0ICAgICAgICAvLyBJZiBkZWNpbWFscyBsb29rcyBtb3JlIGxpa2UgYSBmb3JtYXQsIGFuZCB0aGVyZSBpcyBubyBmb3JtYXQsIHNoaWZ0IHRoZSBwYXJhbWV0ZXJzXG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsICYmIGRlY2ltYWxzICE9IG51bGwgJiYgIWJpZ251bWJlci5pc0JpZ051bWJlcmlzaChkZWNpbWFscykpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZGVjaW1hbHM7XG5cdCAgICAgICAgICAgIGRlY2ltYWxzID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpLCBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCkpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IHBhcnNlRml4ZWQodmFsdWUsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICBpZiAoIWZpeGVkRm9ybWF0LnNpZ25lZCAmJiBudW1lcmljLmx0KFplcm8pKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIiwgXCJvdmVyZmxvd1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGhleCA9IG51bGw7XG5cdCAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuXHQgICAgICAgICAgICBoZXggPSBudW1lcmljLnRvVHdvcyhmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICAgICAgaGV4ID0gbGliJDEuaGV4WmVyb1BhZChoZXgsIGZpeGVkRm9ybWF0LndpZHRoIC8gOCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmZyb21CeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuXHQgICAgICAgIGlmIChsaWIkMS5hcnJheWlmeSh2YWx1ZSkubGVuZ3RoID4gZml4ZWRGb3JtYXQud2lkdGggLyA4KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuXHQgICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBoZXggPSBudW1lcmljLnRvVHdvcygoZml4ZWRGb3JtYXQuc2lnbmVkID8gMCA6IDEpICsgZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgdmFyIGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGliJDEuaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgMCwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIC8vIEFsbG93IE5VTUVSSUNfRkFVTFQgdG8gYnViYmxlIHVwXG5cdCAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5UKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRml4ZWROdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuaXNGaXhlZE51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNGaXhlZE51bWJlcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZpeGVkTnVtYmVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gRml4ZWROdW1iZXI7XG5cdH0pO1xuXG5cdHZhciBmaXhlZG51bWJlciQxID0gdW53cmFwRXhwb3J0cyhmaXhlZG51bWJlcik7XG5cdHZhciBmaXhlZG51bWJlcl8xID0gZml4ZWRudW1iZXIuZm9ybWF0Rml4ZWQ7XG5cdHZhciBmaXhlZG51bWJlcl8yID0gZml4ZWRudW1iZXIucGFyc2VGaXhlZDtcblx0dmFyIGZpeGVkbnVtYmVyXzMgPSBmaXhlZG51bWJlci5GaXhlZEZvcm1hdDtcblx0dmFyIGZpeGVkbnVtYmVyXzQgPSBmaXhlZG51bWJlci5GaXhlZE51bWJlcjtcblxuXHR2YXIgbGliJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5CaWdOdW1iZXIgPSBiaWdudW1iZXIuQmlnTnVtYmVyO1xuXG5cdGV4cG9ydHMuZm9ybWF0Rml4ZWQgPSBmaXhlZG51bWJlci5mb3JtYXRGaXhlZDtcblx0ZXhwb3J0cy5GaXhlZEZvcm1hdCA9IGZpeGVkbnVtYmVyLkZpeGVkRm9ybWF0O1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gZml4ZWRudW1iZXIuRml4ZWROdW1iZXI7XG5cdGV4cG9ydHMucGFyc2VGaXhlZCA9IGZpeGVkbnVtYmVyLnBhcnNlRml4ZWQ7XG5cdH0pO1xuXG5cdHZhciBpbmRleCQyID0gdW53cmFwRXhwb3J0cyhsaWIkMik7XG5cdHZhciBsaWJfMSQyID0gbGliJDIuQmlnTnVtYmVyO1xuXHR2YXIgbGliXzIkMiA9IGxpYiQyLmZvcm1hdEZpeGVkO1xuXHR2YXIgbGliXzMkMiA9IGxpYiQyLkZpeGVkRm9ybWF0O1xuXHR2YXIgbGliXzQkMSA9IGxpYiQyLkZpeGVkTnVtYmVyO1xuXHR2YXIgbGliXzUkMSA9IGxpYiQyLnBhcnNlRml4ZWQ7XG5cblx0dmFyIF92ZXJzaW9uJDYgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwicHJvcGVydGllcy81LjAuMC1iZXRhLjE0M1wiO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kNyA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kNik7XG5cdHZhciBfdmVyc2lvbl8xJDMgPSBfdmVyc2lvbiQ2LnZlcnNpb247XG5cblx0dmFyIGxpYiQzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kNi52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZGVmaW5lUmVhZE9ubHkgPSBkZWZpbmVSZWFkT25seTtcblx0Ly8gQ3Jhd2wgdXAgdGhlIGNvbnN0cnVjdG9yIGNoYWluIHRvIGZpbmQgYSBzdGF0aWMgbWV0aG9kXG5cdGZ1bmN0aW9uIGdldFN0YXRpYyhjdG9yLCBrZXkpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuXHQgICAgICAgIGlmIChjdG9yW2tleV0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGN0b3Jba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFjdG9yLnByb3RvdHlwZSB8fCB0eXBlb2YgKGN0b3IucHJvdG90eXBlKSAhPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHRleHBvcnRzLmdldFN0YXRpYyA9IGdldFN0YXRpYztcblx0ZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXMob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHByb21pc2VzLCByZXN1bHRzO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbHVlOiB2IH0pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwcm9taXNlcyldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gcmVzb2x2ZVByb3BlcnRpZXM7XG5cdGZ1bmN0aW9uIGNoZWNrUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcblx0ICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiAob2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdFwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICBpZiAoIXByb3BlcnRpZXNba2V5XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3Qga2V5IC0gXCIgKyBrZXksIFwidHJhbnNhY3Rpb246XCIgKyBrZXksIG9iamVjdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5jaGVja1Byb3BlcnRpZXMgPSBjaGVja1Byb3BlcnRpZXM7XG5cdGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iamVjdCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuc2hhbGxvd0NvcHkgPSBzaGFsbG93Q29weTtcblx0dmFyIG9wYXF1ZSA9IHsgYmlnaW50OiB0cnVlLCBib29sZWFuOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIG51bWJlcjogdHJ1ZSwgc3RyaW5nOiB0cnVlIH07XG5cdGZ1bmN0aW9uIF9pc0Zyb3plbihvYmplY3QpIHtcblx0ICAgIC8vIE9wYXF1ZSBvYmplY3RzIGFyZSBub3QgbXV0YWJsZSwgc28gc2FmZSB0byBjb3B5IGJ5IGFzc2lnbm1lbnRcblx0ICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwgfHwgb3BhcXVlW3R5cGVvZiAob2JqZWN0KV0pIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgdHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgaWYgKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4ob2JqZWN0W2tleXNbaV1dKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIgKyB0eXBlb2YgKG9iamVjdCksIFwib2JqZWN0XCIsIG9iamVjdCk7XG5cdH1cblx0Ly8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuXHQvLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuXHRmdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG5cdCAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcblx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfVxuXHQgICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBkZWVwQ29weShpdGVtKTsgfSkpO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIkNhbm5vdCBkZWVwQ29weSBcIiArIHR5cGVvZiAob2JqZWN0KSwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0fVxuXHRmdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcblx0ICAgIHJldHVybiBfZGVlcENvcHkob2JqZWN0KTtcblx0fVxuXHRleHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG5cdHZhciBEZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uKGluZm8pIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5mbykge1xuXHQgICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ29weShpbmZvW2tleV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBEZXNjcmlwdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5EZXNjcmlwdGlvbiA9IERlc2NyaXB0aW9uO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkMyA9IHVud3JhcEV4cG9ydHMobGliJDMpO1xuXHR2YXIgbGliXzEkMyA9IGxpYiQzLmRlZmluZVJlYWRPbmx5O1xuXHR2YXIgbGliXzIkMyA9IGxpYiQzLmdldFN0YXRpYztcblx0dmFyIGxpYl8zJDMgPSBsaWIkMy5yZXNvbHZlUHJvcGVydGllcztcblx0dmFyIGxpYl80JDIgPSBsaWIkMy5jaGVja1Byb3BlcnRpZXM7XG5cdHZhciBsaWJfNSQyID0gbGliJDMuc2hhbGxvd0NvcHk7XG5cdHZhciBsaWJfNiQxID0gbGliJDMuZGVlcENvcHk7XG5cdHZhciBsaWJfNyQxID0gbGliJDMuRGVzY3JpcHRpb247XG5cblx0dmFyIF92ZXJzaW9uJDggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJpLzUuMC4wLWJldGEuMTU2XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQ5ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiQ4KTtcblx0dmFyIF92ZXJzaW9uXzEkNCA9IF92ZXJzaW9uJDgudmVyc2lvbjtcblxuXHR2YXIgZnJhZ21lbnRzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXHQ7XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgTW9kaWZpZXJzQnl0ZXMgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUsIHN0b3JhZ2U6IHRydWUgfTtcblx0dmFyIE1vZGlmaWVyc05lc3QgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUgfTtcblx0ZnVuY3Rpb24gY2hlY2tNb2RpZmllcih0eXBlLCBuYW1lKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gXCJieXRlc1wiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcblx0ICAgICAgICBpZiAobmFtZSA9PT0gXCJwYXlhYmxlXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKFwiW1wiKSA+PSAwIHx8IHR5cGUgPT09IFwidHVwbGVcIikge1xuXHQgICAgICAgIGlmIChNb2RpZmllcnNOZXN0W25hbWVdKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSB8fCBuYW1lID09PSBcInBheWFibGVcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBAVE9ETzogTWFrZSBzdXJlIHRoYXQgY2hpbGRyZW4gb2YgYW4gaW5kZXhlZCB0dXBsZSBhcmUgbWFya2VkIHdpdGggYSBudWxsIGluZGV4ZWRcblx0ZnVuY3Rpb24gcGFyc2VQYXJhbVR5cGUocGFyYW0sIGFsbG93SW5kZXhlZCkge1xuXHQgICAgdmFyIG9yaWdpbmFsUGFyYW0gPSBwYXJhbTtcblx0ICAgIGZ1bmN0aW9uIHRocm93RXJyb3IoaSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBcIiArIGksIFwicGFyYW1cIiwgcGFyYW0pO1xuXHQgICAgfVxuXHQgICAgcGFyYW0gPSBwYXJhbS5yZXBsYWNlKC9cXHMvZywgXCIgXCIpO1xuXHQgICAgZnVuY3Rpb24gbmV3Tm9kZShwYXJlbnQpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBwYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG5cdCAgICAgICAgaWYgKGFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICB9XG5cdCAgICB2YXIgcGFyZW50ID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuXHQgICAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBwYXJhbVtpXTtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICAgICAgY2FzZSBcIihcIjpcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSAmJiBub2RlLnR5cGUgPT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSBcInR1cGxlXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93VHlwZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5jb21wb25lbnRzID0gW25ld05vZGUobm9kZSldO1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY29tcG9uZW50c1swXTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiKVwiOlxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGU7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlO1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCIsXCI6XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gbmV3Tm9kZShub2RlLnBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICAvL3sgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBub2RlLnBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmNvbXBvbmVudHMucHVzaChzaWJsaW5nKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIC8vIEhpdCBhIHNwYWNlLi4uXG5cdCAgICAgICAgICAgIGNhc2UgXCIgXCI6XG5cdCAgICAgICAgICAgICAgICAvLyBJZiByZWFkaW5nIHR5cGUsIHRoZSB0eXBlIGlzIGRvbmUgYW5kIG1heSByZWFkIGEgcGFyYW0gb3IgbmFtZVxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93VHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBJZiByZWFkaW5nIG5hbWUsIHRoZSBuYW1lIGlzIGRvbmVcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJbXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUuYWxsb3dBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUucmVhZEFycmF5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiXVwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUucmVhZEFycmF5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5hbGxvd05hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgKz0gYztcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZS5hbGxvd0FycmF5O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKG5vZGUucGFyZW50KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgZW9mXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHBhcmVudC5zdGF0ZTtcblx0ICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG5cdCAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobm9kZS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgIHRocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGggLSA3KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcblx0ICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgcGFyZW50LnR5cGUgPSB2ZXJpZnlUeXBlKHBhcmVudC50eXBlKTtcblx0ICAgIHJldHVybiBwYXJlbnQ7XG5cdH1cblx0ZnVuY3Rpb24gcG9wdWxhdGUob2JqZWN0LCBwYXJhbXMpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShvYmplY3QsIGtleSwgcGFyYW1zW2tleV0pO1xuXHQgICAgfVxuXHR9XG5cdGV4cG9ydHMuRm9ybWF0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcblx0ICAgIC8vIEJhcmUgZm9ybWF0dGluZywgYXMgaXMgbmVlZGVkIGZvciBjb21wdXRpbmcgYSBzaWdoYXNoIG9mIGFuIGV2ZW50IG9yIGZ1bmN0aW9uXG5cdCAgICBzaWdoYXNoOiBcInNpZ2hhc2hcIixcblx0ICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggTWluaW1hbCBzcGFjaW5nIGFuZCB3aXRob3V0IG5hbWVzIChjb21wYWN0IGh1bWFuLXJlYWRhYmxlKVxuXHQgICAgbWluaW1hbDogXCJtaW5pbWFsXCIsXG5cdCAgICAvLyBIdW1hbi1SZWFkYmxlIHdpdGggbmljZSBzcGFjaW5nLCBpbmNsdWRpbmcgYWxsIG5hbWVzXG5cdCAgICBmdWxsOiBcImZ1bGxcIixcblx0ICAgIC8vIEpTT04tZm9ybWF0IGEgbGEgU29saWRpdHlcblx0ICAgIGpzb246IFwianNvblwiXG5cdH0pO1xuXHR2YXIgcGFyYW1UeXBlQXJyYXkgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuXHR2YXIgUGFyYW1UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUGFyYW1UeXBlKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBmcm9tU3RyaW5nXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBQYXJhbVR5cGUoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgICAgIHZhciBtYXRjaCA9IHRoaXMudHlwZS5tYXRjaChwYXJhbVR5cGVBcnJheSk7XG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHBvcHVsYXRlKHRoaXMsIHtcblx0ICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBwYXJzZUludChtYXRjaFsyXSB8fCBcIi0xXCIpLFxuXHQgICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbjogUGFyYW1UeXBlLmZyb21PYmplY3Qoe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzFdLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMuY29tcG9uZW50c1xuXHQgICAgICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgICAgICBiYXNlVHlwZTogXCJhcnJheVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuXHQgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgYmFzZVR5cGU6ICgodGhpcy5jb21wb25lbnRzICE9IG51bGwpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5faXNQYXJhbVR5cGUgPSB0cnVlO1xuXHQgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICAvLyBGb3JtYXQgdGhlIHBhcmFtZXRlciBmcmFnbWVudFxuXHQgICAgLy8gICAtIHNpZ2hhc2g6IFwiKHVpbnQyNTYsYWRkcmVzcylcIlxuXHQgICAgLy8gICAtIG1pbmltYWw6IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJcblx0ICAgIC8vICAgLSBmdWxsOiAgICBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXMgYmFyKSBpbmRleGVkIGJhelwiXG5cdCAgICBQYXJhbVR5cGUucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghZXhwb3J0cy5Gb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuanNvbikge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogKHRoaXMubmFtZSB8fCB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHRfMS5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdF8xLmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiBKU09OLnBhcnNlKGNvbXAuZm9ybWF0KGZvcm1hdCkpOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0XzEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblx0ICAgICAgICAvLyBBcnJheVxuXHQgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgKHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSkgKyBcIl1cIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiBjb21wLmZvcm1hdChmb3JtYXQpOyB9KS5qb2luKChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsICYmIHRoaXMubmFtZSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21TdHJpbmcodmFsdWUsIGFsbG93SW5kZXhlZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkLCB7XG5cdCAgICAgICAgICAgIG5hbWU6ICh2YWx1ZS5uYW1lIHx8IG51bGwpLFxuXHQgICAgICAgICAgICB0eXBlOiB2ZXJpZnlUeXBlKHZhbHVlLnR5cGUpLFxuXHQgICAgICAgICAgICBpbmRleGVkOiAoKHZhbHVlLmluZGV4ZWQgPT0gbnVsbCkgPyBudWxsIDogISF2YWx1ZS5pbmRleGVkKSxcblx0ICAgICAgICAgICAgY29tcG9uZW50czogKHZhbHVlLmNvbXBvbmVudHMgPyB2YWx1ZS5jb21wb25lbnRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBudWxsKVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtVHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICBmdW5jdGlvbiBQYXJhbVR5cGlmeShub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG5cdCAgICAgICAgICAgICAgICBpbmRleGVkOiBub2RlLmluZGV4ZWQsXG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBub2RlLmNvbXBvbmVudHNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwgISFhbGxvd0luZGV4ZWQpKTtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuaXNQYXJhbVR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5faXNQYXJhbVR5cGUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQYXJhbVR5cGU7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUGFyYW1UeXBlID0gUGFyYW1UeXBlO1xuXHQ7XG5cdGZ1bmN0aW9uIHBhcnNlUGFyYW1zKHZhbHVlLCBhbGxvd0luZGV4KSB7XG5cdCAgICByZXR1cm4gc3BsaXROZXN0aW5nKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSwgYWxsb3dJbmRleCk7IH0pO1xuXHR9XG5cdHZhciBGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZyYWdtZW50KGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRnJhZ21lbnQoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuXHQgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICBGcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG5cdCAgICAgICAgICAgICAgICAvLyBAVE9ETzogU29tZXRoaW5nPyBNYXliZSByZXR1cm4gYSBGdW5jdGlvbkZyYWdtZW50PyBBIGN1c3RvbSBEZWZhdWx0RnVuY3Rpb25GcmFnbWVudD9cblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnJhZ21lbnQgb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIFwicmV0dXJuc1wiIGlzIHN1cnJvdW5kZWQgYnkgYSBzcGFjZSBhbmQgYWxsIHdoaXRlc3BhY2UgaXMgZXhhY3RseSBvbmUgc3BhY2Vcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXCgvZywgXCIgKFwiKS5yZXBsYWNlKC9cXCkvZywgXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcblx0ICAgICAgICBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImV2ZW50XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBmcmFnbWVudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGcmFnbWVudC5pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRnJhZ21lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0dmFyIEV2ZW50RnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRXZlbnRGcmFnbWVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEV2ZW50RnJhZ21lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgRXZlbnRGcmFnbWVudC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG5cdCAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXHQgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKTsgfSlcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJldmVudCBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJhbm9ueW1vdXMgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG5cdCAgICB9O1xuXHQgICAgRXZlbnRGcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0V2ZW50RnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG5cdCAgICAgICAgICAgIGFub255bW91czogdmFsdWUuYW5vbnltb3VzLFxuXHQgICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcblx0ICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFtYXRjaCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhbm9ueW1vdXMgPSBmYWxzZTtcblx0ICAgICAgICBtYXRjaFszXS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChtb2RpZmllci50cmltKCkpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIjpcblx0ICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgIG5hbWU6IG1hdGNoWzFdLnRyaW0oKSxcblx0ICAgICAgICAgICAgYW5vbnltb3VzOiBhbm9ueW1vdXMsXG5cdCAgICAgICAgICAgIGlucHV0czogcGFyc2VQYXJhbXMobWF0Y2hbMl0sIHRydWUpLFxuXHQgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJldmVudFwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRXZlbnRGcmFnbWVudDtcblx0fShGcmFnbWVudCkpO1xuXHRleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBFdmVudEZyYWdtZW50O1xuXHRmdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICBwYXJhbXMuZ2FzID0gbnVsbDtcblx0ICAgIHZhciBjb21wcyA9IHZhbHVlLnNwbGl0KFwiQFwiKTtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggIT09IDEpIHtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmUgZ2FzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuZ2FzID0gbGliJDIuQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pO1xuXHQgICAgICAgIHJldHVybiBjb21wc1swXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRmdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICBwYXJhbXMuY29uc3RhbnQgPSBmYWxzZTtcblx0ICAgIHBhcmFtcy5wYXlhYmxlID0gZmFsc2U7XG5cdCAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG5cdCAgICB2YWx1ZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcblx0ICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRcIjpcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInBheWFibGVcIjpcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwibm9ucGF5YWJsZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicHVyZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInB1cmVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwidmlld1wiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuXHQgICAgICAgICAgICBjYXNlIFwiXCI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gdmVyaWZ5U3RhdGUodmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgY29uc3RhbnQ6IGZhbHNlLFxuXHQgICAgICAgIHBheWFibGU6IHRydWUsXG5cdCAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIlxuXHQgICAgfTtcblx0ICAgIGlmICh2YWx1ZS5zdGF0ZU11dGFiaWxpdHkgIT0gbnVsbCkge1xuXHQgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSB2YWx1ZS5zdGF0ZU11dGFiaWxpdHk7XG5cdCAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgY29uc3RhbnQgcHJvcGVydHlcblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmICgoISF2YWx1ZS5jb25zdGFudCkgIT09IHJlc3VsdC5jb25zdGFudCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNldCAoYW5kIGNoZWNrIHRoaW5ncyBhcmUgY29uc2lzdGVudCkgdGhlIHBheWFibGUgcHJvcGVydHlcblx0ICAgICAgICByZXN1bHQucGF5YWJsZSA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG5cdCAgICAgICAgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAoKCEhdmFsdWUucGF5YWJsZSkgIT09IHJlc3VsdC5wYXlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgcGF5YWJsZSBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gISF2YWx1ZS5wYXlhYmxlO1xuXHQgICAgICAgIC8vIElmIHBheWFibGUgd2UgY2FuIGFzc3VtZSBub24tY29uc3RhbnQ7IG90aGVyd2lzZSB3ZSBjYW4ndCBhc3N1bWVcblx0ICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgPT0gbnVsbCAmJiAhcmVzdWx0LnBheWFibGUgJiYgdmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcblx0ICAgICAgICBpZiAocmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSAocmVzdWx0LnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5wYXlhYmxlICYmIHJlc3VsdC5jb25zdGFudCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgcGF5YWJsZSBmdW5jdGlvblwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcblx0ICAgICAgICByZXN1bHQucGF5YWJsZSA9ICFyZXN1bHQuY29uc3RhbnQ7XG5cdCAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQuY29uc3RhbnQgPyBcInZpZXdcIiA6IFwicGF5YWJsZVwiKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0dmFyIENvbnN0cnVjdG9yRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQ29uc3RydWN0b3JGcmFnbWVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yRnJhZ21lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG5cdCAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcblx0ICAgICAgICAgICAgICAgIHBheWJsZTogdGhpcy5wYXlhYmxlLFxuXHQgICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcblx0ICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSk7IH0pXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcImNvbnN0cnVjdG9yKFwiICsgdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcblx0ICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgJiYgdGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcblx0ICAgIH07XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzQ29uc3RydWN0b3JGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuXHQgICAgICAgIGlmIChzdGF0ZS5jb25zdGFudCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY29uc3RydWN0b3IgY2Fubm90IGJlIGNvbnN0YW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICBuYW1lOiBudWxsLFxuXHQgICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuXHQgICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcblx0ICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcblx0ICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG5cdCAgICAgICAgICAgIGdhczogKHZhbHVlLmdhcyA/IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlLmdhcykgOiBudWxsKVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7IHR5cGU6IFwiY29uc3RydWN0b3JcIiB9O1xuXHQgICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIHBhcmVucyA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuXHQgICAgICAgIGlmICghcGFyZW5zIHx8IHBhcmVuc1sxXS50cmltKCkgIT09IFwiY29uc3RydWN0b3JcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0udHJpbSgpLCBmYWxzZSk7XG5cdCAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcblx0ICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5pc0NvbnN0cnVjdG9yRnJhZ21lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiY29uc3RydWN0b3JcIik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQ7XG5cdH0oRnJhZ21lbnQpKTtcblx0ZXhwb3J0cy5Db25zdHJ1Y3RvckZyYWdtZW50ID0gQ29uc3RydWN0b3JGcmFnbWVudDtcblx0dmFyIEZ1bmN0aW9uRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRnVuY3Rpb25GcmFnbWVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRnJhZ21lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cdCAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcblx0ICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgcGF5YmxlOiB0aGlzLnBheWFibGUsXG5cdCAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKTsgfSksXG5cdCAgICAgICAgICAgICAgICBvdXB1dHM6IHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gSlNPTi5wYXJzZShvdXRwdXQuZm9ybWF0KGZvcm1hdCkpOyB9KSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJmdW5jdGlvbiBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ2aWV3IFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwicmV0dXJucyAoXCIgKyB0aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uIChvdXRwdXQpIHsgcmV0dXJuIG91dHB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbihcIiwgXCIpICsgXCIpIFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJAXCIgKyB0aGlzLmdhcy50b1N0cmluZygpICsgXCIgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcblx0ICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuXHQgICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuXHQgICAgICAgICAgICBjb25zdGFudDogc3RhdGUuY29uc3RhbnQsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBvdXRwdXRzOiAodmFsdWUub3V0cHV0cyA/IHZhbHVlLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcblx0ICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcblx0ICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG5cdCAgICAgICAgICAgIGdhczogKHZhbHVlLmdhcyA/IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlLmdhcykgOiBudWxsKVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7IHR5cGU6IFwiZnVuY3Rpb25cIiB9O1xuXHQgICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCIgcmV0dXJucyBcIik7XG5cdCAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFyZW5zID0gY29tcHNbMF0ubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFwYXJlbnMpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG5cdCAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG5cdCAgICAgICAgICAgIHZlcmlmeUlkZW50aWZpZXIocGFyYW1zLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG5cdCAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcblx0ICAgICAgICAvLyBXZSBoYXZlIG91dHB1dHNcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0dXJucyA9IGNvbXBzWzFdLm1hdGNoKHJlZ2V4UGFyZW4pO1xuXHQgICAgICAgICAgICBpZiAocmV0dXJuc1sxXS50cmltKCkgIT0gXCJcIiB8fCByZXR1cm5zWzNdLnRyaW0oKSAhPSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCB0b2tlbnNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBwYXJzZVBhcmFtcyhyZXR1cm5zWzJdLCBmYWxzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQ7XG5cdH0oQ29uc3RydWN0b3JGcmFnbWVudCkpO1xuXHRleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBGdW5jdGlvbkZyYWdtZW50O1xuXHQvL2V4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuXHQvL31cblx0Ly9leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG5cdC8vfVxuXHRmdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpIHtcblx0ICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdG8gdGhlaXIgZnVsbCBkZXNjcmlwdGlvblxuXHQgICAgaWYgKHR5cGUubWF0Y2goL151aW50KCR8W14xLTldKS8pKSB7XG5cdCAgICAgICAgdHlwZSA9IFwidWludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoNCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlLm1hdGNoKC9eaW50KCR8W14xLTldKS8pKSB7XG5cdCAgICAgICAgdHlwZSA9IFwiaW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZygzKTtcblx0ICAgIH1cblx0ICAgIC8vIEBUT0RPOiBtb3JlIHZlcmlmaWNhdGlvblxuXHQgICAgcmV0dXJuIHR5cGU7XG5cdH1cblx0dmFyIHJlZ2V4SWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeW0EtWmEtel9dW0EtWmEtejAtOV9dKiRcIik7XG5cdGZ1bmN0aW9uIHZlcmlmeUlkZW50aWZpZXIodmFsdWUpIHtcblx0ICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLm1hdGNoKHJlZ2V4SWRlbnRpZmllcikpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBpZGVudGlmaWVyIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciByZWdleFBhcmVuID0gbmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpO1xuXHRmdW5jdGlvbiBzcGxpdE5lc3RpbmcodmFsdWUpIHtcblx0ICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgdmFyIGFjY3VtID0gXCJcIjtcblx0ICAgIHZhciBkZXB0aCA9IDA7XG5cdCAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCB2YWx1ZS5sZW5ndGg7IG9mZnNldCsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSB2YWx1ZVtvZmZzZXRdO1xuXHQgICAgICAgIGlmIChjID09PSBcIixcIiAmJiBkZXB0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG5cdCAgICAgICAgICAgIGFjY3VtID0gXCJcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGFjY3VtICs9IGM7XG5cdCAgICAgICAgICAgIGlmIChjID09PSBcIihcIikge1xuXHQgICAgICAgICAgICAgICAgZGVwdGgrKztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIilcIikge1xuXHQgICAgICAgICAgICAgICAgZGVwdGgtLTtcblx0ICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5iYWxhbmNlZCBwYXJlbnRoZXNpc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChhY2N1bSkge1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0fSk7XG5cblx0dmFyIGZyYWdtZW50cyQxID0gdW53cmFwRXhwb3J0cyhmcmFnbWVudHMpO1xuXHR2YXIgZnJhZ21lbnRzXzEgPSBmcmFnbWVudHMuRm9ybWF0VHlwZXM7XG5cdHZhciBmcmFnbWVudHNfMiA9IGZyYWdtZW50cy5QYXJhbVR5cGU7XG5cdHZhciBmcmFnbWVudHNfMyA9IGZyYWdtZW50cy5GcmFnbWVudDtcblx0dmFyIGZyYWdtZW50c180ID0gZnJhZ21lbnRzLkV2ZW50RnJhZ21lbnQ7XG5cdHZhciBmcmFnbWVudHNfNSA9IGZyYWdtZW50cy5Db25zdHJ1Y3RvckZyYWdtZW50O1xuXHR2YXIgZnJhZ21lbnRzXzYgPSBmcmFnbWVudHMuRnVuY3Rpb25GcmFnbWVudDtcblxuXHR2YXIgYWJzdHJhY3RDb2RlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXHRmdW5jdGlvbiBjaGVja1Jlc3VsdEVycm9ycyhyZXN1bHQpIHtcblx0ICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG5cdCAgICB2YXIgZXJyb3JzID0gW107XG5cdCAgICB2YXIgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIGNoaWxkUGF0aC5wdXNoKGtleSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgY2hlY2tFcnJvcnMoW10sIHJlc3VsdCk7XG5cdCAgICByZXR1cm4gZXJyb3JzO1xuXHR9XG5cdGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSBjaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIENvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ29kZXIobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG5cdCAgICAgICAgLy8gQFRPRE86IGRlZmluZVJlYWRPbmx5IHRoZXNlXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxOYW1lO1xuXHQgICAgICAgIHRoaXMuZHluYW1pYyA9IGR5bmFtaWM7XG5cdCAgICB9XG5cdCAgICBDb2Rlci5wcm90b3R5cGUuX3Rocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdmFsdWUpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENvZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkNvZGVyID0gQ29kZXI7XG5cdHZhciBXcml0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBXcml0ZXIod29yZFNpemUpIHtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcblx0ICAgICAgICB0aGlzLl9kYXRhID0gbGliJDEuYXJyYXlpZnkoW10pO1xuXHQgICAgICAgIHRoaXMuX3BhZGRpbmcgPSBuZXcgVWludDhBcnJheSh3b3JkU2l6ZSk7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQxLmhleGxpZnkodGhpcy5fZGF0YSk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEubGVuZ3RoOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFdyaXRlci5wcm90b3R5cGUuX3dyaXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5fZGF0YSA9IGxpYiQxLmNvbmNhdChbdGhpcy5fZGF0YSwgZGF0YV0pO1xuXHQgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcblx0ICAgIH07XG5cdCAgICAvLyBBcnJheWlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSByaWdodCB0byB3b3JkU2l6ZVxuXHQgICAgV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ5dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIGlmIChieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzID0gbGliJDEuY29uY2F0KFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGJ5dGVzKTtcblx0ICAgIH07XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKSk7XG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMud29yZFNpemUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG5cdCAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMud29yZFNpemUsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ5dGVzLmxlbmd0aFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpIHtcblx0ICAgICAgICAgICAgYnl0ZXMgPSBsaWIkMS5jb25jYXQoW3RoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSksIGJ5dGVzXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBieXRlcztcblx0ICAgIH07XG5cdCAgICAvLyBCaWdOdW1iZXJpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgbGVmdCB0byB3b3JkU2l6ZVxuXHQgICAgV3JpdGVyLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVVcGRhdGFibGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICB0aGlzLndyaXRlVmFsdWUoMCk7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBfdGhpcy5fZGF0YS5zZXQoX3RoaXMuX2dldFZhbHVlKHZhbHVlKSwgb2Zmc2V0KTtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBXcml0ZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuV3JpdGVyID0gV3JpdGVyO1xuXHR2YXIgUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVhZGVyKGRhdGEsIHdvcmRTaXplLCBjb2VyY2VGdW5jKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZGF0YVwiLCBsaWIkMS5hcnJheWlmeShkYXRhKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfY29lcmNlRnVuY1wiLCBjb2VyY2VGdW5jKTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHRoaXMuX2RhdGEpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCBcImNvbnN1bWVkXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29mZnNldDsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvLyBUaGUgZGVmYXVsdCBDb2VyY2UgZnVuY3Rpb25cblx0ICAgIFJlYWRlci5jb2VyY2UgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO1xuXHQgICAgICAgIGlmIChtYXRjaCAmJiBwYXJzZUludChtYXRjaFsxXSkgPD0gNDgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b051bWJlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5jb2VyY2UgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fY29lcmNlRnVuYykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29lcmNlRnVuYyhuYW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBSZWFkZXIuY29lcmNlKG5hbWUsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLl9wZWVrQnl0ZXMgPSBmdW5jdGlvbiAob2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLndvcmRTaXplKSAqIHRoaXMud29yZFNpemU7XG5cdCAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuXHQgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLl9kYXRhLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnN1YlJlYWRlciA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFJlYWRlcih0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCArIG9mZnNldCksIHRoaXMud29yZFNpemUsIHRoaXMuX2NvZXJjZUZ1bmMpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IHRoaXMuX3BlZWtCeXRlcygwLCBsZW5ndGgpO1xuXHQgICAgICAgIHRoaXMuX29mZnNldCArPSBieXRlcy5sZW5ndGg7XG5cdCAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuXHQgICAgICAgIHJldHVybiBieXRlcy5zbGljZSgwLCBsZW5ndGgpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0aGlzLnJlYWRCeXRlcyh0aGlzLndvcmRTaXplKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJlYWRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5SZWFkZXIgPSBSZWFkZXI7XG5cdH0pO1xuXG5cdHZhciBhYnN0cmFjdENvZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFic3RyYWN0Q29kZXIpO1xuXHR2YXIgYWJzdHJhY3RDb2Rlcl8xID0gYWJzdHJhY3RDb2Rlci5jaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIGFic3RyYWN0Q29kZXJfMiA9IGFic3RyYWN0Q29kZXIuQ29kZXI7XG5cdHZhciBhYnN0cmFjdENvZGVyXzMgPSBhYnN0cmFjdENvZGVyLldyaXRlcjtcblx0dmFyIGFic3RyYWN0Q29kZXJfNCA9IGFic3RyYWN0Q29kZXIuUmVhZGVyO1xuXG5cdHZhciBzaGEzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvKipcclxuXHQgKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxyXG5cdCAqXHJcblx0ICogQHZlcnNpb24gMC41LjdcclxuXHQgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxyXG5cdCAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XHJcblx0ICogQGxpY2Vuc2UgTUlUXHJcblx0ICovXHJcblx0Lypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblxyXG5cdCAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHt9O1xyXG5cdCAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG5cdCAgaWYgKE5PREVfSlMpIHtcclxuXHQgICAgcm9vdCA9IGNvbW1vbmpzR2xvYmFsO1xyXG5cdCAgfVxyXG5cdCAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmICdvYmplY3QnID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcclxuXHQgIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xyXG5cdCAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcblx0ICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xyXG5cdCAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xyXG5cdCAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcblx0ICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcclxuXHQgICAgICAgICAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXHJcblx0ICAgICAgICAgICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xyXG5cdCAgdmFyIEJJVFMgPSBbMjI0LCAyNTYsIDM4NCwgNTEyXTtcclxuXHQgIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcclxuXHQgIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknXTtcclxuXHJcblx0ICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XHJcblx0ICAgIH07XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xyXG5cdCAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcclxuXHQgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XHJcblx0ICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cyk7XHJcblx0ICAgIH07XHJcblx0ICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gbWV0aG9kO1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xyXG5cdCAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xyXG5cdCAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcclxuXHQgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcclxuXHQgICAgfTtcclxuXHQgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBtZXRob2Q7XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBhbGdvcml0aG1zID0gW1xyXG5cdCAgICB7bmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZH0sXHJcblx0ICAgIHtuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuXHQgICAge25hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2R9XHJcblx0ICBdO1xyXG5cclxuXHQgIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGdvcml0aG1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG5cdCAgICB2YXIgYml0cyAgPSBhbGdvcml0aG0uYml0cztcclxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XHJcblx0ICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArJ18nICsgYml0c1tqXTtcclxuXHQgICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xyXG5cdCAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBhbGdvcml0aG0uY3JlYXRlTWV0aG9kKGJpdHNbal0sIGFsZ29yaXRobS5wYWRkaW5nKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgIHRoaXMuYmxvY2tzID0gW107XHJcblx0ICAgIHRoaXMucyA9IFtdO1xyXG5cdCAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xyXG5cdCAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xyXG5cdCAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5ibG9jayA9IDA7XHJcblx0ICAgIHRoaXMuc3RhcnQgPSAwO1xyXG5cdCAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xyXG5cdCAgICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xyXG5cdCAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcclxuXHQgICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xyXG5cdCAgICAgIHRoaXMuc1tpXSA9IDA7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZyc7XHJcblx0ICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcclxuXHQgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsXHJcblx0ICAgICAgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xyXG5cclxuXHQgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcblx0ICAgICAgaWYgKHRoaXMucmVzZXQpIHtcclxuXHQgICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XHJcblx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAobm90U3RyaW5nKSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cdCAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcclxuXHQgICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuXHQgICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmKHMpO1xyXG5cdCAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xyXG5cdCAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG5cdCAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xyXG5cdCAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgYmxvY2tzW2ldID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xyXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XHJcblx0ICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgIH1cclxuXHQgICAgZihzKTtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBoZXggPSAnJywgYmxvY2s7XHJcblx0ICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcclxuXHQgICAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xyXG5cdCAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgICBpID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuXHQgICAgICBibG9jayA9IHNbaV07XHJcblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcblx0ICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gaGV4O1xyXG5cdCAgfTtcclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xyXG5cdCAgICB2YXIgYnVmZmVyO1xyXG5cdCAgICBpZiAoZXh0cmFCeXRlcykge1xyXG5cdCAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigob3V0cHV0QmxvY2tzICsgMSkgPDwgMik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG5cdCAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5idWZmZXIgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyO1xyXG5cclxuXHQgIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG5cclxuXHQgICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxyXG5cdCAgICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xyXG5cdCAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhcnJheTtcclxuXHQgIH07XHJcblxyXG5cdCAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xyXG5cdCAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXHJcblx0ICAgICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXHJcblx0ICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXHJcblx0ICAgICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcblx0ICAgIGZvciAobiA9IDA7IG4gPCA0ODsgbiArPSAyKSB7XHJcblx0ICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcblx0ICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XHJcblx0ICAgICAgYzIgPSBzWzJdIF4gc1sxMl0gXiBzWzIyXSBeIHNbMzJdIF4gc1s0Ml07XHJcblx0ICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcblx0ICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XHJcblx0ICAgICAgYzUgPSBzWzVdIF4gc1sxNV0gXiBzWzI1XSBeIHNbMzVdIF4gc1s0NV07XHJcblx0ICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcblx0ICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XHJcblx0ICAgICAgYzggPSBzWzhdIF4gc1sxOF0gXiBzWzI4XSBeIHNbMzhdIF4gc1s0OF07XHJcblx0ICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcblxyXG5cdCAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzBdIF49IGg7XHJcblx0ICAgICAgc1sxXSBePSBsO1xyXG5cdCAgICAgIHNbMTBdIF49IGg7XHJcblx0ICAgICAgc1sxMV0gXj0gbDtcclxuXHQgICAgICBzWzIwXSBePSBoO1xyXG5cdCAgICAgIHNbMjFdIF49IGw7XHJcblx0ICAgICAgc1szMF0gXj0gaDtcclxuXHQgICAgICBzWzMxXSBePSBsO1xyXG5cdCAgICAgIHNbNDBdIF49IGg7XHJcblx0ICAgICAgc1s0MV0gXj0gbDtcclxuXHQgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XHJcblx0ICAgICAgc1syXSBePSBoO1xyXG5cdCAgICAgIHNbM10gXj0gbDtcclxuXHQgICAgICBzWzEyXSBePSBoO1xyXG5cdCAgICAgIHNbMTNdIF49IGw7XHJcblx0ICAgICAgc1syMl0gXj0gaDtcclxuXHQgICAgICBzWzIzXSBePSBsO1xyXG5cdCAgICAgIHNbMzJdIF49IGg7XHJcblx0ICAgICAgc1szM10gXj0gbDtcclxuXHQgICAgICBzWzQyXSBePSBoO1xyXG5cdCAgICAgIHNbNDNdIF49IGw7XHJcblx0ICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuXHQgICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xyXG5cdCAgICAgIHNbNF0gXj0gaDtcclxuXHQgICAgICBzWzVdIF49IGw7XHJcblx0ICAgICAgc1sxNF0gXj0gaDtcclxuXHQgICAgICBzWzE1XSBePSBsO1xyXG5cdCAgICAgIHNbMjRdIF49IGg7XHJcblx0ICAgICAgc1syNV0gXj0gbDtcclxuXHQgICAgICBzWzM0XSBePSBoO1xyXG5cdCAgICAgIHNbMzVdIF49IGw7XHJcblx0ICAgICAgc1s0NF0gXj0gaDtcclxuXHQgICAgICBzWzQ1XSBePSBsO1xyXG5cdCAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzZdIF49IGg7XHJcblx0ICAgICAgc1s3XSBePSBsO1xyXG5cdCAgICAgIHNbMTZdIF49IGg7XHJcblx0ICAgICAgc1sxN10gXj0gbDtcclxuXHQgICAgICBzWzI2XSBePSBoO1xyXG5cdCAgICAgIHNbMjddIF49IGw7XHJcblx0ICAgICAgc1szNl0gXj0gaDtcclxuXHQgICAgICBzWzM3XSBePSBsO1xyXG5cdCAgICAgIHNbNDZdIF49IGg7XHJcblx0ICAgICAgc1s0N10gXj0gbDtcclxuXHQgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XHJcblx0ICAgICAgc1s4XSBePSBoO1xyXG5cdCAgICAgIHNbOV0gXj0gbDtcclxuXHQgICAgICBzWzE4XSBePSBoO1xyXG5cdCAgICAgIHNbMTldIF49IGw7XHJcblx0ICAgICAgc1syOF0gXj0gaDtcclxuXHQgICAgICBzWzI5XSBePSBsO1xyXG5cdCAgICAgIHNbMzhdIF49IGg7XHJcblx0ICAgICAgc1szOV0gXj0gbDtcclxuXHQgICAgICBzWzQ4XSBePSBoO1xyXG5cdCAgICAgIHNbNDldIF49IGw7XHJcblxyXG5cdCAgICAgIGIwID0gc1swXTtcclxuXHQgICAgICBiMSA9IHNbMV07XHJcblx0ICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XHJcblx0ICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XHJcblx0ICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcblx0ICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XHJcblx0ICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XHJcblx0ICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcblx0ICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xyXG5cdCAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcclxuXHQgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcblx0ICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xyXG5cdCAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcclxuXHQgICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XHJcblx0ICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG5cdCAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcclxuXHQgICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcclxuXHQgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuXHQgICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XHJcblx0ICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xyXG5cdCAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcclxuXHQgICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XHJcblx0ICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcblx0ICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XHJcblx0ICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xyXG5cdCAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuXHQgICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcclxuXHQgICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcclxuXHQgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuXHQgICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcclxuXHQgICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcclxuXHQgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuXHQgICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcclxuXHQgICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcclxuXHQgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcblx0ICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xyXG5cdCAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcclxuXHQgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcblx0ICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XHJcblx0ICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XHJcblx0ICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcblx0ICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XHJcblx0ICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XHJcblx0ICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcblxyXG5cdCAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcblx0ICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcclxuXHQgICAgICBzWzEwXSA9IGIxMCBeICh+YjEyICYgYjE0KTtcclxuXHQgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuXHQgICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcclxuXHQgICAgICBzWzIxXSA9IGIyMSBeICh+YjIzICYgYjI1KTtcclxuXHQgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuXHQgICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcclxuXHQgICAgICBzWzQwXSA9IGI0MCBeICh+YjQyICYgYjQ0KTtcclxuXHQgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuXHQgICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xyXG5cdCAgICAgIHNbM10gPSBiMyBeICh+YjUgJiBiNyk7XHJcblx0ICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcblx0ICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XHJcblx0ICAgICAgc1syMl0gPSBiMjIgXiAofmIyNCAmIGIyNik7XHJcblx0ICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcblx0ICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XHJcblx0ICAgICAgc1szM10gPSBiMzMgXiAofmIzNSAmIGIzNyk7XHJcblx0ICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcblx0ICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XHJcblx0ICAgICAgc1s0XSA9IGI0IF4gKH5iNiAmIGI4KTtcclxuXHQgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG5cdCAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xyXG5cdCAgICAgIHNbMTVdID0gYjE1IF4gKH5iMTcgJiBiMTkpO1xyXG5cdCAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG5cdCAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xyXG5cdCAgICAgIHNbMzRdID0gYjM0IF4gKH5iMzYgJiBiMzgpO1xyXG5cdCAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG5cdCAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xyXG5cdCAgICAgIHNbNDVdID0gYjQ1IF4gKH5iNDcgJiBiNDkpO1xyXG5cdCAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcblx0ICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcclxuXHQgICAgICBzWzE2XSA9IGIxNiBeICh+YjE4ICYgYjEwKTtcclxuXHQgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuXHQgICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcclxuXHQgICAgICBzWzI3XSA9IGIyNyBeICh+YjI5ICYgYjIxKTtcclxuXHQgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuXHQgICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcclxuXHQgICAgICBzWzQ2XSA9IGI0NiBeICh+YjQ4ICYgYjQwKTtcclxuXHQgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuXHQgICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xyXG5cdCAgICAgIHNbOV0gPSBiOSBeICh+YjEgJiBiMyk7XHJcblx0ICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcblx0ICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XHJcblx0ICAgICAgc1syOF0gPSBiMjggXiAofmIyMCAmIGIyMik7XHJcblx0ICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcblx0ICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XHJcblx0ICAgICAgc1szOV0gPSBiMzkgXiAofmIzMSAmIGIzMyk7XHJcblx0ICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcblx0ICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XHJcblxyXG5cdCAgICAgIHNbMF0gXj0gUkNbbl07XHJcblx0ICAgICAgc1sxXSBePSBSQ1tuICsgMV07XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblxyXG5cdCAgaWYgKENPTU1PTl9KUykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH0pKCk7XG5cdH0pO1xuXG5cdHZhciBsaWIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIganNfc2hhM18xID0gX19pbXBvcnREZWZhdWx0KHNoYTMpO1xuXG5cdGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG5cdCAgICByZXR1cm4gJzB4JyArIGpzX3NoYTNfMS5kZWZhdWx0LmtlY2Nha18yNTYobGliJDEuYXJyYXlpZnkoZGF0YSkpO1xuXHR9XG5cdGV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkNCA9IHVud3JhcEV4cG9ydHMobGliJDQpO1xuXHR2YXIgbGliXzEkNCA9IGxpYiQ0LmtlY2NhazI1NjtcblxuXHR2YXIgX3ZlcnNpb24kYSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJybHAvNS4wLjAtYmV0YS4xMzNcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGIgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGEpO1xuXHR2YXIgX3ZlcnNpb25fMSQ1ID0gX3ZlcnNpb24kYS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkNSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRhLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHdoaWxlICh2YWx1ZSkge1xuXHQgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG5cdCAgICAgICAgdmFsdWUgPj49IDg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogMjU2KSArIGRhdGFbb2Zmc2V0ICsgaV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgdmFyIHBheWxvYWRfMSA9IFtdO1xuXHQgICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICAgICAgICBwYXlsb2FkXzEgPSBwYXlsb2FkXzEuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAocGF5bG9hZF8xLmxlbmd0aCA8PSA1NSkge1xuXHQgICAgICAgICAgICBwYXlsb2FkXzEudW5zaGlmdCgweGMwICsgcGF5bG9hZF8xLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIHJldHVybiBwYXlsb2FkXzE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsZW5ndGhfMSA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkXzEubGVuZ3RoKTtcblx0ICAgICAgICBsZW5ndGhfMS51bnNoaWZ0KDB4ZjcgKyBsZW5ndGhfMS5sZW5ndGgpO1xuXHQgICAgICAgIHJldHVybiBsZW5ndGhfMS5jb25jYXQocGF5bG9hZF8xKTtcblx0ICAgIH1cblx0ICAgIGlmICghbGliJDEuaXNCeXRlc0xpa2Uob2JqZWN0KSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG5cdCAgICB9XG5cdCAgICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpYiQxLmFycmF5aWZ5KG9iamVjdCkpO1xuXHQgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuXHQgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcblx0ICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIHZhciBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuXHQgICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSk7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoX2VuY29kZShvYmplY3QpKTtcblx0fVxuXHRleHBvcnRzLmVuY29kZSA9IGVuY29kZTtcblx0ZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuXHQgICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG5cdCAgICAgICAgaWYgKGNoaWxkT2Zmc2V0ID4gb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcblx0fVxuXHQvLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuXHRmdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuXHQgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgfVxuXHQgICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG5cdCAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzIgPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzIgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgbG9uZyBzZWdtZW50IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoXzMgPSBkYXRhW29mZnNldF0gLSAweGMwO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoXzMgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGhfMyk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuXHQgICAgICAgIHZhciBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzQgPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBsaWIkMS5oZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF80KSk7XG5cdCAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQpLCByZXN1bHQ6IHJlc3VsdCB9O1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoXzUgPSBkYXRhW29mZnNldF0gLSAweDgwO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoXzUgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBsaWIkMS5oZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aF81KSk7XG5cdCAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoXzUpLCByZXN1bHQ6IHJlc3VsdCB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgY29uc3VtZWQ6IDEsIHJlc3VsdDogbGliJDEuaGV4bGlmeShkYXRhW29mZnNldF0pIH07XG5cdH1cblx0ZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcblx0ICAgIHZhciBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KGRhdGEpO1xuXHQgICAgdmFyIGRlY29kZWQgPSBfZGVjb2RlKGJ5dGVzLCAwKTtcblx0ICAgIGlmIChkZWNvZGVkLmNvbnN1bWVkICE9PSBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cdH0pO1xuXG5cdHZhciBpbmRleCQ1ID0gdW53cmFwRXhwb3J0cyhsaWIkNSk7XG5cdHZhciBsaWJfMSQ1ID0gbGliJDUuZW5jb2RlO1xuXHR2YXIgbGliXzIkNCA9IGxpYiQ1LmRlY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhZGRyZXNzLzUuMC4wLWJldGEuMTM1XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRkID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRjKTtcblx0dmFyIF92ZXJzaW9uXzEkNiA9IF92ZXJzaW9uJGMudmVyc2lvbjtcblxuXHR2YXIgbGliJDYgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vIFdlIHVzZSB0aGlzIGZvciBiYXNlIDM2IG1hdGhzXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGMudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgfVxuXHQgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhciBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuXHQgICAgdmFyIGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG5cdCAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuXHQgICAgfVxuXHQgICAgdmFyIGhhc2hlZCA9IGxpYiQxLmFycmF5aWZ5KGxpYiQ0LmtlY2NhazI1NihleHBhbmRlZCkpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG5cdCAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG5cdCAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcblx0ICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG5cdH1cblx0Ly8gU2hpbXMgZm9yIGVudmlyb25tZW50cyB0aGF0IGFyZSBtaXNzaW5nIHNvbWUgcmVxdWlyZWQgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnNcblx0dmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmO1xuXHRmdW5jdGlvbiBsb2cxMCh4KSB7XG5cdCAgICBpZiAoTWF0aC5sb2cxMCkge1xuXHQgICAgICAgIHJldHVybiBNYXRoLmxvZzEwKHgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuXHR9XG5cdC8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG5cdC8vIENyZWF0ZSBsb29rdXAgdGFibGVcblx0dmFyIGliYW5Mb29rdXAgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdCAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG5cdCAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcblx0fVxuXHQvLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG5cdHZhciBzYWZlRGlnaXRzID0gTWF0aC5mbG9vcihsb2cxMChNQVhfU0FGRV9JTlRFR0VSKSk7XG5cdGZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG5cdCAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuXHQgICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XG5cdCAgICB2YXIgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcblx0ICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuXHQgICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuXHQgICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG5cdCAgICB9XG5cdCAgICB2YXIgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG5cdCAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuXHQgICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjaGVja3N1bTtcblx0fVxuXHQ7XG5cdGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuXHQgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cdCAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgfVxuXHQgICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuXHQgICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxuXHQgICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cblx0ICAgICAgICBpZiAoYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSAmJiByZXN1bHQgIT09IGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG5cdCAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cblx0ICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgIT09IGliYW5DaGVja3N1bShhZGRyZXNzKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgPSAobmV3IGJuLkJOKGFkZHJlc3Muc3Vic3RyaW5nKDQpLCAzNikpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmdldEFkZHJlc3MgPSBnZXRBZGRyZXNzO1xuXHRmdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcykge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHRleHBvcnRzLmlzQWRkcmVzcyA9IGlzQWRkcmVzcztcblx0ZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuXHQgICAgdmFyIGJhc2UzNiA9IChuZXcgYm4uQk4oZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMiksIDE2KSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG5cdCAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG5cdCAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcblx0fVxuXHRleHBvcnRzLmdldEljYXBBZGRyZXNzID0gZ2V0SWNhcEFkZHJlc3M7XG5cdC8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuXHRmdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pIHtcblx0ICAgIHZhciBmcm9tID0gbnVsbDtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZnJvbSA9IGdldEFkZHJlc3ModHJhbnNhY3Rpb24uZnJvbSk7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBmcm9tIGFkZHJlc3NcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICB9XG5cdCAgICB2YXIgbm9uY2UgPSBsaWIkMS5zdHJpcFplcm9zKGxpYiQxLmFycmF5aWZ5KGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm5vbmNlKS50b0hleFN0cmluZygpKSk7XG5cdCAgICByZXR1cm4gZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UobGliJDQua2VjY2FrMjU2KGxpYiQ1LmVuY29kZShbZnJvbSwgbm9uY2VdKSksIDEyKSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRDb250cmFjdEFkZHJlc3MgPSBnZXRDb250cmFjdEFkZHJlc3M7XG5cdGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaCkge1xuXHQgICAgaWYgKGxpYiQxLmhleERhdGFMZW5ndGgoc2FsdCkgIT09IDMyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgc2FsdCk7XG5cdCAgICB9XG5cdCAgICBpZiAobGliJDEuaGV4RGF0YUxlbmd0aChpbml0Q29kZUhhc2gpICE9PSAzMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBpbml0Q29kZUhhc2gpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGdldEFkZHJlc3MobGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW1wiMHhmZlwiLCBnZXRBZGRyZXNzKGZyb20pLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGdldENyZWF0ZTJBZGRyZXNzO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkNiA9IHVud3JhcEV4cG9ydHMobGliJDYpO1xuXHR2YXIgbGliXzEkNiA9IGxpYiQ2LmdldEFkZHJlc3M7XG5cdHZhciBsaWJfMiQ1ID0gbGliJDYuaXNBZGRyZXNzO1xuXHR2YXIgbGliXzMkNCA9IGxpYiQ2LmdldEljYXBBZGRyZXNzO1xuXHR2YXIgbGliXzQkMyA9IGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzcztcblx0dmFyIGxpYl81JDMgPSBsaWIkNi5nZXRDcmVhdGUyQWRkcmVzcztcblxuXHR2YXIgYWRkcmVzcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIEFkZHJlc3NDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhBZGRyZXNzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBZGRyZXNzQ29kZXIobG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgbG9jYWxOYW1lLCBmYWxzZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEFkZHJlc3NDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBsaWIkNi5nZXRBZGRyZXNzKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEFkZHJlc3NDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRBZGRyZXNzKGxpYiQxLmhleFplcm9QYWQocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFkZHJlc3NDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQWRkcmVzc0NvZGVyID0gQWRkcmVzc0NvZGVyO1xuXHR9KTtcblxuXHR2YXIgYWRkcmVzcyQxID0gdW53cmFwRXhwb3J0cyhhZGRyZXNzKTtcblx0dmFyIGFkZHJlc3NfMiA9IGFkZHJlc3MuQWRkcmVzc0NvZGVyO1xuXG5cdHZhciBhbm9ueW1vdXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0Ly8gQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuXHR2YXIgQW5vbnltb3VzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQW5vbnltb3VzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBbm9ueW1vdXNDb2Rlcihjb2Rlcikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvZGVyLm5hbWUsIGNvZGVyLnR5cGUsIHVuZGVmaW5lZCwgY29kZXIuZHluYW1pYykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5jb2RlciA9IGNvZGVyO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFub255bW91c0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBbm9ueW1vdXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbm9ueW1vdXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQW5vbnltb3VzQ29kZXIgPSBBbm9ueW1vdXNDb2Rlcjtcblx0fSk7XG5cblx0dmFyIGFub255bW91cyQxID0gdW53cmFwRXhwb3J0cyhhbm9ueW1vdXMpO1xuXHR2YXIgYW5vbnltb3VzXzEgPSBhbm9ueW1vdXMuQW5vbnltb3VzQ29kZXI7XG5cblx0dmFyIGFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cblxuXHRmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcblx0ICAgIHZhciBhcnJheVZhbHVlcyA9IG51bGw7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdCAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh2YWx1ZXMgJiYgdHlwZW9mICh2YWx1ZXMpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgdmFyIHVuaXF1ZV8xID0ge307XG5cdCAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKGZ1bmN0aW9uIChjb2Rlcikge1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcblx0ICAgICAgICAgICAgICAgICAgICBjb2RlcjogY29kZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHVuaXF1ZV8xW25hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2Rlcixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB1bmlxdWVfMVtuYW1lXSA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoY29kZXJzLmxlbmd0aCAhPT0gYXJyYXlWYWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG5cdCAgICB9XG5cdCAgICB2YXIgc3RhdGljV3JpdGVyID0gbmV3IGFic3RyYWN0Q29kZXIuV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG5cdCAgICB2YXIgZHluYW1pY1dyaXRlciA9IG5ldyBhYnN0cmFjdENvZGVyLldyaXRlcih3cml0ZXIud29yZFNpemUpO1xuXHQgICAgdmFyIHVwZGF0ZUZ1bmNzID0gW107XG5cdCAgICBjb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIsIGluZGV4KSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuXHQgICAgICAgICAgICB2YXIgZHluYW1pY09mZnNldF8xID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG5cdCAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG5cdCAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcblx0ICAgICAgICAgICAgdmFyIHVwZGF0ZUZ1bmNfMSA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG5cdCAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goZnVuY3Rpb24gKGJhc2VPZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmNfMShiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldF8xKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuXHQgICAgdXBkYXRlRnVuY3MuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykgeyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcblx0ICAgIHZhciBsZW5ndGggPSB3cml0ZXIud3JpdGVCeXRlcyhzdGF0aWNXcml0ZXIuZGF0YSk7XG5cdCAgICBsZW5ndGggKz0gd3JpdGVyLndyaXRlQnl0ZXMoZHluYW1pY1dyaXRlci5kYXRhKTtcblx0ICAgIHJldHVybiBsZW5ndGg7XG5cdH1cblx0ZXhwb3J0cy5wYWNrID0gcGFjaztcblx0ZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG5cdCAgICB2YXIgdmFsdWVzID0gW107XG5cdCAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2Vcblx0ICAgIHZhciBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcblx0ICAgIC8vIFRoZSBhbW91bnQgb2YgZHluYW1pYyBkYXRhIHJlYWQ7IHRvIGNvbnN1bWUgbGF0ZXIgdG8gc3luY2hyb25pemVcblx0ICAgIHZhciBkeW5hbWljTGVuZ3RoID0gMDtcblx0ICAgIGNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2Rlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcblx0ICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkVmFsdWUoKTtcblx0ICAgICAgICAgICAgdmFyIG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldC50b051bWJlcigpKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkeW5hbWljTGVuZ3RoICs9IG9mZnNldFJlYWRlci5jb25zdW1lZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShyZWFkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBAVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGFuIHNlZSBpZiBpdCBzdGlsbCB3b3Jrcz9cblx0ICAgIC8vIENvbnN1bWUgdGhlIGR5bmFtaWMgY29tcG9uZW50cyBpbiB0aGUgbWFpbiByZWFkZXJcblx0ICAgIHJlYWRlci5yZWFkQnl0ZXMoZHluYW1pY0xlbmd0aCk7XG5cdCAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcblx0ICAgIHZhciB1bmlxdWVOYW1lcyA9IGNvZGVycy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBjb2Rlcikge1xuXHQgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgIGlmIChuYW1lKSB7XG5cdCAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICB9LCB7fSk7XG5cdCAgICAvLyBBZGQgYW55IG5hbWVkIHBhcmFtZXRlcnMgKGkuZS4gdHVwbGVzKVxuXHQgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyLCBpbmRleCkge1xuXHQgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG5cdCAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2luZGV4XTtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgdmFsdWU7IH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgaSwge1xuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHZhbHVlOyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIF9sb29wXzEoaSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuXHR9XG5cdGV4cG9ydHMudW5wYWNrID0gdW5wYWNrO1xuXHR2YXIgQXJyYXlDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhBcnJheUNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQXJyYXlDb2Rlcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuXHQgICAgICAgIHZhciBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5jb2RlciA9IGNvZGVyO1xuXHQgICAgICAgIF90aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBBcnJheUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuXHQgICAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcblx0ICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgdmFsdWUubGVuZ3RoLCBcImNvZGVyIGFycmF5XCIgKyAodGhpcy5sb2NhbE5hbWUgPyAoXCIgXCIgKyB0aGlzLmxvY2FsTmFtZSkgOiBcIlwiKSk7XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29kZXJzLnB1c2godGhpcy5jb2Rlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQXJyYXlDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHZhciBjb3VudCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZFZhbHVlKCkudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgYW5vbnltb3VzLkFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCBjb2RlcnMpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQXJyYXlDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQXJyYXlDb2RlciA9IEFycmF5Q29kZXI7XG5cdH0pO1xuXG5cdHZhciBhcnJheSQxID0gdW53cmFwRXhwb3J0cyhhcnJheSk7XG5cdHZhciBhcnJheV8xID0gYXJyYXkucGFjaztcblx0dmFyIGFycmF5XzIgPSBhcnJheS51bnBhY2s7XG5cdHZhciBhcnJheV8zID0gYXJyYXkuQXJyYXlDb2RlcjtcblxuXHR2YXIgYm9vbGVhbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdHZhciBCb29sZWFuQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQm9vbGVhbkNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQm9vbGVhbkNvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBCb29sZWFuQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuXHQgICAgfTtcblx0ICAgIEJvb2xlYW5Db2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMudHlwZSwgIXJlYWRlci5yZWFkVmFsdWUoKS5pc1plcm8oKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJvb2xlYW5Db2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQm9vbGVhbkNvZGVyID0gQm9vbGVhbkNvZGVyO1xuXHR9KTtcblxuXHR2YXIgYm9vbGVhbiA9IHVud3JhcEV4cG9ydHMoYm9vbGVhbl8xKTtcblx0dmFyIGJvb2xlYW5fMiA9IGJvb2xlYW5fMS5Cb29sZWFuQ29kZXI7XG5cblx0dmFyIGJ5dGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIER5bmFtaWNCeXRlc0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKER5bmFtaWNCeXRlc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRHluYW1pY0J5dGVzQ29kZXIodHlwZSwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIER5bmFtaWNCeXRlc0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIHZhciBsZW5ndGggPSB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIGxlbmd0aDtcblx0ICAgIH07XG5cdCAgICBEeW5hbWljQnl0ZXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGVzKHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRHluYW1pY0J5dGVzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkR5bmFtaWNCeXRlc0NvZGVyID0gRHluYW1pY0J5dGVzQ29kZXI7XG5cdHZhciBCeXRlc0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEJ5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBCeXRlc0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImJ5dGVzXCIsIGxvY2FsTmFtZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEJ5dGVzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIGxpYiQxLmhleGxpZnkoX3N1cGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCByZWFkZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJ5dGVzQ29kZXI7XG5cdH0oRHluYW1pY0J5dGVzQ29kZXIpKTtcblx0ZXhwb3J0cy5CeXRlc0NvZGVyID0gQnl0ZXNDb2Rlcjtcblx0fSk7XG5cblx0dmFyIGJ5dGVzJDEgPSB1bndyYXBFeHBvcnRzKGJ5dGVzKTtcblx0dmFyIGJ5dGVzXzIgPSBieXRlcy5EeW5hbWljQnl0ZXNDb2Rlcjtcblx0dmFyIGJ5dGVzXzMgPSBieXRlcy5CeXRlc0NvZGVyO1xuXG5cdHZhciBmaXhlZEJ5dGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0Ly8gQFRPRE86IE1lcmdlIHRoaXMgd2l0aCBieXRlc1xuXHR2YXIgRml4ZWRCeXRlc0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZpeGVkQnl0ZXNDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZpeGVkQnl0ZXNDb2RlcihzaXplLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSkgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5zaXplID0gc2l6ZTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBGaXhlZEJ5dGVzQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcblx0ICAgIH07XG5cdCAgICBGaXhlZEJ5dGVzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIGxpYiQxLmhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZpeGVkQnl0ZXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuRml4ZWRCeXRlc0NvZGVyID0gRml4ZWRCeXRlc0NvZGVyO1xuXHR9KTtcblxuXHR2YXIgZml4ZWRCeXRlcyQxID0gdW53cmFwRXhwb3J0cyhmaXhlZEJ5dGVzKTtcblx0dmFyIGZpeGVkQnl0ZXNfMSA9IGZpeGVkQnl0ZXMuRml4ZWRCeXRlc0NvZGVyO1xuXG5cdHZhciBfbnVsbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHR2YXIgTnVsbENvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE51bGxDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIE51bGxDb2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKFtdKTtcblx0ICAgIH07XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbnVsbCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE51bGxDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuTnVsbENvZGVyID0gTnVsbENvZGVyO1xuXHR9KTtcblxuXHR2YXIgX251bGwkMSA9IHVud3JhcEV4cG9ydHMoX251bGwpO1xuXHR2YXIgX251bGxfMSA9IF9udWxsLk51bGxDb2RlcjtcblxuXHR2YXIgbGliJDcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0dmFyIEFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblx0ZXhwb3J0cy5BZGRyZXNzWmVybyA9IEFkZHJlc3NaZXJvO1xuXHR2YXIgSGFzaFplcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuXHRleHBvcnRzLkhhc2haZXJvID0gSGFzaFplcm87XG5cdC8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcblx0dmFyIEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcblx0ZXhwb3J0cy5FdGhlclN5bWJvbCA9IEV0aGVyU3ltYm9sO1xuXHR2YXIgTmVnYXRpdmVPbmUgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSgtMSk7XG5cdGV4cG9ydHMuTmVnYXRpdmVPbmUgPSBOZWdhdGl2ZU9uZTtcblx0dmFyIFplcm8gPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSgwKTtcblx0ZXhwb3J0cy5aZXJvID0gWmVybztcblx0dmFyIE9uZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDEpO1xuXHRleHBvcnRzLk9uZSA9IE9uZTtcblx0dmFyIFR3byA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDIpO1xuXHRleHBvcnRzLlR3byA9IFR3bztcblx0dmFyIFdlaVBlckV0aGVyID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIpO1xuXHRleHBvcnRzLldlaVBlckV0aGVyID0gV2VpUGVyRXRoZXI7XG5cdHZhciBNYXhVaW50MjU2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5cdGV4cG9ydHMuTWF4VWludDI1NiA9IE1heFVpbnQyNTY7XG5cdH0pO1xuXG5cdHZhciBpbmRleCQ3ID0gdW53cmFwRXhwb3J0cyhsaWIkNyk7XG5cdHZhciBsaWJfMSQ3ID0gbGliJDcuQWRkcmVzc1plcm87XG5cdHZhciBsaWJfMiQ2ID0gbGliJDcuSGFzaFplcm87XG5cdHZhciBsaWJfMyQ1ID0gbGliJDcuRXRoZXJTeW1ib2w7XG5cdHZhciBsaWJfNCQ0ID0gbGliJDcuTmVnYXRpdmVPbmU7XG5cdHZhciBsaWJfNSQ0ID0gbGliJDcuWmVybztcblx0dmFyIGxpYl82JDIgPSBsaWIkNy5PbmU7XG5cdHZhciBsaWJfNyQyID0gbGliJDcuVHdvO1xuXHR2YXIgbGliXzgkMSA9IGxpYiQ3LldlaVBlckV0aGVyO1xuXHR2YXIgbGliXzkkMSA9IGxpYiQ3Lk1heFVpbnQyNTY7XG5cblx0dmFyIG51bWJlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIE51bWJlckNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE51bWJlckNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTnVtYmVyQ29kZXIoc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLnNpemUgPSBzaXplO1xuXHQgICAgICAgIF90aGlzLnNpZ25lZCA9IHNpZ25lZDtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBOdW1iZXJDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgdiA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcblx0ICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG5cdCAgICAgICAgdmFyIG1heFVpbnRWYWx1ZSA9IGxpYiQ3Lk1heFVpbnQyNTYubWFzayh3cml0ZXIud29yZFNpemUgKiA4KTtcblx0ICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcblx0ICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDggLSAxKTtcblx0ICAgICAgICAgICAgaWYgKHYuZ3QoYm91bmRzKSB8fCB2Lmx0KGJvdW5kcy5hZGQobGliJDcuT25lKS5tdWwobGliJDcuTmVnYXRpdmVPbmUpKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHYubHQobGliJDcuWmVybykgfHwgdi5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4KSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2ID0gdi50b1R3b3ModGhpcy5zaXplICogOCkubWFzayh0aGlzLnNpemUgKiA4KTtcblx0ICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcblx0ICAgICAgICAgICAgdiA9IHYuZnJvbVR3b3ModGhpcy5zaXplICogOCkudG9Ud29zKDggKiB3cml0ZXIud29yZFNpemUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodik7XG5cdCAgICB9O1xuXHQgICAgTnVtYmVyQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSByZWFkZXIucmVhZFZhbHVlKCkubWFzayh0aGlzLnNpemUgKiA4KTtcblx0ICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE51bWJlckNvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5OdW1iZXJDb2RlciA9IE51bWJlckNvZGVyO1xuXHR9KTtcblxuXHR2YXIgbnVtYmVyJDEgPSB1bndyYXBFeHBvcnRzKG51bWJlcik7XG5cdHZhciBudW1iZXJfMSA9IG51bWJlci5OdW1iZXJDb2RlcjtcblxuXHR2YXIgX3ZlcnNpb24kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJzdHJpbmdzLzUuMC4wLWJldGEuMTM3XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRmID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRlKTtcblx0dmFyIF92ZXJzaW9uXzEkNyA9IF92ZXJzaW9uJGUudmVyc2lvbjtcblxuXHR2YXIgdXRmOCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGUudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0KGZ1bmN0aW9uIChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pIHtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuXHQgICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXSA9IFwiTkZEXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG5cdH0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChleHBvcnRzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG5cdDtcblx0dmFyIFV0ZjhFcnJvclJlYXNvbjtcblx0KGZ1bmN0aW9uIChVdGY4RXJyb3JSZWFzb24pIHtcblx0ICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIlVORVhQRUNURURfQ09OVElOVUVcIl0gPSBcInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIjtcblx0ICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJCQURfUFJFRklYXCJdID0gXCJiYWQgY29kZXBvaW50IHByZWZpeFwiO1xuXHQgICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSUlVOXCJdID0gXCJzdHJpbmcgb3ZlcnJ1blwiO1xuXHQgICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJNSVNTSU5HX0NPTlRJTlVFXCJdID0gXCJtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlXCI7XG5cdCAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcblx0ICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcblx0ICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgb3V0c2lkZSB0aGUgVVRGLTggcmFuZ2Vcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG5cdCAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG5cdCAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG5cdCAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuXHQgICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG5cdCAgICAvLyBUaGUgc3RyaW5nIGlzIGFuIG92ZXJsb25nIHJlcGVyZXNlbnRhdGlvblxuXHQgICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuXHQgICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcblx0fSkoVXRmOEVycm9yUmVhc29uID0gZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gfHwgKGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0ge30pKTtcblx0O1xuXHRmdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgXCIgKyBvZmZzZXQgKyBcIjsgXCIgKyByZWFzb24sIFwiYnl0ZXNcIiwgYnl0ZXMpO1xuXHR9XG5cdGZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuXHQgICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuXHQgICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVggfHwgcmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSkge1xuXHQgICAgICAgIHZhciBpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG5cdCAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgfVxuXHQgICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG5cdCAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTikge1xuXHQgICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuXHQgICAgfVxuXHQgICAgLy8gTm90aGluZyB0byBza2lwXG5cdCAgICByZXR1cm4gMDtcblx0fVxuXHRmdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcblx0ICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXHQgICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG5cdCAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuXHQgICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuXHQgICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG5cdH1cblx0Ly8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuXHRleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdCAgICBlcnJvcjogZXJyb3JGdW5jLFxuXHQgICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuXHQgICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcblx0fSk7XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuXHRmdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuXHQgICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xuXHQgICAgICAgIG9uRXJyb3IgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuXHQgICAgfVxuXHQgICAgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShieXRlcyk7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG5cdCAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBjID0gYnl0ZXNbaSsrXTtcblx0ICAgICAgICAvLyAweHh4IHh4eHhcblx0ICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cblx0ICAgICAgICB2YXIgZXh0cmFMZW5ndGggPSBudWxsO1xuXHQgICAgICAgIHZhciBvdmVybG9uZ01hc2sgPSBudWxsO1xuXHQgICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcblx0ICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuXHQgICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG5cdCAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG5cdCAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcblx0ICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuXHQgICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcblx0ICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcblx0ICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuXHQgICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG5cdCAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcblx0ICAgICAgICB2YXIgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuXHQgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG5cdCAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk1JU1NJTkdfQ09OVElOVUUsIGksIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuXHQgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbXVhdGlvbiBieXRlXG5cdCAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG5cdCAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG5cdCAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuXHQgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG5cdCAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcblx0ICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORywgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuXHRmdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pIHtcblx0ICAgIGlmIChmb3JtID09PSB2b2lkIDApIHsgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50OyB9XG5cdCAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuXHQgICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgaWYgKGMgPCAweDgwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG5cdCAgICAgICAgICAgIGkrKztcblx0ICAgICAgICAgICAgdmFyIGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuXHQgICAgICAgICAgICB2YXIgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG5cdDtcblx0ZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSkge1xuXHQgICAgdmFyIGhleCA9IChcIjAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICByZXR1cm4gXCJcXFxcdVwiICsgaGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoIC0gNCk7XG5cdH1cblx0ZnVuY3Rpb24gX3RvRXNjYXBlZFV0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcChmdW5jdGlvbiAoY29kZVBvaW50KSB7XG5cdCAgICAgICAgaWYgKGNvZGVQb2ludCA8IDI1Nikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJcXFxcdFwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFwiXFxcXG5cIjtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM0OiByZXR1cm4gXCJcXFxcXFxcIlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5MjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IDMyICYmIGNvZGVQb2ludCA8IDEyNykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuXHQgICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0ICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcblx0ICAgIH0pLmpvaW4oXCJcIikgKyAnXCInO1xuXHR9XG5cdGV4cG9ydHMuX3RvRXNjYXBlZFV0ZjhTdHJpbmcgPSBfdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0ZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG5cdCAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuXHQgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuXHQgICAgfSkuam9pbihcIlwiKTtcblx0fVxuXHRleHBvcnRzLl90b1V0ZjhTdHJpbmcgPSBfdG9VdGY4U3RyaW5nO1xuXHRmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG5cdH1cblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB0b1V0ZjhTdHJpbmc7XG5cdGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG5cdCAgICBpZiAoZm9ybSA9PT0gdm9pZCAwKSB7IGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudDsgfVxuXHQgICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xuXHR9XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG5cdH0pO1xuXG5cdHZhciB1dGY4JDEgPSB1bndyYXBFeHBvcnRzKHV0ZjgpO1xuXHR2YXIgdXRmOF8xID0gdXRmOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG5cdHZhciB1dGY4XzIgPSB1dGY4LlV0ZjhFcnJvclJlYXNvbjtcblx0dmFyIHV0ZjhfMyA9IHV0ZjguVXRmOEVycm9yRnVuY3M7XG5cdHZhciB1dGY4XzQgPSB1dGY4LnRvVXRmOEJ5dGVzO1xuXHR2YXIgdXRmOF81ID0gdXRmOC5fdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0dmFyIHV0ZjhfNiA9IHV0ZjguX3RvVXRmOFN0cmluZztcblx0dmFyIHV0ZjhfNyA9IHV0ZjgudG9VdGY4U3RyaW5nO1xuXHR2YXIgdXRmOF84ID0gdXRmOC50b1V0ZjhDb2RlUG9pbnRzO1xuXG5cdHZhciBieXRlczMyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHRmdW5jdGlvbiBmb3JtYXRCeXRlczMyU3RyaW5nKHRleHQpIHtcblx0ICAgIC8vIEdldCB0aGUgYnl0ZXNcblx0ICAgIHZhciBieXRlcyA9IHV0ZjgudG9VdGY4Qnl0ZXModGV4dCk7XG5cdCAgICAvLyBDaGVjayB3ZSBoYXZlIHJvb20gZm9yIG51bGwtdGVybWluYXRpb25cblx0ICAgIGlmIChieXRlcy5sZW5ndGggPiAzMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ5dGVzMzIgc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDMyIGJ5dGVzXCIpO1xuXHQgICAgfVxuXHQgICAgLy8gWmVyby1wYWQgKGltcGxpY2l0bHkgbnVsbC10ZXJtaW5hdGVzKVxuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkobGliJDEuY29uY2F0KFtieXRlcywgbGliJDcuSGFzaFplcm9dKS5zbGljZSgwLCAzMikpO1xuXHR9XG5cdGV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IGZvcm1hdEJ5dGVzMzJTdHJpbmc7XG5cdGZ1bmN0aW9uIHBhcnNlQnl0ZXMzMlN0cmluZyhieXRlcykge1xuXHQgICAgdmFyIGRhdGEgPSBsaWIkMS5hcnJheWlmeShieXRlcyk7XG5cdCAgICAvLyBNdXN0IGJlIDMyIGJ5dGVzIHdpdGggYSBudWxsLXRlcm1pbmF0aW9uXG5cdCAgICBpZiAoZGF0YS5sZW5ndGggIT09IDMyKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoZGF0YVszMV0gIT09IDApIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xuXHQgICAgfVxuXHQgICAgLy8gRmluZCB0aGUgbnVsbCB0ZXJtaW5hdGlvblxuXHQgICAgdmFyIGxlbmd0aCA9IDMxO1xuXHQgICAgd2hpbGUgKGRhdGFbbGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgICBsZW5ndGgtLTtcblx0ICAgIH1cblx0ICAgIC8vIERldGVybWluZSB0aGUgc3RyaW5nIHZhbHVlXG5cdCAgICByZXR1cm4gdXRmOC50b1V0ZjhTdHJpbmcoZGF0YS5zbGljZSgwLCBsZW5ndGgpKTtcblx0fVxuXHRleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IHBhcnNlQnl0ZXMzMlN0cmluZztcblx0fSk7XG5cblx0dmFyIGJ5dGVzMzIkMSA9IHVud3JhcEV4cG9ydHMoYnl0ZXMzMik7XG5cdHZhciBieXRlczMyXzEgPSBieXRlczMyLmZvcm1hdEJ5dGVzMzJTdHJpbmc7XG5cdHZhciBieXRlczMyXzIgPSBieXRlczMyLnBhcnNlQnl0ZXMzMlN0cmluZztcblxuXHR2YXIgaWRuYSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRmdW5jdGlvbiBieXRlczIoZGF0YSkge1xuXHQgICAgaWYgKChkYXRhLmxlbmd0aCAlIDQpICE9PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGRhdGFcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChkYXRhLnN1YnN0cmluZyhpLCBpICsgNCksIDE2KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGRhdGEsIGZ1bmMpIHtcblx0ICAgIGlmICghZnVuYykge1xuXHQgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFtwYXJzZUludCh2YWx1ZSwgMTYpXTsgfTtcblx0ICAgIH1cblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBkYXRhLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gcGFpci5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgbG8gKz0gcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcblx0ICAgICAgICByZXN1bHRbbG9dID0gZnVuYyhjb21wc1sxXSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlUmFuZ2VUYWJsZShkYXRhKSB7XG5cdCAgICB2YXIgaGkgPSAwO1xuXHQgICAgcmV0dXJuIGRhdGEuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAodikge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHYuc3BsaXQoXCItXCIpO1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgY29tcHNbMV0gPSBcIjBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoY29tcHNbMV0gPT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgY29tcHNbMV0gPSBcIjFcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxvID0gaGkgKyBwYXJzZUludChjb21wc1swXSwgMTYpO1xuXHQgICAgICAgIGhpID0gcGFyc2VJbnQoY29tcHNbMV0sIDE2KTtcblx0ICAgICAgICByZXR1cm4geyBsOiBsbywgaDogaGkgfTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIG1hdGNoTWFwKHZhbHVlLCByYW5nZXMpIHtcblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcblx0ICAgICAgICBsbyArPSByYW5nZS5sO1xuXHQgICAgICAgIGlmICh2YWx1ZSA+PSBsbyAmJiB2YWx1ZSA8PSBsbyArIHJhbmdlLmggJiYgKCh2YWx1ZSAtIGxvKSAlIChyYW5nZS5kIHx8IDEpKSA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAocmFuZ2UuZSAmJiByYW5nZS5lLmluZGV4T2YodmFsdWUgLSBsbykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIFRhYmxlX0FfMV9yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiMjIxLDEzLTFiLDVmLSw0MC0xMCw1MS1mLDExLTMsMy0zLDItMiwyLTQsOCwyLDE1LDJkLDI4LTgsODgsNDgsMjctLDMtNSwxMS0yMCwyNy0sOCwyOCwzLTUsMTIsMTgsYi1hLDFjLTQsNi0xNiwyLWQsMi0yLDIsMWItNCwxNy05LDhmLSwxMCxmLDFmLTIsMWMtMzQsMzMtMTRlLDQsMzYtLDEzLSw2LTIsMWEtZiw0LDktLDMtLDE3LDgsMi0yLDUtLDIsOC0sMy0sNC04LDItMywzLDYtLDE2LTYsMi0sNy0zLDMtLDE3LDgsMywzLDMtLDIsNi0zLDMtLDQtYSw1LDItNiwxMC1iLDQsOCwyLDQsMTcsOCwzLDYtLGIsNCw0LSwyLWUsMi00LGItMTAsNCw5LSwzLSwxNyw4LDMtLDUtLDktMiwzLSw0LTcsMy0zLDMsNC0zLGMtMTAsMyw3LTIsNCw1LTIsMywyLDMtMiwzLTIsNC0yLDksNC0zLDYtMiw0LDUtOCwyLWUsZC1kLDQsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy04LDMtMyxiLTExLDMsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy02LDIsMy0zLGItMTEsMyw5LDQsMTgsMTEtMyw3LSw0LDUtOCwyLTcsMy0zLGItMTEsMywxMy0yLDE5LGEsMi0sOC0yLDItMyw3LDIsOS0xMSw0LWIsM2ItMywxZS0yNCwzLDItLDMsMi0sMi01LDUsOCw0LDIsMi0sMyxlLDQtLDYsMiw3LSxiLSwzLTIxLDQ5LDIzLTUsMWMtMyw5LDI1LDEwLSwyLTJmLDIzLDYsMyw4LTIsNS01LDFiLTQ1LDI3LTksMmEtLDItMyw1Yi00LDQ1LTQsNTMtNSw4LDQwLDIsNS0sOCwyLDUtLDI4LDIsNS0sMjAsMiw1LSw4LDIsNS0sOCw4LDE4LDIwLDIsNS0sOCwyOCwxNC01LDFkLTIyLDU2LWIsMjc3LTgsMWUtMiw1Mi1lLGUsOC1hLDE4LTgsMTUtYixlLDQsMy1iLDVlLTIsYi0xNSwxMCxiLTUsNTktNywyYi01NTUsOWQtMyw1Yi01LDE3LSw3LSwyNy0sNy0sOSwyLDIsMiwyMC0sMzYsMTAsZi0sNywxNC0sNCxhLDU0LTMsMi02LDYtNSw5LSwxYy0xMCwxMy0xZCwxYy0xNCwzYy0sMTAtNiwzMi1iLDI0MC0zMCwyOC0xOCxjLTE0LGEwLDExNS0sMyw2Ni0sYi03Niw1LDUtLDFkLDI0LDIsNS0yLDIsOC0sMzUtMiwxOSxmLTEwLDFkLTMsMzExLTM3ZiwxYiw1YS1iLGQ3LTE5LGQtMyw0MSw1Ny0sNjgtNCwyOS0zLDVmLDI5LTM3LDJlLTIsMjUtYywyYy0yLDRlLTMsMzAsNzgtMyw2NC0sMjAsMTliNy00OSw1MWE3LTU5LDQ4ZS0yLDM4LTczOCwyYmE1LTViLDIyMmYtLDNjLTk0LDgtYiw2LTQsMWIsNiwyLDMsMyw2ZC0yMCwxNmUtZiw0MS0sMzctNywyZS0yLDExLWYsNS1iLDE4LSxiLDE0LDUtMyw2LDg4LSwyLGJmLTIsNy0sNy0sNy0sNC0yLDgsOC05LDgtMmZmLDIwLDUtYiwxYy1iNCwyNy0sMjctY2JiMSxmNy05LDI4LTIsYjUtMjIxLDU2LDQ4LDMtLDItLDMtLDUsZCwyLDUsMyw0Miw1LSw5LDgsMWQsNSw2LDItMiw4LDE1My0zLDEyMy0zLDMzLTI3ZmQsYTZkYS01MTI4LDIxZi01ZGYsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLDItMWQsNjEtZmY3ZFwiKTtcblx0Ly8gQFRPRE86IE1ha2UgdGhpcyByZWxhdGl2ZS4uLlxuXHR2YXIgVGFibGVfQl8xX2ZsYWdzID0gXCJhZCwzNGYsMTgwNiwxODBiLDE4MGMsMTgwZCwyMDBiLDIwMGMsMjAwZCwyMDYwLGZlZmZcIi5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUludCh2LCAxNik7IH0pO1xuXHR2YXIgVGFibGVfQl8yX3JhbmdlcyA9IFtcblx0ICAgIHsgaDogMjUsIHM6IDMyLCBsOiA2NSB9LFxuXHQgICAgeyBoOiAzMCwgczogMzIsIGU6IFsyM10sIGw6IDEyNyB9LFxuXHQgICAgeyBoOiA1NCwgczogMSwgZTogWzQ4XSwgbDogNjQsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTQsIHM6IDEsIGw6IDU3LCBkOiAyIH0sXG5cdCAgICB7IGg6IDQ0LCBzOiAxLCBsOiAxNywgZDogMiB9LFxuXHQgICAgeyBoOiAxMCwgczogMSwgZTogWzIsIDYsIDhdLCBsOiA2MSwgZDogMiB9LFxuXHQgICAgeyBoOiAxNiwgczogMSwgbDogNjgsIGQ6IDIgfSxcblx0ICAgIHsgaDogODQsIHM6IDEsIGU6IFsxOCwgMjQsIDY2XSwgbDogMTksIGQ6IDIgfSxcblx0ICAgIHsgaDogMjYsIHM6IDMyLCBlOiBbMTddLCBsOiA0MzUgfSxcblx0ICAgIHsgaDogMjIsIHM6IDEsIGw6IDcxLCBkOiAyIH0sXG5cdCAgICB7IGg6IDE1LCBzOiA4MCwgbDogNDAgfSxcblx0ICAgIHsgaDogMzEsIHM6IDMyLCBsOiAxNiB9LFxuXHQgICAgeyBoOiAzMiwgczogMSwgbDogODAsIGQ6IDIgfSxcblx0ICAgIHsgaDogNTIsIHM6IDEsIGw6IDQyLCBkOiAyIH0sXG5cdCAgICB7IGg6IDEyLCBzOiAxLCBsOiA1NSwgZDogMiB9LFxuXHQgICAgeyBoOiA0MCwgczogMSwgZTogWzM4XSwgbDogMTUsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTQsIHM6IDEsIGw6IDQ4LCBkOiAyIH0sXG5cdCAgICB7IGg6IDM3LCBzOiA0OCwgbDogNDkgfSxcblx0ICAgIHsgaDogMTQ4LCBzOiAxLCBsOiA2MzUxLCBkOiAyIH0sXG5cdCAgICB7IGg6IDg4LCBzOiAxLCBsOiAxNjAsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTUsIHM6IDE2LCBsOiA3MDQgfSxcblx0ICAgIHsgaDogMjUsIHM6IDI2LCBsOiA4NTQgfSxcblx0ICAgIHsgaDogMjUsIHM6IDMyLCBsOiA1NTkxNSB9LFxuXHQgICAgeyBoOiAzNywgczogNDAsIGw6IDEyNDcgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk3MTEsIGw6IDUzMjQ4IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5NzYzLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTExOTgxNSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk4NjcsIGU6IFsxLCA0LCA1LCA3LCA4LCAxMSwgMTIsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk5MTksIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5OTcxLCBlOiBbMiwgNywgOCwgMTddLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTEyMDAyMywgZTogWzIsIDcsIDEzLCAxNSwgMTYsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAwNzUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMTI3LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDE3OSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAyMzEsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMjgzLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDMzNSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk1NDMsIGU6IFsxN10sIGw6IDU2IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NjAxLCBlOiBbMTddLCBsOiA1OCB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTY1OSwgZTogWzE3XSwgbDogNTggfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk3MTcsIGU6IFsxN10sIGw6IDU4IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5Nzc1LCBlOiBbMTddLCBsOiA1OCB9XG5cdF07XG5cdHZhciBUYWJsZV9CXzJfbHV0X2FicyA9IGNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO1xuXHR2YXIgVGFibGVfQl8yX2x1dF9yZWwgPSBjcmVhdGVUYWJsZShcIjE3OToxLDI6MSwyOjEsNToxLDI6MSxhOjRmLGE6MSw4OjEsMjoxLDI6MSwzOjEsNToxLDM6MSw0OjEsMjoxLDM6MSw0OjEsODoyLDE6MSwyOjIsMToxLDI6MiwyNzoyLDE5NToyNiwyOjI1LDE6MjUsMToyNSwyOjQwLDI6M2YsMTozZiwzMzoxLDExOi02LDE6LTksMWFjNzotM2EsNmQ6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxiOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGM6LTgsMjotOCwyOi04LDI6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDQ5Oi04LDE6LTgsMTotNGEsMTotNGEsZDotNTYsMTotNTYsMTotNTYsMTotNTYsZDotOCwxOi04LGY6LTgsMTotOCwzOi03XCIpO1xuXHR2YXIgVGFibGVfQl8yX2NvbXBsZXggPSBjcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsIGJ5dGVzMik7XG5cdHZhciBUYWJsZV9DX3JhbmdlcyA9IGNyZWF0ZVJhbmdlVGFibGUoXCI4MC0yMCwyYTAtLDM5YywzMixmNzEsMThlLDdmMi1mLDE5LTcsMzAtNCw3LTUsZjgxLWIsNSxhODAwLTIwZmYsNGQxLTFmLDExMCxmYS02LGQxNzQtNywyZTg0LSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSwyLDFmLTVmLGZmN2YtMjAwMDFcIik7XG5cdGZ1bmN0aW9uIGZsYXR0ZW4odmFsdWVzKSB7XG5cdCAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgYWNjdW0ucHVzaCh2YWx1ZSk7IH0pO1xuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIFtdKTtcblx0fVxuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUExKGNvZGVwb2ludCkge1xuXHQgICAgcmV0dXJuICEhbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9BXzFfcmFuZ2VzKTtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQTEgPSBfbmFtZXByZXBUYWJsZUExO1xuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUIyKGNvZGVwb2ludCkge1xuXHQgICAgdmFyIHJhbmdlID0gbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9CXzJfcmFuZ2VzKTtcblx0ICAgIGlmIChyYW5nZSkge1xuXHQgICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgcmFuZ2Uuc107XG5cdCAgICB9XG5cdCAgICB2YXIgY29kZXMgPSBUYWJsZV9CXzJfbHV0X2Fic1tjb2RlcG9pbnRdO1xuXHQgICAgaWYgKGNvZGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvZGVzO1xuXHQgICAgfVxuXHQgICAgdmFyIHNoaWZ0ID0gVGFibGVfQl8yX2x1dF9yZWxbY29kZXBvaW50XTtcblx0ICAgIGlmIChzaGlmdCkge1xuXHQgICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgc2hpZnRbMF1dO1xuXHQgICAgfVxuXHQgICAgdmFyIGNvbXBsZXggPSBUYWJsZV9CXzJfY29tcGxleFtjb2RlcG9pbnRdO1xuXHQgICAgaWYgKGNvbXBsZXgpIHtcblx0ICAgICAgICByZXR1cm4gY29tcGxleDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdGV4cG9ydHMuX25hbWVwcmVwVGFibGVCMiA9IF9uYW1lcHJlcFRhYmxlQjI7XG5cdGZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQyhjb2RlcG9pbnQpIHtcblx0ICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQ19yYW5nZXMpO1xuXHR9XG5cdGV4cG9ydHMuX25hbWVwcmVwVGFibGVDID0gX25hbWVwcmVwVGFibGVDO1xuXHRmdW5jdGlvbiBuYW1lcHJlcCh2YWx1ZSkge1xuXHQgICAgLy8gVGhpcyBhbGxvd3MgcGxhdGZvcm1zIHdpdGggaW5jb21wbGV0ZSBub3JtYWxpemUgdG8gYnlwYXNzXG5cdCAgICAvLyBpdCBmb3IgdmVyeSBiYXNpYyBuYW1lcyB3aGljaCB0aGUgYnVpbHQtaW4gdG9Mb3dlckNhc2Vcblx0ICAgIC8vIHdpbGwgY2VydGFpbmx5IGhhbmRsZSBjb3JyZWN0bHlcblx0ICAgIGlmICh2YWx1ZS5tYXRjaCgvXlthLXowLTktXSokL2kpICYmIHZhbHVlLmxlbmd0aCA8PSA1OSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgLy8gR2V0IHRoZSBjb2RlIHBvaW50cyAoa2VlcGluZyB0aGUgY3VycmVudCBub3JtYWxpemF0aW9uKVxuXHQgICAgdmFyIGNvZGVzID0gdXRmOC50b1V0ZjhDb2RlUG9pbnRzKHZhbHVlKTtcblx0ICAgIGNvZGVzID0gZmxhdHRlbihjb2Rlcy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICAvLyBTdWJzdGl0dXRlIFRhYmxlIEIuMSAoTWFwcyB0byBOb3RoaW5nKVxuXHQgICAgICAgIGlmIChUYWJsZV9CXzFfZmxhZ3MuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvZGUgPj0gMHhmZTAwICYmIGNvZGUgPD0gMHhmZTBmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjIgKENhc2UgRm9sZGluZylcblx0ICAgICAgICB2YXIgY29kZXNUYWJsZUIyID0gX25hbWVwcmVwVGFibGVCMihjb2RlKTtcblx0ICAgICAgICBpZiAoY29kZXNUYWJsZUIyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb2Rlc1RhYmxlQjI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vIFN1YnN0aXR1dGlvblxuXHQgICAgICAgIHJldHVybiBbY29kZV07XG5cdCAgICB9KSk7XG5cdCAgICAvLyBOb3JtYWxpemUgdXNpbmcgZm9ybSBLQ1xuXHQgICAgY29kZXMgPSB1dGY4LnRvVXRmOENvZGVQb2ludHModXRmOC5fdG9VdGY4U3RyaW5nKGNvZGVzKSwgdXRmOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLQyk7XG5cdCAgICAvLyBQcm9oaWJpdCBUYWJsZXMgQy4xLjIsIEMuMi4yLCBDLjMsIEMuNCwgQy41LCBDLjYsIEMuNywgQy44LCBDLjlcblx0ICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICBpZiAoX25hbWVwcmVwVGFibGVDKGNvZGUpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfUFJPSElCSVRFRFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIFByb2hpYml0IFVuYXNzaWduZWQgQ29kZSBQb2ludHMgKFRhYmxlIEEuMSlcblx0ICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICBpZiAoX25hbWVwcmVwVGFibGVBMShjb2RlKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1VOQVNTSUdORURcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBJRE5BIGV4dHJhc1xuXHQgICAgdmFyIG5hbWUgPSB1dGY4Ll90b1V0ZjhTdHJpbmcoY29kZXMpO1xuXHQgICAgLy8gSUROQTogNC4yLjMuMVxuXHQgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIiB8fCBuYW1lLnN1YnN0cmluZygyLCA0KSA9PT0gXCItLVwiIHx8IG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiLVwiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBoeXBoZW5cIik7XG5cdCAgICB9XG5cdCAgICAvLyBJRE5BOiA0LjIuNFxuXHQgICAgaWYgKG5hbWUubGVuZ3RoID4gNjMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbG9uZ1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuYW1lO1xuXHR9XG5cdGV4cG9ydHMubmFtZXByZXAgPSBuYW1lcHJlcDtcblx0fSk7XG5cblx0dmFyIGlkbmEkMSA9IHVud3JhcEV4cG9ydHMoaWRuYSk7XG5cdHZhciBpZG5hXzEgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQTE7XG5cdHZhciBpZG5hXzIgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQjI7XG5cdHZhciBpZG5hXzMgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQztcblx0dmFyIGlkbmFfNCA9IGlkbmEubmFtZXByZXA7XG5cblx0dmFyIGxpYiQ4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IGJ5dGVzMzIuZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSBieXRlczMyLnBhcnNlQnl0ZXMzMlN0cmluZztcblxuXHRleHBvcnRzLm5hbWVwcmVwID0gaWRuYS5uYW1lcHJlcDtcblxuXHRleHBvcnRzLl90b0VzY2FwZWRVdGY4U3RyaW5nID0gdXRmOC5fdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0ZXhwb3J0cy50b1V0ZjhCeXRlcyA9IHV0ZjgudG9VdGY4Qnl0ZXM7XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHV0ZjgudG9VdGY4Q29kZVBvaW50cztcblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB1dGY4LnRvVXRmOFN0cmluZztcblx0ZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB1dGY4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0ZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IHV0ZjguVXRmOEVycm9yRnVuY3M7XG5cdGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0gdXRmOC5VdGY4RXJyb3JSZWFzb247XG5cdH0pO1xuXG5cdHZhciBpbmRleCQ4ID0gdW53cmFwRXhwb3J0cyhsaWIkOCk7XG5cdHZhciBsaWJfMSQ4ID0gbGliJDguZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0dmFyIGxpYl8yJDcgPSBsaWIkOC5wYXJzZUJ5dGVzMzJTdHJpbmc7XG5cdHZhciBsaWJfMyQ2ID0gbGliJDgubmFtZXByZXA7XG5cdHZhciBsaWJfNCQ1ID0gbGliJDguX3RvRXNjYXBlZFV0ZjhTdHJpbmc7XG5cdHZhciBsaWJfNSQ1ID0gbGliJDgudG9VdGY4Qnl0ZXM7XG5cdHZhciBsaWJfNiQzID0gbGliJDgudG9VdGY4Q29kZVBvaW50cztcblx0dmFyIGxpYl83JDMgPSBsaWIkOC50b1V0ZjhTdHJpbmc7XG5cdHZhciBsaWJfOCQyID0gbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuXHR2YXIgbGliXzkkMiA9IGxpYiQ4LlV0ZjhFcnJvckZ1bmNzO1xuXHR2YXIgbGliXzEwJDEgPSBsaWIkOC5VdGY4RXJyb3JSZWFzb247XG5cblx0dmFyIHN0cmluZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBTdHJpbmdDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhTdHJpbmdDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFN0cmluZ0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInN0cmluZ1wiLCBsb2NhbE5hbWUpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBTdHJpbmdDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCB3cml0ZXIsIGxpYiQ4LnRvVXRmOEJ5dGVzKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgU3RyaW5nQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDgudG9VdGY4U3RyaW5nKF9zdXBlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgcmVhZGVyKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFN0cmluZ0NvZGVyO1xuXHR9KGJ5dGVzLkR5bmFtaWNCeXRlc0NvZGVyKSk7XG5cdGV4cG9ydHMuU3RyaW5nQ29kZXIgPSBTdHJpbmdDb2Rlcjtcblx0fSk7XG5cblx0dmFyIHN0cmluZyQxID0gdW53cmFwRXhwb3J0cyhzdHJpbmcpO1xuXHR2YXIgc3RyaW5nXzEgPSBzdHJpbmcuU3RyaW5nQ29kZXI7XG5cblx0dmFyIHR1cGxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIFR1cGxlQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHVwbGVDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFR1cGxlQ29kZXIoY29kZXJzLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBkeW5hbWljID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHR5cGVzID0gW107XG5cdCAgICAgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG5cdCAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmNvZGVycyA9IGNvZGVycztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBUdXBsZUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheS5wYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBUdXBsZUNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBhcnJheS51bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycykpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUdXBsZUNvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5UdXBsZUNvZGVyID0gVHVwbGVDb2Rlcjtcblx0fSk7XG5cblx0dmFyIHR1cGxlJDEgPSB1bndyYXBFeHBvcnRzKHR1cGxlKTtcblx0dmFyIHR1cGxlXzEgPSB0dXBsZS5UdXBsZUNvZGVyO1xuXG5cdHZhciBhYmlDb2RlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5cdHZhciBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuXHR2YXIgQWJpQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBBYmlDb2Rlcihjb2VyY2VGdW5jKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBBYmlDb2Rlcik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMgfHwgbnVsbCk7XG5cdCAgICB9XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuX2dldENvZGVyID0gZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFkZHJlc3MuQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBib29sZWFuXzEuQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmluZy5TdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJ5dGVzLkJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJheS5BcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ0dXBsZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0dXBsZS5UdXBsZUNvZGVyKChwYXJhbS5jb21wb25lbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0Q29kZXIoY29tcG9uZW50KTtcblx0ICAgICAgICAgICAgICAgIH0pLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcIlwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfbnVsbC5OdWxsQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHU/aW50WzAtOV0qXG5cdCAgICAgICAgdmFyIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuXHQgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2IHx8IChzaXplICUgOCkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgbnVtYmVyLk51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gYnl0ZXNbMC05XStcblx0ICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcblx0ICAgICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBmaXhlZEJ5dGVzLkZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuXHQgICAgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0V29yZFNpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMjsgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0UmVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0Q29kZXIuUmVhZGVyKGRhdGEsIHRoaXMuX2dldFdvcmRTaXplKCksIHRoaXMuY29lcmNlRnVuYyk7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLl9nZXRXcml0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBhYnN0cmFjdENvZGVyLldyaXRlcih0aGlzLl9nZXRXb3JkU2l6ZSgpKTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZXM6IHR5cGVzLCB2YWx1ZXM6IHZhbHVlcyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29kZXJzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fZ2V0Q29kZXIoZnJhZ21lbnRzLlBhcmFtVHlwZS5mcm9tKHR5cGUpKTsgfSk7XG5cdCAgICAgICAgdmFyIGNvZGVyID0gKG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcblx0ICAgICAgICB2YXIgd3JpdGVyID0gdGhpcy5fZ2V0V3JpdGVyKCk7XG5cdCAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcblx0ICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldENvZGVyKGZyYWdtZW50cy5QYXJhbVR5cGUuZnJvbSh0eXBlKSk7IH0pO1xuXHQgICAgICAgIHZhciBjb2RlciA9IG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuXHQgICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUodGhpcy5fZ2V0UmVhZGVyKGxpYiQxLmFycmF5aWZ5KGRhdGEpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFiaUNvZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkFiaUNvZGVyID0gQWJpQ29kZXI7XG5cdGV4cG9ydHMuZGVmYXVsdEFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG5cdH0pO1xuXG5cdHZhciBhYmlDb2RlciQxID0gdW53cmFwRXhwb3J0cyhhYmlDb2Rlcik7XG5cdHZhciBhYmlDb2Rlcl8xID0gYWJpQ29kZXIuQWJpQ29kZXI7XG5cdHZhciBhYmlDb2Rlcl8yID0gYWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyO1xuXG5cdHZhciBfdmVyc2lvbiRnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImhhc2gvNS4wLjAtYmV0YS4xMzRcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGggPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGcpO1xuXHR2YXIgX3ZlcnNpb25fMSQ4ID0gX3ZlcnNpb24kZy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkOSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRnLnZlcnNpb24pO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdHZhciBaZXJvcyA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG5cdHZhciBQYXJ0aXRpb24gPSBuZXcgUmVnRXhwKFwiXigoLiopXFxcXC4pPyhbXi5dKykkXCIpO1xuXHRmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHZhciBjb21wcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGxpYiQ4Lm5hbWVwcmVwKGNvbXBzW2ldKS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHRleHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XG5cdGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyAtIFwiICsgU3RyaW5nKG5hbWUpLCBcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gWmVyb3M7XG5cdCAgICB3aGlsZSAobmFtZS5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgcGFydGl0aW9uID0gbmFtZS5tYXRjaChQYXJ0aXRpb24pO1xuXHQgICAgICAgIHZhciBsYWJlbCA9IGxpYiQ4LnRvVXRmOEJ5dGVzKGxpYiQ4Lm5hbWVwcmVwKHBhcnRpdGlvblszXSkpO1xuXHQgICAgICAgIHJlc3VsdCA9IGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW3Jlc3VsdCwgbGliJDQua2VjY2FrMjU2KGxhYmVsKV0pKTtcblx0ICAgICAgICBuYW1lID0gcGFydGl0aW9uWzJdIHx8IFwiXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMubmFtZWhhc2ggPSBuYW1laGFzaDtcblx0ZnVuY3Rpb24gaWQodGV4dCkge1xuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihsaWIkOC50b1V0ZjhCeXRlcyh0ZXh0KSk7XG5cdH1cblx0ZXhwb3J0cy5pZCA9IGlkO1xuXHRleHBvcnRzLm1lc3NhZ2VQcmVmaXggPSBcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7XG5cdGZ1bmN0aW9uIGhhc2hNZXNzYWdlKG1lc3NhZ2UpIHtcblx0ICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbWVzc2FnZSA9IGxpYiQ4LnRvVXRmOEJ5dGVzKG1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW1xuXHQgICAgICAgIGxpYiQ4LnRvVXRmOEJ5dGVzKGV4cG9ydHMubWVzc2FnZVByZWZpeCksXG5cdCAgICAgICAgbGliJDgudG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG5cdCAgICAgICAgbWVzc2FnZVxuXHQgICAgXSkpO1xuXHR9XG5cdGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBoYXNoTWVzc2FnZTtcblx0fSk7XG5cblx0dmFyIGluZGV4JDkgPSB1bndyYXBFeHBvcnRzKGxpYiQ5KTtcblx0dmFyIGxpYl8xJDkgPSBsaWIkOS5pc1ZhbGlkTmFtZTtcblx0dmFyIGxpYl8yJDggPSBsaWIkOS5uYW1laGFzaDtcblx0dmFyIGxpYl8zJDcgPSBsaWIkOS5pZDtcblx0dmFyIGxpYl80JDYgPSBsaWIkOS5tZXNzYWdlUHJlZml4O1xuXHR2YXIgbGliXzUkNiA9IGxpYiQ5Lmhhc2hNZXNzYWdlO1xuXG5cdHZhciBfaW50ZXJmYWNlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0ZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGFic3RyYWN0Q29kZXIuY2hlY2tSZXN1bHRFcnJvcnM7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXHR2YXIgTG9nRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTG9nRGVzY3JpcHRpb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBMb2dEZXNjcmlwdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTG9nRGVzY3JpcHRpb247XG5cdH0obGliJDMuRGVzY3JpcHRpb24pKTtcblx0ZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IExvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUcmFuc2FjdGlvbkRlc2NyaXB0aW9uLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25EZXNjcmlwdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR2YXIgSW5kZXhlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhJbmRleGVkLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSW5kZXhlZCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBJbmRleGVkLmlzSW5kZXhlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW5kZXhlZDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkluZGV4ZWQgPSBJbmRleGVkO1xuXHRmdW5jdGlvbiB3cmFwQWNjZXNzRXJyb3IocHJvcGVydHksIGVycm9yKSB7XG5cdCAgICB2YXIgd3JhcCA9IG5ldyBFcnJvcihcImRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyBcIiArIHByb3BlcnR5KTtcblx0ICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcblx0ICAgIHJldHVybiB3cmFwO1xuXHR9XG5cdC8qXG5cdGZ1bmN0aW9uIGNoZWNrTmFtZXMoZnJhZ21lbnQ6IEZyYWdtZW50LCB0eXBlOiBcImlucHV0XCIgfCBcIm91dHB1dFwiLCBwYXJhbXM6IEFycmF5PFBhcmFtVHlwZT4pOiB2b2lkIHtcblx0ICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuXHQgICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG5cdCAgICAgICAgICAgIGlmIChhY2N1bVtwYXJhbS5uYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2N1bVtwYXJhbS5uYW1lXSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIDx7IFsgbmFtZTogc3RyaW5nIF06IGJvb2xlYW4gfT57IH0pO1xuXHR9XG5cdCovXG5cdHZhciBJbnRlcmZhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbnRlcmZhY2UoZnJhZ21lbnRzJDEpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSW50ZXJmYWNlKTtcblx0ICAgICAgICB2YXIgYWJpID0gW107XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzJDEpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzJDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzJDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHMuRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG5cdCAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gKGZyYWdtZW50ICE9IG51bGwpOyB9KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWJpQ29kZXJcIiwgbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXRBYmlDb2RlclwiKSgpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJlcnJvcnNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInN0cnVjdHNcIiwge30pO1xuXHQgICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuXHQgICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBidWNrZXQgPSBudWxsO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZXBsb3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IF90aGlzLmZ1bmN0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IF90aGlzLmV2ZW50cztcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcblx0ICAgICAgICAgICAgaWYgKGJ1Y2tldFtzaWduYXR1cmVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gXCIgKyBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJ1Y2tldFtzaWduYXR1cmVdID0gZnJhZ21lbnQ7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG5cdCAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKHtcblx0ICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNJbnRlcmZhY2VcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmcmFnbWVudHMuRm9ybWF0VHlwZXMuZnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludGVyZmFjZSBkb2VzIG5vdCBzdXBwb3J0IGZvcm1hdHRpbmcgc2lnaGFzaFwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gZnJhZ21lbnQuZm9ybWF0KGZvcm1hdCk7IH0pO1xuXHQgICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGZyYWdtZW50cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKGZ1bmN0aW9uIChqKSB7IHJldHVybiBKU09OLnBhcnNlKGopOyB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhYmk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoZXNlIHRvIGhhbmRsZSBvdGhlciBibG9ja2NoYWluc1xuXHQgICAgSW50ZXJmYWNlLmdldEFiaUNvZGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRBZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ5LmlkKGZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ5LmlkKGV2ZW50RnJhZ21lbnQuZm9ybWF0KCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmdldEZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkge1xuXHQgICAgICAgIGlmIChsaWIkMS5pc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0aGlzLmZ1bmN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gdGhpcy5nZXRTaWdoYXNoKG5hbWVfMSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV8xXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJzaWdoYXNoXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZV8yKTsgfSk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZV8yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsIFwibmFtZVwiLCBuYW1lXzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vcm1saXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mdW5jdGlvbnNbZnJhZ21lbnRzLkZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcblx0ICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RXZlbnQgPSBmdW5jdGlvbiAobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykge1xuXHQgICAgICAgIGlmIChsaWIkMS5pc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKSkge1xuXHQgICAgICAgICAgICB2YXIgdG9waWNoYXNoID0gbmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gdGhpcy5ldmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0b3BpY2hhc2ggPT09IHRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lXzMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVfM107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwidG9waWNoYXNoXCIsIHRvcGljaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yVG9waWMuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lXzQgPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5ldmVudHMpLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lXzQpOyB9KTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwibmFtZVwiLCBuYW1lXzQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWVfNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTm9ybWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuXHQgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV2ZW50c1tmcmFnbWVudHMuRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpLmZvcm1hdCgpXTtcblx0ICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JUb3BpYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gR2V0IHRoZSBzaWdoYXNoICh0aGUgYnl0ZXM0IHNlbGVjdG9yKSB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0U2lnaGFzaCA9IGZ1bmN0aW9uIChmdW5jdGlvbkZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RXZlbnRUb3BpYyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuX2RlY29kZVBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5fZW5jb2RlUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVEZXBsb3kgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRGVjb2RlIHRoZSBkYXRhIGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gdHguZGF0YSlcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZGVjb2RlRnVuY3Rpb25EYXRhID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdCAgICAgICAgaWYgKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpICE9PSB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCkpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uIFwiICsgZnVuY3Rpb25GcmFnbWVudC5uYW1lICsgXCIuXCIsIFwiZGF0YVwiLCBsaWIkMS5oZXhsaWZ5KGJ5dGVzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcblx0ICAgIH07XG5cdCAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvbkRhdGEgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KGxpYiQxLmNvbmNhdChbXG5cdCAgICAgICAgICAgIHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSxcblx0ICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG5cdCAgICAgICAgXSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIERlY29kZSB0aGUgcmVzdWx0IGZyb20gYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZyb20gZXRoX2NhbGwpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmRlY29kZUZ1bmN0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdCAgICAgICAgdmFyIHJlYXNvbiA9IG51bGw7XG5cdCAgICAgICAgdmFyIGVycm9yU2lnbmF0dXJlID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKGJ5dGVzLmxlbmd0aCAlIHRoaXMuX2FiaUNvZGVyLl9nZXRXb3JkU2l6ZSgpKSB7XG5cdCAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmRlY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlID0gXCJFcnJvcihzdHJpbmcpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiLCBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCksXG5cdCAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlOiBlcnJvclNpZ25hdHVyZSxcblx0ICAgICAgICAgICAgZXJyb3JBcmdzOiBbcmVhc29uXSxcblx0ICAgICAgICAgICAgcmVhc29uOiByZWFzb25cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25SZXN1bHQgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KHRoaXMuX2FiaUNvZGVyLmVuY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZUZpbHRlclRvcGljcyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IGV2ZW50RnJhZ21lbnQuaW5wdXRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIgKyBldmVudEZyYWdtZW50LmZvcm1hdCgpLCBsaWIuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0b3BpY3MgPSBbXTtcblx0ICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlbmNvZGVUb3BpYyA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkOS5pZCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGliJDQua2VjY2FrMjU2KGxpYiQxLmhleGxpZnkodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChsaWIkMS5oZXhsaWZ5KHZhbHVlKSwgMzIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBldmVudEZyYWdtZW50LmlucHV0c1tpbmRleF07XG5cdCAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpOyB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG5cdCAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0b3BpY3MucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b3BpY3M7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVFdmVudExvZyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdG9waWNzID0gW107XG5cdCAgICAgICAgdmFyIGRhdGFUeXBlcyA9IFtdO1xuXHQgICAgICAgIHZhciBkYXRhVmFsdWVzID0gW107XG5cdCAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChsaWIkOS5pZCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobGliJDQua2VjY2FrMjU2KHZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBAVE9PRFxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKF90aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZGF0YTogdGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG5cdCAgICAgICAgICAgIHRvcGljczogdG9waWNzXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5kZWNvZGVFdmVudExvZyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFldmVudEZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICB2YXIgdG9waWNIYXNoID0gdGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpIHx8IHRvcGljc1swXS50b0xvd2VyQ2FzZSgpICE9PSB0b3BpY0hhc2gpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ0b3BpY3NbMF1cIiwgZXhwZWN0ZWQ6IHRvcGljSGFzaCwgdmFsdWU6IHRvcGljc1swXSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmRleGVkID0gW107XG5cdCAgICAgICAgdmFyIG5vbkluZGV4ZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IFtdO1xuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChmcmFnbWVudHMuUGFyYW1UeXBlLmZyb21PYmplY3QoeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgbGliJDEuY29uY2F0KHRvcGljcykpIDogbnVsbDtcblx0ICAgICAgICB2YXIgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgdmFyIG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG5cdCAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogbnVsbCB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10gfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gQWRkIHRoZSBrZXl3b3JkIGFyZ3VtZW50IGlmIG5hbWVkIGFuZCBzYWZlXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5uYW1lICYmIHJlc3VsdFtwYXJhbS5uYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHJlc3VsdFtpbmRleF07XG5cdCAgICAgICAgICAgICAgICAvLyBNYWtlIGVycm9yIG5hbWVkIHZhbHVlcyB0aHJvdyBvbiBhY2Nlc3Ncblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBwYXJhbS5uYW1lLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoXCJwcm9wZXJ0eSBcIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtLm5hbWUpLCB2YWx1ZV8xKTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3BhcmFtLm5hbWVdID0gdmFsdWVfMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0W2ldO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoXCJpbmRleCBcIiArIGksIHZhbHVlKTsgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIE1ha2UgYWxsIGVycm9yIGluZGV4ZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIF9sb29wXzEoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG5cdCAgICB9O1xuXHQgICAgLy8gR2l2ZW4gYSB0cmFuc2FjdGlvbiwgZmluZCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gZnJhZ21lbnQgKGlmIGFueSkgYW5kXG5cdCAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCBjYWxsIHBhcmFtZXRlcnNcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUucGFyc2VUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24odHguZGF0YS5zdWJzdHJpbmcoMCwgMTApLnRvTG93ZXJDYXNlKCkpO1xuXHQgICAgICAgIGlmICghZnJhZ21lbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbih7XG5cdCAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIHR4LmRhdGEuc3Vic3RyaW5nKDEwKSksXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQ6IGZyYWdtZW50LFxuXHQgICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuXHQgICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICBzaWdoYXNoOiB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuXHQgICAgICAgICAgICB2YWx1ZTogbGliJDIuQmlnTnVtYmVyLmZyb20odHgudmFsdWUgfHwgXCIwXCIpLFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG5cdCAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUucGFyc2VMb2cgPSBmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcblx0ICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG5cdCAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG5cdCAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqc3V0IGEgZnJhZ21lbnQ/XG5cdCAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbih7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuXHQgICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuXHQgICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcblx0ICAgICAgICAgICAgYXJnczogdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLypcblx0ICAgIHN0YXRpYyBmcm9tKHZhbHVlOiBBcnJheTxGcmFnbWVudCB8IHN0cmluZyB8IEpzb25BYmk+IHwgc3RyaW5nIHwgSW50ZXJmYWNlKSB7XG5cdCAgICAgICAgaWYgKEludGVyZmFjZS5pc0ludGVyZmFjZSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgICovXG5cdCAgICBJbnRlcmZhY2UuaXNJbnRlcmZhY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW50ZXJmYWNlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW50ZXJmYWNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkludGVyZmFjZSA9IEludGVyZmFjZTtcblx0fSk7XG5cblx0dmFyIF9pbnRlcmZhY2UkMSA9IHVud3JhcEV4cG9ydHMoX2ludGVyZmFjZSk7XG5cdHZhciBfaW50ZXJmYWNlXzEgPSBfaW50ZXJmYWNlLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHR2YXIgX2ludGVyZmFjZV8yID0gX2ludGVyZmFjZS5Mb2dEZXNjcmlwdGlvbjtcblx0dmFyIF9pbnRlcmZhY2VfMyA9IF9pbnRlcmZhY2UuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcblx0dmFyIF9pbnRlcmZhY2VfNCA9IF9pbnRlcmZhY2UuSW5kZXhlZDtcblx0dmFyIF9pbnRlcmZhY2VfNSA9IF9pbnRlcmZhY2UuSW50ZXJmYWNlO1xuXG5cdHZhciBsaWIkYSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudDtcblx0ZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gZnJhZ21lbnRzLkV2ZW50RnJhZ21lbnQ7XG5cdGV4cG9ydHMuRm9ybWF0VHlwZXMgPSBmcmFnbWVudHMuRm9ybWF0VHlwZXM7XG5cdGV4cG9ydHMuRnJhZ21lbnQgPSBmcmFnbWVudHMuRnJhZ21lbnQ7XG5cdGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGZyYWdtZW50cy5GdW5jdGlvbkZyYWdtZW50O1xuXHRleHBvcnRzLlBhcmFtVHlwZSA9IGZyYWdtZW50cy5QYXJhbVR5cGU7XG5cblx0ZXhwb3J0cy5BYmlDb2RlciA9IGFiaUNvZGVyLkFiaUNvZGVyO1xuXHRleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IGFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcjtcblxuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gX2ludGVyZmFjZS5jaGVja1Jlc3VsdEVycm9ycztcblx0ZXhwb3J0cy5JbmRleGVkID0gX2ludGVyZmFjZS5JbmRleGVkO1xuXHRleHBvcnRzLkludGVyZmFjZSA9IF9pbnRlcmZhY2UuSW50ZXJmYWNlO1xuXHRleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gX2ludGVyZmFjZS5Mb2dEZXNjcmlwdGlvbjtcblx0ZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gX2ludGVyZmFjZS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkYSA9IHVud3JhcEV4cG9ydHMobGliJGEpO1xuXHR2YXIgbGliXzEkYSA9IGxpYiRhLkNvbnN0cnVjdG9yRnJhZ21lbnQ7XG5cdHZhciBsaWJfMiQ5ID0gbGliJGEuRXZlbnRGcmFnbWVudDtcblx0dmFyIGxpYl8zJDggPSBsaWIkYS5Gb3JtYXRUeXBlcztcblx0dmFyIGxpYl80JDcgPSBsaWIkYS5GcmFnbWVudDtcblx0dmFyIGxpYl81JDcgPSBsaWIkYS5GdW5jdGlvbkZyYWdtZW50O1xuXHR2YXIgbGliXzYkNCA9IGxpYiRhLlBhcmFtVHlwZTtcblx0dmFyIGxpYl83JDQgPSBsaWIkYS5BYmlDb2Rlcjtcblx0dmFyIGxpYl84JDMgPSBsaWIkYS5kZWZhdWx0QWJpQ29kZXI7XG5cdHZhciBsaWJfOSQzID0gbGliJGEuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBsaWJfMTAkMiA9IGxpYiRhLkluZGV4ZWQ7XG5cdHZhciBsaWJfMTEkMSA9IGxpYiRhLkludGVyZmFjZTtcblx0dmFyIGxpYl8xMiQxID0gbGliJGEuTG9nRGVzY3JpcHRpb247XG5cdHZhciBsaWJfMTMkMSA9IGxpYiRhLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cblx0dmFyIF92ZXJzaW9uJGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJzdHJhY3QtcHJvdmlkZXIvNS4wLjAtYmV0YS4xNDJcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGogPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGkpO1xuXHR2YXIgX3ZlcnNpb25fMSQ5ID0gX3ZlcnNpb24kaS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkYiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kaS52ZXJzaW9uKTtcblx0O1xuXHQ7XG5cdC8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcblx0Ly8gICAgY2FsbCh0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZXF1ZXN0KTogUHJvbWlzZTxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblx0Ly99O1xuXHR2YXIgRm9ya0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZvcmtFdmVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBGb3JrRXZlbnQuaXNGb3JrRXZlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ya0V2ZW50O1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuRm9ya0V2ZW50ID0gRm9ya0V2ZW50O1xuXHR2YXIgQmxvY2tGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQmxvY2tGb3JrRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBCbG9ja0ZvcmtFdmVudChibG9ja0hhc2gsIGV4cGlyeSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhibG9ja0hhc2gsIDMyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgX2lzQmxvY2tGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcblx0ICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcblx0ICAgICAgICB9KSB8fCB0aGlzO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBCbG9ja0ZvcmtFdmVudDtcblx0fShGb3JrRXZlbnQpKTtcblx0ZXhwb3J0cy5CbG9ja0ZvcmtFdmVudCA9IEJsb2NrRm9ya0V2ZW50O1xuXHR2YXIgVHJhbnNhY3Rpb25Gb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25Gb3JrRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkZvcmtFdmVudChoYXNoLCBleHBpcnkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBoYXNoOiBoYXNoXG5cdCAgICAgICAgfSkgfHwgdGhpcztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25Gb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25Gb3JrRXZlbnQgPSBUcmFuc2FjdGlvbkZvcmtFdmVudDtcblx0dmFyIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJiZWZvcmVIYXNoXCIsIGJlZm9yZUhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBiZWZvcmVIYXNoOiBiZWZvcmVIYXNoLFxuXHQgICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuXHQgICAgICAgIH0pIHx8IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCA9IFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRXhwb3J0ZWQgQWJzdHJhY3RzXG5cdHZhciBQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBQcm92aWRlcik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICB9O1xuXHQgICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgfTtcblx0ICAgIFByb3ZpZGVyLmlzUHJvdmlkZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQcm92aWRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Qcm92aWRlciA9IFByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkYiA9IHVud3JhcEV4cG9ydHMobGliJGIpO1xuXHR2YXIgbGliXzEkYiA9IGxpYiRiLkZvcmtFdmVudDtcblx0dmFyIGxpYl8yJGEgPSBsaWIkYi5CbG9ja0ZvcmtFdmVudDtcblx0dmFyIGxpYl8zJDkgPSBsaWIkYi5UcmFuc2FjdGlvbkZvcmtFdmVudDtcblx0dmFyIGxpYl80JDggPSBsaWIkYi5UcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50O1xuXHR2YXIgbGliXzUkOCA9IGxpYiRiLlByb3ZpZGVyO1xuXG5cdHZhciBfdmVyc2lvbiRrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImFic3RyYWN0LXNpZ25lci81LjAuMC1iZXRhLjE0NVwiO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kbCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kayk7XG5cdHZhciBfdmVyc2lvbl8xJGEgPSBfdmVyc2lvbiRrLnZlcnNpb247XG5cblx0dmFyIGxpYiRjID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRrLnZlcnNpb24pO1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcblx0ICAgIFwiY2hhaW5JZFwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ2YWx1ZVwiXG5cdF07XG5cdC8vIFN1Yi1DbGFzcyBOb3Rlczpcblx0Ly8gIC0gQSBTaWduZXIgTVVTVCBhbHdheXMgbWFrZSBzdXJlLCB0aGF0IGlmIHByZXNlbnQsIHRoZSBcImZyb21cIiBmaWVsZFxuXHQvLyAgICBtYXRjaGVzIHRoZSBTaWduZXIsIGJlZm9yZSBzZW5kaW5nIG9yIHNpZ25pbmcgYSB0cmFuc2FjdGlvblxuXHQvLyAgLSBBIFNpZ25lciBTSE9VTEQgYWx3YXlzIHdyYXAgcHJpdmF0ZSBpbmZvcm1hdGlvbiAoc3VjaCBhcyBhIHByaXZhdGVcblx0Ly8gICAga2V5IG9yIG1uZW1vbmljKSBpbiBhIGZ1bmN0aW9uLCBzbyB0aGF0IGNvbnNvbGUubG9nIGRvZXMgbm90IGxlYWtcblx0Ly8gICAgdGhlIGRhdGFcblx0dmFyIFNpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCBzdXBlclxuXHQgICAgZnVuY3Rpb24gU2lnbmVyKCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBTaWduZXIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50ID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhdGlvblxuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZXN0aW1hdGVHYXNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgY2FsbHMgd2l0aCB0aGUgdHJhbnNhdGlvblxuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpLnRoZW4oZnVuY3Rpb24gKHNpZ25lZFR4KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRDaGFpbklkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcms7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRDaGFpbklkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29yay5jaGFpbklkXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJyZXNvbHZlTmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQ2hlY2tzIGEgdHJhbnNhY3Rpb24gZG9lcyBub3QgY29udGFpbiBpbnZhbGlkIGtleXMgYW5kIGlmXG5cdCAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuXHQgICAgLy8gLSBkb2VzIE5PVCByZXF1aXJlIGEgcHJvdmlkZXJcblx0ICAgIC8vIC0gYWRkcyBcImZyb21cIiBpcyBub3QgcHJlc2VudFxuXHQgICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcblx0ICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuXHQgICAgLy8gICAtIGNhbGxcblx0ICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuXHQgICAgLy8gICAtIHBvcHVsYXRlVHJhbnNhY3Rpb24gKGFuZCB0aGVyZWZvciBzZW5kVHJhbnNhY3Rpb24pXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmNoZWNrVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgaWYgKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24ga2V5OiBcIiArIGtleSwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0eC5mcm9tID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuZ2V0QWRkcmVzcygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwcm92aWRlZCBhZGRyZXNzIG1hdGNoZXMgdGhpcyBzaWduZXJcblx0ICAgICAgICAgICAgdHguZnJvbSA9IFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5mcm9tKSxcblx0ICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWRkcmVzcygpXG5cdCAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFswXSAhPT0gcmVzdWx0WzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG5cdCAgICAvLyB0aGlzIFNpZ25lci4gU2hvdWxkIGJlIHVzZWQgYnkgc2VuZFRyYW5zYWN0aW9uIGJ1dCBOT1QgYnkgc2lnblRyYW5zYWN0aW9uLlxuXHQgICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG5cdCAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG5cdCAgICBTaWduZXIucHJvdG90eXBlLnBvcHVsYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbihmdW5jdGlvbiAodG8pIHsgcmV0dXJuIF90aGlzLnJlc29sdmVOYW1lKHRvKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5ub25jZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChcInBlbmRpbmdcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gdGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4OiB0eFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguY2hhaW5JZCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1sxXSAhPT0gMCAmJiByZXN1bHRzWzBdICE9PSByZXN1bHRzWzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTdWItY2xhc3NlcyBTSE9VTEQgbGVhdmUgdGhlc2UgYWxvbmVcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuX2NoZWNrUHJvdmlkZXIgPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTaWduZXIuaXNTaWduZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2lnbmVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlNpZ25lciA9IFNpZ25lcjtcblx0dmFyIFZvaWRTaWduZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVm9pZFNpZ25lciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFZvaWRTaWduZXIoYWRkcmVzcywgcHJvdmlkZXIpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgVm9pZFNpZ25lcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuX2ZhaWwgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBvcGVyYXRpb24gfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVm9pZFNpZ25lcjtcblx0fShTaWduZXIpKTtcblx0ZXhwb3J0cy5Wb2lkU2lnbmVyID0gVm9pZFNpZ25lcjtcblx0fSk7XG5cblx0dmFyIGluZGV4JGMgPSB1bndyYXBFeHBvcnRzKGxpYiRjKTtcblx0dmFyIGxpYl8xJGMgPSBsaWIkYy5TaWduZXI7XG5cdHZhciBsaWJfMiRiID0gbGliJGMuVm9pZFNpZ25lcjtcblxuXHR2YXIgX3ZlcnNpb24kbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJjb250cmFjdHMvNS4wLjAtYmV0YS4xNTZcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJG4gPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJG0pO1xuXHR2YXIgX3ZlcnNpb25fMSRiID0gX3ZlcnNpb24kbS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0dmFyIF9fc3ByZWFkQXJyYXlzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblx0ICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcblx0ICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcblx0ICAgICAgICAgICAgcltrXSA9IGFbal07XG5cdCAgICByZXR1cm4gcjtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXHQvL2ltcG9ydCB7IEFkZHJlc3NaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuXG5cdC8vIEBUT09EIHJlbW92ZSBkZXBlbmRlbmNlcyB0cmFuc2FjdGlvbnNcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRtLnZlcnNpb24pO1xuXHQ7XG5cdDtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcblx0ICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZVxuXHR9O1xuXHRmdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlciwgbmFtZU9yUHJvbWlzZSkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBuYW1lO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuYW1lT3JQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywganVzdCB1c2UgaXQgKGFmdGVyIGFkZGluZyBjaGVja3N1bSlcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJDYuZ2V0QWRkcmVzcyhuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImEgcHJvdmlkZXIgb3Igc2lnbmVyIGlzIG5lZWRlZCB0byByZXNvbHZlIEVOUyBuYW1lc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlci5yZXNvbHZlTmFtZShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHQvLyBSZWN1cnNpdmVseSByZXBsYWNlcyBFTlMgbmFtZXMgd2l0aCBwcm9taXNlcyB0byByZXNvbHZlIHRoZSBuYW1lIGFuZCByZXNvbHZlcyBhbGwgcHJvcGVydGllc1xuXHRmdW5jdGlvbiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2YWx1ZSwgcGFyYW1UeXBlKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbVR5cGUpKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcmFtVHlwZS5tYXAoZnVuY3Rpb24gKHBhcmFtVHlwZSwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWVbaW5kZXhdIDogdmFsdWVbcGFyYW1UeXBlLm5hbWVdKSwgcGFyYW1UeXBlKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICB9XG5cdCAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc29sdmVOYW1lKHJlc29sdmVyLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwidHVwbGVcIikge1xuXHQgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2YWx1ZSwgcGFyYW1UeXBlLmNvbXBvbmVudHMpO1xuXHQgICAgfVxuXHQgICAgaWYgKHBhcmFtVHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBhcnJheVwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdiwgcGFyYW1UeXBlLmFycmF5Q2hpbGRyZW4pOyB9KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0fVxuXHRmdW5jdGlvbiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvdmVycmlkZXMsIHJlc29sdmVkLCB0eCwgcm8sIHJvVmFsdWUsIGxlZnRvdmVycztcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IGxpYiQzLnNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmFtZXRlciBjb3VudCBtYXRjaGVzXG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJwYXNzZWQgdG8gY29udHJhY3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgXCJmcm9tXCIgb3ZlcnJpZGUgKGFsbG93IHByb21pc2VzKVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdC5zaWduZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aCBhIFNpZ25lciBhcmUgZnJvbSB0aGUgU2lnbmVyJ3MgZnJhbWUtb2YtcmVmZXJlbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGFsbG93IG92ZXJyaWRpbmcgXCJmcm9tXCIgaWYgaXQgbWF0Y2hlcyB0aGUgc2lnbmVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZTogcmVzb2x2ZU5hbWUoY29udHJhY3Quc2lnbmVyLCBvdmVycmlkZXMuZnJvbSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiBjb250cmFjdC5zaWduZXIuZ2V0QWRkcmVzcygpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjaGVjaykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3MoY2hlY2suc2lnbmVyKSAhPT0gY2hlY2sub3ZlcnJpZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ29udHJhY3Qgd2l0aCBhIFNpZ25lciBjYW5ub3Qgb3ZlcnJpZGUgZnJvbVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLmZyb21cIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNoZWNrLm92ZXJyaWRlXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVycmlkZXMuZnJvbSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IHJlc29sdmVOYW1lKGNvbnRyYWN0LnByb3ZpZGVyLCBvdmVycmlkZXMuZnJvbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGhvdXQgYSBzaWduZXIgY2FuIG92ZXJyaWRlIFwiZnJvbVwiLCBhbmQgaWZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5zcGVjaWZpZWQgdGhlIHplcm8gYWRkcmVzcyBpcyB1c2VkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGVzLmZyb20gPSBBZGRyZXNzWmVybztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVzb2x2ZUFkZHJlc3Nlcyhjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIsIGFyZ3MsIGZyYWdtZW50LmlucHV0cyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdC5yZXNvbHZlZEFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IChsaWIkMy5yZXNvbHZlUHJvcGVydGllcyhvdmVycmlkZXMpIHx8IHt9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHggPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkLmFyZ3MpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZWQuYWRkcmVzc1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgcm8gPSByZXNvbHZlZC5vdmVycmlkZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgc2ltcGxlIG92ZXJyaWRlc1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5ub25jZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm5vbmNlID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8ubm9uY2UpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5nYXNMaW1pdCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8uZ2FzTGltaXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8uZ2FzUHJpY2UgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHJvLmdhc1ByaWNlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLmZyb20gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5mcm9tID0gcm8uZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIFwiZ2FzTGltaXRcIiBvdmVycmlkZSwgYnV0IHRoZSBBQkkgc3BlY2lmaWVzIGEgZGVmYXVsdCwgdXNlIGl0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwgJiYgZnJhZ21lbnQuZ2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShmcmFnbWVudC5nYXMpLmFkZCgyMTAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIFwidmFsdWVcIiBvdmVycmlkZVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb1ZhbHVlID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvVmFsdWUuaXNaZXJvKCkgJiYgIWZyYWdtZW50LnBheWFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlcy52YWx1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgudmFsdWUgPSByb1ZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZW12b2UgdGhlIG92ZXJyaWRlc1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubm9uY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNMaW1pdDtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmdhc1ByaWNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGxlZnRvdmVycyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChvdmVycmlkZXNba2V5XSAhPSBudWxsKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRvdmVycy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBsZWZ0b3ZlcnMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfSkuam9pbihcIixcIiksIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiBsZWZ0b3ZlcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0eF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyldO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnJhZ21lbnQpIHtcblx0ICAgIHZhciBzaWduZXJPclByb3ZpZGVyID0gKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlcik7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWduZXJPclByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImVzdGltYXRlIHJlcXVpcmUgYSBwcm92aWRlciBvciBzaWduZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2lnbmVyT3JQcm92aWRlci5lc3RpbWF0ZUdhcyh0eCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuXHQgICAgdmFyIHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrVGFnLCBvdmVycmlkZXMsIHR4LCByZXN1bHQsIHZhbHVlO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBsaWIkMy5zaGFsbG93Q29weShhcmdzLnBvcCgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEob3ZlcnJpZGVzLmJsb2NrVGFnICE9IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgb3ZlcnJpZGVzLmJsb2NrVGFnXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb250cmFjdC5fZGVwbG95ZWQoYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzaWduZXJPclByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZVNpbXBsZSAmJiBmcmFnbWVudC5vdXRwdXRzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkcmVzcyA9IGNvbnRyYWN0LmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuYXJncyA9IGFyZ3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4UmVxdWVzdCwgdHgsIHdhaXQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udHJhY3Quc2lnbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uICE9IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udHJhY3QuX2RlcGxveWVkKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHhSZXF1ZXN0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb250cmFjdC5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4UmVxdWVzdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdhaXQgPSB0eC53YWl0LmJpbmQodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC53YWl0ID0gZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWl0KGNvbmZpcm1hdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50cyA9IHJlY2VpcHQubG9ncy5tYXAoZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBsaWIkMy5kZWVwQ29weShsb2cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgZXZlbnQgbG9nOyBpbmNsdWRlIGl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBwYXJzZWQuYXJncztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZC5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZC5zaWduYXR1cmU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZnVsIG9wZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cmFjdC5wcm92aWRlcjsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja0hhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihyZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVjZWlwdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHhdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcblx0ICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuXHQgICAgICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZmlsdGVyKSB7XG5cdCAgICBpZiAoZmlsdGVyLmFkZHJlc3MgJiYgKGZpbHRlci50b3BpY3MgPT0gbnVsbCB8fCBmaWx0ZXIudG9waWNzLmxlbmd0aCA9PT0gMCkpIHtcblx0ICAgICAgICByZXR1cm4gXCIqXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGZpbHRlci5hZGRyZXNzIHx8IFwiKlwiKSArIFwiQFwiICsgKGZpbHRlci50b3BpY3MgPyBmaWx0ZXIudG9waWNzLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRvcGljLmpvaW4oXCJ8XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9waWM7XG5cdCAgICB9KS5qb2luKFwiOlwiKSA6IFwiXCIpO1xuXHR9XG5cdHZhciBSdW5uaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSdW5uaW5nRXZlbnQodGFnLCBmaWx0ZXIpIHtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZmlsdGVyXCIsIGZpbHRlcik7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cdCAgICB9XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lcjogbGlzdGVuZXIsIG9uY2U6IG9uY2UgfSk7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXHQgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICBpZiAoZG9uZSB8fCBpdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5saXN0ZW5lcjsgfSk7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBsaXN0ZW5lckNvdW50ID0gdGhpcy5saXN0ZW5lckNvdW50KCk7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgYXJnc0NvcHkgPSBhcmdzLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGluIHRoZSBuZXh0IGV2ZW50IGxvb3Bcblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtLmxpc3RlbmVyLmFwcGx5KF90aGlzLCBhcmdzQ29weSk7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICAvLyBSZXNjaGVkdWxlIGl0IGlmIGl0IG5vdCBcIm9uY2VcIlxuXHQgICAgICAgICAgICByZXR1cm4gIShpdGVtLm9uY2UpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50O1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucHJlcGFyZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJucyB0aGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYW4gZW1pdFxuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5nZXRFbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIFtldmVudF07XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJ1bm5pbmdFdmVudDtcblx0fSgpKTtcblx0dmFyIEVycm9yUnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEVycm9yUnVubmluZ0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXJyb3JSdW5uaW5nRXZlbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgbnVsbCkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBFcnJvclJ1bm5pbmdFdmVudDtcblx0fShSdW5uaW5nRXZlbnQpKTtcblx0Ly8gQFRPRE8gRnJhZ21lbnQgc2hvdWxkIGluaGVyaXQgV2lsZGNhcmQ/IGFuZCBqdXN0IG92ZXJyaWRlIGdldEVtaXQ/XG5cdC8vICAgICAgIG9yIGhhdmUgYSBjb21tb24gYWJzdHJhY3Qgc3VwZXIgY2xhc3MsIHdpdGggZW5vdWdoIGNvbnN0cnVjdG9yXG5cdC8vICAgICAgIG9wdGlvbnMgdG8gY29uZmlndXJlIGJvdGguXG5cdC8vIEEgRnJhZ21lbnQgRXZlbnQgd2lsbCBwb3B1bGF0ZSBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCBXaWxkY2FyZFxuXHQvLyB3aWxsLCBhbmQgYWRkaXRpb2FubGx5IGRlcmVmZXJlbmNlIHRoZSBhcmd1bWVudHMgd2hlbiBlbWl0dGluZ1xuXHR2YXIgRnJhZ21lbnRSdW5uaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRnJhZ21lbnRSdW5uaW5nRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGcmFnbWVudFJ1bm5pbmdFdmVudChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgZnJhZ21lbnQsIHRvcGljcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGZpbHRlciA9IHtcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIHRvcGljID0gY29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7XG5cdCAgICAgICAgaWYgKHRvcGljcykge1xuXHQgICAgICAgICAgICBpZiAodG9waWMgIT09IHRvcGljc1swXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsIFwidG9waWNzXCIsIHRvcGljcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IFt0b3BpY107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSB8fCB0aGlzO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRnJhZ21lbnRSdW5uaW5nRXZlbnQucHJvdG90eXBlLnByZXBhcmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wcmVwYXJlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICAgICAgZXZlbnQuZXZlbnQgPSB0aGlzLmZyYWdtZW50Lm5hbWU7XG5cdCAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuXHQgICAgICAgIGV2ZW50LmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhfdGhpcy5mcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBldmVudC5kYXRhLCBldmVudC50b3BpY3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgZXZlbnQuYXJncyA9IG51bGw7XG5cdCAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50UnVubmluZ0V2ZW50LnByb3RvdHlwZS5nZXRFbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIGVycm9ycyA9IGxpYiRhLmNoZWNrUmVzdWx0RXJyb3JzKGV2ZW50LmFyZ3MpO1xuXHQgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yc1swXS5lcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFyZ3MgPSAoZXZlbnQuYXJncyB8fCBbXSkuc2xpY2UoKTtcblx0ICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBhcmdzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGcmFnbWVudFJ1bm5pbmdFdmVudDtcblx0fShSdW5uaW5nRXZlbnQpKTtcblx0Ly8gQSBXaWxkYXJkIEV2ZW50IHdpbGwgYXR0ZW1wdCB0byBwb3B1bGF0ZTpcblx0Ly8gIC0gZXZlbnQgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgbmFtZVxuXHQvLyAgLSBldmVudFNpZ25hdHVyZSAgIFRoZSBmdWxsIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnRcblx0Ly8gIC0gZGVjb2RlICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGRlY29kZSBkYXRhIGFuZCB0b3BpY3Ncblx0Ly8gIC0gYXJncyAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGFuZCB0b3BpY3Ncblx0dmFyIFdpbGRjYXJkUnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdpbGRjYXJkUnVubmluZ0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2lsZGNhcmRSdW5uaW5nRXZlbnQoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIipcIiwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pIHx8IHRoaXM7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJpbnRlcmZhY2VcIiwgY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFdpbGRjYXJkUnVubmluZ0V2ZW50LnByb3RvdHlwZS5wcmVwYXJlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUucHJlcGFyZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJzZWRfMSA9IHRoaXMuaW50ZXJmYWNlLnBhcnNlTG9nKGV2ZW50KTtcblx0ICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWRfMS5uYW1lO1xuXHQgICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZF8xLnNpZ25hdHVyZTtcblx0ICAgICAgICAgICAgZXZlbnQuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEsIHRvcGljcykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWRfMS5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkXzEuYXJncztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIC8vIE5vIG1hdGNoaW5nIGV2ZW50XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBXaWxkY2FyZFJ1bm5pbmdFdmVudDtcblx0fShSdW5uaW5nRXZlbnQpKTtcblx0dmFyIENvbnRyYWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ29udHJhY3QoYWRkcmVzc09yTmFtZSwgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgQ29udHJhY3QpO1xuXHQgICAgICAgIC8vIEBUT0RPOiBNYXliZSBzdGlsbCBjaGVjayB0aGUgYWRkcmVzc09yTmFtZSBsb29rcyBsaWtlIGEgdmFsaWQgYWRkcmVzcyBvciBuYW1lP1xuXHQgICAgICAgIC8vYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtcblx0ICAgICAgICBpZiAoc2lnbmVyT3JQcm92aWRlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgbnVsbCk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChsaWIkYy5TaWduZXIuaXNTaWduZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyLnByb3ZpZGVyIHx8IG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobGliJGIuUHJvdmlkZXIuaXNQcm92aWRlcihzaWduZXJPclByb3ZpZGVyKSkge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNpZ25lciBvciBwcm92aWRlclwiLCBcInNpZ25lck9yUHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY2FsbFN0YXRpY1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJlc3RpbWF0ZUdhc1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJzXCIsIHt9KTtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciB1bmlxdWVGaWx0ZXJzXzEgPSB7fTtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNpZ25hdHVyZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3RoaXMuaW50ZXJmYWNlLmV2ZW50c1tldmVudFNpZ25hdHVyZV07XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5maWx0ZXJzLCBldmVudFNpZ25hdHVyZSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBfdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3M6IF90aGlzLmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZXZlbnQsIGFyZ3MpXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVGaWx0ZXJzXzFbZXZlbnQubmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzXzFbZXZlbnQubmFtZV0gPSBbXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNfMVtldmVudC5uYW1lXS5wdXNoKGV2ZW50U2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZUZpbHRlcnNfMSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSB1bmlxdWVGaWx0ZXJzXzFbbmFtZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5maWx0ZXJzLCBuYW1lLCBfdGhpcy5maWx0ZXJzW2ZpbHRlcnNbMF1dKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRHVwbGljYXRlIGRlZmluaXRpb24gb2YgXCIgKyBuYW1lICsgXCIgKFwiICsgZmlsdGVycy5qb2luKFwiLCBcIikgKyBcIilcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9ydW5uaW5nRXZlbnRzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl93cmFwcGVkRW1pdHNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzT3JOYW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG5vdCBmb3VuZFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuXHQgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IENhbm5vdCBmaW5kIENvbnRyYWN0IC0gXCIgKyBhZGRyZXNzT3JOYW1lKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgUHJvbWlzZS5yZXNvbHZlKGxpYiQ2LmdldEFkZHJlc3MoYWRkcmVzc09yTmFtZSkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgYSBwcm92aWRlciwgd2UgY2Fubm90IHVzZSBFTlMgbmFtZXNcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgaXMgcmVxdWlyZWQgdG8gdXNlIEVOUyBuYW1lIGFzIGNvbnRyYWN0IGFkZHJlc3NcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBDb250cmFjdFwiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdW5pcXVlTmFtZXMgPSB7fTtcblx0ICAgICAgICB2YXIgdW5pcXVlU2lnbmF0dXJlcyA9IHt9O1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG5cdCAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IF90aGlzLmludGVyZmFjZS5mdW5jdGlvbnNbc2lnbmF0dXJlXTtcblx0ICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2lnbmF0dXJlIGlzIHVuaXF1ZTsgaWYgbm90IHRoZSBBQkkgZ2VuZXJhdGlvbiBoYXNcblx0ICAgICAgICAgICAgLy8gbm90IGJlZW4gY2xlYW5lZCBvciBtYXkgYmUgaW5jb3JyZWN0bHkgZ2VuZXJhdGVkXG5cdCAgICAgICAgICAgIGlmICh1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRHVwbGljYXRlIEFCSSBlbnRyeSBmb3IgXCIgKyBKU09OLnN0cmluZ2lmeShuYW1lKSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG5cdCAgICAgICAgICAgIC8vIGFyZSBhbWJpZ3VvdXNcblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGZyYWdtZW50Lm5hbWU7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZU5hbWVzW25hbWVfMV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tuYW1lXzFdID0gW107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tuYW1lXzFdLnB1c2goc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgc2lnbmF0dXJlLCBidWlsZERlZmF1bHQoX3RoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNvbGxhcHNlIHNpbXBsZSBjYWxscyBvbiB0aGlzIGJ1Y2tldCwgd2hpY2ggYWxsb3dzXG5cdCAgICAgICAgICAgIC8vIGZyYW1ld29ya3MgdG8gc2FmZWx5IHVzZSB0aGlzIHdpdGhvdXQgaW50cm9zcGVjdGlvbiBhcyB3ZWxsIGFzXG5cdCAgICAgICAgICAgIC8vIGFsbG93cyBkZWNvZGluZyBlcnJvciByZWNvdmVyeS5cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmZ1bmN0aW9ucywgc2lnbmF0dXJlLCBidWlsZERlZmF1bHQoX3RoaXMsIGZyYWdtZW50LCBmYWxzZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuY2FsbFN0YXRpYywgc2lnbmF0dXJlLCBidWlsZENhbGwoX3RoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIGJ1aWxkUG9wdWxhdGUoX3RoaXMsIGZyYWdtZW50KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZXN0aW1hdGVHYXMsIHNpZ25hdHVyZSwgYnVpbGRFc3RpbWF0ZShfdGhpcywgZnJhZ21lbnQpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZU5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgIC8vIEFtYmlndW91cyBuYW1lcyB0byBub3QgZ2V0IGF0dGFjaGVkIGFzIGJhcmUgbmFtZXNcblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZXMgPSB1bmlxdWVOYW1lc1tuYW1lXTtcblx0ICAgICAgICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBzaWduYXR1cmVzWzBdO1xuXHQgICAgICAgICAgICBpZiAoX3RoaXNbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIG5hbWUsIF90aGlzW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5mdW5jdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZnVuY3Rpb25zLCBuYW1lLCBfdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmNhbGxTdGF0aWNbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuY2FsbFN0YXRpYywgbmFtZSwgX3RoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBuYW1lLCBfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5lc3RpbWF0ZUdhc1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5lc3RpbWF0ZUdhcywgbmFtZSwgX3RoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIENvbnRyYWN0LmdldENvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LmdldEludGVyZmFjZSA9IGZ1bmN0aW9uIChjb250cmFjdEludGVyZmFjZSkge1xuXHQgICAgICAgIGlmIChsaWIkYS5JbnRlcmZhY2UuaXNJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb250cmFjdEludGVyZmFjZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBsaWIkYS5JbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIC8vIEBUT0RPOiBBbGxvdyB0aW1lb3V0P1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmRlcGxveWVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZCgpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fZGVwbG95ZWQgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghdGhpcy5fZGVwbG95ZWRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgIC8vIElmIHdlIHdlcmUganVzdCBkZXBsb3llZCwgd2Uga25vdyB0aGUgdHJhbnNhY3Rpb24gd2Ugc2hvdWxkIG9jY3VyIGluXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kZXBsb3llZFByb21pc2UgPSB0aGlzLmRlcGxveVRyYW5zYWN0aW9uLndhaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBPbmNlIHdlIGFsbG93IGEgdGltZW91dCB0byBiZSBwYXNzZWQgaW4sIHdlIHdpbGwgd2FpdFxuXHQgICAgICAgICAgICAgICAgLy8gdXAgdG8gdGhhdCBtYW55IGJsb2NrcyBmb3IgZ2V0Q29kZVxuXHQgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBwb2xsIGZvciBvdXIgY29kZSB0byBiZSBkZXBsb3llZFxuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcywgYmxvY2tUYWcpLnRoZW4oZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY29udHJhY3Qgbm90IGRlcGxveWVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBfdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldERlcGxveWVkXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZFByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86XG5cdCAgICAvLyBlc3RpbWF0ZUZhbGxiYWNrKG92ZXJyaWRlcz86IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8QmlnTnVtYmVyPlxuXHQgICAgLy8gQFRPRE86XG5cdCAgICAvLyBlc3RpbWF0ZURlcGxveShieXRlY29kZTogc3RyaW5nLCAuLi5hcmdzKTogUHJvbWlzZTxCaWdOdW1iZXI+XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMuc2lnbmVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uKGZhbGxiYWNrKVwiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSBsaWIkMy5zaGFsbG93Q29weShvdmVycmlkZXMgfHwge30pO1xuXHQgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiICsga2V5LCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdHgudG8gPSB0aGlzLnJlc29sdmVkQWRkcmVzcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5kZXBsb3llZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVjb25uZWN0IHRvIGEgZGlmZmVyZW50IHNpZ25lciBvciBwcm92aWRlclxuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoc2lnbmVyT3JQcm92aWRlcikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHNpZ25lck9yUHJvdmlkZXIpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHNpZ25lck9yUHJvdmlkZXIgPSBuZXcgbGliJGMuVm9pZFNpZ25lcihzaWduZXJPclByb3ZpZGVyLCB0aGlzLnByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0aGlzLmRlcGxveVRyYW5zYWN0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuXHQgICAgfTtcblx0ICAgIC8vIFJlLWF0dGFjaCB0byBhIGRpZmZlcmVudCBvbi1jaGFpbiBpbnN0YW5jZSBvZiB0aGlzIGNvbnRyYWN0XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QuaXNJbmRleGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiRhLkluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudCA9IGZ1bmN0aW9uIChydW5uaW5nRXZlbnQpIHtcblx0ICAgICAgICAvLyBBbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBldmVudCBydW5uaW5nOyB3ZSBjYW4gcmUtdXNlIGl0XG5cdCAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ10pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydW5uaW5nRXZlbnQ7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl9nZXRSdW5uaW5nRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIFwiZXJyb3JcIiBldmVudHMgKGlmIHlvdXIgY29udHJhY3QgaGFzIGFuIGVycm9yIGV2ZW50LCBpbmNsdWRlXG5cdCAgICAgICAgICAgIC8vIHRoZSBmdWxsIHNpZ25hdHVyZSB0byBieXBhc3MgdGhpcyBzcGVjaWFsIGV2ZW50IGtleXdvcmQpXG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRXJyb3JSdW5uaW5nRXZlbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KFwiZXZlbnRcIiwgbnVsbCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgYW55IGV2ZW50XG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiKlwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gR2V0IHRoZSBldmVudCBGcmFnbWVudCAodGhyb3dzIGlmIGFtYmlndW91cy91bmtub3duIGV2ZW50KVxuXHQgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBXZSBoYXZlIHRvcGljcyB0byBmaWx0ZXIgYnkuLi5cblx0ICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgLy8gSXMgaXQgYSBrbm93biB0b3BpY2hhc2g/ICh0aHJvd3MgaWYgbm8gbWF0Y2hpbmcgdG9waWNoYXNoKVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvcGljID0gZXZlbnROYW1lLnRvcGljc1swXTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9waWNcIik7IC8vIEBUT0RPOiBNYXkgaGFwcGVuIGZvciBhbm9ueW1vdXMgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudCh0b3BpYyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHtcblx0ICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgIHRvcGljczogZXZlbnROYW1lLnRvcGljc1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX2NoZWNrUnVubmluZ0V2ZW50cyA9IGZ1bmN0aW9uIChydW5uaW5nRXZlbnQpIHtcblx0ICAgICAgICBpZiAocnVubmluZ0V2ZW50Lmxpc3RlbmVyQ291bnQoKSA9PT0gMCkge1xuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvbGxlciBmb3IgdGhpcywgcmVtb3ZlIGl0XG5cdCAgICAgICAgICAgIHZhciBlbWl0ID0gdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuXHQgICAgICAgICAgICBpZiAoZW1pdCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vZmYocnVubmluZ0V2ZW50LmZpbHRlciwgZW1pdCk7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZ3JhY2VmdWxseSByZWNvdmVyXG5cdCAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fd3JhcEV2ZW50ID0gZnVuY3Rpb24gKHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0gbGliJDMuZGVlcENvcHkobG9nKTtcblx0ICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgIF90aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGV2ZW50LmdldEJsb2NrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJvdmlkZXIuZ2V0QmxvY2sobG9nLmJsb2NrSGFzaCk7IH07XG5cdCAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKTsgfTtcblx0ICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQobG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG5cdCAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cgaWYgdGhlIHRvcGljcyBhbmQgZGF0YSBtaXNtYXRjaCB0aGUgc2lnbmF0dXJlXG5cdCAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGV2ZW50O1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChydW5uaW5nRXZlbnQsIGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJldmVudHMgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIGEgc2lnbmVyIHdpdGggYSBwcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIm9uY2VcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcnVubmluZ0V2ZW50LmFkZExpc3RlbmVyKGxpc3RlbmVyLCBvbmNlKTtcblx0ICAgICAgICAvLyBUcmFjayB0aGlzIHJ1bm5pbmcgZXZlbnQgYW5kIGl0cyBsaXN0ZW5lcnMgKG1heSBhbHJlYWR5IGJlIHRoZXJlOyBidXQgbm8gaGFyZCBpbiB1cGRhdGluZylcblx0ICAgICAgICB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddID0gcnVubmluZ0V2ZW50O1xuXHQgICAgICAgIC8vIElmIHdlIGFyZSBub3QgcG9sbGluZyB0aGUgcHJvdmlkZXIsIHN0YXJ0IHBvbGxpbmdcblx0ICAgICAgICBpZiAoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSkge1xuXHQgICAgICAgICAgICB2YXIgd3JhcHBlZEVtaXQgPSBmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBfdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZW1pdCB0aGUgcmVzdWx0IGZvciB0aGUgcGFyYW1ldGVyaXplZCBldmVudC4uLlxuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlY29kZUVycm9yID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdC5hcHBseShfdGhpcywgX19zcHJlYWRBcnJheXMoW3J1bm5pbmdFdmVudC5maWx0ZXJdLCBhcmdzKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGVFcnJvciA9IGVycm9yLmVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBlbWl0IFwiZXZlbnRcIiBmb3IgZnJhZ21lbnQtYmFzZSBldmVudHNcblx0ICAgICAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZXZlbnRcIiwgZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gRW1pdCBcImVycm9yXCIgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudC5kZWNvZGVFcnJvciwgZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10gPSB3cmFwcGVkRW1pdDtcblx0ICAgICAgICAgICAgLy8gU3BlY2lhbCBldmVudHMsIGxpa2UgXCJlcnJvclwiIGRvIG5vdCBoYXZlIGEgZmlsdGVyXG5cdCAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlciwgd3JhcHBlZEVtaXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5xdWVyeUZpbHRlciA9IGZ1bmN0aW9uIChldmVudCwgZnJvbUJsb2NrT3JCbG9ja2hhc2gsIHRvQmxvY2spIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHZhciBmaWx0ZXIgPSBsaWIkMy5zaGFsbG93Q29weShydW5uaW5nRXZlbnQuZmlsdGVyKTtcblx0ICAgICAgICBpZiAodHlwZW9mIChmcm9tQmxvY2tPckJsb2NraGFzaCkgPT09IFwic3RyaW5nXCIgJiYgbGliJDEuaXNIZXhTdHJpbmcoZnJvbUJsb2NrT3JCbG9ja2hhc2gsIDMyKSkge1xuXHQgICAgICAgICAgICBpZiAodG9CbG9jayAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGZyb21CbG9ja09yQmxvY2toYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9ICgoZnJvbUJsb2NrT3JCbG9ja2hhc2ggIT0gbnVsbCkgPyBmcm9tQmxvY2tPckJsb2NraGFzaCA6IDApO1xuXHQgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4oZnVuY3Rpb24gKGxvZ3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKGZ1bmN0aW9uIChsb2cpIHsgcmV0dXJuIF90aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIG51bGwpOyB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgZmFsc2UpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIHRydWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSAocnVubmluZ0V2ZW50LnJ1bihhcmdzKSA+IDApO1xuXHQgICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lckNvdW50KCk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nRXZlbnRzW3RhZ10ubGlzdGVuZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRfMS5wdXNoKGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVycygpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdGFnIGluIHRoaXMuX3J1bm5pbmdFdmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBydW5uaW5nRXZlbnRfMSA9IHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtcblx0ICAgICAgICAgICAgICAgIHJ1bm5pbmdFdmVudF8xLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudF8xKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRGVsZXRlIGFueSBsaXN0ZW5lcnNcblx0ICAgICAgICB2YXIgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG5cdCAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENvbnRyYWN0O1xuXHR9KCkpO1xuXHRleHBvcnRzLkNvbnRyYWN0ID0gQ29udHJhY3Q7XG5cdHZhciBDb250cmFjdEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBDb250cmFjdEZhY3RvcnkoY29udHJhY3RJbnRlcmZhY2UsIGJ5dGVjb2RlLCBzaWduZXIpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIGJ5dGVjb2RlSGV4ID0gbnVsbDtcblx0ICAgICAgICBpZiAodHlwZW9mIChieXRlY29kZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobGliJDEuaXNCeXRlcyhieXRlY29kZSkpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBsaWIkMS5oZXhsaWZ5KGJ5dGVjb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYnl0ZWNvZGUgJiYgdHlwZW9mIChieXRlY29kZS5vYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZS5vYmplY3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBDcmFzaCBpbiB0aGUgbmV4dCB2ZXJpZmljYXRpb24gc3RlcFxuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IFwiIVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYWtlIHN1cmUgaXQgaXMgMHggcHJlZml4ZWRcblx0ICAgICAgICBpZiAoYnl0ZWNvZGVIZXguc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmaW5hbCByZXN1bHQgaXMgdmFsaWQgYnl0ZWNvZGVcblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKGJ5dGVjb2RlSGV4KSB8fCAoYnl0ZWNvZGVIZXgubGVuZ3RoICUgMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZWNvZGVcIiwgXCJieXRlY29kZVwiLCBieXRlY29kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIElmIHdlIGhhdmUgYSBzaWduZXIsIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuXHQgICAgICAgIGlmIChzaWduZXIgJiYgIWxpYiRjLlNpZ25lci5pc1NpZ25lcihzaWduZXIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNpZ25lclwiLCBcInNpZ25lclwiLCBzaWduZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImJ5dGVjb2RlXCIsIGJ5dGVjb2RlSGV4KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIHNpZ25lciB8fCBudWxsKTtcblx0ICAgIH1cblx0ICAgIC8vIEBUT0RPOiBGdXR1cmU7IHJlbmFtZSB0byBwb3B1bHRlVHJhbnNhY3Rpb24/XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmdldERlcGxveVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSB7fTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIDEgYWRkaXRpb25hbCBhcmd1bWVudCwgd2UgYWxsb3cgdHJhbnNhY3Rpb24gb3ZlcnJpZGVzXG5cdCAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICAgIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0eCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkVHJhbnNhY3Rpb25LZXlzW2tleV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiICsga2V5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEbyBub3QgYWxsb3cgdGhlc2UgdG8gYmUgb3ZlcnJpZGRlbiBpbiBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb25cblx0ICAgICAgICBbXCJkYXRhXCIsIFwiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IGtleSB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgIC8vIFNldCB0aGUgZGF0YSB0byB0aGUgYnl0ZWNvZGUgKyB0aGUgZW5jb2RlZCBjb25zdHJ1Y3RvciBhcmd1bWVudHNcblx0ICAgICAgICB0eC5kYXRhID0gbGliJDEuaGV4bGlmeShsaWIkMS5jb25jYXQoW1xuXHQgICAgICAgICAgICB0aGlzLmJ5dGVjb2RlLFxuXHQgICAgICAgICAgICB0aGlzLmludGVyZmFjZS5lbmNvZGVEZXBsb3koYXJncylcblx0ICAgICAgICBdKSk7XG5cdCAgICAgICAgcmV0dXJuIHR4O1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuZGVwbG95ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBvdmVycmlkZXMsIHBhcmFtcywgdW5zaWduZWRUeCwgdHgsIGFkZHJlc3MsIGNvbnRyYWN0O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgMSBleHRyYSBwYXJhbWV0ZXIgd2FzIHBhc3NlZCBpbiwgaXQgY29udGFpbnMgb3ZlcnJpZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGggKyAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBhcmdzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2FsbCBtYXRjaGVzIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlQWRkcmVzc2VzKHRoaXMuc2lnbmVyLCBhcmdzLCB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVuc2lnbmVkVHggPSB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih1bnNpZ25lZFR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldENvbnRyYWN0QWRkcmVzc1wiKSh0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0ID0gbGliJDMuZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsIFwiZGVwbG95VHJhbnNhY3Rpb25cIiwgdHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY29udHJhY3RdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLmNvbnN0cnVjdG9yKS5nZXRDb250cmFjdChhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChzaWduZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmludGVyZmFjZSwgdGhpcy5ieXRlY29kZSwgc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkuZnJvbVNvbGlkaXR5ID0gZnVuY3Rpb24gKGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcblx0ICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgY29tcGlsZXIgb3V0cHV0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwiY29tcGlsZXJPdXRwdXRcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGNvbXBpbGVyT3V0cHV0ID0gSlNPTi5wYXJzZShjb21waWxlck91dHB1dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhYmkgPSBjb21waWxlck91dHB1dC5hYmk7XG5cdCAgICAgICAgdmFyIGJ5dGVjb2RlID0gbnVsbDtcblx0ICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGUpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGUgPSBjb21waWxlck91dHB1dC5ieXRlY29kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoY29tcGlsZXJPdXRwdXQuZXZtICYmIGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZSkge1xuXHQgICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFiaSwgYnl0ZWNvZGUsIHNpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LmdldEludGVyZmFjZSA9IGZ1bmN0aW9uIChjb250cmFjdEludGVyZmFjZSkge1xuXHQgICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5nZXRDb250cmFjdEFkZHJlc3MgPSBmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDYuZ2V0Q29udHJhY3RBZGRyZXNzKHR4KTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkuZ2V0Q29udHJhY3QgPSBmdW5jdGlvbiAoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENvbnRyYWN0RmFjdG9yeTtcblx0fSgpKTtcblx0ZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBDb250cmFjdEZhY3Rvcnk7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRkID0gdW53cmFwRXhwb3J0cyhsaWIkZCk7XG5cdHZhciBsaWJfMSRkID0gbGliJGQuQ29udHJhY3Q7XG5cdHZhciBsaWJfMiRjID0gbGliJGQuQ29udHJhY3RGYWN0b3J5O1xuXG5cdHZhciBsaWIkZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiB2YXIgYmFzZXggPSByZXF1aXJlKFwiYmFzZS14XCIpO1xuXHQgKlxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgYmFzZWQgb24gYmFzZS14LiBUaGUgbWFpbiByZWFzb24gdG9cblx0ICogZGV2aWF0ZSB3YXMgdG8gcHJldmVudCB0aGUgZGVwZW5kZW5jeSBvZiBCdWZmZXIuXG5cdCAqXG5cdCAqIENvbnRyaWJ1dG9yczpcblx0ICpcblx0ICogYmFzZS14IGVuY29kaW5nXG5cdCAqIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuXHQgKiBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcblx0ICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcblx0ICogUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuXHQgKiBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG5cdCAqXG5cdCAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuXHQgKlxuXHQgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuXHQgKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG5cdCAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cblx0ICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG5cdCAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuXHQgKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXHQgKlxuXHQgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuXHQgKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHQgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdCAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHQgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0ICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHQgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuXHQgKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG5cdCAqIElOIFRIRSBTT0ZUV0FSRS5cblx0ICpcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBCYXNlWCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEJhc2VYKGFscGhhYmV0KSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJiYXNlXCIsIGFscGhhYmV0Lmxlbmd0aCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuXHQgICAgICAgIC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgQmFzZVgucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkaWdpdHMgPSBbMF07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW2ldO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG5cdCAgICAgICAgICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIHRoaXMuYmFzZTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSB0aGlzLmJhc2UpO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RyaW5nID0gXCJcIjtcblx0ICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuXHQgICAgICAgIGZvciAodmFyIGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHtcblx0ICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuX2xlYWRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcblx0ICAgICAgICBmb3IgKHZhciBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSB7XG5cdCAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLmFscGhhYmV0W2RpZ2l0c1txXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdHJpbmc7XG5cdCAgICB9O1xuXHQgICAgQmFzZVgucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJ5dGVzLnB1c2goMCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgYnl0ZSA9IHRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtcblx0ICAgICAgICAgICAgaWYgKGJ5dGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY2FycnkgPSBieXRlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIHRoaXMuYmFzZTtcblx0ICAgICAgICAgICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3Ncblx0ICAgICAgICBmb3IgKHZhciBrID0gMDsgdmFsdWVba10gPT09IHRoaXMuX2xlYWRlciAmJiBrIDwgdmFsdWUubGVuZ3RoIC0gMTsgKytrKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5hcnJheWlmeShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQmFzZVg7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmFzZVggPSBCYXNlWDtcblx0dmFyIEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuXHRleHBvcnRzLkJhc2UzMiA9IEJhc2UzMjtcblx0dmFyIEJhc2U1OCA9IG5ldyBCYXNlWChcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7XG5cdGV4cG9ydHMuQmFzZTU4ID0gQmFzZTU4O1xuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuXHR9KTtcblxuXHR2YXIgaW5kZXgkZSA9IHVud3JhcEV4cG9ydHMobGliJGUpO1xuXHR2YXIgbGliXzEkZSA9IGxpYiRlLkJhc2VYO1xuXHR2YXIgbGliXzIkZCA9IGxpYiRlLkJhc2UzMjtcblx0dmFyIGxpYl8zJGEgPSBsaWIkZS5CYXNlNTg7XG5cblx0dmFyIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcblxuXHRmdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcblx0ICBpZiAoIXZhbClcblx0ICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0fVxuXG5cdGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuXHQgIGlmIChsICE9IHIpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG5cdH07XG5cblx0dmFyIGluaGVyaXRzX2Jyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGlmIChzdXBlckN0b3IpIHtcblx0ICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG5cdCAgICAgICAgY29uc3RydWN0b3I6IHtcblx0ICAgICAgICAgIHZhbHVlOiBjdG9yLFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuXHQgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICBpZiAoc3VwZXJDdG9yKSB7XG5cdCAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHQgICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciBpbmhlcml0c18xID0gaW5oZXJpdHNfYnJvd3NlcjtcblxuXHRmdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcblx0ICAgIHJldHVybiBtc2cuc2xpY2UoKTtcblx0ICBpZiAoIW1zZylcblx0ICAgIHJldHVybiBbXTtcblx0ICB2YXIgcmVzID0gW107XG5cdCAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAoIWVuYykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgdmFyIGhpID0gYyA+PiA4O1xuXHQgICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuXHQgICAgICAgIGlmIChoaSlcblx0ICAgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgcmVzLnB1c2gobG8pO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcblx0ICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcblx0ICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuXHQgICAgICAgIG1zZyA9ICcwJyArIG1zZztcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcblx0ICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciB0b0FycmF5XzEgPSB0b0FycmF5O1xuXG5cdGZ1bmN0aW9uIHRvSGV4KG1zZykge1xuXHQgIHZhciByZXMgPSAnJztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciB0b0hleF8xID0gdG9IZXg7XG5cblx0ZnVuY3Rpb24gaHRvbmwodykge1xuXHQgIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcblx0ICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuXHQgICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuXHQgICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG5cdCAgcmV0dXJuIHJlcyA+Pj4gMDtcblx0fVxuXHR2YXIgaHRvbmxfMSA9IGh0b25sO1xuXG5cdGZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcblx0ICB2YXIgcmVzID0gJyc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciB3ID0gbXNnW2ldO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG5cdCAgICAgIHcgPSBodG9ubCh3KTtcblx0ICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHRvSGV4MzJfMSA9IHRvSGV4MzI7XG5cblx0ZnVuY3Rpb24gemVybzIod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHZhciB6ZXJvMl8xID0gemVybzI7XG5cblx0ZnVuY3Rpb24gemVybzgod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuXHQgICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuXHQgICAgcmV0dXJuICcwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcblx0ICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuXHQgICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuXHQgICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHZhciB6ZXJvOF8xID0gemVybzg7XG5cblx0ZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG5cdCAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChsZW4gJSA0ID09PSAwKTtcblx0ICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuXHQgIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuXHQgICAgdmFyIHc7XG5cdCAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcblx0ICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuXHQgICAgZWxzZVxuXHQgICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG5cdCAgICByZXNbaV0gPSB3ID4+PiAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciBqb2luMzJfMSA9IGpvaW4zMjtcblxuXHRmdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG5cdCAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcblx0ICAgIHZhciBtID0gbXNnW2ldO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcblx0ICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG5cdCAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcblx0ICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG5cdCAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcblx0ICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuXHQgICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcblx0ICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHNwbGl0MzJfMSA9IHNwbGl0MzI7XG5cblx0ZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcblx0ICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xuXHR9XG5cdHZhciByb3RyMzJfMSA9IHJvdHIzMjtcblxuXHRmdW5jdGlvbiByb3RsMzIodywgYikge1xuXHQgIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG5cdH1cblx0dmFyIHJvdGwzMl8xID0gcm90bDMyO1xuXG5cdGZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcblx0ICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfMSA9IHN1bTMyO1xuXG5cdGZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuXHQgIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfM18xID0gc3VtMzJfMztcblxuXHRmdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcblx0ICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl80XzEgPSBzdW0zMl80O1xuXG5cdGZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuXHQgIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl81XzEgPSBzdW0zMl81O1xuXG5cdGZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcblx0ICB2YXIgYmggPSBidWZbcG9zXTtcblx0ICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cblx0ICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG5cdCAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuXHQgIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG5cdCAgYnVmW3BvcyArIDFdID0gbG87XG5cdH1cblx0dmFyIHN1bTY0XzEgPSBzdW02NDtcblxuXHRmdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuXHQgIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcblx0ICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG5cdCAgcmV0dXJuIGhpID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF9oaV8xID0gc3VtNjRfaGk7XG5cblx0ZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcblx0ICB2YXIgbG8gPSBhbCArIGJsO1xuXHQgIHJldHVybiBsbyA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfbG9fMSA9IHN1bTY0X2xvO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG5cdCAgdmFyIGNhcnJ5ID0gMDtcblx0ICB2YXIgbG8gPSBhbDtcblx0ICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgZGwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuXHQgIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG5cdCAgcmV0dXJuIGhpID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF80X2hpXzEgPSBzdW02NF80X2hpO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG5cdCAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG5cdCAgcmV0dXJuIGxvID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF80X2xvXzEgPSBzdW02NF80X2xvO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcblx0ICB2YXIgY2FycnkgPSAwO1xuXHQgIHZhciBsbyA9IGFsO1xuXHQgIGxvID0gKGxvICsgYmwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgZWwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuXHQgIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcblx0ICByZXR1cm4gaGkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzVfaGlfMSA9IHN1bTY0XzVfaGk7XG5cblx0ZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuXHQgIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cblx0ICByZXR1cm4gbG8gPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzVfbG9fMSA9IHN1bTY0XzVfbG87XG5cblx0ZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG5cdCAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG5cdCAgcmV0dXJuIHIgPj4+IDA7XG5cdH1cblx0dmFyIHJvdHI2NF9oaV8xID0gcm90cjY0X2hpO1xuXG5cdGZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuXHQgIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuXHQgIHJldHVybiByID4+PiAwO1xuXHR9XG5cdHZhciByb3RyNjRfbG9fMSA9IHJvdHI2NF9sbztcblxuXHRmdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuXHQgIHJldHVybiBhaCA+Pj4gbnVtO1xuXHR9XG5cdHZhciBzaHI2NF9oaV8xID0gc2hyNjRfaGk7XG5cblx0ZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcblx0ICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcblx0ICByZXR1cm4gciA+Pj4gMDtcblx0fVxuXHR2YXIgc2hyNjRfbG9fMSA9IHNocjY0X2xvO1xuXG5cdHZhciB1dGlscyA9IHtcblx0XHRpbmhlcml0czogaW5oZXJpdHNfMSxcblx0XHR0b0FycmF5OiB0b0FycmF5XzEsXG5cdFx0dG9IZXg6IHRvSGV4XzEsXG5cdFx0aHRvbmw6IGh0b25sXzEsXG5cdFx0dG9IZXgzMjogdG9IZXgzMl8xLFxuXHRcdHplcm8yOiB6ZXJvMl8xLFxuXHRcdHplcm84OiB6ZXJvOF8xLFxuXHRcdGpvaW4zMjogam9pbjMyXzEsXG5cdFx0c3BsaXQzMjogc3BsaXQzMl8xLFxuXHRcdHJvdHIzMjogcm90cjMyXzEsXG5cdFx0cm90bDMyOiByb3RsMzJfMSxcblx0XHRzdW0zMjogc3VtMzJfMSxcblx0XHRzdW0zMl8zOiBzdW0zMl8zXzEsXG5cdFx0c3VtMzJfNDogc3VtMzJfNF8xLFxuXHRcdHN1bTMyXzU6IHN1bTMyXzVfMSxcblx0XHRzdW02NDogc3VtNjRfMSxcblx0XHRzdW02NF9oaTogc3VtNjRfaGlfMSxcblx0XHRzdW02NF9sbzogc3VtNjRfbG9fMSxcblx0XHRzdW02NF80X2hpOiBzdW02NF80X2hpXzEsXG5cdFx0c3VtNjRfNF9sbzogc3VtNjRfNF9sb18xLFxuXHRcdHN1bTY0XzVfaGk6IHN1bTY0XzVfaGlfMSxcblx0XHRzdW02NF81X2xvOiBzdW02NF81X2xvXzEsXG5cdFx0cm90cjY0X2hpOiByb3RyNjRfaGlfMSxcblx0XHRyb3RyNjRfbG86IHJvdHI2NF9sb18xLFxuXHRcdHNocjY0X2hpOiBzaHI2NF9oaV8xLFxuXHRcdHNocjY0X2xvOiBzaHI2NF9sb18xXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdGZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcblx0ICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXHQgIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcblx0ICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuXHQgIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcblx0ICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuXHQgIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuXHQgIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cblx0ICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG5cdCAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG5cdH1cblx0dmFyIEJsb2NrSGFzaF8xID0gQmxvY2tIYXNoO1xuXG5cdEJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG5cdCAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG5cdCAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG5cdCAgaWYgKCF0aGlzLnBlbmRpbmcpXG5cdCAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG5cdCAgZWxzZVxuXHQgICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuXHQgIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cblx0ICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG5cdCAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG5cdCAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cblx0ICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuXHQgICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuXHQgICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcblx0ICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuXHQgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG5cdCAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG5cdCAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRCbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cblx0ICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG5cdH07XG5cblx0QmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuXHQgIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcblx0ICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG5cdCAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuXHQgIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcblx0ICByZXNbMF0gPSAweDgwO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuXHQgICAgcmVzW2ldID0gMDtcblxuXHQgIC8vIEFwcGVuZCBsZW5ndGhcblx0ICBsZW4gPDw9IDM7XG5cdCAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuXHQgICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuXHQgICAgICByZXNbaSsrXSA9IDA7XG5cblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblxuXHQgICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG5cdCAgICAgIHJlc1tpKytdID0gMDtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdHZhciBjb21tb24gPSB7XG5cdFx0QmxvY2tIYXNoOiBCbG9ja0hhc2hfMVxuXHR9O1xuXG5cdHZhciBfMSA9IHt9O1xuXG5cdHZhciBfMjI0ID0ge307XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblx0dmFyIHJvdHIzMiQxID0gdXRpbHMucm90cjMyO1xuXG5cdGZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuXHQgIGlmIChzID09PSAwKVxuXHQgICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG5cdCAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcblx0ICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG5cdCAgaWYgKHMgPT09IDIpXG5cdCAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG5cdH1cblx0dmFyIGZ0XzFfMSA9IGZ0XzE7XG5cblx0ZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG5cdCAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xuXHR9XG5cdHZhciBjaDMyXzEgPSBjaDMyO1xuXG5cdGZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcblx0ICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xuXHR9XG5cdHZhciBtYWozMl8xID0gbWFqMzI7XG5cblx0ZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcblx0ICByZXR1cm4geCBeIHkgXiB6O1xuXHR9XG5cdHZhciBwMzJfMSA9IHAzMjtcblxuXHRmdW5jdGlvbiBzMF8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCAyKSBeIHJvdHIzMiQxKHgsIDEzKSBeIHJvdHIzMiQxKHgsIDIyKTtcblx0fVxuXHR2YXIgczBfMjU2XzEgPSBzMF8yNTY7XG5cblx0ZnVuY3Rpb24gczFfMjU2KHgpIHtcblx0ICByZXR1cm4gcm90cjMyJDEoeCwgNikgXiByb3RyMzIkMSh4LCAxMSkgXiByb3RyMzIkMSh4LCAyNSk7XG5cdH1cblx0dmFyIHMxXzI1Nl8xID0gczFfMjU2O1xuXG5cdGZ1bmN0aW9uIGcwXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDcpIF4gcm90cjMyJDEoeCwgMTgpIF4gKHggPj4+IDMpO1xuXHR9XG5cdHZhciBnMF8yNTZfMSA9IGcwXzI1NjtcblxuXHRmdW5jdGlvbiBnMV8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCAxNykgXiByb3RyMzIkMSh4LCAxOSkgXiAoeCA+Pj4gMTApO1xuXHR9XG5cdHZhciBnMV8yNTZfMSA9IGcxXzI1NjtcblxuXHR2YXIgY29tbW9uJDEgPSB7XG5cdFx0ZnRfMTogZnRfMV8xLFxuXHRcdGNoMzI6IGNoMzJfMSxcblx0XHRtYWozMjogbWFqMzJfMSxcblx0XHRwMzI6IHAzMl8xLFxuXHRcdHMwXzI1NjogczBfMjU2XzEsXG5cdFx0czFfMjU2OiBzMV8yNTZfMSxcblx0XHRnMF8yNTY6IGcwXzI1Nl8xLFxuXHRcdGcxXzI1NjogZzFfMjU2XzFcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXG5cdHZhciBzdW0zMiQxID0gdXRpbHMuc3VtMzI7XG5cdHZhciBzdW0zMl80JDEgPSB1dGlscy5zdW0zMl80O1xuXHR2YXIgc3VtMzJfNSQxID0gdXRpbHMuc3VtMzJfNTtcblx0dmFyIGNoMzIkMSA9IGNvbW1vbiQxLmNoMzI7XG5cdHZhciBtYWozMiQxID0gY29tbW9uJDEubWFqMzI7XG5cdHZhciBzMF8yNTYkMSA9IGNvbW1vbiQxLnMwXzI1Njtcblx0dmFyIHMxXzI1NiQxID0gY29tbW9uJDEuczFfMjU2O1xuXHR2YXIgZzBfMjU2JDEgPSBjb21tb24kMS5nMF8yNTY7XG5cdHZhciBnMV8yNTYkMSA9IGNvbW1vbiQxLmcxXzI1NjtcblxuXHR2YXIgQmxvY2tIYXNoJDEgPSBjb21tb24uQmxvY2tIYXNoO1xuXG5cdHZhciBzaGEyNTZfSyA9IFtcblx0ICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuXHQgIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG5cdCAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcblx0ICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuXHQgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG5cdCAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcblx0ICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuXHQgIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG5cdCAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcblx0ICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuXHQgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG5cdCAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcblx0ICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuXHQgIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG5cdCAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcblx0ICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5cdF07XG5cblx0ZnVuY3Rpb24gU0hBMjU2KCkge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKVxuXHQgICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuXHQgIEJsb2NrSGFzaCQxLmNhbGwodGhpcyk7XG5cdCAgdGhpcy5oID0gW1xuXHQgICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSxcblx0ICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcblx0ICBdO1xuXHQgIHRoaXMuayA9IHNoYTI1Nl9LO1xuXHQgIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG5cdH1cblx0dXRpbHMuaW5oZXJpdHMoU0hBMjU2LCBCbG9ja0hhc2gkMSk7XG5cdHZhciBfMjU2ID0gU0hBMjU2O1xuXG5cdFNIQTI1Ni5ibG9ja1NpemUgPSA1MTI7XG5cdFNIQTI1Ni5vdXRTaXplID0gMjU2O1xuXHRTSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuXHRTSEEyNTYucGFkTGVuZ3RoID0gNjQ7XG5cblx0U0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG5cdCAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cdCAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuXHQgICAgV1tpXSA9IHN1bTMyXzQkMShnMV8yNTYkMShXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYkMShXW2kgLSAxNV0pLCBXW2kgLSAxNl0pO1xuXG5cdCAgdmFyIGEgPSB0aGlzLmhbMF07XG5cdCAgdmFyIGIgPSB0aGlzLmhbMV07XG5cdCAgdmFyIGMgPSB0aGlzLmhbMl07XG5cdCAgdmFyIGQgPSB0aGlzLmhbM107XG5cdCAgdmFyIGUgPSB0aGlzLmhbNF07XG5cdCAgdmFyIGYgPSB0aGlzLmhbNV07XG5cdCAgdmFyIGcgPSB0aGlzLmhbNl07XG5cdCAgdmFyIGggPSB0aGlzLmhbN107XG5cblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgVDEgPSBzdW0zMl81JDEoaCwgczFfMjU2JDEoZSksIGNoMzIkMShlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcblx0ICAgIHZhciBUMiA9IHN1bTMyJDEoczBfMjU2JDEoYSksIG1hajMyJDEoYSwgYiwgYykpO1xuXHQgICAgaCA9IGc7XG5cdCAgICBnID0gZjtcblx0ICAgIGYgPSBlO1xuXHQgICAgZSA9IHN1bTMyJDEoZCwgVDEpO1xuXHQgICAgZCA9IGM7XG5cdCAgICBjID0gYjtcblx0ICAgIGIgPSBhO1xuXHQgICAgYSA9IHN1bTMyJDEoVDEsIFQyKTtcblx0ICB9XG5cblx0ICB0aGlzLmhbMF0gPSBzdW0zMiQxKHRoaXMuaFswXSwgYSk7XG5cdCAgdGhpcy5oWzFdID0gc3VtMzIkMSh0aGlzLmhbMV0sIGIpO1xuXHQgIHRoaXMuaFsyXSA9IHN1bTMyJDEodGhpcy5oWzJdLCBjKTtcblx0ICB0aGlzLmhbM10gPSBzdW0zMiQxKHRoaXMuaFszXSwgZCk7XG5cdCAgdGhpcy5oWzRdID0gc3VtMzIkMSh0aGlzLmhbNF0sIGUpO1xuXHQgIHRoaXMuaFs1XSA9IHN1bTMyJDEodGhpcy5oWzVdLCBmKTtcblx0ICB0aGlzLmhbNl0gPSBzdW0zMiQxKHRoaXMuaFs2XSwgZyk7XG5cdCAgdGhpcy5oWzddID0gc3VtMzIkMSh0aGlzLmhbN10sIGgpO1xuXHR9O1xuXG5cdFNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xuXHR9O1xuXG5cdHZhciBfMzg0ID0ge307XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblx0dmFyIHJvdHI2NF9oaSQxID0gdXRpbHMucm90cjY0X2hpO1xuXHR2YXIgcm90cjY0X2xvJDEgPSB1dGlscy5yb3RyNjRfbG87XG5cdHZhciBzaHI2NF9oaSQxID0gdXRpbHMuc2hyNjRfaGk7XG5cdHZhciBzaHI2NF9sbyQxID0gdXRpbHMuc2hyNjRfbG87XG5cdHZhciBzdW02NCQxID0gdXRpbHMuc3VtNjQ7XG5cdHZhciBzdW02NF9oaSQxID0gdXRpbHMuc3VtNjRfaGk7XG5cdHZhciBzdW02NF9sbyQxID0gdXRpbHMuc3VtNjRfbG87XG5cdHZhciBzdW02NF80X2hpJDEgPSB1dGlscy5zdW02NF80X2hpO1xuXHR2YXIgc3VtNjRfNF9sbyQxID0gdXRpbHMuc3VtNjRfNF9sbztcblx0dmFyIHN1bTY0XzVfaGkkMSA9IHV0aWxzLnN1bTY0XzVfaGk7XG5cdHZhciBzdW02NF81X2xvJDEgPSB1dGlscy5zdW02NF81X2xvO1xuXG5cdHZhciBCbG9ja0hhc2gkMiA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0dmFyIHNoYTUxMl9LID0gW1xuXHQgIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG5cdCAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcblx0ICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuXHQgIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG5cdCAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcblx0ICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuXHQgIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG5cdCAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcblx0ICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuXHQgIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG5cdCAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4Myxcblx0ICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuXHQgIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG5cdCAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcblx0ICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuXHQgIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG5cdCAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcblx0ICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuXHQgIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG5cdCAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcblx0ICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuXHQgIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG5cdCAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcblx0ICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuXHQgIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG5cdCAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcblx0ICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuXHQgIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG5cdCAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcblx0ICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuXHQgIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG5cdCAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcblx0ICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuXHQgIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG5cdCAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcblx0ICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuXHQgIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG5cdCAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0Yyxcblx0ICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuXHQgIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcblx0XTtcblxuXHRmdW5jdGlvbiBTSEE1MTIoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG5cdCAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG5cdCAgQmxvY2tIYXNoJDIuY2FsbCh0aGlzKTtcblx0ICB0aGlzLmggPSBbXG5cdCAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuXHQgICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcblx0ICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG5cdCAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuXHQgICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcblx0ICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG5cdCAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuXHQgICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuXHQgIHRoaXMuayA9IHNoYTUxMl9LO1xuXHQgIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xuXHR9XG5cdHV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoJDIpO1xuXHR2YXIgXzUxMiA9IFNIQTUxMjtcblxuXHRTSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblx0U0hBNTEyLm91dFNpemUgPSA1MTI7XG5cdFNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICAvLyAzMiB4IDMyYml0IHdvcmRzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuXHQgICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXHQgIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuXHQgICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG5cdCAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuXHQgICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuXHQgICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuXHQgICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcblx0ICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuXHQgICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG5cdCAgICBXW2ldID0gc3VtNjRfNF9oaSQxKFxuXHQgICAgICBjMF9oaSwgYzBfbG8sXG5cdCAgICAgIGMxX2hpLCBjMV9sbyxcblx0ICAgICAgYzJfaGksIGMyX2xvLFxuXHQgICAgICBjM19oaSwgYzNfbG8pO1xuXHQgICAgV1tpICsgMV0gPSBzdW02NF80X2xvJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyk7XG5cdCAgfVxuXHR9O1xuXG5cdFNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuXHQgIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuXHQgIHZhciBXID0gdGhpcy5XO1xuXG5cdCAgdmFyIGFoID0gdGhpcy5oWzBdO1xuXHQgIHZhciBhbCA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYmggPSB0aGlzLmhbMl07XG5cdCAgdmFyIGJsID0gdGhpcy5oWzNdO1xuXHQgIHZhciBjaCA9IHRoaXMuaFs0XTtcblx0ICB2YXIgY2wgPSB0aGlzLmhbNV07XG5cdCAgdmFyIGRoID0gdGhpcy5oWzZdO1xuXHQgIHZhciBkbCA9IHRoaXMuaFs3XTtcblx0ICB2YXIgZWggPSB0aGlzLmhbOF07XG5cdCAgdmFyIGVsID0gdGhpcy5oWzldO1xuXHQgIHZhciBmaCA9IHRoaXMuaFsxMF07XG5cdCAgdmFyIGZsID0gdGhpcy5oWzExXTtcblx0ICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuXHQgIHZhciBnbCA9IHRoaXMuaFsxM107XG5cdCAgdmFyIGhoID0gdGhpcy5oWzE0XTtcblx0ICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHZhciBjMF9oaSA9IGhoO1xuXHQgICAgdmFyIGMwX2xvID0gaGw7XG5cdCAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcblx0ICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuXHQgICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcblx0ICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG5cdCAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG5cdCAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuXHQgICAgdmFyIGM0X2hpID0gV1tpXTtcblx0ICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG5cdCAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyxcblx0ICAgICAgYzRfaGksIGM0X2xvKTtcblx0ICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8kMShcblx0ICAgICAgYzBfaGksIGMwX2xvLFxuXHQgICAgICBjMV9oaSwgYzFfbG8sXG5cdCAgICAgIGMyX2hpLCBjMl9sbyxcblx0ICAgICAgYzNfaGksIGMzX2xvLFxuXHQgICAgICBjNF9oaSwgYzRfbG8pO1xuXG5cdCAgICBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuXHQgICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcblx0ICAgIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cdCAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG5cdCAgICB2YXIgVDJfaGkgPSBzdW02NF9oaSQxKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblx0ICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvJDEoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG5cdCAgICBoaCA9IGdoO1xuXHQgICAgaGwgPSBnbDtcblxuXHQgICAgZ2ggPSBmaDtcblx0ICAgIGdsID0gZmw7XG5cblx0ICAgIGZoID0gZWg7XG5cdCAgICBmbCA9IGVsO1xuXG5cdCAgICBlaCA9IHN1bTY0X2hpJDEoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXHQgICAgZWwgPSBzdW02NF9sbyQxKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuXHQgICAgZGggPSBjaDtcblx0ICAgIGRsID0gY2w7XG5cblx0ICAgIGNoID0gYmg7XG5cdCAgICBjbCA9IGJsO1xuXG5cdCAgICBiaCA9IGFoO1xuXHQgICAgYmwgPSBhbDtcblxuXHQgICAgYWggPSBzdW02NF9oaSQxKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcblx0ICAgIGFsID0gc3VtNjRfbG8kMShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG5cdCAgfVxuXG5cdCAgc3VtNjQkMSh0aGlzLmgsIDAsIGFoLCBhbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDIsIGJoLCBibCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDQsIGNoLCBjbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDYsIGRoLCBkbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDgsIGVoLCBlbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuXHQgIHN1bTY0JDEodGhpcy5oLCAxMiwgZ2gsIGdsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgMTQsIGhoLCBobCk7XG5cdH07XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcblx0ICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuXHQgIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcblx0ICB2YXIgYzBfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDI4KTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDIpOyAgLy8gMzRcblx0ICB2YXIgYzJfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAyOCk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyKTsgIC8vIDM0XG5cdCAgdmFyIGMyX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCA3KTsgIC8vIDM5XG5cblx0ICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuXHQgIHZhciBjMF9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTQpO1xuXHQgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTgpO1xuXHQgIHZhciBjMl9oaSA9IHJvdHI2NF9oaSQxKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE0KTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE4KTtcblx0ICB2YXIgYzJfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2hpID0gcm90cjY0X2hpJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHNoYTEgPSBfMTtcblx0dmFyIHNoYTIyNCA9IF8yMjQ7XG5cdHZhciBzaGEyNTYgPSBfMjU2O1xuXHR2YXIgc2hhMzg0ID0gXzM4NDtcblx0dmFyIHNoYTUxMiA9IF81MTI7XG5cblx0dmFyIHNoYSA9IHtcblx0XHRzaGExOiBzaGExLFxuXHRcdHNoYTIyNDogc2hhMjI0LFxuXHRcdHNoYTI1Njogc2hhMjU2LFxuXHRcdHNoYTM4NDogc2hhMzg0LFxuXHRcdHNoYTUxMjogc2hhNTEyXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciByb3RsMzIkMSA9IHV0aWxzLnJvdGwzMjtcblx0dmFyIHN1bTMyJDIgPSB1dGlscy5zdW0zMjtcblx0dmFyIHN1bTMyXzMkMSA9IHV0aWxzLnN1bTMyXzM7XG5cdHZhciBzdW0zMl80JDIgPSB1dGlscy5zdW0zMl80O1xuXHR2YXIgQmxvY2tIYXNoJDMgPSBjb21tb24uQmxvY2tIYXNoO1xuXG5cdGZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcblx0ICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cblx0ICBCbG9ja0hhc2gkMy5jYWxsKHRoaXMpO1xuXG5cdCAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG5cdCAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcblx0fVxuXHR1dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCQzKTtcblx0dmFyIHJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuXHRSSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuXHRSSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblx0UklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5Mjtcblx0UklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5cdFJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIEEgPSB0aGlzLmhbMF07XG5cdCAgdmFyIEIgPSB0aGlzLmhbMV07XG5cdCAgdmFyIEMgPSB0aGlzLmhbMl07XG5cdCAgdmFyIEQgPSB0aGlzLmhbM107XG5cdCAgdmFyIEUgPSB0aGlzLmhbNF07XG5cdCAgdmFyIEFoID0gQTtcblx0ICB2YXIgQmggPSBCO1xuXHQgIHZhciBDaCA9IEM7XG5cdCAgdmFyIERoID0gRDtcblx0ICB2YXIgRWggPSBFO1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuXHQgICAgdmFyIFQgPSBzdW0zMiQyKFxuXHQgICAgICByb3RsMzIkMShcblx0ICAgICAgICBzdW0zMl80JDIoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuXHQgICAgICAgIHNbal0pLFxuXHQgICAgICBFKTtcblx0ICAgIEEgPSBFO1xuXHQgICAgRSA9IEQ7XG5cdCAgICBEID0gcm90bDMyJDEoQywgMTApO1xuXHQgICAgQyA9IEI7XG5cdCAgICBCID0gVDtcblx0ICAgIFQgPSBzdW0zMiQyKFxuXHQgICAgICByb3RsMzIkMShcblx0ICAgICAgICBzdW0zMl80JDIoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG5cdCAgICAgICAgc2hbal0pLFxuXHQgICAgICBFaCk7XG5cdCAgICBBaCA9IEVoO1xuXHQgICAgRWggPSBEaDtcblx0ICAgIERoID0gcm90bDMyJDEoQ2gsIDEwKTtcblx0ICAgIENoID0gQmg7XG5cdCAgICBCaCA9IFQ7XG5cdCAgfVxuXHQgIFQgPSBzdW0zMl8zJDEodGhpcy5oWzFdLCBDLCBEaCk7XG5cdCAgdGhpcy5oWzFdID0gc3VtMzJfMyQxKHRoaXMuaFsyXSwgRCwgRWgpO1xuXHQgIHRoaXMuaFsyXSA9IHN1bTMyXzMkMSh0aGlzLmhbM10sIEUsIEFoKTtcblx0ICB0aGlzLmhbM10gPSBzdW0zMl8zJDEodGhpcy5oWzRdLCBBLCBCaCk7XG5cdCAgdGhpcy5oWzRdID0gc3VtMzJfMyQxKHRoaXMuaFswXSwgQiwgQ2gpO1xuXHQgIHRoaXMuaFswXSA9IFQ7XG5cdH07XG5cblx0UklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG5cdCAgaWYgKGogPD0gMTUpXG5cdCAgICByZXR1cm4geCBeIHkgXiB6O1xuXHQgIGVsc2UgaWYgKGogPD0gMzEpXG5cdCAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG5cdCAgZWxzZSBpZiAoaiA8PSA0Nylcblx0ICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcblx0ICBlbHNlIGlmIChqIDw9IDYzKVxuXHQgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcblx0fVxuXG5cdGZ1bmN0aW9uIEsoaikge1xuXHQgIGlmIChqIDw9IDE1KVxuXHQgICAgcmV0dXJuIDB4MDAwMDAwMDA7XG5cdCAgZWxzZSBpZiAoaiA8PSAzMSlcblx0ICAgIHJldHVybiAweDVhODI3OTk5O1xuXHQgIGVsc2UgaWYgKGogPD0gNDcpXG5cdCAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcblx0ICBlbHNlIGlmIChqIDw9IDYzKVxuXHQgICAgcmV0dXJuIDB4OGYxYmJjZGM7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG5cdH1cblxuXHRmdW5jdGlvbiBLaChqKSB7XG5cdCAgaWYgKGogPD0gMTUpXG5cdCAgICByZXR1cm4gMHg1MGEyOGJlNjtcblx0ICBlbHNlIGlmIChqIDw9IDMxKVxuXHQgICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG5cdCAgZWxzZSBpZiAoaiA8PSA0Nylcblx0ICAgIHJldHVybiAweDZkNzAzZWYzO1xuXHQgIGVsc2UgaWYgKGogPD0gNjMpXG5cdCAgICByZXR1cm4gMHg3YTZkNzZlOTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gMHgwMDAwMDAwMDtcblx0fVxuXG5cdHZhciByID0gW1xuXHQgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG5cdCAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcblx0ICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuXHQgIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG5cdCAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXHRdO1xuXG5cdHZhciByaCA9IFtcblx0ICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuXHQgIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG5cdCAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcblx0ICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuXHQgIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcblx0XTtcblxuXHR2YXIgcyA9IFtcblx0ICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG5cdCAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuXHQgIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcblx0ICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG5cdCAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5cdF07XG5cblx0dmFyIHNoID0gW1xuXHQgIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcblx0ICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG5cdCAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuXHQgIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcblx0ICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcblx0XTtcblxuXHR2YXIgcmlwZW1kID0ge1xuXHRcdHJpcGVtZDE2MDogcmlwZW1kMTYwXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdGZ1bmN0aW9uIEhtYWMoaGFzaCwga2V5LCBlbmMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG5cdCAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuXHQgIHRoaXMuSGFzaCA9IGhhc2g7XG5cdCAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG5cdCAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcblx0ICB0aGlzLmlubmVyID0gbnVsbDtcblx0ICB0aGlzLm91dGVyID0gbnVsbDtcblxuXHQgIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xuXHR9XG5cdHZhciBobWFjID0gSG1hYztcblxuXHRIbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG5cdCAgLy8gU2hvcnRlbiBrZXksIGlmIG5lZWRlZFxuXHQgIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG5cdCAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG5cdCAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuXHQgICAga2V5LnB1c2goMCk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuXHQgICAga2V5W2ldIF49IDB4MzY7XG5cdCAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuXHQgIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuXHQgIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG5cdCAgICBrZXlbaV0gXj0gMHg2YTtcblx0ICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXHR9O1xuXG5cdEhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuXHQgIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRIbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG5cdCAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG5cdCAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG5cdH07XG5cblx0dmFyIGhhc2hfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIGhhc2ggPSBleHBvcnRzO1xuXG5cdGhhc2gudXRpbHMgPSB1dGlscztcblx0aGFzaC5jb21tb24gPSBjb21tb247XG5cdGhhc2guc2hhID0gc2hhO1xuXHRoYXNoLnJpcGVtZCA9IHJpcGVtZDtcblx0aGFzaC5obWFjID0gaG1hYztcblxuXHQvLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcblx0aGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcblx0aGFzaC5zaGEyNTYgPSBoYXNoLnNoYS5zaGEyNTY7XG5cdGhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuXHRoYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcblx0aGFzaC5zaGE1MTIgPSBoYXNoLnNoYS5zaGE1MTI7XG5cdGhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuXHR9KTtcblx0dmFyIGhhc2hfMiA9IGhhc2hfMS5obWFjO1xuXHR2YXIgaGFzaF8zID0gaGFzaF8xLnJpcGVtZDE2MDtcblx0dmFyIGhhc2hfNCA9IGhhc2hfMS5zaGEyNTY7XG5cdHZhciBoYXNoXzUgPSBoYXNoXzEuc2hhNTEyO1xuXG5cdHZhciBfdmVyc2lvbiRvID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInNoYTIvNS4wLjAtYmV0YS4xMzdcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHAgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJG8pO1xuXHR2YXIgX3ZlcnNpb25fMSRjID0gX3ZlcnNpb24kby52ZXJzaW9uO1xuXG5cdHZhciBicm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGhhc2ggPSBfX2ltcG9ydFN0YXIoaGFzaF8xKTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJG8udmVyc2lvbik7XG5cdHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG5cdChmdW5jdGlvbiAoU3VwcG9ydGVkQWxnb3JpdGhtKSB7XG5cdCAgICBTdXBwb3J0ZWRBbGdvcml0aG1bXCJzaGEyNTZcIl0gPSBcInNoYTI1NlwiO1xuXHQgICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcblx0fSkoU3VwcG9ydGVkQWxnb3JpdGhtID0gZXhwb3J0cy5TdXBwb3J0ZWRBbGdvcml0aG0gfHwgKGV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcblx0O1xuXHRmdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuXHQgICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnJpcGVtZDE2MCgpLnVwZGF0ZShsaWIkMS5hcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcblx0fVxuXHRleHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcblx0ZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcblx0ICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGEyNTYoKS51cGRhdGUobGliJDEuYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG5cdH1cblx0ZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5cdGZ1bmN0aW9uIHNoYTUxMihkYXRhKSB7XG5cdCAgICByZXR1cm4gXCIweFwiICsgKGhhc2guc2hhNTEyKCkudXBkYXRlKGxpYiQxLmFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xuXHR9XG5cdGV4cG9ydHMuc2hhNTEyID0gc2hhNTEyO1xuXHRmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuXHQgICAgaWYgKCFTdXBwb3J0ZWRBbGdvcml0aG1bYWxnb3JpdGhtXSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcblx0ICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjB4XCIgKyBoYXNoLmhtYWMoaGFzaFthbGdvcml0aG1dLCBsaWIkMS5hcnJheWlmeShrZXkpKS51cGRhdGUobGliJDEuYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKTtcblx0fVxuXHRleHBvcnRzLmNvbXB1dGVIbWFjID0gY29tcHV0ZUhtYWM7XG5cdH0pO1xuXG5cdHZhciBicm93c2VyJDEgPSB1bndyYXBFeHBvcnRzKGJyb3dzZXIpO1xuXHR2YXIgYnJvd3Nlcl8xID0gYnJvd3Nlci5TdXBwb3J0ZWRBbGdvcml0aG07XG5cdHZhciBicm93c2VyXzIgPSBicm93c2VyLnJpcGVtZDE2MDtcblx0dmFyIGJyb3dzZXJfMyA9IGJyb3dzZXIuc2hhMjU2O1xuXHR2YXIgYnJvd3Nlcl80ID0gYnJvd3Nlci5zaGE1MTI7XG5cdHZhciBicm93c2VyXzUgPSBicm93c2VyLmNvbXB1dGVIbWFjO1xuXG5cdHZhciBicm93c2VyJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHRmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgaGFzaEFsZ29yaXRobSkge1xuXHQgICAgcGFzc3dvcmQgPSBsaWIkMS5hcnJheWlmeShwYXNzd29yZCk7XG5cdCAgICBzYWx0ID0gbGliJDEuYXJyYXlpZnkoc2FsdCk7XG5cdCAgICB2YXIgaExlbjtcblx0ICAgIHZhciBsID0gMTtcblx0ICAgIHZhciBESyA9IG5ldyBVaW50OEFycmF5KGtleWxlbik7XG5cdCAgICB2YXIgYmxvY2sxID0gbmV3IFVpbnQ4QXJyYXkoc2FsdC5sZW5ndGggKyA0KTtcblx0ICAgIGJsb2NrMS5zZXQoc2FsdCk7XG5cdCAgICAvL3NhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXHQgICAgdmFyIHI7XG5cdCAgICB2YXIgVDtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuXHQgICAgICAgIC8vYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoXSA9IChpID4+IDI0KSAmIDB4ZmY7XG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgMV0gPSAoaSA+PiAxNikgJiAweGZmO1xuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aCArIDJdID0gKGkgPj4gOCkgJiAweGZmO1xuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aCArIDNdID0gaSAmIDB4ZmY7XG5cdCAgICAgICAgLy9sZXQgVSA9IGNyZWF0ZUhtYWMocGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpO1xuXHQgICAgICAgIHZhciBVID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLCBwYXNzd29yZCwgYmxvY2sxKSk7XG5cdCAgICAgICAgaWYgKCFoTGVuKSB7XG5cdCAgICAgICAgICAgIGhMZW4gPSBVLmxlbmd0aDtcblx0ICAgICAgICAgICAgVCA9IG5ldyBVaW50OEFycmF5KGhMZW4pO1xuXHQgICAgICAgICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pO1xuXHQgICAgICAgICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vVS5jb3B5KFQsIDAsIDAsIGhMZW4pXG5cdCAgICAgICAgVC5zZXQoVSk7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcblx0ICAgICAgICAgICAgLy9VID0gY3JlYXRlSG1hYyhwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpO1xuXHQgICAgICAgICAgICBVID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLCBwYXNzd29yZCwgVSkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKylcblx0ICAgICAgICAgICAgICAgIFRba10gXj0gVVtrXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRlc3RQb3MgPSAoaSAtIDEpICogaExlbjtcblx0ICAgICAgICB2YXIgbGVuID0gKGkgPT09IGwgPyByIDogaExlbik7XG5cdCAgICAgICAgLy9ULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcblx0ICAgICAgICBESy5zZXQobGliJDEuYXJyYXlpZnkoVCkuc2xpY2UoMCwgbGVuKSwgZGVzdFBvcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShESyk7XG5cdH1cblx0ZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjI7XG5cdH0pO1xuXG5cdHZhciBicm93c2VyJDMgPSB1bndyYXBFeHBvcnRzKGJyb3dzZXIkMik7XG5cdHZhciBicm93c2VyXzEkMSA9IGJyb3dzZXIkMi5wYmtkZjI7XG5cblx0dmFyIHZlcnNpb24gPSBcIjYuNS4yXCI7XG5cdHZhciBfcGFja2FnZSA9IHtcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uXG5cdH07XG5cblx0dmFyIF9wYWNrYWdlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0dmVyc2lvbjogdmVyc2lvbixcblx0XHQnZGVmYXVsdCc6IF9wYWNrYWdlXG5cdH0pO1xuXG5cdHZhciB1dGlsc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHV0aWxzID0gZXhwb3J0cztcblxuXHRmdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcblx0ICAgIHJldHVybiBtc2cuc2xpY2UoKTtcblx0ICBpZiAoIW1zZylcblx0ICAgIHJldHVybiBbXTtcblx0ICB2YXIgcmVzID0gW107XG5cdCAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfVxuXHQgIGlmIChlbmMgPT09ICdoZXgnKSB7XG5cdCAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuXHQgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuXHQgICAgICBtc2cgPSAnMCcgKyBtc2c7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcblx0ICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcblx0ICAgICAgdmFyIGhpID0gYyA+PiA4O1xuXHQgICAgICB2YXIgbG8gPSBjICYgMHhmZjtcblx0ICAgICAgaWYgKGhpKVxuXHQgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICByZXMucHVzaChsbyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cblx0ZnVuY3Rpb24gemVybzIod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHV0aWxzLnplcm8yID0gemVybzI7XG5cblx0ZnVuY3Rpb24gdG9IZXgobXNnKSB7XG5cdCAgdmFyIHJlcyA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dXRpbHMudG9IZXggPSB0b0hleDtcblxuXHR1dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB0b0hleChhcnIpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiBhcnI7XG5cdH07XG5cdH0pO1xuXG5cdHZhciB1dGlsc18xJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5cblxuXG5cdHV0aWxzLmFzc2VydCA9IG1pbmltYWxpc3RpY0Fzc2VydDtcblx0dXRpbHMudG9BcnJheSA9IHV0aWxzXzEudG9BcnJheTtcblx0dXRpbHMuemVybzIgPSB1dGlsc18xLnplcm8yO1xuXHR1dGlscy50b0hleCA9IHV0aWxzXzEudG9IZXg7XG5cdHV0aWxzLmVuY29kZSA9IHV0aWxzXzEuZW5jb2RlO1xuXG5cdC8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5cdGZ1bmN0aW9uIGdldE5BRihudW0sIHcsIGJpdHMpIHtcblx0ICB2YXIgbmFmID0gbmV3IEFycmF5KE1hdGgubWF4KG51bS5iaXRMZW5ndGgoKSwgYml0cykgKyAxKTtcblx0ICBuYWYuZmlsbCgwKTtcblxuXHQgIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcblx0ICB2YXIgayA9IG51bS5jbG9uZSgpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciB6O1xuXHQgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcblx0ICAgIGlmIChrLmlzT2RkKCkpIHtcblx0ICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG5cdCAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIHogPSBtb2Q7XG5cdCAgICAgIGsuaXN1Ym4oeik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB6ID0gMDtcblx0ICAgIH1cblxuXHQgICAgbmFmW2ldID0gejtcblx0ICAgIGsuaXVzaHJuKDEpO1xuXHQgIH1cblxuXHQgIHJldHVybiBuYWY7XG5cdH1cblx0dXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG5cdC8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuXHRmdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG5cdCAgdmFyIGpzZiA9IFtcblx0ICAgIFtdLFxuXHQgICAgW11cblx0ICBdO1xuXG5cdCAgazEgPSBrMS5jbG9uZSgpO1xuXHQgIGsyID0gazIuY2xvbmUoKTtcblx0ICB2YXIgZDEgPSAwO1xuXHQgIHZhciBkMiA9IDA7XG5cdCAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG5cdCAgICAvLyBGaXJzdCBwaGFzZVxuXHQgICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG5cdCAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcblx0ICAgIGlmIChtMTQgPT09IDMpXG5cdCAgICAgIG0xNCA9IC0xO1xuXHQgICAgaWYgKG0yNCA9PT0gMylcblx0ICAgICAgbTI0ID0gLTE7XG5cdCAgICB2YXIgdTE7XG5cdCAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG5cdCAgICAgIHUxID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG5cdCAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcblx0ICAgICAgICB1MSA9IC1tMTQ7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICB1MSA9IG0xNDtcblx0ICAgIH1cblx0ICAgIGpzZlswXS5wdXNoKHUxKTtcblxuXHQgICAgdmFyIHUyO1xuXHQgICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuXHQgICAgICB1MiA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuXHQgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG5cdCAgICAgICAgdTIgPSAtbTI0O1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgdTIgPSBtMjQ7XG5cdCAgICB9XG5cdCAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cblx0ICAgIC8vIFNlY29uZCBwaGFzZVxuXHQgICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuXHQgICAgICBkMSA9IDEgLSBkMTtcblx0ICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcblx0ICAgICAgZDIgPSAxIC0gZDI7XG5cdCAgICBrMS5pdXNocm4oMSk7XG5cdCAgICBrMi5pdXNocm4oMSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpzZjtcblx0fVxuXHR1dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cblx0ZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuXHQgIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuXHQgIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcblx0ICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG5cdCAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHR9XG5cdHV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuXHQgIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xuXHR9XG5cdHV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5cdGZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuXHQgIHJldHVybiBuZXcgYm4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcblx0fVxuXHR1dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cdH0pO1xuXG5cdHZhciBicm9yYW5kID0gZnVuY3Rpb24obGVuZ3RoKSB7IHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOyAoY29tbW9uanNHbG9iYWwuY3J5cHRvIHx8IGNvbW1vbmpzR2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTsgcmV0dXJuIHJlc3VsdDsgfTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cdHZhciBnZXROQUYgPSB1dGlsc18xJDEuZ2V0TkFGO1xuXHR2YXIgZ2V0SlNGID0gdXRpbHNfMSQxLmdldEpTRjtcblx0dmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuXHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdCAgdGhpcy5wID0gbmV3IGJuKGNvbmYucCwgMTYpO1xuXG5cdCAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuXHQgIHRoaXMucmVkID0gY29uZi5wcmltZSA/IGJuLnJlZChjb25mLnByaW1lKSA6IGJuLm1vbnQodGhpcy5wKTtcblxuXHQgIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcblx0ICB0aGlzLnplcm8gPSBuZXcgYm4oMCkudG9SZWQodGhpcy5yZWQpO1xuXHQgIHRoaXMub25lID0gbmV3IGJuKDEpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLnR3byA9IG5ldyBibigyKS50b1JlZCh0aGlzLnJlZCk7XG5cblx0ICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuXHQgIHRoaXMubiA9IGNvbmYubiAmJiBuZXcgYm4oY29uZi5uLCAxNik7XG5cdCAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cblx0ICAvLyBUZW1wb3JhcnkgYXJyYXlzXG5cdCAgdGhpcy5fd25hZlQxID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG5cdCAgdGhpcy5fd25hZlQ0ID0gbmV3IEFycmF5KDQpO1xuXG5cdCAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuXHQgIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG5cdCAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcblx0ICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcblx0ICAgIHRoaXMucmVkTiA9IG51bGw7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG5cdCAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuXHQgIH1cblx0fVxuXHR2YXIgYmFzZSA9IEJhc2VDdXJ2ZTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG5cdCAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG5cdCAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cblx0ICB2YXIgbmFmID0gZ2V0TkFGKGssIDEsIHRoaXMuX2JpdExlbmd0aCk7XG5cdCAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG5cdCAgSSAvPSAzO1xuXG5cdCAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG5cdCAgdmFyIHJlcHIgPSBbXTtcblx0ICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG5cdCAgICB2YXIgbmFmVyA9IDA7XG5cdCAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuXHQgICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba107XG5cdCAgICByZXByLnB1c2gobmFmVyk7XG5cdCAgfVxuXG5cdCAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICB2YXIgYiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIG5hZlcgPSByZXByW2pdO1xuXHQgICAgICBpZiAobmFmVyA9PT0gaSlcblx0ICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG5cdCAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuXHQgICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcblx0ICAgIH1cblx0ICAgIGEgPSBhLmFkZChiKTtcblx0ICB9XG5cdCAgcmV0dXJuIGEudG9QKCk7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcblx0ICB2YXIgdyA9IDQ7XG5cblx0ICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuXHQgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG5cdCAgdyA9IG5hZlBvaW50cy53bmQ7XG5cdCAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cblx0ICAvLyBHZXQgTkFGIGZvcm1cblx0ICB2YXIgbmFmID0gZ2V0TkFGKGssIHcsIHRoaXMuX2JpdExlbmd0aCk7XG5cblx0ICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuXHQgIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICBmb3IgKHZhciBpID0gbmFmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAvLyBDb3VudCB6ZXJvZXNcblx0ICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG5cdCAgICAgIGsrKztcblx0ICAgIGlmIChpID49IDApXG5cdCAgICAgIGsrKztcblx0ICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuXG5cdCAgICBpZiAoaSA8IDApXG5cdCAgICAgIGJyZWFrO1xuXHQgICAgdmFyIHogPSBuYWZbaV07XG5cdCAgICBhc3NlcnQkMSh6ICE9PSAwKTtcblx0ICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKSB7XG5cdCAgICAgIC8vIEogKy0gUFxuXHQgICAgICBpZiAoeiA+IDApXG5cdCAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoeiAtIDEpID4+IDFdKTtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gSiArLSBKXG5cdCAgICAgIGlmICh6ID4gMClcblx0ICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoeiAtIDEpID4+IDFdKTtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWNvYmlhblJlc3VsdCkge1xuXHQgIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcblx0ICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuXHQgIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cblx0ICAvLyBGaWxsIGFsbCBhcnJheXNcblx0ICB2YXIgbWF4ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICB2YXIgcCA9IHBvaW50c1tpXTtcblx0ICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG5cdCAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG5cdCAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuXHQgIH1cblxuXHQgIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcblx0ICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcblx0ICAgIHZhciBhID0gaSAtIDE7XG5cdCAgICB2YXIgYiA9IGk7XG5cdCAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcblx0ICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG5cdCAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdLCB0aGlzLl9iaXRMZW5ndGgpO1xuXHQgICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbWIgPSBbXG5cdCAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuXHQgICAgICBudWxsLCAvKiAzICovXG5cdCAgICAgIG51bGwsIC8qIDUgKi9cblx0ICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cblx0ICAgIF07XG5cblx0ICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcblx0ICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG5cdCAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG5cdCAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcblx0ICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuXHQgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG5cdCAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG5cdCAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGluZGV4ID0gW1xuXHQgICAgICAtMywgLyogLTEgLTEgKi9cblx0ICAgICAgLTEsIC8qIC0xIDAgKi9cblx0ICAgICAgLTUsIC8qIC0xIDEgKi9cblx0ICAgICAgLTcsIC8qIDAgLTEgKi9cblx0ICAgICAgMCwgLyogMCAwICovXG5cdCAgICAgIDcsIC8qIDAgMSAqL1xuXHQgICAgICA1LCAvKiAxIC0xICovXG5cdCAgICAgIDEsIC8qIDEgMCAqL1xuXHQgICAgICAzICAvKiAxIDEgKi9cblx0ICAgIF07XG5cblx0ICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuXHQgICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcblx0ICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuXHQgICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heDsgaisrKSB7XG5cdCAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG5cdCAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cblx0ICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuXHQgICAgICBuYWZbYl1bal0gPSAwO1xuXHQgICAgICB3bmRbYV0gPSBjb21iO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuXHQgIGZvciAodmFyIGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICB2YXIgayA9IDA7XG5cblx0ICAgIHdoaWxlIChpID49IDApIHtcblx0ICAgICAgdmFyIHplcm8gPSB0cnVlO1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG5cdCAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcblx0ICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuXHQgICAgICAgICAgemVybyA9IGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghemVybylcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgaysrO1xuXHQgICAgICBpLS07XG5cdCAgICB9XG5cdCAgICBpZiAoaSA+PSAwKVxuXHQgICAgICBrKys7XG5cdCAgICBhY2MgPSBhY2MuZGJscChrKTtcblx0ICAgIGlmIChpIDwgMClcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgdmFyIHogPSB0bXBbal07XG5cdCAgICAgIHZhciBwO1xuXHQgICAgICBpZiAoeiA9PT0gMClcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgZWxzZSBpZiAoeiA+IDApXG5cdCAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuXHQgICAgICBlbHNlIGlmICh6IDwgMClcblx0ICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG5cdCAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuXHQgICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG5cdCAgICB3bmRbaV0gPSBudWxsO1xuXG5cdCAgaWYgKGphY29iaWFuUmVzdWx0KVxuXHQgICAgcmV0dXJuIGFjYztcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gYWNjLnRvUCgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSwgdHlwZSkge1xuXHQgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcblx0ICB0aGlzLnR5cGUgPSB0eXBlO1xuXHQgIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xuXHR9XG5cdEJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKC8qb3RoZXIqLykge1xuXHQgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xuXHR9O1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG5cdCAgYnl0ZXMgPSB1dGlsc18xJDEudG9BcnJheShieXRlcywgZW5jKTtcblxuXHQgIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG5cdCAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuXHQgIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG5cdCAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcblx0ICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcblx0ICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcblx0ICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuXHQgICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuXG5cdCAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcblx0ICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcblx0ICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG5cdCAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG5cdCAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG5cdCAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cblx0ICBpZiAoY29tcGFjdClcblx0ICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cblx0ICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSkgO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuXHQgIHJldHVybiB1dGlsc18xJDEuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG5cdCAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIHZhciBwcmVjb21wdXRlZCA9IHtcblx0ICAgIGRvdWJsZXM6IG51bGwsXG5cdCAgICBuYWY6IG51bGwsXG5cdCAgICBiZXRhOiBudWxsXG5cdCAgfTtcblx0ICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG5cdCAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuXHQgIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG5cdCAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcblx0ICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcztcblx0ICBpZiAoIWRvdWJsZXMpXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcblx0ICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG5cdCAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG5cdCAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcblx0ICB2YXIgYWNjID0gdGhpcztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuXHQgICAgICBhY2MgPSBhY2MuZGJsKCk7XG5cdCAgICBkb3VibGVzLnB1c2goYWNjKTtcblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0ZXA6IHN0ZXAsXG5cdCAgICBwb2ludHM6IGRvdWJsZXNcblx0ICB9O1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG5cdCAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG5cdCAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cblx0ICB2YXIgcmVzID0gWyB0aGlzIF07XG5cdCAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuXHQgIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuXHQgICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcblx0ICByZXR1cm4ge1xuXHQgICAgd25kOiB3bmQsXG5cdCAgICBwb2ludHM6IHJlc1xuXHQgIH07XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuXHQgIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuXHQgIHZhciByID0gdGhpcztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcblx0ICAgIHIgPSByLmRibCgpO1xuXHQgIHJldHVybiByO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cblx0dmFyIGFzc2VydCQyID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcblx0ICBiYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cblx0ICB0aGlzLmEgPSBuZXcgYm4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuXHQgIHRoaXMuYiA9IG5ldyBibihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG5cdCAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcblx0ICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cblx0ICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcblx0ICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG5cdCAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xuXHR9XG5cdGluaGVyaXRzX2Jyb3dzZXIoU2hvcnRDdXJ2ZSwgYmFzZSk7XG5cdHZhciBzaG9ydF8xID0gU2hvcnRDdXJ2ZTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG5cdCAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuXHQgIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG5cdCAgICByZXR1cm47XG5cblx0ICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG5cdCAgdmFyIGJldGE7XG5cdCAgdmFyIGxhbWJkYTtcblx0ICBpZiAoY29uZi5iZXRhKSB7XG5cdCAgICBiZXRhID0gbmV3IGJuKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG5cdCAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcblx0ICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG5cdCAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgfVxuXHQgIGlmIChjb25mLmxhbWJkYSkge1xuXHQgICAgbGFtYmRhID0gbmV3IGJuKGNvbmYubGFtYmRhLCAxNik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuXHQgICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcblx0ICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcblx0ICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG5cdCAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuXHQgIHZhciBiYXNpcztcblx0ICBpZiAoY29uZi5iYXNpcykge1xuXHQgICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBhOiBuZXcgYm4odmVjLmEsIDE2KSxcblx0ICAgICAgICBiOiBuZXcgYm4odmVjLmIsIDE2KVxuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIGJldGE6IGJldGEsXG5cdCAgICBsYW1iZGE6IGxhbWJkYSxcblx0ICAgIGJhc2lzOiBiYXNpc1xuXHQgIH07XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG5cdCAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuXHQgIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuXHQgIC8vXG5cdCAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBibi5tb250KG51bSk7XG5cdCAgdmFyIHRpbnYgPSBuZXcgYm4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG5cdCAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuXHQgIHZhciBzID0gbmV3IGJuKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuXHQgIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG5cdCAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcblx0ICByZXR1cm4gWyBsMSwgbDIgXTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcblx0ICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcblx0ICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cblx0ICAvLyAzLjc0XG5cdCAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcblx0ICB2YXIgdSA9IGxhbWJkYTtcblx0ICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuXHQgIHZhciB4MSA9IG5ldyBibigxKTtcblx0ICB2YXIgeTEgPSBuZXcgYm4oMCk7XG5cdCAgdmFyIHgyID0gbmV3IGJuKDApO1xuXHQgIHZhciB5MiA9IG5ldyBibigxKTtcblxuXHQgIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2Qgbilcblx0ICB2YXIgYTA7XG5cdCAgdmFyIGIwO1xuXHQgIC8vIEZpcnN0IHZlY3RvclxuXHQgIHZhciBhMTtcblx0ICB2YXIgYjE7XG5cdCAgLy8gU2Vjb25kIHZlY3RvclxuXHQgIHZhciBhMjtcblx0ICB2YXIgYjI7XG5cblx0ICB2YXIgcHJldlI7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciByO1xuXHQgIHZhciB4O1xuXHQgIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcblx0ICAgIHZhciBxID0gdi5kaXYodSk7XG5cdCAgICByID0gdi5zdWIocS5tdWwodSkpO1xuXHQgICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuXHQgICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuXHQgICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG5cdCAgICAgIGEwID0gcHJldlIubmVnKCk7XG5cdCAgICAgIGIwID0geDE7XG5cdCAgICAgIGExID0gci5uZWcoKTtcblx0ICAgICAgYjEgPSB4O1xuXHQgICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBwcmV2UiA9IHI7XG5cblx0ICAgIHYgPSB1O1xuXHQgICAgdSA9IHI7XG5cdCAgICB4MiA9IHgxO1xuXHQgICAgeDEgPSB4O1xuXHQgICAgeTIgPSB5MTtcblx0ICAgIHkxID0geTtcblx0ICB9XG5cdCAgYTIgPSByLm5lZygpO1xuXHQgIGIyID0geDtcblxuXHQgIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcblx0ICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG5cdCAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcblx0ICAgIGEyID0gYTA7XG5cdCAgICBiMiA9IGIwO1xuXHQgIH1cblxuXHQgIC8vIE5vcm1hbGl6ZSBzaWduc1xuXHQgIGlmIChhMS5uZWdhdGl2ZSkge1xuXHQgICAgYTEgPSBhMS5uZWcoKTtcblx0ICAgIGIxID0gYjEubmVnKCk7XG5cdCAgfVxuXHQgIGlmIChhMi5uZWdhdGl2ZSkge1xuXHQgICAgYTIgPSBhMi5uZWcoKTtcblx0ICAgIGIyID0gYjIubmVnKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFtcblx0ICAgIHsgYTogYTEsIGI6IGIxIH0sXG5cdCAgICB7IGE6IGEyLCBiOiBiMiB9XG5cdCAgXTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG5cdCAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuXHQgIHZhciB2MSA9IGJhc2lzWzBdO1xuXHQgIHZhciB2MiA9IGJhc2lzWzFdO1xuXG5cdCAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblx0ICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG5cdCAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuXHQgIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcblx0ICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG5cdCAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuXHQgIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuXHQgIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG5cdCAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcblx0ICB4ID0gbmV3IGJuKHgsIDE2KTtcblx0ICBpZiAoIXgucmVkKVxuXHQgICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG5cdCAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG5cdCAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG5cdCAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcblx0ICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG5cdCAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcblx0ICAvLyB0byBub24tcmVkIGZvcm0/XG5cdCAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcblx0ICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuXHQgICAgeSA9IHkucmVkTmVnKCk7XG5cblx0ICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG5cdCAgaWYgKHBvaW50LmluZilcblx0ICAgIHJldHVybiB0cnVlO1xuXG5cdCAgdmFyIHggPSBwb2ludC54O1xuXHQgIHZhciB5ID0gcG9pbnQueTtcblxuXHQgIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG5cdCAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcblx0ICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuXHQgICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCBqYWNvYmlhblJlc3VsdCkge1xuXHQgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcblx0ICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuXHQgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cdCAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuXHQgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG5cdCAgICAgIHNwbGl0LmsxLmluZWcoKTtcblx0ICAgICAgcCA9IHAubmVnKHRydWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG5cdCAgICAgIHNwbGl0LmsyLmluZWcoKTtcblx0ICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuXHQgICAgfVxuXG5cdCAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG5cdCAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuXHQgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcblx0ICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuXHQgIH1cblx0ICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG5cdCAgLy8gQ2xlYW4tdXAgcmVmZXJlbmNlcyB0byBwb2ludHMgYW5kIGNvZWZmaWNpZW50c1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuXHQgICAgbnBvaW50c1tqXSA9IG51bGw7XG5cdCAgICBuY29lZmZzW2pdID0gbnVsbDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRmdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcblx0ICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG5cdCAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuXHQgICAgdGhpcy54ID0gbnVsbDtcblx0ICAgIHRoaXMueSA9IG51bGw7XG5cdCAgICB0aGlzLmluZiA9IHRydWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMueCA9IG5ldyBibih4LCAxNik7XG5cdCAgICB0aGlzLnkgPSBuZXcgYm4oeSwgMTYpO1xuXHQgICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cblx0ICAgIGlmIChpc1JlZCkge1xuXHQgICAgICB0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgfVxuXHQgICAgaWYgKCF0aGlzLngucmVkKVxuXHQgICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgaWYgKCF0aGlzLnkucmVkKVxuXHQgICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgdGhpcy5pbmYgPSBmYWxzZTtcblx0ICB9XG5cdH1cblx0aW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcblx0ICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuXHQgIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG5cdCAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG5cdCAgICByZXR1cm47XG5cblx0ICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcblx0ICBpZiAocHJlICYmIHByZS5iZXRhKVxuXHQgICAgcmV0dXJuIHByZS5iZXRhO1xuXG5cdCAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuXHQgIGlmIChwcmUpIHtcblx0ICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG5cdCAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcblx0ICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcblx0ICAgIH07XG5cdCAgICBwcmUuYmV0YSA9IGJldGE7XG5cdCAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuXHQgICAgICBiZXRhOiBudWxsLFxuXHQgICAgICBuYWY6IHByZS5uYWYgJiYge1xuXHQgICAgICAgIHduZDogcHJlLm5hZi53bmQsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcblx0ICAgICAgfSxcblx0ICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiBiZXRhO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuXHQgICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuXHQgIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcblx0ICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG5cdCAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuXHQgICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSlcblx0ICAgIH0sXG5cdCAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcblx0ICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG5cdCAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG5cdCAgICB9XG5cdCAgfSBdO1xuXHR9O1xuXG5cdFBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG5cdCAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuXHQgICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuXHQgIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcblx0ICBpZiAoIW9ialsyXSlcblx0ICAgIHJldHVybiByZXM7XG5cblx0ICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG5cdCAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG5cdCAgfVxuXG5cdCAgdmFyIHByZSA9IG9ialsyXTtcblx0ICByZXMucHJlY29tcHV0ZWQgPSB7XG5cdCAgICBiZXRhOiBudWxsLFxuXHQgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcblx0ICAgIH0sXG5cdCAgICBuYWY6IHByZS5uYWYgJiYge1xuXHQgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuXHQgICAgfVxuXHQgIH07XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+Jztcblx0ICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuXHQgICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG5cdCAgcmV0dXJuIHRoaXMuaW5mO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuXHQgIC8vIE8gKyBQID0gUFxuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiBwO1xuXG5cdCAgLy8gUCArIE8gPSBQXG5cdCAgaWYgKHAuaW5mKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyBQICsgUCA9IDJQXG5cdCAgaWYgKHRoaXMuZXEocCkpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuXHQgIC8vIFAgKyAoLVApID0gT1xuXHQgIGlmICh0aGlzLm5lZygpLmVxKHApKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICAvLyBQICsgUSA9IE9cblx0ICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcblx0ICBpZiAoYy5jbXBuKDApICE9PSAwKVxuXHQgICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuXHQgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIDJQID0gT1xuXHQgIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG5cdCAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuXHQgIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuXHQgIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cblx0ICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuXHQgIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcblx0ICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcblx0ICBrID0gbmV3IGJuKGssIDE2KTtcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICBlbHNlIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuXHQgIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuXHQgIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG5cdCAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG5cdCAgaWYgKHRoaXMuY3VydmUuZW5kbylcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG5cdCAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcblx0ICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcblx0ICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuXHQgIHJldHVybiB0aGlzID09PSBwIHx8XG5cdCAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuXHQgICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcblx0ICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuXHQgICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG5cdCAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuXHQgICAgICByZXR1cm4gcC5uZWcoKTtcblx0ICAgIH07XG5cdCAgICByZXMucHJlY29tcHV0ZWQgPSB7XG5cdCAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG5cdCAgICAgICAgd25kOiBwcmUubmFmLnduZCxcblx0ICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpXG5cdCAgICAgIH0sXG5cdCAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcblx0ICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuXHQgIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuXHQgIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuXHQgICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG5cdCAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcblx0ICAgIHRoaXMueiA9IG5ldyBibigwKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcblx0ICAgIHRoaXMueSA9IG5ldyBibih5LCAxNik7XG5cdCAgICB0aGlzLnogPSBuZXcgYm4oeiwgMTYpO1xuXHQgIH1cblx0ICBpZiAoIXRoaXMueC5yZWQpXG5cdCAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgIGlmICghdGhpcy55LnJlZClcblx0ICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgaWYgKCF0aGlzLnoucmVkKVxuXHQgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuXHQgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cdH1cblx0aW5oZXJpdHNfYnJvd3NlcihKUG9pbnQsIGJhc2UuQmFzZVBvaW50KTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuXHQgIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG5cdCAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuXHQgIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG5cdCAgdmFyIGF4ID0gdGhpcy54LnJlZE11bCh6aW52Mik7XG5cdCAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuXHQgIC8vIE8gKyBQID0gUFxuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiBwO1xuXG5cdCAgLy8gUCArIE8gPSBQXG5cdCAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyAxMk0gKyA0UyArIDdBXG5cdCAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuXHQgIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuXHQgIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcblx0ICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuXHQgIHZhciBoID0gdTEucmVkU3ViKHUyKTtcblx0ICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG5cdCAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuXHQgICAgaWYgKHIuY21wbigwKSAhPT0gMClcblx0ICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgICAgZWxzZVxuXHQgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcblx0ICB9XG5cblx0ICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuXHQgIHZhciBoMyA9IGgyLnJlZE11bChoKTtcblx0ICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cblx0ICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcblx0ICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuXHQgIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcblx0ICAvLyBPICsgUCA9IFBcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gcC50b0ooKTtcblxuXHQgIC8vIFAgKyBPID0gUFxuXHQgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gOE0gKyAzUyArIDdBXG5cdCAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuXHQgIHZhciB1MSA9IHRoaXMueDtcblx0ICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcblx0ICB2YXIgczEgPSB0aGlzLnk7XG5cdCAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cblx0ICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG5cdCAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuXHQgIGlmIChoLmNtcG4oMCkgPT09IDApIHtcblx0ICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG5cdCAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICAgIGVsc2Vcblx0ICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cdCAgfVxuXG5cdCAgdmFyIGgyID0gaC5yZWRTcXIoKTtcblx0ICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG5cdCAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG5cdCAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG5cdCAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcblx0ICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKGgpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAocG93KSB7XG5cdCAgaWYgKHBvdyA9PT0gMClcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIGlmICghcG93KVxuXHQgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cblx0ICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuXHQgICAgdmFyIHIgPSB0aGlzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKylcblx0ICAgICAgciA9IHIuZGJsKCk7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcblx0ICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcblx0ICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblx0ICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuXHQgIHZhciBqeCA9IHRoaXMueDtcblx0ICB2YXIgankgPSB0aGlzLnk7XG5cdCAgdmFyIGp6ID0gdGhpcy56O1xuXHQgIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuXHQgIC8vIFJldXNlIHJlc3VsdHNcblx0ICB2YXIganlkID0gankucmVkQWRkKGp5KTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG5cdCAgICB2YXIgangyID0gangucmVkU3FyKCk7XG5cdCAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcblx0ICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcblx0ICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG5cdCAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG5cdCAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG5cdCAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblx0ICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG5cdCAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG5cdCAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcblx0ICAgIGlmIChpICsgMSA8IHBvdylcblx0ICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuXHQgICAganggPSBueDtcblx0ICAgIGp6ID0gbno7XG5cdCAgICBqeWQgPSBkbnk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcblx0ICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG5cdCAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG5cdCAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuXHQgIHZhciBueDtcblx0ICB2YXIgbnk7XG5cdCAgdmFyIG56O1xuXHQgIC8vIFogPSAxXG5cdCAgaWYgKHRoaXMuek9uZSkge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcblx0ICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG5cdCAgICAvLyAxTSArIDVTICsgMTRBXG5cblx0ICAgIC8vIFhYID0gWDFeMlxuXHQgICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuXHQgICAgLy8gWVkgPSBZMV4yXG5cdCAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgICAvLyBZWVlZID0gWVleMlxuXHQgICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcblx0ICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuXHQgICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuXHQgICAgcyA9IHMucmVkSUFkZChzKTtcblx0ICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuXHQgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuXHQgICAgLy8gVCA9IE0gXiAyIC0gMipTXG5cdCAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG5cdCAgICAvLyA4ICogWVlZWVxuXHQgICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblx0ICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cblx0ICAgIC8vIFgzID0gVFxuXHQgICAgbnggPSB0O1xuXHQgICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG5cdCAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG5cdCAgICAvLyBaMyA9IDIqWTFcblx0ICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuXHQgICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG5cdCAgICAvLyAyTSArIDVTICsgMTNBXG5cblx0ICAgIC8vIEEgPSBYMV4yXG5cdCAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAgIC8vIEIgPSBZMV4yXG5cdCAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAgIC8vIEMgPSBCXjJcblx0ICAgIHZhciBjID0gYi5yZWRTcXIoKTtcblx0ICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcblx0ICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG5cdCAgICBkID0gZC5yZWRJQWRkKGQpO1xuXHQgICAgLy8gRSA9IDMgKiBBXG5cdCAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG5cdCAgICAvLyBGID0gRV4yXG5cdCAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cblx0ICAgIC8vIDggKiBDXG5cdCAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG5cdCAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXHQgICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuXHQgICAgLy8gWDMgPSBGIC0gMiAqIERcblx0ICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG5cdCAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG5cdCAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuXHQgICAgLy8gWjMgPSAyICogWTEgKiBaMVxuXHQgICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG5cdCAgICBueiA9IG56LnJlZElBZGQobnopO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcblx0ICB2YXIgbng7XG5cdCAgdmFyIG55O1xuXHQgIHZhciBuejtcblx0ICAvLyBaID0gMVxuXHQgIGlmICh0aGlzLnpPbmUpIHtcblx0ICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG5cdCAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuXHQgICAgLy8gMU0gKyA1UyArIDE1QVxuXG5cdCAgICAvLyBYWCA9IFgxXjJcblx0ICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAgIC8vIFlZID0gWTFeMlxuXHQgICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gWVlZWSA9IFlZXjJcblx0ICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG5cdCAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcblx0ICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcblx0ICAgIHMgPSBzLnJlZElBZGQocyk7XG5cdCAgICAvLyBNID0gMyAqIFhYICsgYVxuXHQgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcblx0ICAgIC8vIFQgPSBNXjIgLSAyICogU1xuXHQgICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblx0ICAgIC8vIFgzID0gVFxuXHQgICAgbnggPSB0O1xuXHQgICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG5cdCAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG5cdCAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblx0ICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcblx0ICAgIC8vIFozID0gMiAqIFkxXG5cdCAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuXHQgICAgLy8gM00gKyA1U1xuXG5cdCAgICAvLyBkZWx0YSA9IFoxXjJcblx0ICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICAgIC8vIGdhbW1hID0gWTFeMlxuXHQgICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcblx0ICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG5cdCAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcblx0ICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG5cdCAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG5cdCAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuXHQgICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuXHQgICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcblx0ICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG5cdCAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuXHQgICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcblx0ICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuXHQgICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG5cdCAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuXHQgICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcblx0ICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG5cdCAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuXHQgICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG5cdCAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cblx0ICAvLyA0TSArIDZTICsgMTBBXG5cdCAgdmFyIGp4ID0gdGhpcy54O1xuXHQgIHZhciBqeSA9IHRoaXMueTtcblx0ICB2YXIganogPSB0aGlzLno7XG5cdCAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG5cdCAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuXHQgIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuXHQgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG5cdCAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuXHQgIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG5cdCAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcblx0ICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG5cdCAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cblx0ICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcblx0ICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuXHQgIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG5cdCAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcblx0ICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcblx0ICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cblx0ICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuXHQgIC8vIDVNICsgMTBTICsgLi4uXG5cblx0ICAvLyBYWCA9IFgxXjJcblx0ICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgLy8gWVkgPSBZMV4yXG5cdCAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuXHQgIC8vIFpaID0gWjFeMlxuXHQgIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICAvLyBZWVlZID0gWVleMlxuXHQgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG5cdCAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG5cdCAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuXHQgIC8vIE1NID0gTV4yXG5cdCAgdmFyIG1tID0gbS5yZWRTcXIoKTtcblx0ICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuXHQgIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcblx0ICBlID0gZS5yZWRJQWRkKGUpO1xuXHQgIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuXHQgIGUgPSBlLnJlZElTdWIobW0pO1xuXHQgIC8vIEVFID0gRV4yXG5cdCAgdmFyIGVlID0gZS5yZWRTcXIoKTtcblx0ICAvLyBUID0gMTYqWVlZWVxuXHQgIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuXHQgIHQgPSB0LnJlZElBZGQodCk7XG5cdCAgdCA9IHQucmVkSUFkZCh0KTtcblx0ICB0ID0gdC5yZWRJQWRkKHQpO1xuXHQgIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuXHQgIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG5cdCAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuXHQgIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuXHQgIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG5cdCAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcblx0ICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuXHQgIG54ID0gbngucmVkSUFkZChueCk7XG5cdCAgbnggPSBueC5yZWRJQWRkKG54KTtcblx0ICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcblx0ICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcblx0ICBueSA9IG55LnJlZElBZGQobnkpO1xuXHQgIG55ID0gbnkucmVkSUFkZChueSk7XG5cdCAgbnkgPSBueS5yZWRJQWRkKG55KTtcblx0ICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG5cdCAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuXHQgIGsgPSBuZXcgYm4oaywga2Jhc2UpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcblx0ICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcblx0ICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG5cdCAgaWYgKHRoaXMgPT09IHApXG5cdCAgICByZXR1cm4gdHJ1ZTtcblxuXHQgIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcblx0ICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG5cdCAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG5cdCAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcblx0ICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuXHQgIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuXHQgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgIHJldHVybiB0cnVlO1xuXG5cdCAgdmFyIHhjID0geC5jbG9uZSgpO1xuXHQgIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG5cdCAgZm9yICg7Oykge1xuXHQgICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuXHQgICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblxuXHQgICAgcngucmVkSUFkZCh0KTtcblx0ICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG5cdCAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcblx0ICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG5cdCAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcblx0ICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuXHQgIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcblx0fTtcblxuXHR2YXIgbW9udCA9IHt9O1xuXG5cdHZhciBlZHdhcmRzID0ge307XG5cblx0dmFyIGN1cnZlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY3VydmUgPSBleHBvcnRzO1xuXG5cdGN1cnZlLmJhc2UgPSBiYXNlO1xuXHRjdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5cdGN1cnZlLm1vbnQgPSBtb250O1xuXHRjdXJ2ZS5lZHdhcmRzID0gZWR3YXJkcztcblx0fSk7XG5cblx0dmFyIHNlY3AyNTZrMSA9IHVuZGVmaW5lZDtcblxuXHR2YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY3VydmVzID0gZXhwb3J0cztcblxuXG5cblxuXG5cdHZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcblx0ICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuXHQgIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLmVkd2FyZHMob3B0aW9ucyk7XG5cdCAgZWxzZVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLm1vbnQob3B0aW9ucyk7XG5cdCAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXHQgIHRoaXMubiA9IHRoaXMuY3VydmUubjtcblx0ICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cblx0ICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG5cdCAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xuXHR9XG5cdGN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5cdGZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgdmFsdWU6IGN1cnZlXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gY3VydmU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgncDE5MicsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAncDE5MicsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuXHQgIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG5cdCAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDIyNCcsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAncDIyNCcsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuXHQgIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG5cdCAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDI1NicsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiBudWxsLFxuXHQgIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG5cdCAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcblx0ICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuXHQgIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuXHQgICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcblx0ICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG5cdCAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcblx0ICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG5cdCAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMzg0LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcblx0ICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG5cdCAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG5cdCAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDUyMScsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiBudWxsLFxuXHQgIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcblx0ICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG5cdCAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuXHQgICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcblx0ICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuXHQgIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG5cdCAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5Jyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhNTEyLFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcblx0ICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcblx0ICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG5cdCAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG5cdCAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG5cdCAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcblx0ICB0eXBlOiAnbW9udCcsXG5cdCAgcHJpbWU6ICdwMjU1MTknLFxuXHQgIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcblx0ICBhOiAnNzZkMDYnLFxuXHQgIGI6ICcxJyxcblx0ICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnOSdcblx0ICBdXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuXHQgIHR5cGU6ICdlZHdhcmRzJyxcblx0ICBwcmltZTogJ3AyNTUxOScsXG5cdCAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuXHQgIGE6ICctMScsXG5cdCAgYzogJzEnLFxuXHQgIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcblx0ICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG5cdCAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG5cdCAgICAvLyA0LzVcblx0ICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4J1xuXHQgIF1cblx0fSk7XG5cblx0dmFyIHByZTtcblx0dHJ5IHtcblx0ICBwcmUgPSBzZWNwMjU2azE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0ICBwcmUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6ICdrMjU2Jyxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuXHQgIGE6ICcwJyxcblx0ICBiOiAnNycsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcblx0ICBoOiAnMScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1NixcblxuXHQgIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuXHQgIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcblx0ICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcblx0ICBiYXNpczogW1xuXHQgICAge1xuXHQgICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuXHQgICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuXHQgICAgfSxcblx0ICAgIHtcblx0ICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG5cdCAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNSdcblx0ICAgIH1cblx0ICBdLFxuXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuXHQgICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuXHQgICAgcHJlXG5cdCAgXVxuXHR9KTtcblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblx0ZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG5cdCAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuXHQgIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblx0ICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuXHQgIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG5cdCAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cblx0ICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuXHQgIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuXHQgIHRoaXMuSyA9IG51bGw7XG5cdCAgdGhpcy5WID0gbnVsbDtcblxuXHQgIHZhciBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcblx0ICB2YXIgbm9uY2UgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG5cdCAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG5cdCAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblx0ICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcblx0fVxuXHR2YXIgaG1hY0RyYmcgPSBIbWFjRFJCRztcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG5cdCAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG5cdCAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG5cdCAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRoaXMuS1tpXSA9IDB4MDA7XG5cdCAgICB0aGlzLlZbaV0gPSAweDAxO1xuXHQgIH1cblxuXHQgIHRoaXMuX3VwZGF0ZShzZWVkKTtcblx0ICB0aGlzLl9yZXNlZWQgPSAxO1xuXHQgIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcblx0ICByZXR1cm4gbmV3IGhhc2hfMS5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG5cdCAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcblx0ICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcblx0ICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcblx0ICBpZiAoc2VlZClcblx0ICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcblx0ICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuXHQgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcblx0ICBpZiAoIXNlZWQpXG5cdCAgICByZXR1cm47XG5cblx0ICB0aGlzLksgPSB0aGlzLl9obWFjKClcblx0ICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG5cdCAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG5cdCAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcblx0ICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuXHQgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG5cdCAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcblx0ICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG5cdCAgICBhZGRFbmMgPSBhZGQ7XG5cdCAgICBhZGQgPSBlbnRyb3B5RW5jO1xuXHQgICAgZW50cm9weUVuYyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcblx0ICBhZGQgPSB1dGlsc18xLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuXG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcblx0ICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG5cdCAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuXHQgIHRoaXMuX3Jlc2VlZCA9IDE7XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG5cdCAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG5cdCAgLy8gT3B0aW9uYWwgZW5jb2Rpbmdcblx0ICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIGFkZEVuYyA9IGFkZDtcblx0ICAgIGFkZCA9IGVuYztcblx0ICAgIGVuYyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG5cdCAgaWYgKGFkZCkge1xuXHQgICAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcblx0ICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuXHQgIH1cblxuXHQgIHZhciB0ZW1wID0gW107XG5cdCAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG5cdCAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG5cdCAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcblx0ICB9XG5cblx0ICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuXHQgIHRoaXMuX3VwZGF0ZShhZGQpO1xuXHQgIHRoaXMuX3Jlc2VlZCsrO1xuXHQgIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXHR2YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcblx0ICB0aGlzLmVjID0gZWM7XG5cdCAgdGhpcy5wcml2ID0gbnVsbDtcblx0ICB0aGlzLnB1YiA9IG51bGw7XG5cblx0ICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcblx0ICBpZiAob3B0aW9ucy5wcml2KVxuXHQgICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG5cdCAgaWYgKG9wdGlvbnMucHViKVxuXHQgICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG5cdH1cblx0dmFyIGtleSA9IEtleVBhaXI7XG5cblx0S2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcblx0ICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcblx0ICAgIHJldHVybiBwdWI7XG5cblx0ICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcblx0ICAgIHB1YjogcHViLFxuXHQgICAgcHViRW5jOiBlbmNcblx0ICB9KTtcblx0fTtcblxuXHRLZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuXHQgIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcblx0ICAgIHJldHVybiBwcml2O1xuXG5cdCAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG5cdCAgICBwcml2OiBwcml2LFxuXHQgICAgcHJpdkVuYzogZW5jXG5cdCAgfSk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblx0ICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuXHQgIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuXHQgIGlmICghcHViLnZhbGlkYXRlKCkpXG5cdCAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuXHQgIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cblx0ICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcblx0ICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG5cdCAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuXHQgICAgZW5jID0gY29tcGFjdDtcblx0ICAgIGNvbXBhY3QgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICghdGhpcy5wdWIpXG5cdCAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuXHQgIGlmICghZW5jKVxuXHQgICAgcmV0dXJuIHRoaXMucHViO1xuXG5cdCAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMucHJpdjtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG5cdCAgdGhpcy5wcml2ID0gbmV3IGJuKGtleSwgZW5jIHx8IDE2KTtcblxuXHQgIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuXHQgIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuXHQgIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcblx0ICBpZiAoa2V5LnggfHwga2V5LnkpIHtcblx0ICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cblx0ICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG5cdCAgICAvLyBgeWAgY29vcmRpbmF0ZXMuXG5cdCAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcblx0ICAgICAgYXNzZXJ0JDMoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcblx0ICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcblx0ICAgICAgYXNzZXJ0JDMoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcblx0fTtcblxuXHQvLyBFQ0RIXG5cdEtleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcblx0ICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcblx0fTtcblxuXHQvLyBFQ0RTQVxuXHRLZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuXHQgIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuXHQgIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcblx0ICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciBhc3NlcnQkNCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cblx0ZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsIGVuYykge1xuXHQgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cblx0ICBpZiAodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsIGVuYykpXG5cdCAgICByZXR1cm47XG5cblx0ICBhc3NlcnQkNChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG5cdCAgdGhpcy5yID0gbmV3IGJuKG9wdGlvbnMuciwgMTYpO1xuXHQgIHRoaXMucyA9IG5ldyBibihvcHRpb25zLnMsIDE2KTtcblx0ICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG5cdCAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXHQgIGVsc2Vcblx0ICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcblx0fVxuXHR2YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuXG5cdGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuXHQgIHRoaXMucGxhY2UgPSAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuXHQgIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG5cdCAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG5cdCAgICByZXR1cm4gaW5pdGlhbDtcblx0ICB9XG5cdCAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4Zjtcblx0ICB2YXIgdmFsID0gMDtcblx0ICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG5cdCAgICB2YWwgPDw9IDg7XG5cdCAgICB2YWwgfD0gYnVmW29mZl07XG5cdCAgfVxuXHQgIHAucGxhY2UgPSBvZmY7XG5cdCAgcmV0dXJuIHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcblx0ICB2YXIgaSA9IDA7XG5cdCAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuXHQgIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcblx0ICAgIGkrKztcblx0ICB9XG5cdCAgaWYgKGkgPT09IDApIHtcblx0ICAgIHJldHVybiBidWY7XG5cdCAgfVxuXHQgIHJldHVybiBidWYuc2xpY2UoaSk7XG5cdH1cblxuXHRTaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuXHQgIGRhdGEgPSB1dGlsc18xJDEudG9BcnJheShkYXRhLCBlbmMpO1xuXHQgIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG5cdCAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuXHQgIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG5cdCAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcblx0ICBwLnBsYWNlICs9IHJsZW47XG5cdCAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcblx0ICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG5cdCAgaWYgKHJbMF0gPT09IDAgJiYgKHJbMV0gJiAweDgwKSkge1xuXHQgICAgciA9IHIuc2xpY2UoMSk7XG5cdCAgfVxuXHQgIGlmIChzWzBdID09PSAwICYmIChzWzFdICYgMHg4MCkpIHtcblx0ICAgIHMgPSBzLnNsaWNlKDEpO1xuXHQgIH1cblxuXHQgIHRoaXMuciA9IG5ldyBibihyKTtcblx0ICB0aGlzLnMgPSBuZXcgYm4ocyk7XG5cdCAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuXHQgIGlmIChsZW4gPCAweDgwKSB7XG5cdCAgICBhcnIucHVzaChsZW4pO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuXHQgIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuXHQgIHdoaWxlICgtLW9jdGV0cykge1xuXHQgICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcblx0ICB9XG5cdCAgYXJyLnB1c2gobGVuKTtcblx0fVxuXG5cdFNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcblx0ICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG5cdCAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChyWzBdICYgMHg4MClcblx0ICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChzWzBdICYgMHg4MClcblx0ICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cblx0ICByID0gcm1QYWRkaW5nKHIpO1xuXHQgIHMgPSBybVBhZGRpbmcocyk7XG5cblx0ICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcblx0ICAgIHMgPSBzLnNsaWNlKDEpO1xuXHQgIH1cblx0ICB2YXIgYXJyID0gWyAweDAyIF07XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuXHQgIGFyciA9IGFyci5jb25jYXQocik7XG5cdCAgYXJyLnB1c2goMHgwMik7XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuXHQgIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG5cdCAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuXHQgIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG5cdCAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG5cdCAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUocmVzLCBlbmMpO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cblx0dmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuXHRmdW5jdGlvbiBFQyhvcHRpb25zKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcblx0ICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cblx0ICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG5cdCAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXHQgICAgYXNzZXJ0JDUoY3VydmVzXzEuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuXHQgICAgb3B0aW9ucyA9IGN1cnZlc18xW29wdGlvbnNdO1xuXHQgIH1cblxuXHQgIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG5cdCAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXNfMS5QcmVzZXRDdXJ2ZSlcblx0ICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cblx0ICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcblx0ICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG5cdCAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcblx0ICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cblx0ICAvLyBQb2ludCBvbiBjdXJ2ZVxuXHQgIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcblx0ICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuXHQgIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG5cdCAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcblx0fVxuXHR2YXIgZWMgPSBFQztcblxuXHRFQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuXHQgIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuXHQgIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcblx0ICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG5cdCAgaWYgKCFvcHRpb25zKVxuXHQgICAgb3B0aW9ucyA9IHt9O1xuXG5cdCAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG5cdCAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuXHQgICAgaGFzaDogdGhpcy5oYXNoLFxuXHQgICAgcGVyczogb3B0aW9ucy5wZXJzLFxuXHQgICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4Jyxcblx0ICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBicm9yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuXHQgICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG5cdCAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuXHQgIH0pO1xuXG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgYm4oMikpO1xuXHQgIGRvIHtcblx0ICAgIHZhciBwcml2ID0gbmV3IGJuKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcblx0ICAgIGlmIChwcml2LmNtcChuczIpID4gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHByaXYuaWFkZG4oMSk7XG5cdCAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcblx0ICB9IHdoaWxlICh0cnVlKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcblx0ICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcblx0ICBpZiAoZGVsdGEgPiAwKVxuXHQgICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcblx0ICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcblx0ICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIG1zZztcblx0fTtcblxuXHRFQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuXHQgIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuXHQgICAgb3B0aW9ucyA9IGVuYztcblx0ICAgIGVuYyA9IG51bGw7XG5cdCAgfVxuXHQgIGlmICghb3B0aW9ucylcblx0ICAgIG9wdGlvbnMgPSB7fTtcblxuXHQgIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuXHQgIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csIDE2KSk7XG5cblx0ICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuXHQgIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG5cdCAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG5cdCAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuXHQgIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuXHQgIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuXHQgIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcblx0ICAgIGhhc2g6IHRoaXMuaGFzaCxcblx0ICAgIGVudHJvcHk6IGJrZXksXG5cdCAgICBub25jZTogbm9uY2UsXG5cdCAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG5cdCAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnXG5cdCAgfSk7XG5cblx0ICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcblx0ICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgYm4oMSkpO1xuXG5cdCAgZm9yICh2YXIgaXRlciA9IDA7IHRydWU7IGl0ZXIrKykge1xuXHQgICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuXHQgICAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG5cdCAgICAgICAgbmV3IGJuKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuXHQgICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuXHQgICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG5cdCAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuXHQgICAgICBjb250aW51ZTtcblxuXHQgICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcblx0ICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcblx0ICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuXHQgICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuXHQgICAgaWYgKHMuY21wbigwKSA9PT0gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cblx0ICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG5cdCAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG5cdCAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuXHQgICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgc2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcblx0ICB9XG5cdH07XG5cblx0RUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSQxLCBrZXksIGVuYykge1xuXHQgIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csIDE2KSk7XG5cdCAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcblx0ICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuXHQgIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG5cdCAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuXHQgIHZhciBzID0gc2lnbmF0dXJlJDEucztcblx0ICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgLy8gVmFsaWRhdGUgc2lnbmF0dXJlXG5cdCAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcblx0ICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcblx0ICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKHRoaXMubik7XG5cblx0ICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuXHQgICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcblx0ICAgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcblx0ICB9XG5cblx0ICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG5cdCAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuXHQgIHZhciBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuXHQgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiBmYWxzZTtcblxuXHQgIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG5cdCAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuXHQgIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuXHQgIHJldHVybiBwLmVxWFRvUChyKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuXHQgIGFzc2VydCQ1KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG5cdCAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuXG5cdCAgdmFyIG4gPSB0aGlzLm47XG5cdCAgdmFyIGUgPSBuZXcgYm4obXNnKTtcblx0ICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG5cdCAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXG5cdCAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG5cdCAgdmFyIGlzWU9kZCA9IGogJiAxO1xuXHQgIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcblx0ICBpZiAoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcblx0ICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cblx0ICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuXHQgIGlmIChpc1NlY29uZEtleSlcblx0ICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcblx0ICBlbHNlXG5cdCAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIsIGlzWU9kZCk7XG5cblx0ICB2YXIgckludiA9IHNpZ25hdHVyZSQxLnIuaW52bShuKTtcblx0ICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcblx0ICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG5cdCAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG5cdCAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG5cdCAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSQxLCBRLCBlbmMpIHtcblx0ICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cdCAgaWYgKHNpZ25hdHVyZSQxLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG5cdCAgICByZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICB2YXIgUXByaW1lO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSQxLCBpKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChRcHJpbWUuZXEoUSkpXG5cdCAgICAgIHJldHVybiBpO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xuXHR9O1xuXG5cdHZhciBlZGRzYSA9IHt9O1xuXG5cdHZhciByZXF1aXJlJCQwJDEgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKF9wYWNrYWdlJDEpO1xuXG5cdHZhciBlbGxpcHRpY18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuXHRlbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSQkMCQxLnZlcnNpb247XG5cdGVsbGlwdGljLnV0aWxzID0gdXRpbHNfMSQxO1xuXHRlbGxpcHRpYy5yYW5kID0gYnJvcmFuZDtcblx0ZWxsaXB0aWMuY3VydmUgPSBjdXJ2ZV8xO1xuXHRlbGxpcHRpYy5jdXJ2ZXMgPSBjdXJ2ZXNfMTtcblxuXHQvLyBQcm90b2NvbHNcblx0ZWxsaXB0aWMuZWMgPSBlYztcblx0ZWxsaXB0aWMuZWRkc2EgPSBlZGRzYTtcblx0fSk7XG5cdHZhciBlbGxpcHRpY18yID0gZWxsaXB0aWNfMS5lYztcblxuXHR2YXIgX3ZlcnNpb24kcSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJzaWduaW5nLWtleS81LjAuMC1iZXRhLjEzNlwiO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kciA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kcSk7XG5cdHZhciBfdmVyc2lvbl8xJGQgPSBfdmVyc2lvbiRxLnZlcnNpb247XG5cblx0dmFyIGxpYiRmID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHEudmVyc2lvbik7XG5cdHZhciBfY3VydmUgPSBudWxsO1xuXHRmdW5jdGlvbiBnZXRDdXJ2ZSgpIHtcblx0ICAgIGlmICghX2N1cnZlKSB7XG5cdCAgICAgICAgX2N1cnZlID0gbmV3IGVsbGlwdGljXzEuZWMoXCJzZWNwMjU2azFcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gX2N1cnZlO1xuXHR9XG5cdHZhciBTaWduaW5nS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU2lnbmluZ0tleShwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByaXZhdGVLZXlcIiwgbGliJDEuaGV4bGlmeShwcml2YXRlS2V5KSk7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb21wcmVzc2VkUHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25pbmdLZXlcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBTaWduaW5nS2V5LnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgcDAgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKTtcblx0ICAgICAgICB2YXIgcDEgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkob3RoZXIpKTtcblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIik7XG5cdCAgICB9O1xuXHQgICAgU2lnbmluZ0tleS5wcm90b3R5cGUuc2lnbkRpZ2VzdCA9IGZ1bmN0aW9uIChkaWdlc3QpIHtcblx0ICAgICAgICB2YXIga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUobGliJDEuYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG5cdCAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihsaWIkMS5hcnJheWlmeShkaWdlc3QpLCB7IGNhbm9uaWNhbDogdHJ1ZSB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuc3BsaXRTaWduYXR1cmUoe1xuXHQgICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcblx0ICAgICAgICAgICAgcjogbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNiksIDMyKSxcblx0ICAgICAgICAgICAgczogbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUucy50b1N0cmluZygxNiksIDMyKSxcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduaW5nS2V5LnByb3RvdHlwZS5jb21wdXRlU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyS2V5KSB7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIHZhciBvdGhlcktleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBrZXlQYWlyLmRlcml2ZShvdGhlcktleVBhaXIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIFNpZ25pbmdLZXkuaXNTaWduaW5nS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTaWduaW5nS2V5O1xuXHR9KCkpO1xuXHRleHBvcnRzLlNpZ25pbmdLZXkgPSBTaWduaW5nS2V5O1xuXHRmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG5cdCAgICB2YXIgc2lnID0gbGliJDEuc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcblx0ICAgIHZhciBycyA9IHsgcjogbGliJDEuYXJyYXlpZnkoc2lnLnIpLCBzOiBsaWIkMS5hcnJheWlmeShzaWcucykgfTtcblx0ICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLnJlY292ZXJQdWJLZXkobGliJDEuYXJyYXlpZnkoZGlnZXN0KSwgcnMsIHNpZy5yZWNvdmVyeVBhcmFtKS5lbmNvZGUoXCJoZXhcIiwgZmFsc2UpO1xuXHR9XG5cdGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXk7XG5cdGZ1bmN0aW9uIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShrZXkpO1xuXHQgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcblx0ICAgICAgICB2YXIgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShieXRlcykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG5cdCAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuXHQgICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuaGV4bGlmeShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXlcIiwgXCJrZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuXHR9XG5cdGV4cG9ydHMuY29tcHV0ZVB1YmxpY0tleSA9IGNvbXB1dGVQdWJsaWNLZXk7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRmID0gdW53cmFwRXhwb3J0cyhsaWIkZik7XG5cdHZhciBsaWJfMSRmID0gbGliJGYuU2lnbmluZ0tleTtcblx0dmFyIGxpYl8yJGUgPSBsaWIkZi5yZWNvdmVyUHVibGljS2V5O1xuXHR2YXIgbGliXzMkYiA9IGxpYiRmLmNvbXB1dGVQdWJsaWNLZXk7XG5cblx0dmFyIF92ZXJzaW9uJHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuMC4wLWJldGEuMTM2XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiR0ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRzKTtcblx0dmFyIF92ZXJzaW9uXzEkZSA9IF92ZXJzaW9uJHMudmVyc2lvbjtcblxuXHR2YXIgbGliJGcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXHR2YXIgUkxQID0gX19pbXBvcnRTdGFyKGxpYiQ1KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHMudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkNi5nZXRBZGRyZXNzKHZhbHVlKTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVOdW1iZXIodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ3Llplcm87XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHR9XG5cdHZhciB0cmFuc2FjdGlvbkZpZWxkcyA9IFtcblx0ICAgIHsgbmFtZTogXCJub25jZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG5cdCAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcImdhc0xpbWl0XCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcblx0ICAgIHsgbmFtZTogXCJ0b1wiLCBsZW5ndGg6IDIwIH0sXG5cdCAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcImRhdGFcIiB9LFxuXHRdO1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcblx0ICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZVxuXHR9O1xuXHRmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcblx0ICAgIHZhciBwdWJsaWNLZXkgPSBsaWIkZi5jb21wdXRlUHVibGljS2V5KGtleSk7XG5cdCAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UobGliJDQua2VjY2FrMjU2KGxpYiQxLmhleERhdGFTbGljZShwdWJsaWNLZXksIDEpKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gY29tcHV0ZUFkZHJlc3M7XG5cdGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG5cdCAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MobGliJGYucmVjb3ZlclB1YmxpY0tleShsaWIkMS5hcnJheWlmeShkaWdlc3QpLCBzaWduYXR1cmUpKTtcblx0fVxuXHRleHBvcnRzLnJlY292ZXJBZGRyZXNzID0gcmVjb3ZlckFkZHJlc3M7XG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG5cdCAgICBsaWIkMy5jaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuXHQgICAgdmFyIHJhdyA9IFtdO1xuXHQgICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNhY3Rpb25bZmllbGRJbmZvLm5hbWVdIHx8IChbXSk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICBpZiAoZmllbGRJbmZvLm51bWVyaWMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgPSBsaWIkMS5hcnJheWlmeShsaWIkMS5oZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSk7XG5cdCAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcblx0ICAgICAgICBpZiAoZmllbGRJbmZvLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFZhcmlhYmxlLXdpZHRoICh3aXRoIGEgbWF4aW11bSlcblx0ICAgICAgICBpZiAoZmllbGRJbmZvLm1heExlbmd0aCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGxpYiQxLnN0cmlwWmVyb3ModmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gZmllbGRJbmZvLm1heExlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJhdy5wdXNoKGxpYiQxLmhleGxpZnkodmFsdWUpKTtcblx0ICAgIH0pO1xuXHQgICAgdmFyIGNoYWluSWQgPSAwO1xuXHQgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuXHQgICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG5cdCAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChzaWduYXR1cmUgJiYgIWxpYiQxLmlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuXHQgICAgICAgIC8vIE5vIGNoYWluSWQgcHJvdmlkZWQsIGJ1dCB0aGUgc2lnbmF0dXJlIGlzIHNpZ25pbmcgd2l0aCBFSVAtMTU1OyBkZXJpdmUgY2hhaW5JZFxuXHQgICAgICAgIGNoYWluSWQgPSBNYXRoLmZsb29yKChzaWduYXR1cmUudiAtIDM1KSAvIDIpO1xuXHQgICAgfVxuXHQgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuXHQgICAgaWYgKGNoYWluSWQgIT09IDApIHtcblx0ICAgICAgICByYXcucHVzaChsaWIkMS5oZXhsaWZ5KGNoYWluSWQpKTtcblx0ICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICB9XG5cdCAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYXRpb25cblx0ICAgIGlmICghc2lnbmF0dXJlKSB7XG5cdCAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcblx0ICAgIH1cblx0ICAgIC8vIFRoZSBzcGxpdFNpZ25hdHVyZSB3aWxsIGVuc3VyZSB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgcmVjb3ZlcnlQYXJhbSBpbiB0aGVcblx0ICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG5cdCAgICB2YXIgc2lnID0gbGliJDEuc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcblx0ICAgIC8vIFdlIHB1c2hlZCBhIGNoYWluSWQgYW5kIG51bGwgciwgcyBvbiBmb3IgaGFzaGluZyBvbmx5OyByZW1vdmUgdGhvc2Vcblx0ICAgIHZhciB2ID0gMjcgKyBzaWcucmVjb3ZlcnlQYXJhbTtcblx0ICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgcmF3LnBvcCgpO1xuXHQgICAgICAgIHJhdy5wb3AoKTtcblx0ICAgICAgICByYXcucG9wKCk7XG5cdCAgICAgICAgdiArPSBjaGFpbklkICogMiArIDg7XG5cdCAgICAgICAgLy8gSWYgYW4gRUlQLTE1NSB2IChkaXJlY3RseSBvciBpbmRpcmVjdGx5OyBtYXliZSBfdnMpIHdhcyBwcm92aWRlZCwgY2hlY2sgaXQhXG5cdCAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChzaWcudiAhPT0gdikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICB9XG5cdCAgICByYXcucHVzaChsaWIkMS5oZXhsaWZ5KHYpKTtcblx0ICAgIHJhdy5wdXNoKGxpYiQxLnN0cmlwWmVyb3MobGliJDEuYXJyYXlpZnkoc2lnLnIpKSk7XG5cdCAgICByYXcucHVzaChsaWIkMS5zdHJpcFplcm9zKGxpYiQxLmFycmF5aWZ5KHNpZy5zKSkpO1xuXHQgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcblx0fVxuXHRleHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcblx0ZnVuY3Rpb24gcGFyc2UocmF3VHJhbnNhY3Rpb24pIHtcblx0ICAgIHZhciB0cmFuc2FjdGlvbiA9IFJMUC5kZWNvZGUocmF3VHJhbnNhY3Rpb24pO1xuXHQgICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByYXcgdHJhbnNhY3Rpb25cIiwgXCJyYXdUcmFuc2FjdGlvblwiLCByYXdUcmFuc2FjdGlvbik7XG5cdCAgICB9XG5cdCAgICB2YXIgdHggPSB7XG5cdCAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcblx0ICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKSxcblx0ICAgICAgICBnYXNMaW1pdDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKSxcblx0ICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG5cdCAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG5cdCAgICAgICAgZGF0YTogdHJhbnNhY3Rpb25bNV0sXG5cdCAgICAgICAgY2hhaW5JZDogMFxuXHQgICAgfTtcblx0ICAgIC8vIExlZ2FjeSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuXHQgICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdHgudiA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uWzZdKS50b051bWJlcigpO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH1cblx0ICAgIHR4LnIgPSBsaWIkMS5oZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzddLCAzMik7XG5cdCAgICB0eC5zID0gbGliJDEuaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls4XSwgMzIpO1xuXHQgICAgaWYgKGxpYiQyLkJpZ051bWJlci5mcm9tKHR4LnIpLmlzWmVybygpICYmIGxpYiQyLkJpZ051bWJlci5mcm9tKHR4LnMpLmlzWmVybygpKSB7XG5cdCAgICAgICAgLy8gRUlQLTE1NSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuXHQgICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuXHQgICAgICAgIHR4LnYgPSAwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgLy8gU2lnbmVkIFRyYW5hc2FjdGlvblxuXHQgICAgICAgIHR4LmNoYWluSWQgPSBNYXRoLmZsb29yKCh0eC52IC0gMzUpIC8gMik7XG5cdCAgICAgICAgaWYgKHR4LmNoYWluSWQgPCAwKSB7XG5cdCAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IHR4LnYgLSAyNztcblx0ICAgICAgICB2YXIgcmF3ID0gdHJhbnNhY3Rpb24uc2xpY2UoMCwgNik7XG5cdCAgICAgICAgaWYgKHR4LmNoYWluSWQgIT09IDApIHtcblx0ICAgICAgICAgICAgcmF3LnB1c2gobGliJDEuaGV4bGlmeSh0eC5jaGFpbklkKSk7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICAgICAgICAgIHJlY292ZXJ5UGFyYW0gLT0gdHguY2hhaW5JZCAqIDIgKyA4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlnZXN0ID0gbGliJDQua2VjY2FrMjU2KFJMUC5lbmNvZGUocmF3KSk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiBsaWIkMS5oZXhsaWZ5KHR4LnIpLCBzOiBsaWIkMS5oZXhsaWZ5KHR4LnMpLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0eC5oYXNoID0gbGliJDQua2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0eDtcblx0fVxuXHRleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRnID0gdW53cmFwRXhwb3J0cyhsaWIkZyk7XG5cdHZhciBsaWJfMSRnID0gbGliJGcuY29tcHV0ZUFkZHJlc3M7XG5cdHZhciBsaWJfMiRmID0gbGliJGcucmVjb3ZlckFkZHJlc3M7XG5cdHZhciBsaWJfMyRjID0gbGliJGcuc2VyaWFsaXplO1xuXHR2YXIgbGliXzQkOSA9IGxpYiRnLnBhcnNlO1xuXG5cdHZhciBfdmVyc2lvbiR1ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIndvcmRsaXN0cy81LjAuMC1iZXRhLjEzN1wiO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kdiA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kdSk7XG5cdHZhciBfdmVyc2lvbl8xJGYgPSBfdmVyc2lvbiR1LnZlcnNpb247XG5cblx0dmFyIHdvcmRsaXN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvLyBUaGlzIGdldHMgb3ZlcnJpZGRlbiBieSByb2xsdXBcblx0dmFyIGV4cG9ydFdvcmRsaXN0ID0gZmFsc2U7XG5cblxuXG5cblx0ZXhwb3J0cy5sb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiR1LnZlcnNpb24pO1xuXHR2YXIgV29yZGxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBXb3JkbGlzdChsb2NhbGUpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgZXhwb3J0cy5sb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBXb3JkbGlzdCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJsb2NhbGVcIiwgbG9jYWxlKTtcblx0ICAgIH1cblx0ICAgIC8vIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcblx0ICAgIFdvcmRsaXN0LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChtbmVtb25pYykge1xuXHQgICAgICAgIHJldHVybiBtbmVtb25pYy50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKy9nKTtcblx0ICAgIH07XG5cdCAgICAvLyBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzXG5cdCAgICBXb3JkbGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh3b3Jkcykge1xuXHQgICAgICAgIHJldHVybiB3b3Jkcy5qb2luKFwiIFwiKTtcblx0ICAgIH07XG5cdCAgICBXb3JkbGlzdC5jaGVjayA9IGZ1bmN0aW9uICh3b3JkbGlzdCkge1xuXHQgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjA0ODsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkID0gd29yZGxpc3QuZ2V0V29yZChpKTtcblx0ICAgICAgICAgICAgaWYgKGkgIT09IHdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3JkKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDkuaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGxhbmcsIG5hbWUpIHtcblx0ICAgICAgICBpZiAoIW5hbWUpIHtcblx0ICAgICAgICAgICAgbmFtZSA9IGxhbmcubG9jYWxlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZXhwb3J0V29yZGxpc3QpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBhbnlHbG9iYWwgPSB3aW5kb3c7XG5cdCAgICAgICAgICAgICAgICBpZiAoYW55R2xvYmFsLl9ldGhlcnMgJiYgYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzLCBuYW1lLCBsYW5nKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdvcmRsaXN0O1xuXHR9KCkpO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gV29yZGxpc3Q7XG5cdH0pO1xuXG5cdHZhciB3b3JkbGlzdCQxID0gdW53cmFwRXhwb3J0cyh3b3JkbGlzdCk7XG5cdHZhciB3b3JkbGlzdF8xID0gd29yZGxpc3QubG9nZ2VyO1xuXHR2YXIgd29yZGxpc3RfMiA9IHdvcmRsaXN0LldvcmRsaXN0O1xuXG5cdHZhciBsYW5nRW5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHR2YXIgd29yZHMgPSBcIkFiYW5kb25BYmlsaXR5QWJsZUFib3V0QWJvdmVBYnNlbnRBYnNvcmJBYnN0cmFjdEFic3VyZEFidXNlQWNjZXNzQWNjaWRlbnRBY2NvdW50QWNjdXNlQWNoaWV2ZUFjaWRBY291c3RpY0FjcXVpcmVBY3Jvc3NBY3RBY3Rpb25BY3RvckFjdHJlc3NBY3R1YWxBZGFwdEFkZEFkZGljdEFkZHJlc3NBZGp1c3RBZG1pdEFkdWx0QWR2YW5jZUFkdmljZUFlcm9iaWNBZmZhaXJBZmZvcmRBZnJhaWRBZ2FpbkFnZUFnZW50QWdyZWVBaGVhZEFpbUFpckFpcnBvcnRBaXNsZUFsYXJtQWxidW1BbGNvaG9sQWxlcnRBbGllbkFsbEFsbGV5QWxsb3dBbG1vc3RBbG9uZUFscGhhQWxyZWFkeUFsc29BbHRlckFsd2F5c0FtYXRldXJBbWF6aW5nQW1vbmdBbW91bnRBbXVzZWRBbmFseXN0QW5jaG9yQW5jaWVudEFuZ2VyQW5nbGVBbmdyeUFuaW1hbEFua2xlQW5ub3VuY2VBbm51YWxBbm90aGVyQW5zd2VyQW50ZW5uYUFudGlxdWVBbnhpZXR5QW55QXBhcnRBcG9sb2d5QXBwZWFyQXBwbGVBcHByb3ZlQXByaWxBcmNoQXJjdGljQXJlYUFyZW5hQXJndWVBcm1Bcm1lZEFybW9yQXJteUFyb3VuZEFycmFuZ2VBcnJlc3RBcnJpdmVBcnJvd0FydEFydGVmYWN0QXJ0aXN0QXJ0d29ya0Fza0FzcGVjdEFzc2F1bHRBc3NldEFzc2lzdEFzc3VtZUFzdGhtYUF0aGxldGVBdG9tQXR0YWNrQXR0ZW5kQXR0aXR1ZGVBdHRyYWN0QXVjdGlvbkF1ZGl0QXVndXN0QXVudEF1dGhvckF1dG9BdXR1bW5BdmVyYWdlQXZvY2Fkb0F2b2lkQXdha2VBd2FyZUF3YXlBd2Vzb21lQXdmdWxBd2t3YXJkQXhpc0JhYnlCYWNoZWxvckJhY29uQmFkZ2VCYWdCYWxhbmNlQmFsY29ueUJhbGxCYW1ib29CYW5hbmFCYW5uZXJCYXJCYXJlbHlCYXJnYWluQmFycmVsQmFzZUJhc2ljQmFza2V0QmF0dGxlQmVhY2hCZWFuQmVhdXR5QmVjYXVzZUJlY29tZUJlZWZCZWZvcmVCZWdpbkJlaGF2ZUJlaGluZEJlbGlldmVCZWxvd0JlbHRCZW5jaEJlbmVmaXRCZXN0QmV0cmF5QmV0dGVyQmV0d2VlbkJleW9uZEJpY3ljbGVCaWRCaWtlQmluZEJpb2xvZ3lCaXJkQmlydGhCaXR0ZXJCbGFja0JsYWRlQmxhbWVCbGFua2V0Qmxhc3RCbGVha0JsZXNzQmxpbmRCbG9vZEJsb3Nzb21CbG91c2VCbHVlQmx1ckJsdXNoQm9hcmRCb2F0Qm9keUJvaWxCb21iQm9uZUJvbnVzQm9va0Jvb3N0Qm9yZGVyQm9yaW5nQm9ycm93Qm9zc0JvdHRvbUJvdW5jZUJveEJveUJyYWNrZXRCcmFpbkJyYW5kQnJhc3NCcmF2ZUJyZWFkQnJlZXplQnJpY2tCcmlkZ2VCcmllZkJyaWdodEJyaW5nQnJpc2tCcm9jY29saUJyb2tlbkJyb256ZUJyb29tQnJvdGhlckJyb3duQnJ1c2hCdWJibGVCdWRkeUJ1ZGdldEJ1ZmZhbG9CdWlsZEJ1bGJCdWxrQnVsbGV0QnVuZGxlQnVua2VyQnVyZGVuQnVyZ2VyQnVyc3RCdXNCdXNpbmVzc0J1c3lCdXR0ZXJCdXllckJ1enpDYWJiYWdlQ2FiaW5DYWJsZUNhY3R1c0NhZ2VDYWtlQ2FsbENhbG1DYW1lcmFDYW1wQ2FuQ2FuYWxDYW5jZWxDYW5keUNhbm5vbkNhbm9lQ2FudmFzQ2FueW9uQ2FwYWJsZUNhcGl0YWxDYXB0YWluQ2FyQ2FyYm9uQ2FyZENhcmdvQ2FycGV0Q2FycnlDYXJ0Q2FzZUNhc2hDYXNpbm9DYXN0bGVDYXN1YWxDYXRDYXRhbG9nQ2F0Y2hDYXRlZ29yeUNhdHRsZUNhdWdodENhdXNlQ2F1dGlvbkNhdmVDZWlsaW5nQ2VsZXJ5Q2VtZW50Q2Vuc3VzQ2VudHVyeUNlcmVhbENlcnRhaW5DaGFpckNoYWxrQ2hhbXBpb25DaGFuZ2VDaGFvc0NoYXB0ZXJDaGFyZ2VDaGFzZUNoYXRDaGVhcENoZWNrQ2hlZXNlQ2hlZkNoZXJyeUNoZXN0Q2hpY2tlbkNoaWVmQ2hpbGRDaGltbmV5Q2hvaWNlQ2hvb3NlQ2hyb25pY0NodWNrbGVDaHVua0NodXJuQ2lnYXJDaW5uYW1vbkNpcmNsZUNpdGl6ZW5DaXR5Q2l2aWxDbGFpbUNsYXBDbGFyaWZ5Q2xhd0NsYXlDbGVhbkNsZXJrQ2xldmVyQ2xpY2tDbGllbnRDbGlmZkNsaW1iQ2xpbmljQ2xpcENsb2NrQ2xvZ0Nsb3NlQ2xvdGhDbG91ZENsb3duQ2x1YkNsdW1wQ2x1c3RlckNsdXRjaENvYWNoQ29hc3RDb2NvbnV0Q29kZUNvZmZlZUNvaWxDb2luQ29sbGVjdENvbG9yQ29sdW1uQ29tYmluZUNvbWVDb21mb3J0Q29taWNDb21tb25Db21wYW55Q29uY2VydENvbmR1Y3RDb25maXJtQ29uZ3Jlc3NDb25uZWN0Q29uc2lkZXJDb250cm9sQ29udmluY2VDb29rQ29vbENvcHBlckNvcHlDb3JhbENvcmVDb3JuQ29ycmVjdENvc3RDb3R0b25Db3VjaENvdW50cnlDb3VwbGVDb3Vyc2VDb3VzaW5Db3ZlckNveW90ZUNyYWNrQ3JhZGxlQ3JhZnRDcmFtQ3JhbmVDcmFzaENyYXRlckNyYXdsQ3JhenlDcmVhbUNyZWRpdENyZWVrQ3Jld0NyaWNrZXRDcmltZUNyaXNwQ3JpdGljQ3JvcENyb3NzQ3JvdWNoQ3Jvd2RDcnVjaWFsQ3J1ZWxDcnVpc2VDcnVtYmxlQ3J1bmNoQ3J1c2hDcnlDcnlzdGFsQ3ViZUN1bHR1cmVDdXBDdXBib2FyZEN1cmlvdXNDdXJyZW50Q3VydGFpbkN1cnZlQ3VzaGlvbkN1c3RvbUN1dGVDeWNsZURhZERhbWFnZURhbXBEYW5jZURhbmdlckRhcmluZ0Rhc2hEYXVnaHRlckRhd25EYXlEZWFsRGViYXRlRGVicmlzRGVjYWRlRGVjZW1iZXJEZWNpZGVEZWNsaW5lRGVjb3JhdGVEZWNyZWFzZURlZXJEZWZlbnNlRGVmaW5lRGVmeURlZ3JlZURlbGF5RGVsaXZlckRlbWFuZERlbWlzZURlbmlhbERlbnRpc3REZW55RGVwYXJ0RGVwZW5kRGVwb3NpdERlcHRoRGVwdXR5RGVyaXZlRGVzY3JpYmVEZXNlcnREZXNpZ25EZXNrRGVzcGFpckRlc3Ryb3lEZXRhaWxEZXRlY3REZXZlbG9wRGV2aWNlRGV2b3RlRGlhZ3JhbURpYWxEaWFtb25kRGlhcnlEaWNlRGllc2VsRGlldERpZmZlckRpZ2l0YWxEaWduaXR5RGlsZW1tYURpbm5lckRpbm9zYXVyRGlyZWN0RGlydERpc2FncmVlRGlzY292ZXJEaXNlYXNlRGlzaERpc21pc3NEaXNvcmRlckRpc3BsYXlEaXN0YW5jZURpdmVydERpdmlkZURpdm9yY2VEaXp6eURvY3RvckRvY3VtZW50RG9nRG9sbERvbHBoaW5Eb21haW5Eb25hdGVEb25rZXlEb25vckRvb3JEb3NlRG91YmxlRG92ZURyYWZ0RHJhZ29uRHJhbWFEcmFzdGljRHJhd0RyZWFtRHJlc3NEcmlmdERyaWxsRHJpbmtEcmlwRHJpdmVEcm9wRHJ1bURyeUR1Y2tEdW1iRHVuZUR1cmluZ0R1c3REdXRjaER1dHlEd2FyZkR5bmFtaWNFYWdlckVhZ2xlRWFybHlFYXJuRWFydGhFYXNpbHlFYXN0RWFzeUVjaG9FY29sb2d5RWNvbm9teUVkZ2VFZGl0RWR1Y2F0ZUVmZm9ydEVnZ0VpZ2h0RWl0aGVyRWxib3dFbGRlckVsZWN0cmljRWxlZ2FudEVsZW1lbnRFbGVwaGFudEVsZXZhdG9yRWxpdGVFbHNlRW1iYXJrRW1ib2R5RW1icmFjZUVtZXJnZUVtb3Rpb25FbXBsb3lFbXBvd2VyRW1wdHlFbmFibGVFbmFjdEVuZEVuZGxlc3NFbmRvcnNlRW5lbXlFbmVyZ3lFbmZvcmNlRW5nYWdlRW5naW5lRW5oYW5jZUVuam95RW5saXN0RW5vdWdoRW5yaWNoRW5yb2xsRW5zdXJlRW50ZXJFbnRpcmVFbnRyeUVudmVsb3BlRXBpc29kZUVxdWFsRXF1aXBFcmFFcmFzZUVyb2RlRXJvc2lvbkVycm9yRXJ1cHRFc2NhcGVFc3NheUVzc2VuY2VFc3RhdGVFdGVybmFsRXRoaWNzRXZpZGVuY2VFdmlsRXZva2VFdm9sdmVFeGFjdEV4YW1wbGVFeGNlc3NFeGNoYW5nZUV4Y2l0ZUV4Y2x1ZGVFeGN1c2VFeGVjdXRlRXhlcmNpc2VFeGhhdXN0RXhoaWJpdEV4aWxlRXhpc3RFeGl0RXhvdGljRXhwYW5kRXhwZWN0RXhwaXJlRXhwbGFpbkV4cG9zZUV4cHJlc3NFeHRlbmRFeHRyYUV5ZUV5ZWJyb3dGYWJyaWNGYWNlRmFjdWx0eUZhZGVGYWludEZhaXRoRmFsbEZhbHNlRmFtZUZhbWlseUZhbW91c0ZhbkZhbmN5RmFudGFzeUZhcm1GYXNoaW9uRmF0RmF0YWxGYXRoZXJGYXRpZ3VlRmF1bHRGYXZvcml0ZUZlYXR1cmVGZWJydWFyeUZlZGVyYWxGZWVGZWVkRmVlbEZlbWFsZUZlbmNlRmVzdGl2YWxGZXRjaEZldmVyRmV3RmliZXJGaWN0aW9uRmllbGRGaWd1cmVGaWxlRmlsbUZpbHRlckZpbmFsRmluZEZpbmVGaW5nZXJGaW5pc2hGaXJlRmlybUZpcnN0RmlzY2FsRmlzaEZpdEZpdG5lc3NGaXhGbGFnRmxhbWVGbGFzaEZsYXRGbGF2b3JGbGVlRmxpZ2h0RmxpcEZsb2F0RmxvY2tGbG9vckZsb3dlckZsdWlkRmx1c2hGbHlGb2FtRm9jdXNGb2dGb2lsRm9sZEZvbGxvd0Zvb2RGb290Rm9yY2VGb3Jlc3RGb3JnZXRGb3JrRm9ydHVuZUZvcnVtRm9yd2FyZEZvc3NpbEZvc3RlckZvdW5kRm94RnJhZ2lsZUZyYW1lRnJlcXVlbnRGcmVzaEZyaWVuZEZyaW5nZUZyb2dGcm9udEZyb3N0RnJvd25Gcm96ZW5GcnVpdEZ1ZWxGdW5GdW5ueUZ1cm5hY2VGdXJ5RnV0dXJlR2FkZ2V0R2FpbkdhbGF4eUdhbGxlcnlHYW1lR2FwR2FyYWdlR2FyYmFnZUdhcmRlbkdhcmxpY0dhcm1lbnRHYXNHYXNwR2F0ZUdhdGhlckdhdWdlR2F6ZUdlbmVyYWxHZW5pdXNHZW5yZUdlbnRsZUdlbnVpbmVHZXN0dXJlR2hvc3RHaWFudEdpZnRHaWdnbGVHaW5nZXJHaXJhZmZlR2lybEdpdmVHbGFkR2xhbmNlR2xhcmVHbGFzc0dsaWRlR2xpbXBzZUdsb2JlR2xvb21HbG9yeUdsb3ZlR2xvd0dsdWVHb2F0R29kZGVzc0dvbGRHb29kR29vc2VHb3JpbGxhR29zcGVsR29zc2lwR292ZXJuR293bkdyYWJHcmFjZUdyYWluR3JhbnRHcmFwZUdyYXNzR3Jhdml0eUdyZWF0R3JlZW5HcmlkR3JpZWZHcml0R3JvY2VyeUdyb3VwR3Jvd0dydW50R3VhcmRHdWVzc0d1aWRlR3VpbHRHdWl0YXJHdW5HeW1IYWJpdEhhaXJIYWxmSGFtbWVySGFtc3RlckhhbmRIYXBweUhhcmJvckhhcmRIYXJzaEhhcnZlc3RIYXRIYXZlSGF3a0hhemFyZEhlYWRIZWFsdGhIZWFydEhlYXZ5SGVkZ2Vob2dIZWlnaHRIZWxsb0hlbG1ldEhlbHBIZW5IZXJvSGlkZGVuSGlnaEhpbGxIaW50SGlwSGlyZUhpc3RvcnlIb2JieUhvY2tleUhvbGRIb2xlSG9saWRheUhvbGxvd0hvbWVIb25leUhvb2RIb3BlSG9ybkhvcnJvckhvcnNlSG9zcGl0YWxIb3N0SG90ZWxIb3VySG92ZXJIdWJIdWdlSHVtYW5IdW1ibGVIdW1vckh1bmRyZWRIdW5ncnlIdW50SHVyZGxlSHVycnlIdXJ0SHVzYmFuZEh5YnJpZEljZUljb25JZGVhSWRlbnRpZnlJZGxlSWdub3JlSWxsSWxsZWdhbElsbG5lc3NJbWFnZUltaXRhdGVJbW1lbnNlSW1tdW5lSW1wYWN0SW1wb3NlSW1wcm92ZUltcHVsc2VJbmNoSW5jbHVkZUluY29tZUluY3JlYXNlSW5kZXhJbmRpY2F0ZUluZG9vckluZHVzdHJ5SW5mYW50SW5mbGljdEluZm9ybUluaGFsZUluaGVyaXRJbml0aWFsSW5qZWN0SW5qdXJ5SW5tYXRlSW5uZXJJbm5vY2VudElucHV0SW5xdWlyeUluc2FuZUluc2VjdEluc2lkZUluc3BpcmVJbnN0YWxsSW50YWN0SW50ZXJlc3RJbnRvSW52ZXN0SW52aXRlSW52b2x2ZUlyb25Jc2xhbmRJc29sYXRlSXNzdWVJdGVtSXZvcnlKYWNrZXRKYWd1YXJKYXJKYXp6SmVhbG91c0plYW5zSmVsbHlKZXdlbEpvYkpvaW5Kb2tlSm91cm5leUpveUp1ZGdlSnVpY2VKdW1wSnVuZ2xlSnVuaW9ySnVua0p1c3RLYW5nYXJvb0tlZW5LZWVwS2V0Y2h1cEtleUtpY2tLaWRLaWRuZXlLaW5kS2luZ2RvbUtpc3NLaXRLaXRjaGVuS2l0ZUtpdHRlbktpd2lLbmVlS25pZmVLbm9ja0tub3dMYWJMYWJlbExhYm9yTGFkZGVyTGFkeUxha2VMYW1wTGFuZ3VhZ2VMYXB0b3BMYXJnZUxhdGVyTGF0aW5MYXVnaExhdW5kcnlMYXZhTGF3TGF3bkxhd3N1aXRMYXllckxhenlMZWFkZXJMZWFmTGVhcm5MZWF2ZUxlY3R1cmVMZWZ0TGVnTGVnYWxMZWdlbmRMZWlzdXJlTGVtb25MZW5kTGVuZ3RoTGVuc0xlb3BhcmRMZXNzb25MZXR0ZXJMZXZlbExpYXJMaWJlcnR5TGlicmFyeUxpY2Vuc2VMaWZlTGlmdExpZ2h0TGlrZUxpbWJMaW1pdExpbmtMaW9uTGlxdWlkTGlzdExpdHRsZUxpdmVMaXphcmRMb2FkTG9hbkxvYnN0ZXJMb2NhbExvY2tMb2dpY0xvbmVseUxvbmdMb29wTG90dGVyeUxvdWRMb3VuZ2VMb3ZlTG95YWxMdWNreUx1Z2dhZ2VMdW1iZXJMdW5hckx1bmNoTHV4dXJ5THlyaWNzTWFjaGluZU1hZE1hZ2ljTWFnbmV0TWFpZE1haWxNYWluTWFqb3JNYWtlTWFtbWFsTWFuTWFuYWdlTWFuZGF0ZU1hbmdvTWFuc2lvbk1hbnVhbE1hcGxlTWFyYmxlTWFyY2hNYXJnaW5NYXJpbmVNYXJrZXRNYXJyaWFnZU1hc2tNYXNzTWFzdGVyTWF0Y2hNYXRlcmlhbE1hdGhNYXRyaXhNYXR0ZXJNYXhpbXVtTWF6ZU1lYWRvd01lYW5NZWFzdXJlTWVhdE1lY2hhbmljTWVkYWxNZWRpYU1lbG9keU1lbHRNZW1iZXJNZW1vcnlNZW50aW9uTWVudU1lcmN5TWVyZ2VNZXJpdE1lcnJ5TWVzaE1lc3NhZ2VNZXRhbE1ldGhvZE1pZGRsZU1pZG5pZ2h0TWlsa01pbGxpb25NaW1pY01pbmRNaW5pbXVtTWlub3JNaW51dGVNaXJhY2xlTWlycm9yTWlzZXJ5TWlzc01pc3Rha2VNaXhNaXhlZE1peHR1cmVNb2JpbGVNb2RlbE1vZGlmeU1vbU1vbWVudE1vbml0b3JNb25rZXlNb25zdGVyTW9udGhNb29uTW9yYWxNb3JlTW9ybmluZ01vc3F1aXRvTW90aGVyTW90aW9uTW90b3JNb3VudGFpbk1vdXNlTW92ZU1vdmllTXVjaE11ZmZpbk11bGVNdWx0aXBseU11c2NsZU11c2V1bU11c2hyb29tTXVzaWNNdXN0TXV0dWFsTXlzZWxmTXlzdGVyeU15dGhOYWl2ZU5hbWVOYXBraW5OYXJyb3dOYXN0eU5hdGlvbk5hdHVyZU5lYXJOZWNrTmVlZE5lZ2F0aXZlTmVnbGVjdE5laXRoZXJOZXBoZXdOZXJ2ZU5lc3ROZXROZXR3b3JrTmV1dHJhbE5ldmVyTmV3c05leHROaWNlTmlnaHROb2JsZU5vaXNlTm9taW5lZU5vb2RsZU5vcm1hbE5vcnRoTm9zZU5vdGFibGVOb3RlTm90aGluZ05vdGljZU5vdmVsTm93TnVjbGVhck51bWJlck51cnNlTnV0T2FrT2JleU9iamVjdE9ibGlnZU9ic2N1cmVPYnNlcnZlT2J0YWluT2J2aW91c09jY3VyT2NlYW5PY3RvYmVyT2Rvck9mZk9mZmVyT2ZmaWNlT2Z0ZW5PaWxPa2F5T2xkT2xpdmVPbHltcGljT21pdE9uY2VPbmVPbmlvbk9ubGluZU9ubHlPcGVuT3BlcmFPcGluaW9uT3Bwb3NlT3B0aW9uT3JhbmdlT3JiaXRPcmNoYXJkT3JkZXJPcmRpbmFyeU9yZ2FuT3JpZW50T3JpZ2luYWxPcnBoYW5Pc3RyaWNoT3RoZXJPdXRkb29yT3V0ZXJPdXRwdXRPdXRzaWRlT3ZhbE92ZW5PdmVyT3duT3duZXJPeHlnZW5PeXN0ZXJPem9uZVBhY3RQYWRkbGVQYWdlUGFpclBhbGFjZVBhbG1QYW5kYVBhbmVsUGFuaWNQYW50aGVyUGFwZXJQYXJhZGVQYXJlbnRQYXJrUGFycm90UGFydHlQYXNzUGF0Y2hQYXRoUGF0aWVudFBhdHJvbFBhdHRlcm5QYXVzZVBhdmVQYXltZW50UGVhY2VQZWFudXRQZWFyUGVhc2FudFBlbGljYW5QZW5QZW5hbHR5UGVuY2lsUGVvcGxlUGVwcGVyUGVyZmVjdFBlcm1pdFBlcnNvblBldFBob25lUGhvdG9QaHJhc2VQaHlzaWNhbFBpYW5vUGljbmljUGljdHVyZVBpZWNlUGlnUGlnZW9uUGlsbFBpbG90UGlua1Bpb25lZXJQaXBlUGlzdG9sUGl0Y2hQaXp6YVBsYWNlUGxhbmV0UGxhc3RpY1BsYXRlUGxheVBsZWFzZVBsZWRnZVBsdWNrUGx1Z1BsdW5nZVBvZW1Qb2V0UG9pbnRQb2xhclBvbGVQb2xpY2VQb25kUG9ueVBvb2xQb3B1bGFyUG9ydGlvblBvc2l0aW9uUG9zc2libGVQb3N0UG90YXRvUG90dGVyeVBvdmVydHlQb3dkZXJQb3dlclByYWN0aWNlUHJhaXNlUHJlZGljdFByZWZlclByZXBhcmVQcmVzZW50UHJldHR5UHJldmVudFByaWNlUHJpZGVQcmltYXJ5UHJpbnRQcmlvcml0eVByaXNvblByaXZhdGVQcml6ZVByb2JsZW1Qcm9jZXNzUHJvZHVjZVByb2ZpdFByb2dyYW1Qcm9qZWN0UHJvbW90ZVByb29mUHJvcGVydHlQcm9zcGVyUHJvdGVjdFByb3VkUHJvdmlkZVB1YmxpY1B1ZGRpbmdQdWxsUHVscFB1bHNlUHVtcGtpblB1bmNoUHVwaWxQdXBweVB1cmNoYXNlUHVyaXR5UHVycG9zZVB1cnNlUHVzaFB1dFB1enpsZVB5cmFtaWRRdWFsaXR5UXVhbnR1bVF1YXJ0ZXJRdWVzdGlvblF1aWNrUXVpdFF1aXpRdW90ZVJhYmJpdFJhY2Nvb25SYWNlUmFja1JhZGFyUmFkaW9SYWlsUmFpblJhaXNlUmFsbHlSYW1wUmFuY2hSYW5kb21SYW5nZVJhcGlkUmFyZVJhdGVSYXRoZXJSYXZlblJhd1Jhem9yUmVhZHlSZWFsUmVhc29uUmViZWxSZWJ1aWxkUmVjYWxsUmVjZWl2ZVJlY2lwZVJlY29yZFJlY3ljbGVSZWR1Y2VSZWZsZWN0UmVmb3JtUmVmdXNlUmVnaW9uUmVncmV0UmVndWxhclJlamVjdFJlbGF4UmVsZWFzZVJlbGllZlJlbHlSZW1haW5SZW1lbWJlclJlbWluZFJlbW92ZVJlbmRlclJlbmV3UmVudFJlb3BlblJlcGFpclJlcGVhdFJlcGxhY2VSZXBvcnRSZXF1aXJlUmVzY3VlUmVzZW1ibGVSZXNpc3RSZXNvdXJjZVJlc3BvbnNlUmVzdWx0UmV0aXJlUmV0cmVhdFJldHVyblJldW5pb25SZXZlYWxSZXZpZXdSZXdhcmRSaHl0aG1SaWJSaWJib25SaWNlUmljaFJpZGVSaWRnZVJpZmxlUmlnaHRSaWdpZFJpbmdSaW90UmlwcGxlUmlza1JpdHVhbFJpdmFsUml2ZXJSb2FkUm9hc3RSb2JvdFJvYnVzdFJvY2tldFJvbWFuY2VSb29mUm9va2llUm9vbVJvc2VSb3RhdGVSb3VnaFJvdW5kUm91dGVSb3lhbFJ1YmJlclJ1ZGVSdWdSdWxlUnVuUnVud2F5UnVyYWxTYWRTYWRkbGVTYWRuZXNzU2FmZVNhaWxTYWxhZFNhbG1vblNhbG9uU2FsdFNhbHV0ZVNhbWVTYW1wbGVTYW5kU2F0aXNmeVNhdG9zaGlTYXVjZVNhdXNhZ2VTYXZlU2F5U2NhbGVTY2FuU2NhcmVTY2F0dGVyU2NlbmVTY2hlbWVTY2hvb2xTY2llbmNlU2Npc3NvcnNTY29ycGlvblNjb3V0U2NyYXBTY3JlZW5TY3JpcHRTY3J1YlNlYVNlYXJjaFNlYXNvblNlYXRTZWNvbmRTZWNyZXRTZWN0aW9uU2VjdXJpdHlTZWVkU2Vla1NlZ21lbnRTZWxlY3RTZWxsU2VtaW5hclNlbmlvclNlbnNlU2VudGVuY2VTZXJpZXNTZXJ2aWNlU2Vzc2lvblNldHRsZVNldHVwU2V2ZW5TaGFkb3dTaGFmdFNoYWxsb3dTaGFyZVNoZWRTaGVsbFNoZXJpZmZTaGllbGRTaGlmdFNoaW5lU2hpcFNoaXZlclNob2NrU2hvZVNob290U2hvcFNob3J0U2hvdWxkZXJTaG92ZVNocmltcFNocnVnU2h1ZmZsZVNoeVNpYmxpbmdTaWNrU2lkZVNpZWdlU2lnaHRTaWduU2lsZW50U2lsa1NpbGx5U2lsdmVyU2ltaWxhclNpbXBsZVNpbmNlU2luZ1NpcmVuU2lzdGVyU2l0dWF0ZVNpeFNpemVTa2F0ZVNrZXRjaFNraVNraWxsU2tpblNraXJ0U2t1bGxTbGFiU2xhbVNsZWVwU2xlbmRlclNsaWNlU2xpZGVTbGlnaHRTbGltU2xvZ2FuU2xvdFNsb3dTbHVzaFNtYWxsU21hcnRTbWlsZVNtb2tlU21vb3RoU25hY2tTbmFrZVNuYXBTbmlmZlNub3dTb2FwU29jY2VyU29jaWFsU29ja1NvZGFTb2Z0U29sYXJTb2xkaWVyU29saWRTb2x1dGlvblNvbHZlU29tZW9uZVNvbmdTb29uU29ycnlTb3J0U291bFNvdW5kU291cFNvdXJjZVNvdXRoU3BhY2VTcGFyZVNwYXRpYWxTcGF3blNwZWFrU3BlY2lhbFNwZWVkU3BlbGxTcGVuZFNwaGVyZVNwaWNlU3BpZGVyU3Bpa2VTcGluU3Bpcml0U3BsaXRTcG9pbFNwb25zb3JTcG9vblNwb3J0U3BvdFNwcmF5U3ByZWFkU3ByaW5nU3B5U3F1YXJlU3F1ZWV6ZVNxdWlycmVsU3RhYmxlU3RhZGl1bVN0YWZmU3RhZ2VTdGFpcnNTdGFtcFN0YW5kU3RhcnRTdGF0ZVN0YXlTdGVha1N0ZWVsU3RlbVN0ZXBTdGVyZW9TdGlja1N0aWxsU3RpbmdTdG9ja1N0b21hY2hTdG9uZVN0b29sU3RvcnlTdG92ZVN0cmF0ZWd5U3RyZWV0U3RyaWtlU3Ryb25nU3RydWdnbGVTdHVkZW50U3R1ZmZTdHVtYmxlU3R5bGVTdWJqZWN0U3VibWl0U3Vid2F5U3VjY2Vzc1N1Y2hTdWRkZW5TdWZmZXJTdWdhclN1Z2dlc3RTdWl0U3VtbWVyU3VuU3VubnlTdW5zZXRTdXBlclN1cHBseVN1cHJlbWVTdXJlU3VyZmFjZVN1cmdlU3VycHJpc2VTdXJyb3VuZFN1cnZleVN1c3BlY3RTdXN0YWluU3dhbGxvd1N3YW1wU3dhcFN3YXJtU3dlYXJTd2VldFN3aWZ0U3dpbVN3aW5nU3dpdGNoU3dvcmRTeW1ib2xTeW1wdG9tU3lydXBTeXN0ZW1UYWJsZVRhY2tsZVRhZ1RhaWxUYWxlbnRUYWxrVGFua1RhcGVUYXJnZXRUYXNrVGFzdGVUYXR0b29UYXhpVGVhY2hUZWFtVGVsbFRlblRlbmFudFRlbm5pc1RlbnRUZXJtVGVzdFRleHRUaGFua1RoYXRUaGVtZVRoZW5UaGVvcnlUaGVyZVRoZXlUaGluZ1RoaXNUaG91Z2h0VGhyZWVUaHJpdmVUaHJvd1RodW1iVGh1bmRlclRpY2tldFRpZGVUaWdlclRpbHRUaW1iZXJUaW1lVGlueVRpcFRpcmVkVGlzc3VlVGl0bGVUb2FzdFRvYmFjY29Ub2RheVRvZGRsZXJUb2VUb2dldGhlclRvaWxldFRva2VuVG9tYXRvVG9tb3Jyb3dUb25lVG9uZ3VlVG9uaWdodFRvb2xUb290aFRvcFRvcGljVG9wcGxlVG9yY2hUb3JuYWRvVG9ydG9pc2VUb3NzVG90YWxUb3VyaXN0VG93YXJkVG93ZXJUb3duVG95VHJhY2tUcmFkZVRyYWZmaWNUcmFnaWNUcmFpblRyYW5zZmVyVHJhcFRyYXNoVHJhdmVsVHJheVRyZWF0VHJlZVRyZW5kVHJpYWxUcmliZVRyaWNrVHJpZ2dlclRyaW1UcmlwVHJvcGh5VHJvdWJsZVRydWNrVHJ1ZVRydWx5VHJ1bXBldFRydXN0VHJ1dGhUcnlUdWJlVHVpdGlvblR1bWJsZVR1bmFUdW5uZWxUdXJrZXlUdXJuVHVydGxlVHdlbHZlVHdlbnR5VHdpY2VUd2luVHdpc3RUd29UeXBlVHlwaWNhbFVnbHlVbWJyZWxsYVVuYWJsZVVuYXdhcmVVbmNsZVVuY292ZXJVbmRlclVuZG9VbmZhaXJVbmZvbGRVbmhhcHB5VW5pZm9ybVVuaXF1ZVVuaXRVbml2ZXJzZVVua25vd25VbmxvY2tVbnRpbFVudXN1YWxVbnZlaWxVcGRhdGVVcGdyYWRlVXBob2xkVXBvblVwcGVyVXBzZXRVcmJhblVyZ2VVc2FnZVVzZVVzZWRVc2VmdWxVc2VsZXNzVXN1YWxVdGlsaXR5VmFjYW50VmFjdXVtVmFndWVWYWxpZFZhbGxleVZhbHZlVmFuVmFuaXNoVmFwb3JWYXJpb3VzVmFzdFZhdWx0VmVoaWNsZVZlbHZldFZlbmRvclZlbnR1cmVWZW51ZVZlcmJWZXJpZnlWZXJzaW9uVmVyeVZlc3NlbFZldGVyYW5WaWFibGVWaWJyYW50VmljaW91c1ZpY3RvcnlWaWRlb1ZpZXdWaWxsYWdlVmludGFnZVZpb2xpblZpcnR1YWxWaXJ1c1Zpc2FWaXNpdFZpc3VhbFZpdGFsVml2aWRWb2NhbFZvaWNlVm9pZFZvbGNhbm9Wb2x1bWVWb3RlVm95YWdlV2FnZVdhZ29uV2FpdFdhbGtXYWxsV2FsbnV0V2FudFdhcmZhcmVXYXJtV2Fycmlvcldhc2hXYXNwV2FzdGVXYXRlcldhdmVXYXlXZWFsdGhXZWFwb25XZWFyV2Vhc2VsV2VhdGhlcldlYldlZGRpbmdXZWVrZW5kV2VpcmRXZWxjb21lV2VzdFdldFdoYWxlV2hhdFdoZWF0V2hlZWxXaGVuV2hlcmVXaGlwV2hpc3BlcldpZGVXaWR0aFdpZmVXaWxkV2lsbFdpbldpbmRvd1dpbmVXaW5nV2lua1dpbm5lcldpbnRlcldpcmVXaXNkb21XaXNlV2lzaFdpdG5lc3NXb2xmV29tYW5Xb25kZXJXb29kV29vbFdvcmRXb3JrV29ybGRXb3JyeVdvcnRoV3JhcFdyZWNrV3Jlc3RsZVdyaXN0V3JpdGVXcm9uZ1lhcmRZZWFyWWVsbG93WW91WW91bmdZb3V0aFplYnJhWmVyb1pvbmVab29cIjtcblx0dmFyIHdvcmRsaXN0JDEgPSBudWxsO1xuXHRmdW5jdGlvbiBsb2FkV29yZHMobGFuZykge1xuXHQgICAgaWYgKHdvcmRsaXN0JDEgIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHdvcmRsaXN0JDEgPSB3b3Jkcy5yZXBsYWNlKC8oW0EtWl0pL2csIFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKTtcblx0ICAgIGlmICh3b3JkbGlzdC5Xb3JkbGlzdC5jaGVjayhsYW5nKSAhPT0gXCIweDNjOGFjYzFlN2IwOGQ4ZTc2ZjlmZGEwMTVlZjQ4ZGM4YzcxMGE3M2NiN2UwZjc3YjJjMThhOWI1YTdhZGRlNjBcIikge1xuXHQgICAgICAgIHdvcmRsaXN0JDEgPSBudWxsO1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBlbiAoRW5nbGlzaCkgRkFJTEVEXCIpO1xuXHQgICAgfVxuXHR9XG5cdHZhciBMYW5nRW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTGFuZ0VuLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTGFuZ0VuKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImVuXCIpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBMYW5nRW4ucHJvdG90eXBlLmdldFdvcmQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgICAgICBsb2FkV29yZHModGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHdvcmRsaXN0JDFbaW5kZXhdO1xuXHQgICAgfTtcblx0ICAgIExhbmdFbi5wcm90b3R5cGUuZ2V0V29yZEluZGV4ID0gZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICBsb2FkV29yZHModGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHdvcmRsaXN0JDEuaW5kZXhPZih3b3JkKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTGFuZ0VuO1xuXHR9KHdvcmRsaXN0LldvcmRsaXN0KSk7XG5cdHZhciBsYW5nRW4gPSBuZXcgTGFuZ0VuKCk7XG5cdGV4cG9ydHMubGFuZ0VuID0gbGFuZ0VuO1xuXHR3b3JkbGlzdC5Xb3JkbGlzdC5yZWdpc3RlcihsYW5nRW4pO1xuXHR9KTtcblxuXHR2YXIgbGFuZ0VuID0gdW53cmFwRXhwb3J0cyhsYW5nRW5fMSk7XG5cdHZhciBsYW5nRW5fMiA9IGxhbmdFbl8xLmxhbmdFbjtcblxuXHR2YXIgYnJvd3NlciQ0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvLyBXb3JkbGlzdHNcblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDM5L2JpcC0wMDM5LXdvcmRsaXN0cy5tZFxuXG5cdGV4cG9ydHMuV29yZGxpc3QgPSB3b3JkbGlzdC5Xb3JkbGlzdDtcblxuXHR2YXIgd29yZGxpc3RzID0geyBlbjogbGFuZ0VuXzEubGFuZ0VuIH07XG5cdGV4cG9ydHMud29yZGxpc3RzID0gd29yZGxpc3RzO1xuXHR9KTtcblxuXHR2YXIgYnJvd3NlciQ1ID0gdW53cmFwRXhwb3J0cyhicm93c2VyJDQpO1xuXHR2YXIgYnJvd3Nlcl8xJDIgPSBicm93c2VyJDQuV29yZGxpc3Q7XG5cdHZhciBicm93c2VyXzIkMSA9IGJyb3dzZXIkNC53b3JkbGlzdHM7XG5cblx0dmFyIF92ZXJzaW9uJHcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGRub2RlLzUuMC4wLWJldGEuMTQwXCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiR4ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiR3KTtcblx0dmFyIF92ZXJzaW9uXzEkZyA9IF92ZXJzaW9uJHcudmVyc2lvbjtcblxuXHR2YXIgbGliJGggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiR3LnZlcnNpb24pO1xuXHR2YXIgTiA9IGxpYiQyLkJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xuXHQvLyBcIkJpdGNvaW4gc2VlZFwiXG5cdHZhciBNYXN0ZXJTZWNyZXQgPSBsaWIkOC50b1V0ZjhCeXRlcyhcIkJpdGNvaW4gc2VlZFwiKTtcblx0dmFyIEhhcmRlbmVkQml0ID0gMHg4MDAwMDAwMDtcblx0Ly8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTVNCIGJpdHMgc2V0XG5cdGZ1bmN0aW9uIGdldFVwcGVyTWFzayhiaXRzKSB7XG5cdCAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKTtcblx0fVxuXHQvLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBMU0IgYml0cyBzZXRcblx0ZnVuY3Rpb24gZ2V0TG93ZXJNYXNrKGJpdHMpIHtcblx0ICAgIHJldHVybiAoMSA8PCBiaXRzKSAtIDE7XG5cdH1cblx0ZnVuY3Rpb24gYnl0ZXMzMih2YWx1ZSkge1xuXHQgICAgcmV0dXJuIGxpYiQxLmhleFplcm9QYWQobGliJDEuaGV4bGlmeSh2YWx1ZSksIDMyKTtcblx0fVxuXHRmdW5jdGlvbiBiYXNlNThjaGVjayhkYXRhKSB7XG5cdCAgICByZXR1cm4gbGliJGUuQmFzZTU4LmVuY29kZShsaWIkMS5jb25jYXQoW2RhdGEsIGxpYiQxLmhleERhdGFTbGljZShicm93c2VyLnNoYTI1Nihicm93c2VyLnNoYTI1NihkYXRhKSksIDAsIDQpXSkpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFdvcmRsaXN0KHdvcmRsaXN0KSB7XG5cdCAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBicm93c2VyJDQud29yZGxpc3RzW1wiZW5cIl07XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh3b3JkbGlzdCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YXIgd29yZHMgPSBicm93c2VyJDQud29yZGxpc3RzW3dvcmRsaXN0XTtcblx0ICAgICAgICBpZiAod29yZHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBsb2NhbGVcIiwgXCJ3b3JkbGlzdFwiLCB3b3JkbGlzdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3b3Jkcztcblx0ICAgIH1cblx0ICAgIHJldHVybiB3b3JkbGlzdDtcblx0fVxuXHR2YXIgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcblx0ZXhwb3J0cy5kZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuXHQ7XG5cdHZhciBIRE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICAvKipcblx0ICAgICAqICBUaGlzIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuXHQgICAgICpcblx0ICAgICAqICBQbGVhc2UgdXNlOlxuXHQgICAgICogICAtIGZyb21NbmVtb25pY1xuXHQgICAgICogICAtIGZyb21TZWVkXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIEhETm9kZShjb25zdHJ1Y3Rvckd1YXJkLCBwcml2YXRlS2V5LCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbW5lbW9uaWNPclBhdGgpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEhETm9kZSk7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhETm9kZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICB2YXIgc2lnbmluZ0tleSA9IG5ldyBsaWIkZi5TaWduaW5nS2V5KHByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByaXZhdGVLZXlcIiwgc2lnbmluZ0tleS5wcml2YXRlS2V5KTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwdWJsaWNLZXlcIiwgc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwdWJsaWNLZXlcIiwgbGliJDEuaGV4bGlmeShwdWJsaWNLZXkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwYXJlbnRGaW5nZXJwcmludFwiLCBwYXJlbnRGaW5nZXJwcmludCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaW5nZXJwcmludFwiLCBsaWIkMS5oZXhEYXRhU2xpY2UoYnJvd3Nlci5yaXBlbWQxNjAoYnJvd3Nlci5zaGEyNTYodGhpcy5wdWJsaWNLZXkpKSwgMCwgNCkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBsaWIkZy5jb21wdXRlQWRkcmVzcyh0aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY2hhaW5Db2RlXCIsIGNoYWluQ29kZSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbmRleFwiLCBpbmRleCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJkZXB0aFwiLCBkZXB0aCk7XG5cdCAgICAgICAgaWYgKG1uZW1vbmljT3JQYXRoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy8gRnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90IHByZXNlcnZlIHRoZSBwYXRoIChlLmcuIGV4dGVuZGVkIGtleXMpXG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwibW5lbW9uaWNcIiwgbnVsbCk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicGF0aFwiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIChtbmVtb25pY09yUGF0aCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgLy8gRnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90IHByZXNlcnZlIHRoZSBtbmVtb25pYyAoZS5nLiBuZXV0ZXJlZClcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwYXRoXCIsIG1uZW1vbmljT3JQYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEZyb20gYSBmdWxseSBxdWFsaWZpZWQgc291cmNlXG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwibW5lbW9uaWNcIiwgbW5lbW9uaWNPclBhdGgpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBhdGhcIiwgbW5lbW9uaWNPclBhdGgucGF0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhETm9kZS5wcm90b3R5cGUsIFwiZXh0ZW5kZWRLZXlcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcblx0ICAgICAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW5pdG1lbnQgaXMgdGhhdFxuXHQgICAgICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcblx0ICAgICAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcblx0ICAgICAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGggPj0gMjU2KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aCB0b28gbGFyZ2UhXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNThjaGVjayhsaWIkMS5jb25jYXQoW1xuXHQgICAgICAgICAgICAgICAgKCh0aGlzLnByaXZhdGVLZXkgIT0gbnVsbCkgPyBcIjB4MDQ4OEFERTRcIiA6IFwiMHgwNDg4QjIxRVwiKSxcblx0ICAgICAgICAgICAgICAgIGxpYiQxLmhleGxpZnkodGhpcy5kZXB0aCksXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuXHQgICAgICAgICAgICAgICAgbGliJDEuaGV4WmVyb1BhZChsaWIkMS5oZXhsaWZ5KHRoaXMuaW5kZXgpLCA0KSxcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5Db2RlLFxuXHQgICAgICAgICAgICAgICAgKCh0aGlzLnByaXZhdGVLZXkgIT0gbnVsbCkgPyBsaWIkMS5jb25jYXQoW1wiMHgwMFwiLCB0aGlzLnByaXZhdGVLZXldKSA6IHRoaXMucHVibGljS2V5KSxcblx0ICAgICAgICAgICAgXSkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgSEROb2RlLnByb3RvdHlwZS5uZXV0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIG51bGwsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5wYXRoKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLl9kZXJpdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgICAgICBpZiAoaW5kZXggPiAweGZmZmZmZmZmKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5kZXggLSBcIiArIFN0cmluZyhpbmRleCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBCYXNlIHBhdGhcblx0ICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblx0ICAgICAgICBpZiAocGF0aCkge1xuXHQgICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XG5cdCAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZXJpdmUgY2hpbGQgb2YgbmV1dGVyZWQgbm9kZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuXHQgICAgICAgICAgICBkYXRhLnNldChsaWIkMS5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpLCAxKTtcblx0ICAgICAgICAgICAgLy8gSGFyZGVuZWQgcGF0aFxuXHQgICAgICAgICAgICBpZiAocGF0aCkge1xuXHQgICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRGF0YSA9IHNlcl9wKHBvaW50KGtfcGFyKSlcblx0ICAgICAgICAgICAgZGF0YS5zZXQobGliJDEuYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRGF0YSArPSBzZXJfMzIoaSlcblx0ICAgICAgICBmb3IgKHZhciBpID0gMjQ7IGkgPj0gMDsgaSAtPSA4KSB7XG5cdCAgICAgICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgSSA9IGxpYiQxLmFycmF5aWZ5KGJyb3dzZXIuY29tcHV0ZUhtYWMoYnJvd3Nlci5TdXBwb3J0ZWRBbGdvcml0aG0uc2hhNTEyLCB0aGlzLmNoYWluQ29kZSwgZGF0YSkpO1xuXHQgICAgICAgIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuXHQgICAgICAgIHZhciBJUiA9IEkuc2xpY2UoMzIpO1xuXHQgICAgICAgIC8vIFRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIHZhciBraSA9IG51bGw7XG5cdCAgICAgICAgLy8gVGhlIHB1YmxpYyBrZXlcblx0ICAgICAgICB2YXIgS2kgPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAga2kgPSBieXRlczMyKGxpYiQyLkJpZ051bWJlci5mcm9tKElMKS5hZGQodGhpcy5wcml2YXRlS2V5KS5tb2QoTikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGVrID0gbmV3IGxpYiRmLlNpZ25pbmdLZXkobGliJDEuaGV4bGlmeShJTCkpO1xuXHQgICAgICAgICAgICBLaSA9IGVrLl9hZGRQb2ludCh0aGlzLnB1YmxpY0tleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtbmVtb25pY09yUGF0aCA9IHBhdGg7XG5cdCAgICAgICAgdmFyIHNyY01uZW1vbmljID0gdGhpcy5tbmVtb25pYztcblx0ICAgICAgICBpZiAoc3JjTW5lbW9uaWMpIHtcblx0ICAgICAgICAgICAgbW5lbW9uaWNPclBhdGggPSBPYmplY3QuZnJlZXplKHtcblx0ICAgICAgICAgICAgICAgIHBocmFzZTogc3JjTW5lbW9uaWMucGhyYXNlLFxuXHQgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcblx0ICAgICAgICAgICAgICAgIGxvY2FsZTogKHNyY01uZW1vbmljLmxvY2FsZSB8fCBcImVuXCIpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwga2ksIEtpLCB0aGlzLmZpbmdlcnByaW50LCBieXRlczMyKElSKSwgaW5kZXgsIHRoaXMuZGVwdGggKyAxLCBtbmVtb25pY09yUGF0aCk7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLnByb3RvdHlwZS5kZXJpdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0ICAgICAgICB2YXIgY29tcG9uZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuXHQgICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIgJiYgdGhpcy5kZXB0aCAhPT0gMCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIC0gXCIgKyBwYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudHMuc2hpZnQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuXHQgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IEhhcmRlbmVkQml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Ll9kZXJpdmUoSGFyZGVuZWRCaXQgKyBpbmRleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IEhhcmRlbmVkQml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Ll9kZXJpdmUoaW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudCAtIFwiICsgY29tcG9uZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5fZnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCwgbW5lbW9uaWMpIHtcblx0ICAgICAgICB2YXIgc2VlZEFycmF5ID0gbGliJDEuYXJyYXlpZnkoc2VlZCk7XG5cdCAgICAgICAgaWYgKHNlZWRBcnJheS5sZW5ndGggPCAxNiB8fCBzZWVkQXJyYXkubGVuZ3RoID4gNjQpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZWVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgSSA9IGxpYiQxLmFycmF5aWZ5KGJyb3dzZXIuY29tcHV0ZUhtYWMoYnJvd3Nlci5TdXBwb3J0ZWRBbGdvcml0aG0uc2hhNTEyLCBNYXN0ZXJTZWNyZXQsIHNlZWRBcnJheSkpO1xuXHQgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBieXRlczMyKEkuc2xpY2UoMCwgMzIpKSwgbnVsbCwgXCIweDAwMDAwMDAwXCIsIGJ5dGVzMzIoSS5zbGljZSgzMikpLCAwLCAwLCBtbmVtb25pYyk7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLmZyb21NbmVtb25pYyA9IGZ1bmN0aW9uIChtbmVtb25pYywgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG5cdCAgICAgICAgLy8gSWYgYSBsb2NhbGUgbmFtZSB3YXMgcGFzc2VkIGluLCBmaW5kIHRoZSBhc3NvY2lhdGVkIHdvcmRsaXN0XG5cdCAgICAgICAgd29yZGxpc3QgPSBnZXRXb3JkbGlzdCh3b3JkbGlzdCk7XG5cdCAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjaW5nIGluIHRoZSBtbmVtb25pYyAodGhyb3dzIGlmIHRoZSBtbmVtb25pYyBpcyBpbnZhbGlkKVxuXHQgICAgICAgIG1uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWMobW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSwgd29yZGxpc3QpO1xuXHQgICAgICAgIHJldHVybiBIRE5vZGUuX2Zyb21TZWVkKG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzd29yZCksIHtcblx0ICAgICAgICAgICAgcGhyYXNlOiBtbmVtb25pYyxcblx0ICAgICAgICAgICAgcGF0aDogXCJtXCIsXG5cdCAgICAgICAgICAgIGxvY2FsZTogd29yZGxpc3QubG9jYWxlXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLmZyb21TZWVkID0gZnVuY3Rpb24gKHNlZWQpIHtcblx0ICAgICAgICByZXR1cm4gSEROb2RlLl9mcm9tU2VlZChzZWVkLCBudWxsKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKGV4dGVuZGVkS2V5KSB7XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJGUuQmFzZTU4LmRlY29kZShleHRlbmRlZEtleSk7XG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gODIgfHwgYmFzZTU4Y2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSAhPT0gZXh0ZW5kZWRLZXkpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsIFwiZXh0ZW5kZWRLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGVwdGggPSBieXRlc1s0XTtcblx0ICAgICAgICB2YXIgcGFyZW50RmluZ2VycHJpbnQgPSBsaWIkMS5oZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsIDkpKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChsaWIkMS5oZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG5cdCAgICAgICAgdmFyIGNoYWluQ29kZSA9IGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG5cdCAgICAgICAgdmFyIGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG5cdCAgICAgICAgc3dpdGNoIChsaWIkMS5oZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSkge1xuXHQgICAgICAgICAgICAvLyBQdWJsaWMgS2V5XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0ODhiMjFlXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4N2NmXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwgbnVsbCwgbGliJDEuaGV4bGlmeShrZXkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBpbmRleCwgZGVwdGgsIG51bGwpO1xuXHQgICAgICAgICAgICAvLyBQcml2YXRlIEtleVxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODM5NCBcIjpcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBsaWIkMS5oZXhsaWZ5KGtleS5zbGljZSgxKSksIG51bGwsIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEhETm9kZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5IRE5vZGUgPSBIRE5vZGU7XG5cdGZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzd29yZCkge1xuXHQgICAgaWYgKCFwYXNzd29yZCkge1xuXHQgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcblx0ICAgIH1cblx0ICAgIHZhciBzYWx0ID0gbGliJDgudG9VdGY4Qnl0ZXMoXCJtbmVtb25pY1wiICsgcGFzc3dvcmQsIGxpYiQ4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKTtcblx0ICAgIHJldHVybiBicm93c2VyJDIucGJrZGYyKGxpYiQ4LnRvVXRmOEJ5dGVzKG1uZW1vbmljLCBsaWIkOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCksIHNhbHQsIDIwNDgsIDY0LCBcInNoYTUxMlwiKTtcblx0fVxuXHRleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbW5lbW9uaWNUb1NlZWQ7XG5cdGZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuXHQgICAgd29yZGxpc3QgPSBnZXRXb3JkbGlzdCh3b3JkbGlzdCk7XG5cdCAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcblx0ICAgIHZhciB3b3JkcyA9IHdvcmRsaXN0LnNwbGl0KG1uZW1vbmljKTtcblx0ICAgIGlmICgod29yZHMubGVuZ3RoICUgMykgIT09IDApIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1uZW1vbmljXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIGVudHJvcHkgPSBsaWIkMS5hcnJheWlmeShuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEgKiB3b3Jkcy5sZW5ndGggLyA4KSkpO1xuXHQgICAgdmFyIG9mZnNldCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuXHQgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgMTE7IGJpdCsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG5cdCAgICAgICAgICAgICAgICBlbnRyb3B5W29mZnNldCA+PiAzXSB8PSAoMSA8PCAoNyAtIChvZmZzZXQgJSA4KSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9mZnNldCsrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBlbnRyb3B5Qml0cyA9IDMyICogd29yZHMubGVuZ3RoIC8gMztcblx0ICAgIHZhciBjaGVja3N1bUJpdHMgPSB3b3Jkcy5sZW5ndGggLyAzO1xuXHQgICAgdmFyIGNoZWNrc3VtTWFzayA9IGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuXHQgICAgdmFyIGNoZWNrc3VtID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5zaGEyNTYoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XG5cdCAgICBpZiAoY2hlY2tzdW0gIT09IChlbnRyb3B5W2VudHJvcHkubGVuZ3RoIC0gMV0gJiBjaGVja3N1bU1hc2spKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaGVja3N1bVwiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KGVudHJvcHkuc2xpY2UoMCwgZW50cm9weUJpdHMgLyA4KSk7XG5cdH1cblx0ZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5O1xuXHRmdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuXHQgICAgd29yZGxpc3QgPSBnZXRXb3JkbGlzdCh3b3JkbGlzdCk7XG5cdCAgICBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkoZW50cm9weSk7XG5cdCAgICBpZiAoKGVudHJvcHkubGVuZ3RoICUgNCkgIT09IDAgfHwgZW50cm9weS5sZW5ndGggPCAxNiB8fCBlbnRyb3B5Lmxlbmd0aCA+IDMyKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbnRyb3B5XCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIGluZGljZXMgPSBbMF07XG5cdCAgICB2YXIgcmVtYWluaW5nQml0cyA9IDExO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gQ29uc3VtZSB0aGUgd2hvbGUgYnl0ZSAod2l0aCBzdGlsbCBtb3JlIHRvIGdvKVxuXHQgICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IDg7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldO1xuXHQgICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG5cdCAgICAgICAgICAgIC8vIFRoaXMgYnl0ZSB3aWxsIGNvbXBsZXRlIGFuIDExLWJpdCBpbmRleFxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSByZW1haW5pbmdCaXRzO1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXSA+PiAoOCAtIHJlbWFpbmluZ0JpdHMpO1xuXHQgICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG5cdCAgICAgICAgICAgIGluZGljZXMucHVzaChlbnRyb3B5W2ldICYgZ2V0TG93ZXJNYXNrKDggLSByZW1haW5pbmdCaXRzKSk7XG5cdCAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgKz0gMztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBDb21wdXRlIHRoZSBjaGVja3N1bSBiaXRzXG5cdCAgICB2YXIgY2hlY2tzdW1CaXRzID0gZW50cm9weS5sZW5ndGggLyA0O1xuXHQgICAgdmFyIGNoZWNrc3VtID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5zaGEyNTYoZW50cm9weSkpWzBdICYgZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG5cdCAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXG5cdCAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IGNoZWNrc3VtQml0cztcblx0ICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSAoY2hlY2tzdW0gPj4gKDggLSBjaGVja3N1bUJpdHMpKTtcblx0ICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gd29yZGxpc3QuZ2V0V29yZChpbmRleCk7IH0pKTtcblx0fVxuXHRleHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG5cdGZ1bmN0aW9uIGlzVmFsaWRNbmVtb25pYyhtbmVtb25pYywgd29yZGxpc3QpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblx0ZXhwb3J0cy5pc1ZhbGlkTW5lbW9uaWMgPSBpc1ZhbGlkTW5lbW9uaWM7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRoID0gdW53cmFwRXhwb3J0cyhsaWIkaCk7XG5cdHZhciBsaWJfMSRoID0gbGliJGguZGVmYXVsdFBhdGg7XG5cdHZhciBsaWJfMiRnID0gbGliJGguSEROb2RlO1xuXHR2YXIgbGliXzMkZCA9IGxpYiRoLm1uZW1vbmljVG9TZWVkO1xuXHR2YXIgbGliXzQkYSA9IGxpYiRoLm1uZW1vbmljVG9FbnRyb3B5O1xuXHR2YXIgbGliXzUkOSA9IGxpYiRoLmVudHJvcHlUb01uZW1vbmljO1xuXHR2YXIgbGliXzYkNSA9IGxpYiRoLmlzVmFsaWRNbmVtb25pYztcblxuXHR2YXIgX3ZlcnNpb24keSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJyYW5kb20vNS4wLjAtYmV0YS4xMzZcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHogPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHkpO1xuXHR2YXIgX3ZlcnNpb25fMSRoID0gX3ZlcnNpb24keS52ZXJzaW9uO1xuXG5cdHZhciBzaHVmZmxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRmdW5jdGlvbiBzaHVmZmxlZChhcnJheSkge1xuXHQgICAgYXJyYXkgPSBhcnJheS5zbGljZSgpO1xuXHQgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuXHQgICAgICAgIHZhciB0bXAgPSBhcnJheVtpXTtcblx0ICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuXHQgICAgICAgIGFycmF5W2pdID0gdG1wO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5O1xuXHR9XG5cdGV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcblx0fSk7XG5cblx0dmFyIHNodWZmbGUkMSA9IHVud3JhcEV4cG9ydHMoc2h1ZmZsZSk7XG5cdHZhciBzaHVmZmxlXzEgPSBzaHVmZmxlLnNodWZmbGVkO1xuXG5cdHZhciBicm93c2VyJDYgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiR5LnZlcnNpb24pO1xuXG5cdGV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlLnNodWZmbGVkO1xuXHR2YXIgYW55R2xvYmFsID0gbnVsbDtcblx0dHJ5IHtcblx0ICAgIGFueUdsb2JhbCA9IHdpbmRvdztcblx0ICAgIGlmIChhbnlHbG9iYWwgPT0gbnVsbCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBuZXh0XCIpO1xuXHQgICAgfVxuXHR9XG5cdGNhdGNoIChlcnJvcikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBhbnlHbG9iYWwgPSBjb21tb25qc0dsb2JhbDtcblx0ICAgICAgICBpZiAoYW55R2xvYmFsID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgYW55R2xvYmFsID0ge307XG5cdCAgICB9XG5cdH1cblx0dmFyIGNyeXB0byA9IGFueUdsb2JhbC5jcnlwdG8gfHwgYW55R2xvYmFsLm1zQ3J5cHRvO1xuXHRpZiAoIWNyeXB0byB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuXHQgICAgbG9nZ2VyLndhcm4oXCJXQVJOSU5HOiBNaXNzaW5nIHN0cm9uZyByYW5kb20gbnVtYmVyIHNvdXJjZVwiKTtcblx0ICAgIGNyeXB0byA9IHtcblx0ICAgICAgICBnZXRSYW5kb21WYWx1ZXM6IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gc2VjdXJlIHJhbmRvbSBzb3VyY2UgYXZhaWFsYmxlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNyeXB0by5nZXRSYW5kb21WYWx1ZXNcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuXHQgICAgaWYgKGxlbmd0aCA8PSAwIHx8IGxlbmd0aCA+IDEwMjQgfHwgKGxlbmd0aCAlIDEpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoXCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblx0ICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTtcblx0ICAgIHJldHVybiBsaWIkMS5hcnJheWlmeShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcblx0O1xuXHR9KTtcblxuXHR2YXIgYnJvd3NlciQ3ID0gdW53cmFwRXhwb3J0cyhicm93c2VyJDYpO1xuXHR2YXIgYnJvd3Nlcl8xJDMgPSBicm93c2VyJDYuc2h1ZmZsZWQ7XG5cdHZhciBicm93c2VyXzIkMiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcztcblxuXHR2YXIgYWVzSnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdChmdW5jdGlvbihyb290KSB7XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrSW50KHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIChwYXJzZUludCh2YWx1ZSkgPT09IHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2hlY2tJbnRzKGFycmF5aXNoKSB7XG5cdCAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaC5sZW5ndGgpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheWlzaC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoIWNoZWNrSW50KGFycmF5aXNoW2ldKSB8fCBhcnJheWlzaFtpXSA8IDAgfHwgYXJyYXlpc2hbaV0gPiAyNTUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb2VyY2VBcnJheShhcmcsIGNvcHkpIHtcblxuXHQgICAgICAgIC8vIEFycmF5QnVmZmVyIHZpZXdcblx0ICAgICAgICBpZiAoYXJnLmJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSAmJiBhcmcubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSB7XG5cblx0ICAgICAgICAgICAgaWYgKGNvcHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChhcmcuc2xpY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBhcmc7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gSXQncyBhbiBhcnJheTsgY2hlY2sgaXQgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhIGJ5dGVcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdCAgICAgICAgICAgIGlmICghY2hlY2tJbnRzKGFyZykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgY29udGFpbnMgaW52YWxpZCB2YWx1ZTogJyArIGFyZyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBTb21ldGhpbmcgZWxzZSwgYnV0IGJlaGF2ZXMgbGlrZSBhbiBhcnJheSAobWF5YmUgYSBCdWZmZXI/IEFyZ3VtZW50cz8pXG5cdCAgICAgICAgaWYgKGNoZWNrSW50KGFyZy5sZW5ndGgpICYmIGNoZWNrSW50cyhhcmcpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcmcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXJyYXktbGlrZSBvYmplY3QnKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlQXJyYXkobGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2VBcnJheSwgdGFyZ2V0QXJyYXksIHRhcmdldFN0YXJ0LCBzb3VyY2VTdGFydCwgc291cmNlRW5kKSB7XG5cdCAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ICE9IG51bGwgfHwgc291cmNlRW5kICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKHNvdXJjZUFycmF5LnNsaWNlKSB7XG5cdCAgICAgICAgICAgICAgICBzb3VyY2VBcnJheSA9IHNvdXJjZUFycmF5LnNsaWNlKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgc291cmNlQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzb3VyY2VBcnJheSwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGFyZ2V0QXJyYXkuc2V0KHNvdXJjZUFycmF5LCB0YXJnZXRTdGFydCk7XG5cdCAgICB9XG5cblxuXG5cdCAgICB2YXIgY29udmVydFV0ZjggPSAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gdG9CeXRlcyh0ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cdCAgICAgICAgICAgIHRleHQgPSBlbmNvZGVVUkkodGV4dCk7XG5cdCAgICAgICAgICAgIHdoaWxlIChpIDwgdGV4dC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkrKyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgJSBzaWduLCBlbmNvZGUgdGhlIGZvbGxvd2luZyAyIGJ5dGVzIGFzIGEgaGV4IHZhbHVlXG5cdCAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMzcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludCh0ZXh0LnN1YnN0cihpLCAyKSwgMTYpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG5cblx0ICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwganVzdCB0aGUgYWN0dWFsIGJ5dGVcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY29lcmNlQXJyYXkocmVzdWx0KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpID0gMDtcblxuXHQgICAgICAgICAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGMgPSBieXRlc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPiAxOTEgJiYgYyA8IDIyNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgxZikgPDwgNikgfCAoYnl0ZXNbaSArIDFdICYgMHgzZikpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwZikgPDwgMTIpIHwgKChieXRlc1tpICsgMV0gJiAweDNmKSA8PCA2KSB8IChieXRlc1tpICsgMl0gJiAweDNmKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcblx0ICAgICAgICAgICAgZnJvbUJ5dGVzOiBmcm9tQnl0ZXMsXG5cdCAgICAgICAgfVxuXHQgICAgfSkoKTtcblxuXHQgICAgdmFyIGNvbnZlcnRIZXggPSAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gdG9CeXRlcyh0ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludCh0ZXh0LnN1YnN0cihpLCAyKSwgMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaHR0cDovL2l4dGkubmV0L2RldmVsb3BtZW50L2phdmFzY3JpcHQvMjAxMS8xMS8xMS9iYXNlNjQtZW5jb2RlZGVjb2RlLW9mLXV0ZjgtaW4tYnJvd3Nlci13aXRoLWpzLmh0bWxcblx0ICAgICAgICB2YXIgSGV4ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBieXRlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChIZXhbKHYgJiAweGYwKSA+PiA0XSArIEhleFt2ICYgMHgwZl0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0b0J5dGVzOiB0b0J5dGVzLFxuXHQgICAgICAgICAgICBmcm9tQnl0ZXM6IGZyb21CeXRlcyxcblx0ICAgICAgICB9XG5cdCAgICB9KSgpO1xuXG5cblx0ICAgIC8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuXHQgICAgdmFyIG51bWJlck9mUm91bmRzID0gezE2OiAxMCwgMjQ6IDEyLCAzMjogMTR9O1xuXG5cdCAgICAvLyBSb3VuZCBjb25zdGFudCB3b3Jkc1xuXHQgICAgdmFyIHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XG5cblx0ICAgIC8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXG5cdCAgICB2YXIgUyA9IFsweDYzLCAweDdjLCAweDc3LCAweDdiLCAweGYyLCAweDZiLCAweDZmLCAweGM1LCAweDMwLCAweDAxLCAweDY3LCAweDJiLCAweGZlLCAweGQ3LCAweGFiLCAweDc2LCAweGNhLCAweDgyLCAweGM5LCAweDdkLCAweGZhLCAweDU5LCAweDQ3LCAweGYwLCAweGFkLCAweGQ0LCAweGEyLCAweGFmLCAweDljLCAweGE0LCAweDcyLCAweGMwLCAweGI3LCAweGZkLCAweDkzLCAweDI2LCAweDM2LCAweDNmLCAweGY3LCAweGNjLCAweDM0LCAweGE1LCAweGU1LCAweGYxLCAweDcxLCAweGQ4LCAweDMxLCAweDE1LCAweDA0LCAweGM3LCAweDIzLCAweGMzLCAweDE4LCAweDk2LCAweDA1LCAweDlhLCAweDA3LCAweDEyLCAweDgwLCAweGUyLCAweGViLCAweDI3LCAweGIyLCAweDc1LCAweDA5LCAweDgzLCAweDJjLCAweDFhLCAweDFiLCAweDZlLCAweDVhLCAweGEwLCAweDUyLCAweDNiLCAweGQ2LCAweGIzLCAweDI5LCAweGUzLCAweDJmLCAweDg0LCAweDUzLCAweGQxLCAweDAwLCAweGVkLCAweDIwLCAweGZjLCAweGIxLCAweDViLCAweDZhLCAweGNiLCAweGJlLCAweDM5LCAweDRhLCAweDRjLCAweDU4LCAweGNmLCAweGQwLCAweGVmLCAweGFhLCAweGZiLCAweDQzLCAweDRkLCAweDMzLCAweDg1LCAweDQ1LCAweGY5LCAweDAyLCAweDdmLCAweDUwLCAweDNjLCAweDlmLCAweGE4LCAweDUxLCAweGEzLCAweDQwLCAweDhmLCAweDkyLCAweDlkLCAweDM4LCAweGY1LCAweGJjLCAweGI2LCAweGRhLCAweDIxLCAweDEwLCAweGZmLCAweGYzLCAweGQyLCAweGNkLCAweDBjLCAweDEzLCAweGVjLCAweDVmLCAweDk3LCAweDQ0LCAweDE3LCAweGM0LCAweGE3LCAweDdlLCAweDNkLCAweDY0LCAweDVkLCAweDE5LCAweDczLCAweDYwLCAweDgxLCAweDRmLCAweGRjLCAweDIyLCAweDJhLCAweDkwLCAweDg4LCAweDQ2LCAweGVlLCAweGI4LCAweDE0LCAweGRlLCAweDVlLCAweDBiLCAweGRiLCAweGUwLCAweDMyLCAweDNhLCAweDBhLCAweDQ5LCAweDA2LCAweDI0LCAweDVjLCAweGMyLCAweGQzLCAweGFjLCAweDYyLCAweDkxLCAweDk1LCAweGU0LCAweDc5LCAweGU3LCAweGM4LCAweDM3LCAweDZkLCAweDhkLCAweGQ1LCAweDRlLCAweGE5LCAweDZjLCAweDU2LCAweGY0LCAweGVhLCAweDY1LCAweDdhLCAweGFlLCAweDA4LCAweGJhLCAweDc4LCAweDI1LCAweDJlLCAweDFjLCAweGE2LCAweGI0LCAweGM2LCAweGU4LCAweGRkLCAweDc0LCAweDFmLCAweDRiLCAweGJkLCAweDhiLCAweDhhLCAweDcwLCAweDNlLCAweGI1LCAweDY2LCAweDQ4LCAweDAzLCAweGY2LCAweDBlLCAweDYxLCAweDM1LCAweDU3LCAweGI5LCAweDg2LCAweGMxLCAweDFkLCAweDllLCAweGUxLCAweGY4LCAweDk4LCAweDExLCAweDY5LCAweGQ5LCAweDhlLCAweDk0LCAweDliLCAweDFlLCAweDg3LCAweGU5LCAweGNlLCAweDU1LCAweDI4LCAweGRmLCAweDhjLCAweGExLCAweDg5LCAweDBkLCAweGJmLCAweGU2LCAweDQyLCAweDY4LCAweDQxLCAweDk5LCAweDJkLCAweDBmLCAweGIwLCAweDU0LCAweGJiLCAweDE2XTtcblx0ICAgIHZhciBTaSA9WzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xuXG5cdCAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cblx0ICAgIHZhciBUMSA9IFsweGM2NjM2M2E1LCAweGY4N2M3Yzg0LCAweGVlNzc3Nzk5LCAweGY2N2I3YjhkLCAweGZmZjJmMjBkLCAweGQ2NmI2YmJkLCAweGRlNmY2ZmIxLCAweDkxYzVjNTU0LCAweDYwMzAzMDUwLCAweDAyMDEwMTAzLCAweGNlNjc2N2E5LCAweDU2MmIyYjdkLCAweGU3ZmVmZTE5LCAweGI1ZDdkNzYyLCAweDRkYWJhYmU2LCAweGVjNzY3NjlhLCAweDhmY2FjYTQ1LCAweDFmODI4MjlkLCAweDg5YzljOTQwLCAweGZhN2Q3ZDg3LCAweGVmZmFmYTE1LCAweGIyNTk1OWViLCAweDhlNDc0N2M5LCAweGZiZjBmMDBiLCAweDQxYWRhZGVjLCAweGIzZDRkNDY3LCAweDVmYTJhMmZkLCAweDQ1YWZhZmVhLCAweDIzOWM5Y2JmLCAweDUzYTRhNGY3LCAweGU0NzI3Mjk2LCAweDliYzBjMDViLCAweDc1YjdiN2MyLCAweGUxZmRmZDFjLCAweDNkOTM5M2FlLCAweDRjMjYyNjZhLCAweDZjMzYzNjVhLCAweDdlM2YzZjQxLCAweGY1ZjdmNzAyLCAweDgzY2NjYzRmLCAweDY4MzQzNDVjLCAweDUxYTVhNWY0LCAweGQxZTVlNTM0LCAweGY5ZjFmMTA4LCAweGUyNzE3MTkzLCAweGFiZDhkODczLCAweDYyMzEzMTUzLCAweDJhMTUxNTNmLCAweDA4MDQwNDBjLCAweDk1YzdjNzUyLCAweDQ2MjMyMzY1LCAweDlkYzNjMzVlLCAweDMwMTgxODI4LCAweDM3OTY5NmExLCAweDBhMDUwNTBmLCAweDJmOWE5YWI1LCAweDBlMDcwNzA5LCAweDI0MTIxMjM2LCAweDFiODA4MDliLCAweGRmZTJlMjNkLCAweGNkZWJlYjI2LCAweDRlMjcyNzY5LCAweDdmYjJiMmNkLCAweGVhNzU3NTlmLCAweDEyMDkwOTFiLCAweDFkODM4MzllLCAweDU4MmMyYzc0LCAweDM0MWExYTJlLCAweDM2MWIxYjJkLCAweGRjNmU2ZWIyLCAweGI0NWE1YWVlLCAweDViYTBhMGZiLCAweGE0NTI1MmY2LCAweDc2M2IzYjRkLCAweGI3ZDZkNjYxLCAweDdkYjNiM2NlLCAweDUyMjkyOTdiLCAweGRkZTNlMzNlLCAweDVlMmYyZjcxLCAweDEzODQ4NDk3LCAweGE2NTM1M2Y1LCAweGI5ZDFkMTY4LCAweDAwMDAwMDAwLCAweGMxZWRlZDJjLCAweDQwMjAyMDYwLCAweGUzZmNmYzFmLCAweDc5YjFiMWM4LCAweGI2NWI1YmVkLCAweGQ0NmE2YWJlLCAweDhkY2JjYjQ2LCAweDY3YmViZWQ5LCAweDcyMzkzOTRiLCAweDk0NGE0YWRlLCAweDk4NGM0Y2Q0LCAweGIwNTg1OGU4LCAweDg1Y2ZjZjRhLCAweGJiZDBkMDZiLCAweGM1ZWZlZjJhLCAweDRmYWFhYWU1LCAweGVkZmJmYjE2LCAweDg2NDM0M2M1LCAweDlhNGQ0ZGQ3LCAweDY2MzMzMzU1LCAweDExODU4NTk0LCAweDhhNDU0NWNmLCAweGU5ZjlmOTEwLCAweDA0MDIwMjA2LCAweGZlN2Y3ZjgxLCAweGEwNTA1MGYwLCAweDc4M2MzYzQ0LCAweDI1OWY5ZmJhLCAweDRiYThhOGUzLCAweGEyNTE1MWYzLCAweDVkYTNhM2ZlLCAweDgwNDA0MGMwLCAweDA1OGY4ZjhhLCAweDNmOTI5MmFkLCAweDIxOWQ5ZGJjLCAweDcwMzgzODQ4LCAweGYxZjVmNTA0LCAweDYzYmNiY2RmLCAweDc3YjZiNmMxLCAweGFmZGFkYTc1LCAweDQyMjEyMTYzLCAweDIwMTAxMDMwLCAweGU1ZmZmZjFhLCAweGZkZjNmMzBlLCAweGJmZDJkMjZkLCAweDgxY2RjZDRjLCAweDE4MGMwYzE0LCAweDI2MTMxMzM1LCAweGMzZWNlYzJmLCAweGJlNWY1ZmUxLCAweDM1OTc5N2EyLCAweDg4NDQ0NGNjLCAweDJlMTcxNzM5LCAweDkzYzRjNDU3LCAweDU1YTdhN2YyLCAweGZjN2U3ZTgyLCAweDdhM2QzZDQ3LCAweGM4NjQ2NGFjLCAweGJhNWQ1ZGU3LCAweDMyMTkxOTJiLCAweGU2NzM3Mzk1LCAweGMwNjA2MGEwLCAweDE5ODE4MTk4LCAweDllNGY0ZmQxLCAweGEzZGNkYzdmLCAweDQ0MjIyMjY2LCAweDU0MmEyYTdlLCAweDNiOTA5MGFiLCAweDBiODg4ODgzLCAweDhjNDY0NmNhLCAweGM3ZWVlZTI5LCAweDZiYjhiOGQzLCAweDI4MTQxNDNjLCAweGE3ZGVkZTc5LCAweGJjNWU1ZWUyLCAweDE2MGIwYjFkLCAweGFkZGJkYjc2LCAweGRiZTBlMDNiLCAweDY0MzIzMjU2LCAweDc0M2EzYTRlLCAweDE0MGEwYTFlLCAweDkyNDk0OWRiLCAweDBjMDYwNjBhLCAweDQ4MjQyNDZjLCAweGI4NWM1Y2U0LCAweDlmYzJjMjVkLCAweGJkZDNkMzZlLCAweDQzYWNhY2VmLCAweGM0NjI2MmE2LCAweDM5OTE5MWE4LCAweDMxOTU5NWE0LCAweGQzZTRlNDM3LCAweGYyNzk3OThiLCAweGQ1ZTdlNzMyLCAweDhiYzhjODQzLCAweDZlMzczNzU5LCAweGRhNmQ2ZGI3LCAweDAxOGQ4ZDhjLCAweGIxZDVkNTY0LCAweDljNGU0ZWQyLCAweDQ5YTlhOWUwLCAweGQ4NmM2Y2I0LCAweGFjNTY1NmZhLCAweGYzZjRmNDA3LCAweGNmZWFlYTI1LCAweGNhNjU2NWFmLCAweGY0N2E3YThlLCAweDQ3YWVhZWU5LCAweDEwMDgwODE4LCAweDZmYmFiYWQ1LCAweGYwNzg3ODg4LCAweDRhMjUyNTZmLCAweDVjMmUyZTcyLCAweDM4MWMxYzI0LCAweDU3YTZhNmYxLCAweDczYjRiNGM3LCAweDk3YzZjNjUxLCAweGNiZThlODIzLCAweGExZGRkZDdjLCAweGU4NzQ3NDljLCAweDNlMWYxZjIxLCAweDk2NGI0YmRkLCAweDYxYmRiZGRjLCAweDBkOGI4Yjg2LCAweDBmOGE4YTg1LCAweGUwNzA3MDkwLCAweDdjM2UzZTQyLCAweDcxYjViNWM0LCAweGNjNjY2NmFhLCAweDkwNDg0OGQ4LCAweDA2MDMwMzA1LCAweGY3ZjZmNjAxLCAweDFjMGUwZTEyLCAweGMyNjE2MWEzLCAweDZhMzUzNTVmLCAweGFlNTc1N2Y5LCAweDY5YjliOWQwLCAweDE3ODY4NjkxLCAweDk5YzFjMTU4LCAweDNhMWQxZDI3LCAweDI3OWU5ZWI5LCAweGQ5ZTFlMTM4LCAweGViZjhmODEzLCAweDJiOTg5OGIzLCAweDIyMTExMTMzLCAweGQyNjk2OWJiLCAweGE5ZDlkOTcwLCAweDA3OGU4ZTg5LCAweDMzOTQ5NGE3LCAweDJkOWI5YmI2LCAweDNjMWUxZTIyLCAweDE1ODc4NzkyLCAweGM5ZTllOTIwLCAweDg3Y2VjZTQ5LCAweGFhNTU1NWZmLCAweDUwMjgyODc4LCAweGE1ZGZkZjdhLCAweDAzOGM4YzhmLCAweDU5YTFhMWY4LCAweDA5ODk4OTgwLCAweDFhMGQwZDE3LCAweDY1YmZiZmRhLCAweGQ3ZTZlNjMxLCAweDg0NDI0MmM2LCAweGQwNjg2OGI4LCAweDgyNDE0MWMzLCAweDI5OTk5OWIwLCAweDVhMmQyZDc3LCAweDFlMGYwZjExLCAweDdiYjBiMGNiLCAweGE4NTQ1NGZjLCAweDZkYmJiYmQ2LCAweDJjMTYxNjNhXTtcblx0ICAgIHZhciBUMiA9IFsweGE1YzY2MzYzLCAweDg0Zjg3YzdjLCAweDk5ZWU3Nzc3LCAweDhkZjY3YjdiLCAweDBkZmZmMmYyLCAweGJkZDY2YjZiLCAweGIxZGU2ZjZmLCAweDU0OTFjNWM1LCAweDUwNjAzMDMwLCAweDAzMDIwMTAxLCAweGE5Y2U2NzY3LCAweDdkNTYyYjJiLCAweDE5ZTdmZWZlLCAweDYyYjVkN2Q3LCAweGU2NGRhYmFiLCAweDlhZWM3Njc2LCAweDQ1OGZjYWNhLCAweDlkMWY4MjgyLCAweDQwODljOWM5LCAweDg3ZmE3ZDdkLCAweDE1ZWZmYWZhLCAweGViYjI1OTU5LCAweGM5OGU0NzQ3LCAweDBiZmJmMGYwLCAweGVjNDFhZGFkLCAweDY3YjNkNGQ0LCAweGZkNWZhMmEyLCAweGVhNDVhZmFmLCAweGJmMjM5YzljLCAweGY3NTNhNGE0LCAweDk2ZTQ3MjcyLCAweDViOWJjMGMwLCAweGMyNzViN2I3LCAweDFjZTFmZGZkLCAweGFlM2Q5MzkzLCAweDZhNGMyNjI2LCAweDVhNmMzNjM2LCAweDQxN2UzZjNmLCAweDAyZjVmN2Y3LCAweDRmODNjY2NjLCAweDVjNjgzNDM0LCAweGY0NTFhNWE1LCAweDM0ZDFlNWU1LCAweDA4ZjlmMWYxLCAweDkzZTI3MTcxLCAweDczYWJkOGQ4LCAweDUzNjIzMTMxLCAweDNmMmExNTE1LCAweDBjMDgwNDA0LCAweDUyOTVjN2M3LCAweDY1NDYyMzIzLCAweDVlOWRjM2MzLCAweDI4MzAxODE4LCAweGExMzc5Njk2LCAweDBmMGEwNTA1LCAweGI1MmY5YTlhLCAweDA5MGUwNzA3LCAweDM2MjQxMjEyLCAweDliMWI4MDgwLCAweDNkZGZlMmUyLCAweDI2Y2RlYmViLCAweDY5NGUyNzI3LCAweGNkN2ZiMmIyLCAweDlmZWE3NTc1LCAweDFiMTIwOTA5LCAweDllMWQ4MzgzLCAweDc0NTgyYzJjLCAweDJlMzQxYTFhLCAweDJkMzYxYjFiLCAweGIyZGM2ZTZlLCAweGVlYjQ1YTVhLCAweGZiNWJhMGEwLCAweGY2YTQ1MjUyLCAweDRkNzYzYjNiLCAweDYxYjdkNmQ2LCAweGNlN2RiM2IzLCAweDdiNTIyOTI5LCAweDNlZGRlM2UzLCAweDcxNWUyZjJmLCAweDk3MTM4NDg0LCAweGY1YTY1MzUzLCAweDY4YjlkMWQxLCAweDAwMDAwMDAwLCAweDJjYzFlZGVkLCAweDYwNDAyMDIwLCAweDFmZTNmY2ZjLCAweGM4NzliMWIxLCAweGVkYjY1YjViLCAweGJlZDQ2YTZhLCAweDQ2OGRjYmNiLCAweGQ5NjdiZWJlLCAweDRiNzIzOTM5LCAweGRlOTQ0YTRhLCAweGQ0OTg0YzRjLCAweGU4YjA1ODU4LCAweDRhODVjZmNmLCAweDZiYmJkMGQwLCAweDJhYzVlZmVmLCAweGU1NGZhYWFhLCAweDE2ZWRmYmZiLCAweGM1ODY0MzQzLCAweGQ3OWE0ZDRkLCAweDU1NjYzMzMzLCAweDk0MTE4NTg1LCAweGNmOGE0NTQ1LCAweDEwZTlmOWY5LCAweDA2MDQwMjAyLCAweDgxZmU3ZjdmLCAweGYwYTA1MDUwLCAweDQ0NzgzYzNjLCAweGJhMjU5ZjlmLCAweGUzNGJhOGE4LCAweGYzYTI1MTUxLCAweGZlNWRhM2EzLCAweGMwODA0MDQwLCAweDhhMDU4ZjhmLCAweGFkM2Y5MjkyLCAweGJjMjE5ZDlkLCAweDQ4NzAzODM4LCAweDA0ZjFmNWY1LCAweGRmNjNiY2JjLCAweGMxNzdiNmI2LCAweDc1YWZkYWRhLCAweDYzNDIyMTIxLCAweDMwMjAxMDEwLCAweDFhZTVmZmZmLCAweDBlZmRmM2YzLCAweDZkYmZkMmQyLCAweDRjODFjZGNkLCAweDE0MTgwYzBjLCAweDM1MjYxMzEzLCAweDJmYzNlY2VjLCAweGUxYmU1ZjVmLCAweGEyMzU5Nzk3LCAweGNjODg0NDQ0LCAweDM5MmUxNzE3LCAweDU3OTNjNGM0LCAweGYyNTVhN2E3LCAweDgyZmM3ZTdlLCAweDQ3N2EzZDNkLCAweGFjYzg2NDY0LCAweGU3YmE1ZDVkLCAweDJiMzIxOTE5LCAweDk1ZTY3MzczLCAweGEwYzA2MDYwLCAweDk4MTk4MTgxLCAweGQxOWU0ZjRmLCAweDdmYTNkY2RjLCAweDY2NDQyMjIyLCAweDdlNTQyYTJhLCAweGFiM2I5MDkwLCAweDgzMGI4ODg4LCAweGNhOGM0NjQ2LCAweDI5YzdlZWVlLCAweGQzNmJiOGI4LCAweDNjMjgxNDE0LCAweDc5YTdkZWRlLCAweGUyYmM1ZTVlLCAweDFkMTYwYjBiLCAweDc2YWRkYmRiLCAweDNiZGJlMGUwLCAweDU2NjQzMjMyLCAweDRlNzQzYTNhLCAweDFlMTQwYTBhLCAweGRiOTI0OTQ5LCAweDBhMGMwNjA2LCAweDZjNDgyNDI0LCAweGU0Yjg1YzVjLCAweDVkOWZjMmMyLCAweDZlYmRkM2QzLCAweGVmNDNhY2FjLCAweGE2YzQ2MjYyLCAweGE4Mzk5MTkxLCAweGE0MzE5NTk1LCAweDM3ZDNlNGU0LCAweDhiZjI3OTc5LCAweDMyZDVlN2U3LCAweDQzOGJjOGM4LCAweDU5NmUzNzM3LCAweGI3ZGE2ZDZkLCAweDhjMDE4ZDhkLCAweDY0YjFkNWQ1LCAweGQyOWM0ZTRlLCAweGUwNDlhOWE5LCAweGI0ZDg2YzZjLCAweGZhYWM1NjU2LCAweDA3ZjNmNGY0LCAweDI1Y2ZlYWVhLCAweGFmY2E2NTY1LCAweDhlZjQ3YTdhLCAweGU5NDdhZWFlLCAweDE4MTAwODA4LCAweGQ1NmZiYWJhLCAweDg4ZjA3ODc4LCAweDZmNGEyNTI1LCAweDcyNWMyZTJlLCAweDI0MzgxYzFjLCAweGYxNTdhNmE2LCAweGM3NzNiNGI0LCAweDUxOTdjNmM2LCAweDIzY2JlOGU4LCAweDdjYTFkZGRkLCAweDljZTg3NDc0LCAweDIxM2UxZjFmLCAweGRkOTY0YjRiLCAweGRjNjFiZGJkLCAweDg2MGQ4YjhiLCAweDg1MGY4YThhLCAweDkwZTA3MDcwLCAweDQyN2MzZTNlLCAweGM0NzFiNWI1LCAweGFhY2M2NjY2LCAweGQ4OTA0ODQ4LCAweDA1MDYwMzAzLCAweDAxZjdmNmY2LCAweDEyMWMwZTBlLCAweGEzYzI2MTYxLCAweDVmNmEzNTM1LCAweGY5YWU1NzU3LCAweGQwNjliOWI5LCAweDkxMTc4Njg2LCAweDU4OTljMWMxLCAweDI3M2ExZDFkLCAweGI5Mjc5ZTllLCAweDM4ZDllMWUxLCAweDEzZWJmOGY4LCAweGIzMmI5ODk4LCAweDMzMjIxMTExLCAweGJiZDI2OTY5LCAweDcwYTlkOWQ5LCAweDg5MDc4ZThlLCAweGE3MzM5NDk0LCAweGI2MmQ5YjliLCAweDIyM2MxZTFlLCAweDkyMTU4Nzg3LCAweDIwYzllOWU5LCAweDQ5ODdjZWNlLCAweGZmYWE1NTU1LCAweDc4NTAyODI4LCAweDdhYTVkZmRmLCAweDhmMDM4YzhjLCAweGY4NTlhMWExLCAweDgwMDk4OTg5LCAweDE3MWEwZDBkLCAweGRhNjViZmJmLCAweDMxZDdlNmU2LCAweGM2ODQ0MjQyLCAweGI4ZDA2ODY4LCAweGMzODI0MTQxLCAweGIwMjk5OTk5LCAweDc3NWEyZDJkLCAweDExMWUwZjBmLCAweGNiN2JiMGIwLCAweGZjYTg1NDU0LCAweGQ2NmRiYmJiLCAweDNhMmMxNjE2XTtcblx0ICAgIHZhciBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcblx0ICAgIHZhciBUNCA9IFsweDYzNjNhNWM2LCAweDdjN2M4NGY4LCAweDc3Nzc5OWVlLCAweDdiN2I4ZGY2LCAweGYyZjIwZGZmLCAweDZiNmJiZGQ2LCAweDZmNmZiMWRlLCAweGM1YzU1NDkxLCAweDMwMzA1MDYwLCAweDAxMDEwMzAyLCAweDY3NjdhOWNlLCAweDJiMmI3ZDU2LCAweGZlZmUxOWU3LCAweGQ3ZDc2MmI1LCAweGFiYWJlNjRkLCAweDc2NzY5YWVjLCAweGNhY2E0NThmLCAweDgyODI5ZDFmLCAweGM5Yzk0MDg5LCAweDdkN2Q4N2ZhLCAweGZhZmExNWVmLCAweDU5NTllYmIyLCAweDQ3NDdjOThlLCAweGYwZjAwYmZiLCAweGFkYWRlYzQxLCAweGQ0ZDQ2N2IzLCAweGEyYTJmZDVmLCAweGFmYWZlYTQ1LCAweDljOWNiZjIzLCAweGE0YTRmNzUzLCAweDcyNzI5NmU0LCAweGMwYzA1YjliLCAweGI3YjdjMjc1LCAweGZkZmQxY2UxLCAweDkzOTNhZTNkLCAweDI2MjY2YTRjLCAweDM2MzY1YTZjLCAweDNmM2Y0MTdlLCAweGY3ZjcwMmY1LCAweGNjY2M0ZjgzLCAweDM0MzQ1YzY4LCAweGE1YTVmNDUxLCAweGU1ZTUzNGQxLCAweGYxZjEwOGY5LCAweDcxNzE5M2UyLCAweGQ4ZDg3M2FiLCAweDMxMzE1MzYyLCAweDE1MTUzZjJhLCAweDA0MDQwYzA4LCAweGM3Yzc1Mjk1LCAweDIzMjM2NTQ2LCAweGMzYzM1ZTlkLCAweDE4MTgyODMwLCAweDk2OTZhMTM3LCAweDA1MDUwZjBhLCAweDlhOWFiNTJmLCAweDA3MDcwOTBlLCAweDEyMTIzNjI0LCAweDgwODA5YjFiLCAweGUyZTIzZGRmLCAweGViZWIyNmNkLCAweDI3Mjc2OTRlLCAweGIyYjJjZDdmLCAweDc1NzU5ZmVhLCAweDA5MDkxYjEyLCAweDgzODM5ZTFkLCAweDJjMmM3NDU4LCAweDFhMWEyZTM0LCAweDFiMWIyZDM2LCAweDZlNmViMmRjLCAweDVhNWFlZWI0LCAweGEwYTBmYjViLCAweDUyNTJmNmE0LCAweDNiM2I0ZDc2LCAweGQ2ZDY2MWI3LCAweGIzYjNjZTdkLCAweDI5Mjk3YjUyLCAweGUzZTMzZWRkLCAweDJmMmY3MTVlLCAweDg0ODQ5NzEzLCAweDUzNTNmNWE2LCAweGQxZDE2OGI5LCAweDAwMDAwMDAwLCAweGVkZWQyY2MxLCAweDIwMjA2MDQwLCAweGZjZmMxZmUzLCAweGIxYjFjODc5LCAweDViNWJlZGI2LCAweDZhNmFiZWQ0LCAweGNiY2I0NjhkLCAweGJlYmVkOTY3LCAweDM5Mzk0YjcyLCAweDRhNGFkZTk0LCAweDRjNGNkNDk4LCAweDU4NThlOGIwLCAweGNmY2Y0YTg1LCAweGQwZDA2YmJiLCAweGVmZWYyYWM1LCAweGFhYWFlNTRmLCAweGZiZmIxNmVkLCAweDQzNDNjNTg2LCAweDRkNGRkNzlhLCAweDMzMzM1NTY2LCAweDg1ODU5NDExLCAweDQ1NDVjZjhhLCAweGY5ZjkxMGU5LCAweDAyMDIwNjA0LCAweDdmN2Y4MWZlLCAweDUwNTBmMGEwLCAweDNjM2M0NDc4LCAweDlmOWZiYTI1LCAweGE4YThlMzRiLCAweDUxNTFmM2EyLCAweGEzYTNmZTVkLCAweDQwNDBjMDgwLCAweDhmOGY4YTA1LCAweDkyOTJhZDNmLCAweDlkOWRiYzIxLCAweDM4Mzg0ODcwLCAweGY1ZjUwNGYxLCAweGJjYmNkZjYzLCAweGI2YjZjMTc3LCAweGRhZGE3NWFmLCAweDIxMjE2MzQyLCAweDEwMTAzMDIwLCAweGZmZmYxYWU1LCAweGYzZjMwZWZkLCAweGQyZDI2ZGJmLCAweGNkY2Q0YzgxLCAweDBjMGMxNDE4LCAweDEzMTMzNTI2LCAweGVjZWMyZmMzLCAweDVmNWZlMWJlLCAweDk3OTdhMjM1LCAweDQ0NDRjYzg4LCAweDE3MTczOTJlLCAweGM0YzQ1NzkzLCAweGE3YTdmMjU1LCAweDdlN2U4MmZjLCAweDNkM2Q0NzdhLCAweDY0NjRhY2M4LCAweDVkNWRlN2JhLCAweDE5MTkyYjMyLCAweDczNzM5NWU2LCAweDYwNjBhMGMwLCAweDgxODE5ODE5LCAweDRmNGZkMTllLCAweGRjZGM3ZmEzLCAweDIyMjI2NjQ0LCAweDJhMmE3ZTU0LCAweDkwOTBhYjNiLCAweDg4ODg4MzBiLCAweDQ2NDZjYThjLCAweGVlZWUyOWM3LCAweGI4YjhkMzZiLCAweDE0MTQzYzI4LCAweGRlZGU3OWE3LCAweDVlNWVlMmJjLCAweDBiMGIxZDE2LCAweGRiZGI3NmFkLCAweGUwZTAzYmRiLCAweDMyMzI1NjY0LCAweDNhM2E0ZTc0LCAweDBhMGExZTE0LCAweDQ5NDlkYjkyLCAweDA2MDYwYTBjLCAweDI0MjQ2YzQ4LCAweDVjNWNlNGI4LCAweGMyYzI1ZDlmLCAweGQzZDM2ZWJkLCAweGFjYWNlZjQzLCAweDYyNjJhNmM0LCAweDkxOTFhODM5LCAweDk1OTVhNDMxLCAweGU0ZTQzN2QzLCAweDc5Nzk4YmYyLCAweGU3ZTczMmQ1LCAweGM4Yzg0MzhiLCAweDM3Mzc1OTZlLCAweDZkNmRiN2RhLCAweDhkOGQ4YzAxLCAweGQ1ZDU2NGIxLCAweDRlNGVkMjljLCAweGE5YTllMDQ5LCAweDZjNmNiNGQ4LCAweDU2NTZmYWFjLCAweGY0ZjQwN2YzLCAweGVhZWEyNWNmLCAweDY1NjVhZmNhLCAweDdhN2E4ZWY0LCAweGFlYWVlOTQ3LCAweDA4MDgxODEwLCAweGJhYmFkNTZmLCAweDc4Nzg4OGYwLCAweDI1MjU2ZjRhLCAweDJlMmU3MjVjLCAweDFjMWMyNDM4LCAweGE2YTZmMTU3LCAweGI0YjRjNzczLCAweGM2YzY1MTk3LCAweGU4ZTgyM2NiLCAweGRkZGQ3Y2ExLCAweDc0NzQ5Y2U4LCAweDFmMWYyMTNlLCAweDRiNGJkZDk2LCAweGJkYmRkYzYxLCAweDhiOGI4NjBkLCAweDhhOGE4NTBmLCAweDcwNzA5MGUwLCAweDNlM2U0MjdjLCAweGI1YjVjNDcxLCAweDY2NjZhYWNjLCAweDQ4NDhkODkwLCAweDAzMDMwNTA2LCAweGY2ZjYwMWY3LCAweDBlMGUxMjFjLCAweDYxNjFhM2MyLCAweDM1MzU1ZjZhLCAweDU3NTdmOWFlLCAweGI5YjlkMDY5LCAweDg2ODY5MTE3LCAweGMxYzE1ODk5LCAweDFkMWQyNzNhLCAweDllOWViOTI3LCAweGUxZTEzOGQ5LCAweGY4ZjgxM2ViLCAweDk4OThiMzJiLCAweDExMTEzMzIyLCAweDY5NjliYmQyLCAweGQ5ZDk3MGE5LCAweDhlOGU4OTA3LCAweDk0OTRhNzMzLCAweDliOWJiNjJkLCAweDFlMWUyMjNjLCAweDg3ODc5MjE1LCAweGU5ZTkyMGM5LCAweGNlY2U0OTg3LCAweDU1NTVmZmFhLCAweDI4Mjg3ODUwLCAweGRmZGY3YWE1LCAweDhjOGM4ZjAzLCAweGExYTFmODU5LCAweDg5ODk4MDA5LCAweDBkMGQxNzFhLCAweGJmYmZkYTY1LCAweGU2ZTYzMWQ3LCAweDQyNDJjNjg0LCAweDY4NjhiOGQwLCAweDQxNDFjMzgyLCAweDk5OTliMDI5LCAweDJkMmQ3NzVhLCAweDBmMGYxMTFlLCAweGIwYjBjYjdiLCAweDU0NTRmY2E4LCAweGJiYmJkNjZkLCAweDE2MTYzYTJjXTtcblxuXHQgICAgLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uXG5cdCAgICB2YXIgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG5cdCAgICB2YXIgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XG5cdCAgICB2YXIgVDcgPSBbMHhhNzUwNTFmNCwgMHg2NTUzN2U0MSwgMHhhNGMzMWExNywgMHg1ZTk2M2EyNywgMHg2YmNiM2JhYiwgMHg0NWYxMWY5ZCwgMHg1OGFiYWNmYSwgMHgwMzkzNGJlMywgMHhmYTU1MjAzMCwgMHg2ZGY2YWQ3NiwgMHg3NjkxODhjYywgMHg0YzI1ZjUwMiwgMHhkN2ZjNGZlNSwgMHhjYmQ3YzUyYSwgMHg0NDgwMjYzNSwgMHhhMzhmYjU2MiwgMHg1YTQ5ZGViMSwgMHgxYjY3MjViYSwgMHgwZTk4NDVlYSwgMHhjMGUxNWRmZSwgMHg3NTAyYzMyZiwgMHhmMDEyODE0YywgMHg5N2EzOGQ0NiwgMHhmOWM2NmJkMywgMHg1ZmU3MDM4ZiwgMHg5Yzk1MTU5MiwgMHg3YWViYmY2ZCwgMHg1OWRhOTU1MiwgMHg4MzJkZDRiZSwgMHgyMWQzNTg3NCwgMHg2OTI5NDllMCwgMHhjODQ0OGVjOSwgMHg4OTZhNzVjMiwgMHg3OTc4ZjQ4ZSwgMHgzZTZiOTk1OCwgMHg3MWRkMjdiOSwgMHg0ZmI2YmVlMSwgMHhhZDE3ZjA4OCwgMHhhYzY2YzkyMCwgMHgzYWI0N2RjZSwgMHg0YTE4NjNkZiwgMHgzMTgyZTUxYSwgMHgzMzYwOTc1MSwgMHg3ZjQ1NjI1MywgMHg3N2UwYjE2NCwgMHhhZTg0YmI2YiwgMHhhMDFjZmU4MSwgMHgyYjk0ZjkwOCwgMHg2ODU4NzA0OCwgMHhmZDE5OGY0NSwgMHg2Yzg3OTRkZSwgMHhmOGI3NTI3YiwgMHhkMzIzYWI3MywgMHgwMmUyNzI0YiwgMHg4ZjU3ZTMxZiwgMHhhYjJhNjY1NSwgMHgyODA3YjJlYiwgMHhjMjAzMmZiNSwgMHg3YjlhODZjNSwgMHgwOGE1ZDMzNywgMHg4N2YyMzAyOCwgMHhhNWIyMjNiZiwgMHg2YWJhMDIwMywgMHg4MjVjZWQxNiwgMHgxYzJiOGFjZiwgMHhiNDkyYTc3OSwgMHhmMmYwZjMwNywgMHhlMmExNGU2OSwgMHhmNGNkNjVkYSwgMHhiZWQ1MDYwNSwgMHg2MjFmZDEzNCwgMHhmZThhYzRhNiwgMHg1MzlkMzQyZSwgMHg1NWEwYTJmMywgMHhlMTMyMDU4YSwgMHhlYjc1YTRmNiwgMHhlYzM5MGI4MywgMHhlZmFhNDA2MCwgMHg5ZjA2NWU3MSwgMHgxMDUxYmQ2ZSwgMHg4YWY5M2UyMSwgMHgwNjNkOTZkZCwgMHgwNWFlZGQzZSwgMHhiZDQ2NGRlNiwgMHg4ZGI1OTE1NCwgMHg1ZDA1NzFjNCwgMHhkNDZmMDQwNiwgMHgxNWZmNjA1MCwgMHhmYjI0MTk5OCwgMHhlOTk3ZDZiZCwgMHg0M2NjODk0MCwgMHg5ZTc3NjdkOSwgMHg0MmJkYjBlOCwgMHg4Yjg4MDc4OSwgMHg1YjM4ZTcxOSwgMHhlZWRiNzljOCwgMHgwYTQ3YTE3YywgMHgwZmU5N2M0MiwgMHgxZWM5Zjg4NCwgMHgwMDAwMDAwMCwgMHg4NjgzMDk4MCwgMHhlZDQ4MzIyYiwgMHg3MGFjMWUxMSwgMHg3MjRlNmM1YSwgMHhmZmZiZmQwZSwgMHgzODU2MGY4NSwgMHhkNTFlM2RhZSwgMHgzOTI3MzYyZCwgMHhkOTY0MGEwZiwgMHhhNjIxNjg1YywgMHg1NGQxOWI1YiwgMHgyZTNhMjQzNiwgMHg2N2IxMGMwYSwgMHhlNzBmOTM1NywgMHg5NmQyYjRlZSwgMHg5MTllMWI5YiwgMHhjNTRmODBjMCwgMHgyMGEyNjFkYywgMHg0YjY5NWE3NywgMHgxYTE2MWMxMiwgMHhiYTBhZTI5MywgMHgyYWU1YzBhMCwgMHhlMDQzM2MyMiwgMHgxNzFkMTIxYiwgMHgwZDBiMGUwOSwgMHhjN2FkZjI4YiwgMHhhOGI5MmRiNiwgMHhhOWM4MTQxZSwgMHgxOTg1NTdmMSwgMHgwNzRjYWY3NSwgMHhkZGJiZWU5OSwgMHg2MGZkYTM3ZiwgMHgyNjlmZjcwMSwgMHhmNWJjNWM3MiwgMHgzYmM1NDQ2NiwgMHg3ZTM0NWJmYiwgMHgyOTc2OGI0MywgMHhjNmRjY2IyMywgMHhmYzY4YjZlZCwgMHhmMTYzYjhlNCwgMHhkY2NhZDczMSwgMHg4NTEwNDI2MywgMHgyMjQwMTM5NywgMHgxMTIwODRjNiwgMHgyNDdkODU0YSwgMHgzZGY4ZDJiYiwgMHgzMjExYWVmOSwgMHhhMTZkYzcyOSwgMHgyZjRiMWQ5ZSwgMHgzMGYzZGNiMiwgMHg1MmVjMGQ4NiwgMHhlM2QwNzdjMSwgMHgxNjZjMmJiMywgMHhiOTk5YTk3MCwgMHg0OGZhMTE5NCwgMHg2NDIyNDdlOSwgMHg4Y2M0YThmYywgMHgzZjFhYTBmMCwgMHgyY2Q4NTY3ZCwgMHg5MGVmMjIzMywgMHg0ZWM3ODc0OSwgMHhkMWMxZDkzOCwgMHhhMmZlOGNjYSwgMHgwYjM2OThkNCwgMHg4MWNmYTZmNSwgMHhkZTI4YTU3YSwgMHg4ZTI2ZGFiNywgMHhiZmE0M2ZhZCwgMHg5ZGU0MmMzYSwgMHg5MjBkNTA3OCwgMHhjYzliNmE1ZiwgMHg0NjYyNTQ3ZSwgMHgxM2MyZjY4ZCwgMHhiOGU4OTBkOCwgMHhmNzVlMmUzOSwgMHhhZmY1ODJjMywgMHg4MGJlOWY1ZCwgMHg5MzdjNjlkMCwgMHgyZGE5NmZkNSwgMHgxMmIzY2YyNSwgMHg5OTNiYzhhYywgMHg3ZGE3MTAxOCwgMHg2MzZlZTg5YywgMHhiYjdiZGIzYiwgMHg3ODA5Y2QyNiwgMHgxOGY0NmU1OSwgMHhiNzAxZWM5YSwgMHg5YWE4ODM0ZiwgMHg2ZTY1ZTY5NSwgMHhlNjdlYWFmZiwgMHhjZjA4MjFiYywgMHhlOGU2ZWYxNSwgMHg5YmQ5YmFlNywgMHgzNmNlNGE2ZiwgMHgwOWQ0ZWE5ZiwgMHg3Y2Q2MjliMCwgMHhiMmFmMzFhNCwgMHgyMzMxMmEzZiwgMHg5NDMwYzZhNSwgMHg2NmMwMzVhMiwgMHhiYzM3NzQ0ZSwgMHhjYWE2ZmM4MiwgMHhkMGIwZTA5MCwgMHhkODE1MzNhNywgMHg5ODRhZjEwNCwgMHhkYWY3NDFlYywgMHg1MDBlN2ZjZCwgMHhmNjJmMTc5MSwgMHhkNjhkNzY0ZCwgMHhiMDRkNDNlZiwgMHg0ZDU0Y2NhYSwgMHgwNGRmZTQ5NiwgMHhiNWUzOWVkMSwgMHg4ODFiNGM2YSwgMHgxZmI4YzEyYywgMHg1MTdmNDY2NSwgMHhlYTA0OWQ1ZSwgMHgzNTVkMDE4YywgMHg3NDczZmE4NywgMHg0MTJlZmIwYiwgMHgxZDVhYjM2NywgMHhkMjUyOTJkYiwgMHg1NjMzZTkxMCwgMHg0NzEzNmRkNiwgMHg2MThjOWFkNywgMHgwYzdhMzdhMSwgMHgxNDhlNTlmOCwgMHgzYzg5ZWIxMywgMHgyN2VlY2VhOSwgMHhjOTM1Yjc2MSwgMHhlNWVkZTExYywgMHhiMTNjN2E0NywgMHhkZjU5OWNkMiwgMHg3MzNmNTVmMiwgMHhjZTc5MTgxNCwgMHgzN2JmNzNjNywgMHhjZGVhNTNmNywgMHhhYTViNWZmZCwgMHg2ZjE0ZGYzZCwgMHhkYjg2Nzg0NCwgMHhmMzgxY2FhZiwgMHhjNDNlYjk2OCwgMHgzNDJjMzgyNCwgMHg0MDVmYzJhMywgMHhjMzcyMTYxZCwgMHgyNTBjYmNlMiwgMHg0OThiMjgzYywgMHg5NTQxZmYwZCwgMHgwMTcxMzlhOCwgMHhiM2RlMDgwYywgMHhlNDljZDhiNCwgMHhjMTkwNjQ1NiwgMHg4NDYxN2JjYiwgMHhiNjcwZDUzMiwgMHg1Yzc0NDg2YywgMHg1NzQyZDBiOF07XG5cdCAgICB2YXIgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG5cblx0ICAgIC8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvbiBrZXkgZXhwYW5zaW9uXG5cdCAgICB2YXIgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XG5cdCAgICB2YXIgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG5cdCAgICB2YXIgVTMgPSBbMHgwMDAwMDAwMCwgMHgwZDBiMGUwOSwgMHgxYTE2MWMxMiwgMHgxNzFkMTIxYiwgMHgzNDJjMzgyNCwgMHgzOTI3MzYyZCwgMHgyZTNhMjQzNiwgMHgyMzMxMmEzZiwgMHg2ODU4NzA0OCwgMHg2NTUzN2U0MSwgMHg3MjRlNmM1YSwgMHg3ZjQ1NjI1MywgMHg1Yzc0NDg2YywgMHg1MTdmNDY2NSwgMHg0NjYyNTQ3ZSwgMHg0YjY5NWE3NywgMHhkMGIwZTA5MCwgMHhkZGJiZWU5OSwgMHhjYWE2ZmM4MiwgMHhjN2FkZjI4YiwgMHhlNDljZDhiNCwgMHhlOTk3ZDZiZCwgMHhmZThhYzRhNiwgMHhmMzgxY2FhZiwgMHhiOGU4OTBkOCwgMHhiNWUzOWVkMSwgMHhhMmZlOGNjYSwgMHhhZmY1ODJjMywgMHg4Y2M0YThmYywgMHg4MWNmYTZmNSwgMHg5NmQyYjRlZSwgMHg5YmQ5YmFlNywgMHhiYjdiZGIzYiwgMHhiNjcwZDUzMiwgMHhhMTZkYzcyOSwgMHhhYzY2YzkyMCwgMHg4ZjU3ZTMxZiwgMHg4MjVjZWQxNiwgMHg5NTQxZmYwZCwgMHg5ODRhZjEwNCwgMHhkMzIzYWI3MywgMHhkZTI4YTU3YSwgMHhjOTM1Yjc2MSwgMHhjNDNlYjk2OCwgMHhlNzBmOTM1NywgMHhlYTA0OWQ1ZSwgMHhmZDE5OGY0NSwgMHhmMDEyODE0YywgMHg2YmNiM2JhYiwgMHg2NmMwMzVhMiwgMHg3MWRkMjdiOSwgMHg3Y2Q2MjliMCwgMHg1ZmU3MDM4ZiwgMHg1MmVjMGQ4NiwgMHg0NWYxMWY5ZCwgMHg0OGZhMTE5NCwgMHgwMzkzNGJlMywgMHgwZTk4NDVlYSwgMHgxOTg1NTdmMSwgMHgxNDhlNTlmOCwgMHgzN2JmNzNjNywgMHgzYWI0N2RjZSwgMHgyZGE5NmZkNSwgMHgyMGEyNjFkYywgMHg2ZGY2YWQ3NiwgMHg2MGZkYTM3ZiwgMHg3N2UwYjE2NCwgMHg3YWViYmY2ZCwgMHg1OWRhOTU1MiwgMHg1NGQxOWI1YiwgMHg0M2NjODk0MCwgMHg0ZWM3ODc0OSwgMHgwNWFlZGQzZSwgMHgwOGE1ZDMzNywgMHgxZmI4YzEyYywgMHgxMmIzY2YyNSwgMHgzMTgyZTUxYSwgMHgzYzg5ZWIxMywgMHgyYjk0ZjkwOCwgMHgyNjlmZjcwMSwgMHhiZDQ2NGRlNiwgMHhiMDRkNDNlZiwgMHhhNzUwNTFmNCwgMHhhYTViNWZmZCwgMHg4OTZhNzVjMiwgMHg4NDYxN2JjYiwgMHg5MzdjNjlkMCwgMHg5ZTc3NjdkOSwgMHhkNTFlM2RhZSwgMHhkODE1MzNhNywgMHhjZjA4MjFiYywgMHhjMjAzMmZiNSwgMHhlMTMyMDU4YSwgMHhlYzM5MGI4MywgMHhmYjI0MTk5OCwgMHhmNjJmMTc5MSwgMHhkNjhkNzY0ZCwgMHhkYjg2Nzg0NCwgMHhjYzliNmE1ZiwgMHhjMTkwNjQ1NiwgMHhlMmExNGU2OSwgMHhlZmFhNDA2MCwgMHhmOGI3NTI3YiwgMHhmNWJjNWM3MiwgMHhiZWQ1MDYwNSwgMHhiM2RlMDgwYywgMHhhNGMzMWExNywgMHhhOWM4MTQxZSwgMHg4YWY5M2UyMSwgMHg4N2YyMzAyOCwgMHg5MGVmMjIzMywgMHg5ZGU0MmMzYSwgMHgwNjNkOTZkZCwgMHgwYjM2OThkNCwgMHgxYzJiOGFjZiwgMHgxMTIwODRjNiwgMHgzMjExYWVmOSwgMHgzZjFhYTBmMCwgMHgyODA3YjJlYiwgMHgyNTBjYmNlMiwgMHg2ZTY1ZTY5NSwgMHg2MzZlZTg5YywgMHg3NDczZmE4NywgMHg3OTc4ZjQ4ZSwgMHg1YTQ5ZGViMSwgMHg1NzQyZDBiOCwgMHg0MDVmYzJhMywgMHg0ZDU0Y2NhYSwgMHhkYWY3NDFlYywgMHhkN2ZjNGZlNSwgMHhjMGUxNWRmZSwgMHhjZGVhNTNmNywgMHhlZWRiNzljOCwgMHhlM2QwNzdjMSwgMHhmNGNkNjVkYSwgMHhmOWM2NmJkMywgMHhiMmFmMzFhNCwgMHhiZmE0M2ZhZCwgMHhhOGI5MmRiNiwgMHhhNWIyMjNiZiwgMHg4NjgzMDk4MCwgMHg4Yjg4MDc4OSwgMHg5Yzk1MTU5MiwgMHg5MTllMWI5YiwgMHgwYTQ3YTE3YywgMHgwNzRjYWY3NSwgMHgxMDUxYmQ2ZSwgMHgxZDVhYjM2NywgMHgzZTZiOTk1OCwgMHgzMzYwOTc1MSwgMHgyNDdkODU0YSwgMHgyOTc2OGI0MywgMHg2MjFmZDEzNCwgMHg2ZjE0ZGYzZCwgMHg3ODA5Y2QyNiwgMHg3NTAyYzMyZiwgMHg1NjMzZTkxMCwgMHg1YjM4ZTcxOSwgMHg0YzI1ZjUwMiwgMHg0MTJlZmIwYiwgMHg2MThjOWFkNywgMHg2Yzg3OTRkZSwgMHg3YjlhODZjNSwgMHg3NjkxODhjYywgMHg1NWEwYTJmMywgMHg1OGFiYWNmYSwgMHg0ZmI2YmVlMSwgMHg0MmJkYjBlOCwgMHgwOWQ0ZWE5ZiwgMHgwNGRmZTQ5NiwgMHgxM2MyZjY4ZCwgMHgxZWM5Zjg4NCwgMHgzZGY4ZDJiYiwgMHgzMGYzZGNiMiwgMHgyN2VlY2VhOSwgMHgyYWU1YzBhMCwgMHhiMTNjN2E0NywgMHhiYzM3NzQ0ZSwgMHhhYjJhNjY1NSwgMHhhNjIxNjg1YywgMHg4NTEwNDI2MywgMHg4ODFiNGM2YSwgMHg5ZjA2NWU3MSwgMHg5MjBkNTA3OCwgMHhkOTY0MGEwZiwgMHhkNDZmMDQwNiwgMHhjMzcyMTYxZCwgMHhjZTc5MTgxNCwgMHhlZDQ4MzIyYiwgMHhlMDQzM2MyMiwgMHhmNzVlMmUzOSwgMHhmYTU1MjAzMCwgMHhiNzAxZWM5YSwgMHhiYTBhZTI5MywgMHhhZDE3ZjA4OCwgMHhhMDFjZmU4MSwgMHg4MzJkZDRiZSwgMHg4ZTI2ZGFiNywgMHg5OTNiYzhhYywgMHg5NDMwYzZhNSwgMHhkZjU5OWNkMiwgMHhkMjUyOTJkYiwgMHhjNTRmODBjMCwgMHhjODQ0OGVjOSwgMHhlYjc1YTRmNiwgMHhlNjdlYWFmZiwgMHhmMTYzYjhlNCwgMHhmYzY4YjZlZCwgMHg2N2IxMGMwYSwgMHg2YWJhMDIwMywgMHg3ZGE3MTAxOCwgMHg3MGFjMWUxMSwgMHg1MzlkMzQyZSwgMHg1ZTk2M2EyNywgMHg0OThiMjgzYywgMHg0NDgwMjYzNSwgMHgwZmU5N2M0MiwgMHgwMmUyNzI0YiwgMHgxNWZmNjA1MCwgMHgxOGY0NmU1OSwgMHgzYmM1NDQ2NiwgMHgzNmNlNGE2ZiwgMHgyMWQzNTg3NCwgMHgyY2Q4NTY3ZCwgMHgwYzdhMzdhMSwgMHgwMTcxMzlhOCwgMHgxNjZjMmJiMywgMHgxYjY3MjViYSwgMHgzODU2MGY4NSwgMHgzNTVkMDE4YywgMHgyMjQwMTM5NywgMHgyZjRiMWQ5ZSwgMHg2NDIyNDdlOSwgMHg2OTI5NDllMCwgMHg3ZTM0NWJmYiwgMHg3MzNmNTVmMiwgMHg1MDBlN2ZjZCwgMHg1ZDA1NzFjNCwgMHg0YTE4NjNkZiwgMHg0NzEzNmRkNiwgMHhkY2NhZDczMSwgMHhkMWMxZDkzOCwgMHhjNmRjY2IyMywgMHhjYmQ3YzUyYSwgMHhlOGU2ZWYxNSwgMHhlNWVkZTExYywgMHhmMmYwZjMwNywgMHhmZmZiZmQwZSwgMHhiNDkyYTc3OSwgMHhiOTk5YTk3MCwgMHhhZTg0YmI2YiwgMHhhMzhmYjU2MiwgMHg4MGJlOWY1ZCwgMHg4ZGI1OTE1NCwgMHg5YWE4ODM0ZiwgMHg5N2EzOGQ0Nl07XG5cdCAgICB2YXIgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XG5cblx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goXG5cdCAgICAgICAgICAgICAgICAoYnl0ZXNbaSAgICBdIDw8IDI0KSB8XG5cdCAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSB8XG5cdCAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8ICA4KSB8XG5cdCAgICAgICAgICAgICAgICAgYnl0ZXNbaSArIDNdXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBBRVMgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQUVTKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2tleScsIHtcblx0ICAgICAgICAgICAgdmFsdWU6IGNvZXJjZUFycmF5KGtleSwgdHJ1ZSlcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHRoaXMuX3ByZXBhcmUoKTtcblx0ICAgIH07XG5cblxuXHQgICAgQUVTLnByb3RvdHlwZS5fcHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdCAgICAgICAgdmFyIHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG5cdCAgICAgICAgaWYgKHJvdW5kcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG5cdCAgICAgICAgdGhpcy5fS2UgPSBbXTtcblxuXHQgICAgICAgIC8vIGRlY3J5cHRpb24gcm91bmQga2V5c1xuXHQgICAgICAgIHRoaXMuX0tkID0gW107XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSByb3VuZHM7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9LZS5wdXNoKFswLCAwLCAwLCAwXSk7XG5cdCAgICAgICAgICAgIHRoaXMuX0tkLnB1c2goWzAsIDAsIDAsIDBdKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcm91bmRLZXlDb3VudCA9IChyb3VuZHMgKyAxKSAqIDQ7XG5cdCAgICAgICAgdmFyIEtDID0gdGhpcy5rZXkubGVuZ3RoIC8gNDtcblxuXHQgICAgICAgIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIGludHNcblx0ICAgICAgICB2YXIgdGsgPSBjb252ZXJ0VG9JbnQzMih0aGlzLmtleSk7XG5cblx0ICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcblx0ICAgICAgICB2YXIgaW5kZXg7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBLQzsgaSsrKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuXHQgICAgICAgICAgICB0aGlzLl9LZVtpbmRleF1baSAlIDRdID0gdGtbaV07XG5cdCAgICAgICAgICAgIHRoaXMuX0tkW3JvdW5kcyAtIGluZGV4XVtpICUgNF0gPSB0a1tpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmaXBzLTE5NyBzZWN0aW9uIDUuMilcblx0ICAgICAgICB2YXIgcmNvbnBvaW50ZXIgPSAwO1xuXHQgICAgICAgIHZhciB0ID0gS0MsIHR0O1xuXHQgICAgICAgIHdoaWxlICh0IDwgcm91bmRLZXlDb3VudCkge1xuXHQgICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG5cdCAgICAgICAgICAgIHRrWzBdIF49ICgoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMjQpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAgOCkgJiAweEZGXSA8PCAxNikgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgKFNbIHR0ICAgICAgICAmIDB4RkZdIDw8ICA4KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgU1sodHQgPj4gMjQpICYgMHhGRl0gICAgICAgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgIChyY29uW3Jjb25wb2ludGVyXSA8PCAyNCkpO1xuXHQgICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuXG5cdCAgICAgICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZvciBub24tMjU2IGJpdClcblx0ICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRrW2ldIF49IHRrW2kgLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG5cblx0ICAgICAgICAgICAgICAgIHRrW0tDIC8gMl0gXj0gKFNbIHR0ICAgICAgICAmIDB4RkZdICAgICAgICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAgOCkgJiAweEZGXSA8PCAgOCkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAoS0MgLyAyKSArIDE7IGkgPCBLQzsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG5cdCAgICAgICAgICAgIHZhciBpID0gMCwgciwgYztcblx0ICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuXHQgICAgICAgICAgICAgICAgciA9IHQgPj4gMjtcblx0ICAgICAgICAgICAgICAgIGMgPSB0ICUgNDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX0tlW3JdW2NdID0gdGtbaV07XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9LZFtyb3VuZHMgLSByXVtjXSA9IHRrW2krK107XG5cdCAgICAgICAgICAgICAgICB0Kys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcblx0ICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgNDsgYysrKSB7XG5cdCAgICAgICAgICAgICAgICB0dCA9IHRoaXMuX0tkW3JdW2NdO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fS2Rbcl1bY10gPSAoVTFbKHR0ID4+IDI0KSAmIDB4RkZdIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVM1sodHQgPj4gIDgpICYgMHhGRl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTRbIHR0ICAgICAgICAmIDB4RkZdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIEFFUy5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcm91bmRzID0gdGhpcy5fS2UubGVuZ3RoIC0gMTtcblx0ICAgICAgICB2YXIgYSA9IFswLCAwLCAwLCAwXTtcblxuXHQgICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuXHQgICAgICAgIHZhciB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0W2ldIF49IHRoaXMuX0tlWzBdW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcblx0ICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhW2ldID0gKFQxWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQyWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQzWyh0WyhpICsgMikgJSA0XSA+PiAgOCkgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQ0WyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0tlW3JdW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkoMTYpLCB0dDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0dCA9IHRoaXMuX0tlW3JvdW5kc11baV07XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSAgICBdID0gKFNbKHRbIGkgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAxXSA9IChTWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXiAodHQgPj4gIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNbIHRbKGkgKyAzKSAlIDRdICAgICAgICAmIDB4ZmZdIF4gIHR0ICAgICAgICkgJiAweGZmO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXG5cdCAgICBBRVMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kcyA9IHRoaXMuX0tkLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgdmFyIGEgPSBbMCwgMCwgMCwgMF07XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcblx0ICAgICAgICB2YXIgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRbaV0gXj0gdGhpcy5fS2RbMF1baV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuXHQgICAgICAgIGZvciAodmFyIHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGFbaV0gPSAoVDVbKHRbIGkgICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiAgOCkgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFQ4WyB0WyhpICsgMSkgJSA0XSAgICAgICAgJiAweGZmXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkoMTYpLCB0dDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0dCA9IHRoaXMuX0tkW3JvdW5kc11baV07XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSAgICBdID0gKFNpWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeICh0dCA+PiAyNCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTaVsodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXiAodHQgPj4gIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpWyB0WyhpICsgMSkgJSA0XSAgICAgICAgJiAweGZmXSBeICB0dCAgICAgICApICYgMHhmZjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIEVsZWN0b25pYyBDb2RlYm9vayAoRUNCKVxuXHQgICAgICovXG5cdCAgICB2YXIgTW9kZU9mT3BlcmF0aW9uRUNCID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkVDQikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiRWxlY3Ryb25pYyBDb2RlIEJsb2NrXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJlY2JcIjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkVDQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHBsYWludGV4dCA9IGNvZXJjZUFycmF5KHBsYWludGV4dCk7XG5cblx0ICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY3JlYXRlQXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShwbGFpbnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXHQgICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcblx0ICAgICAgICAgICAgY29weUFycmF5KGJsb2NrLCBjaXBoZXJ0ZXh0LCBpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkVDQi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcblx0ICAgICAgICBjaXBoZXJ0ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICBpZiAoKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHBsYWludGV4dCA9IGNyZWF0ZUFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcblx0ICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9hZXMuZGVjcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgcGxhaW50ZXh0LCBpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgfTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBCbG9jayBDaGFpbmluZyAoQ0JDKVxuXHQgICAgICovXG5cdCAgICB2YXIgTW9kZU9mT3BlcmF0aW9uQ0JDID0gZnVuY3Rpb24oa2V5LCBpdikge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DQkMpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkNpcGhlciBCbG9jayBDaGFpbmluZ1wiO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwiY2JjXCI7XG5cblx0ICAgICAgICBpZiAoIWl2KSB7XG5cdCAgICAgICAgICAgIGl2ID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgfSBlbHNlIGlmIChpdi5sZW5ndGggIT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9sYXN0Q2lwaGVyYmxvY2sgPSBjb2VyY2VBcnJheShpdiwgdHJ1ZSk7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChwbGFpbnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkocGxhaW50ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrW2pdIF49IHRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuX2xhc3RDaXBoZXJibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcblx0ICAgICAgICAgICAgY29weUFycmF5KHRoaXMuX2xhc3RDaXBoZXJibG9jaywgY2lwaGVydGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgY2lwaGVydGV4dCA9IGNvZXJjZUFycmF5KGNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuXHQgICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gdGhpcy5fbGFzdENpcGhlcmJsb2NrW2pdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY29weUFycmF5KGNpcGhlcnRleHQsIHRoaXMuX2xhc3RDaXBoZXJibG9jaywgMCwgaSwgaSArIDE2KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgfTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBGZWVkYmFjayAoQ0ZCKVxuXHQgICAgICovXG5cdCAgICB2YXIgTW9kZU9mT3BlcmF0aW9uQ0ZCID0gZnVuY3Rpb24oa2V5LCBpdiwgc2VnbWVudFNpemUpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0ZCKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgRmVlZGJhY2tcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcImNmYlwiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgc2l6ZSknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXNlZ21lbnRTaXplKSB7IHNlZ21lbnRTaXplID0gMTsgfVxuXG5cdCAgICAgICAgdGhpcy5zZWdtZW50U2l6ZSA9IHNlZ21lbnRTaXplO1xuXG5cdCAgICAgICAgdGhpcy5fc2hpZnRSZWdpc3RlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIHNlZ21lbnRTaXplIGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgdmFyIHhvclNlZ21lbnQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpICs9IHRoaXMuc2VnbWVudFNpemUpIHtcblx0ICAgICAgICAgICAgeG9yU2VnbWVudCA9IHRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc2VnbWVudFNpemU7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZW5jcnlwdGVkW2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXG5cdCAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9zaGlmdFJlZ2lzdGVyLCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAwLCB0aGlzLnNlZ21lbnRTaXplKTtcblx0ICAgICAgICAgICAgY29weUFycmF5KGVuY3J5cHRlZCwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMTYgLSB0aGlzLnNlZ21lbnRTaXplLCBpLCBpICsgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcblx0ICAgICAgICBpZiAoKGNpcGhlcnRleHQubGVuZ3RoICUgdGhpcy5zZWdtZW50U2l6ZSkgIT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIHNlZ21lbnRTaXplIGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0LCB0cnVlKTtcblxuXHQgICAgICAgIHZhciB4b3JTZWdtZW50O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgICAgIHhvclNlZ21lbnQgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc2VnbWVudFNpemU7IGorKykge1xuXHQgICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXG5cdCAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9zaGlmdFJlZ2lzdGVyLCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAwLCB0aGlzLnNlZ21lbnRTaXplKTtcblx0ICAgICAgICAgICAgY29weUFycmF5KGNpcGhlcnRleHQsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDE2IC0gdGhpcy5zZWdtZW50U2l6ZSwgaSwgaSArIHRoaXMuc2VnbWVudFNpemUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIE91dHB1dCBGZWVkYmFjayAoT0ZCKVxuXHQgICAgICovXG5cdCAgICB2YXIgTW9kZU9mT3BlcmF0aW9uT0ZCID0gZnVuY3Rpb24oa2V5LCBpdikge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25PRkIpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIk91dHB1dCBGZWVkYmFja1wiO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwib2ZiXCI7XG5cblx0ICAgICAgICBpZiAoIWl2KSB7XG5cdCAgICAgICAgICAgIGl2ID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgfSBlbHNlIGlmIChpdi5sZW5ndGggIT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVyID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXHQgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9IDE2O1xuXG5cdCAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgdmFyIGVuY3J5cHRlZCA9IGNvZXJjZUFycmF5KHBsYWludGV4dCwgdHJ1ZSk7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbGFzdFByZWNpcGhlckluZGV4ID09PSAxNikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFByZWNpcGhlciA9IHRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX2xhc3RQcmVjaXBoZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFByZWNpcGhlckluZGV4ID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbmNyeXB0ZWRbaV0gXj0gdGhpcy5fbGFzdFByZWNpcGhlclt0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXgrK107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcblx0ICAgIH07XG5cblx0ICAgIC8vIERlY3J5cHRpb24gaXMgc3ltZXRyaWNcblx0ICAgIE1vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZGVjcnlwdCA9IE1vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZW5jcnlwdDtcblxuXG5cdCAgICAvKipcblx0ICAgICAqICBDb3VudGVyIG9iamVjdCBmb3IgQ1RSIGNvbW1vbiBtb2RlIG9mIG9wZXJhdGlvblxuXHQgICAgICovXG5cdCAgICB2YXIgQ291bnRlciA9IGZ1bmN0aW9uKGluaXRpYWxWYWx1ZSkge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb3VudGVyKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQ291bnRlciBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2UgYWxsb3cgMCwgYnV0IGFueXRoaW5nIGZhbHNlLWlzaCB1c2VzIHRoZSBkZWZhdWx0IDFcblx0ICAgICAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSAwICYmICFpbml0aWFsVmFsdWUpIHsgaW5pdGlhbFZhbHVlID0gMTsgfVxuXG5cdCAgICAgICAgaWYgKHR5cGVvZihpbml0aWFsVmFsdWUpID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICB0aGlzLl9jb3VudGVyID0gY3JlYXRlQXJyYXkoMTYpO1xuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlKGluaXRpYWxWYWx1ZSk7XG5cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnNldEJ5dGVzKGluaXRpYWxWYWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgQ291bnRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSAnbnVtYmVyJyB8fCBwYXJzZUludCh2YWx1ZSkgIT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvdW50ZXIgdmFsdWUgKG11c3QgYmUgYW4gaW50ZWdlciknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE1OyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvdW50ZXJbaW5kZXhdID0gdmFsdWUgJSAyNTY7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gODtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBDb3VudGVyLnByb3RvdHlwZS5zZXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG5cdCAgICAgICAgYnl0ZXMgPSBjb2VyY2VBcnJheShieXRlcywgdHJ1ZSk7XG5cblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb3VudGVyIGJ5dGVzIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fY291bnRlciA9IGJ5dGVzO1xuXHQgICAgfTtcblxuXHQgICAgQ291bnRlci5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE1OyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcltpXSA9PT0gMjU1KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldID0gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ZXJbaV0rKztcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENvdW50ZXIgKENUUilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNUUiA9IGZ1bmN0aW9uKGtleSwgY291bnRlcikge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DVFIpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkNvdW50ZXJcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcImN0clwiO1xuXG5cdCAgICAgICAgaWYgKCEoY291bnRlciBpbnN0YW5jZW9mIENvdW50ZXIpKSB7XG5cdCAgICAgICAgICAgIGNvdW50ZXIgPSBuZXcgQ291bnRlcihjb3VudGVyKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9jb3VudGVyID0gY291bnRlcjtcblxuXHQgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9IDE2O1xuXG5cdCAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgdmFyIGVuY3J5cHRlZCA9IGNvZXJjZUFycmF5KHBsYWludGV4dCwgdHJ1ZSk7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4ID09PSAxNikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVtYWluaW5nQ291bnRlciA9IHRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX2NvdW50ZXIuX2NvdW50ZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4ID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ZXIuaW5jcmVtZW50KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJbdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4KytdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFBhZGRpbmdcblxuXHQgICAgLy8gU2VlOmh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzE1XG5cdCAgICBmdW5jdGlvbiBwa2NzN3BhZChkYXRhKSB7XG5cdCAgICAgICAgZGF0YSA9IGNvZXJjZUFycmF5KGRhdGEsIHRydWUpO1xuXHQgICAgICAgIHZhciBwYWRkZXIgPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkoZGF0YS5sZW5ndGggKyBwYWRkZXIpO1xuXHQgICAgICAgIGNvcHlBcnJheShkYXRhLCByZXN1bHQpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICByZXN1bHRbaV0gPSBwYWRkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHBrY3M3c3RyaXAoZGF0YSkge1xuXHQgICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcblx0ICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAxNikgeyB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIGxlbmd0aCcpOyB9XG5cblx0ICAgICAgICB2YXIgcGFkZGVyID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgIGlmIChwYWRkZXIgPiAxNikgeyB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7IH1cblxuXHQgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIHBhZGRlcjtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRlcjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkobGVuZ3RoKTtcblx0ICAgICAgICBjb3B5QXJyYXkoZGF0YSwgcmVzdWx0LCAwLCAwLCBsZW5ndGgpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBFeHBvcnRpbmdcblxuXG5cdCAgICAvLyBUaGUgYmxvY2sgY2lwaGVyXG5cdCAgICB2YXIgYWVzanMgPSB7XG5cdCAgICAgICAgQUVTOiBBRVMsXG5cdCAgICAgICAgQ291bnRlcjogQ291bnRlcixcblxuXHQgICAgICAgIE1vZGVPZk9wZXJhdGlvbjoge1xuXHQgICAgICAgICAgICBlY2I6IE1vZGVPZk9wZXJhdGlvbkVDQixcblx0ICAgICAgICAgICAgY2JjOiBNb2RlT2ZPcGVyYXRpb25DQkMsXG5cdCAgICAgICAgICAgIGNmYjogTW9kZU9mT3BlcmF0aW9uQ0ZCLFxuXHQgICAgICAgICAgICBvZmI6IE1vZGVPZk9wZXJhdGlvbk9GQixcblx0ICAgICAgICAgICAgY3RyOiBNb2RlT2ZPcGVyYXRpb25DVFJcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdXRpbHM6IHtcblx0ICAgICAgICAgICAgaGV4OiBjb252ZXJ0SGV4LFxuXHQgICAgICAgICAgICB1dGY4OiBjb252ZXJ0VXRmOFxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwYWRkaW5nOiB7XG5cdCAgICAgICAgICAgIHBrY3M3OiB7XG5cdCAgICAgICAgICAgICAgICBwYWQ6IHBrY3M3cGFkLFxuXHQgICAgICAgICAgICAgICAgc3RyaXA6IHBrY3M3c3RyaXBcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfYXJyYXlUZXN0OiB7XG5cdCAgICAgICAgICAgIGNvZXJjZUFycmF5OiBjb2VyY2VBcnJheSxcblx0ICAgICAgICAgICAgY3JlYXRlQXJyYXk6IGNyZWF0ZUFycmF5LFxuXHQgICAgICAgICAgICBjb3B5QXJyYXk6IGNvcHlBcnJheSxcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cblx0ICAgIC8vIG5vZGUuanNcblx0ICAgIGlmICgnb2JqZWN0JyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFlc2pzO1xuXG5cdCAgICAvLyBSZXF1aXJlSlMvQU1EXG5cdCAgICAvLyBodHRwOi8vd3d3LnJlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbFxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRFxuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YodW5kZWZpbmVkKSA9PT0gJ2Z1bmN0aW9uJyAmJiB1bmRlZmluZWQuYW1kKSB7XG5cdCAgICAgICAgdW5kZWZpbmVkKGFlc2pzKTtcblxuXHQgICAgLy8gV2ViIEJyb3dzZXJzXG5cdCAgICB9IGVsc2Uge1xuXG5cdCAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGxpYnJhcnkgYXQgXCJhZXNqc1wiIG1ha2Ugc3VyZSBpdCdzIHN0aWxsIGF2YWlsYWJsZVxuXHQgICAgICAgIGlmIChyb290LmFlc2pzKSB7XG5cdCAgICAgICAgICAgIGFlc2pzLl9hZXNqcyA9IHJvb3QuYWVzanM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcm9vdC5hZXNqcyA9IGFlc2pzO1xuXHQgICAgfVxuXG5cblx0fSkoY29tbW9uanNHbG9iYWwpO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kQSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJqc29uLXdhbGxldHMvNS4wLjAtYmV0YS4xNDBcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEIgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEEpO1xuXHR2YXIgX3ZlcnNpb25fMSRpID0gX3ZlcnNpb24kQS52ZXJzaW9uO1xuXG5cdHZhciB1dGlscyQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0ZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09ICdzdHJpbmcnICYmIGhleFN0cmluZy5zdWJzdHJpbmcoMCwgMikgIT09ICcweCcpIHtcblx0ICAgICAgICBoZXhTdHJpbmcgPSAnMHgnICsgaGV4U3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGhleFN0cmluZyk7XG5cdH1cblx0ZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gbG9vc2VBcnJheWlmeTtcblx0ZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLnpwYWQgPSB6cGFkO1xuXHRmdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHQgICAgaWYgKHR5cGVvZiAocGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhCeXRlcyhwYXNzd29yZCwgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHBhc3N3b3JkKTtcblx0fVxuXHRleHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5cdGZ1bmN0aW9uIHNlYXJjaFBhdGgob2JqZWN0LCBwYXRoKSB7XG5cdCAgICB2YXIgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXHQgICAgdmFyIGNvbXBzID0gcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcblx0ICAgICAgICB2YXIgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXBzW2ldKSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEaWRuJ3QgZmluZCBvbmUuIDonKFxuXHQgICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3cgY2hlY2sgdGhpcyBjaGlsZC4uLlxuXHQgICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3VycmVudENoaWxkO1xuXHR9XG5cdGV4cG9ydHMuc2VhcmNoUGF0aCA9IHNlYXJjaFBhdGg7XG5cdH0pO1xuXG5cdHZhciB1dGlscyQyID0gdW53cmFwRXhwb3J0cyh1dGlscyQxKTtcblx0dmFyIHV0aWxzXzEkMiA9IHV0aWxzJDEubG9vc2VBcnJheWlmeTtcblx0dmFyIHV0aWxzXzIgPSB1dGlscyQxLnpwYWQ7XG5cdHZhciB1dGlsc18zID0gdXRpbHMkMS5nZXRQYXNzd29yZDtcblx0dmFyIHV0aWxzXzQgPSB1dGlscyQxLnNlYXJjaFBhdGg7XG5cblx0dmFyIGNyb3dkc2FsZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgYWVzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQoYWVzSnMpO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEEudmVyc2lvbik7XG5cblx0dmFyIENyb3dkc2FsZUFjY291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQ3Jvd2RzYWxlQWNjb3VudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIENyb3dkc2FsZUFjY291bnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ3Jvd2RzYWxlQWNjb3VudC5wcm90b3R5cGUuaXNDcm93ZHNhbGVBY2NvdW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0Nyb3dkc2FsZUFjY291bnQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDcm93ZHNhbGVBY2NvdW50O1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuQ3Jvd2RzYWxlQWNjb3VudCA9IENyb3dkc2FsZUFjY291bnQ7XG5cdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2xcblx0ZnVuY3Rpb24gZGVjcnlwdChqc29uLCBwYXNzd29yZCkge1xuXHQgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgcGFzc3dvcmQgPSB1dGlscyQxLmdldFBhc3N3b3JkKHBhc3N3b3JkKTtcblx0ICAgIC8vIEV0aGVyZXVtIEFkZHJlc3Ncblx0ICAgIHZhciBldGhhZGRyID0gbGliJDYuZ2V0QWRkcmVzcyh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJldGhhZGRyXCIpKTtcblx0ICAgIC8vIEVuY3J5cHRlZCBTZWVkXG5cdCAgICB2YXIgZW5jc2VlZCA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJlbmNzZWVkXCIpKTtcblx0ICAgIGlmICghZW5jc2VlZCB8fCAoZW5jc2VlZC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcblx0ICAgIH1cblx0ICAgIHZhciBrZXkgPSBsaWIkMS5hcnJheWlmeShicm93c2VyJDIucGJrZGYyKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsIFwic2hhMjU2XCIpKS5zbGljZSgwLCAxNik7XG5cdCAgICB2YXIgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcblx0ICAgIHZhciBlbmNyeXB0ZWRTZWVkID0gZW5jc2VlZC5zbGljZSgxNik7XG5cdCAgICAvLyBEZWNyeXB0IHRoZSBzZWVkXG5cdCAgICB2YXIgYWVzQ2JjID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcblx0ICAgIHZhciBzZWVkID0gYWVzX2pzXzEuZGVmYXVsdC5wYWRkaW5nLnBrY3M3LnN0cmlwKGxpYiQxLmFycmF5aWZ5KGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG5cdCAgICAvLyBUaGlzIHdhbGxldCBmb3JtYXQgaXMgd2VpcmQuLi4gQ29udmVydCB0aGUgYmluYXJ5IGVuY29kZWQgaGV4IHRvIGEgc3RyaW5nLlxuXHQgICAgdmFyIHNlZWRIZXggPSBcIlwiO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgc2VlZEhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlZWRbaV0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHNlZWRIZXhCeXRlcyA9IGxpYiQ4LnRvVXRmOEJ5dGVzKHNlZWRIZXgpO1xuXHQgICAgdmFyIHByaXZhdGVLZXkgPSBsaWIkNC5rZWNjYWsyNTYoc2VlZEhleEJ5dGVzKTtcblx0ICAgIHJldHVybiBuZXcgQ3Jvd2RzYWxlQWNjb3VudCh7XG5cdCAgICAgICAgX2lzQ3Jvd2RzYWxlQWNjb3VudDogdHJ1ZSxcblx0ICAgICAgICBhZGRyZXNzOiBldGhhZGRyLFxuXHQgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG5cdH0pO1xuXG5cdHZhciBjcm93ZHNhbGUkMSA9IHVud3JhcEV4cG9ydHMoY3Jvd2RzYWxlKTtcblx0dmFyIGNyb3dkc2FsZV8xID0gY3Jvd2RzYWxlLkNyb3dkc2FsZUFjY291bnQ7XG5cdHZhciBjcm93ZHNhbGVfMiA9IGNyb3dkc2FsZS5kZWNyeXB0O1xuXG5cdHZhciBpbnNwZWN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pIHtcblx0ICAgIHZhciBkYXRhID0gbnVsbDtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEuZW5jc2VlZCAmJiBkYXRhLmV0aGFkZHIpO1xuXHR9XG5cdGV4cG9ydHMuaXNDcm93ZHNhbGVXYWxsZXQgPSBpc0Nyb3dkc2FsZVdhbGxldDtcblx0ZnVuY3Rpb24gaXNLZXlzdG9yZVdhbGxldChqc29uKSB7XG5cdCAgICB2YXIgZGF0YSA9IG51bGw7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSAhPT0gZGF0YS52ZXJzaW9uIHx8IHBhcnNlSW50KGRhdGEudmVyc2lvbikgIT09IDMpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogUHV0IG1vcmUgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCBoYXMga2RmLCBpdiBhbmQgYWxsIHRoYXQgZ29vZCBzdHVmZlxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0tleXN0b3JlV2FsbGV0ID0gaXNLZXlzdG9yZVdhbGxldDtcblx0Ly9leHBvcnQgZnVuY3Rpb24gaXNKc29uV2FsbGV0KGpzb246IHN0cmluZyk6IGJvb2xlYW4ge1xuXHQvLyAgICByZXR1cm4gKGlzU2VjcmV0U3RvcmFnZVdhbGxldChqc29uKSB8fCBpc0Nyb3dkc2FsZVdhbGxldChqc29uKSk7XG5cdC8vfVxuXHRmdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKSB7XG5cdCAgICBpZiAoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmV0aGFkZHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGdldEpzb25XYWxsZXRBZGRyZXNzO1xuXHR9KTtcblxuXHR2YXIgaW5zcGVjdCQxID0gdW53cmFwRXhwb3J0cyhpbnNwZWN0KTtcblx0dmFyIGluc3BlY3RfMSA9IGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQ7XG5cdHZhciBpbnNwZWN0XzIgPSBpbnNwZWN0LmlzS2V5c3RvcmVXYWxsZXQ7XG5cdHZhciBpbnNwZWN0XzMgPSBpbnNwZWN0LmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXG5cdHZhciBzY3J5cHQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdChmdW5jdGlvbihyb290KSB7XG5cdCAgICBjb25zdCBNQVhfVkFMVUUgPSAweDdmZmZmZmZmO1xuXG5cdCAgICAvLyBUaGUgU0hBMjU2IGFuZCBQQktERjIgaW1wbGVtZW50YXRpb24gYXJlIGZyb20gc2NyeXB0LWFzeW5jLWpzOlxuXHQgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNoZXN0L3NjcnlwdC1hc3luYy1qc1xuXHQgICAgZnVuY3Rpb24gU0hBMjU2KG0pIHtcblx0ICAgICAgICBjb25zdCBLID0gbmV3IFVpbnQzMkFycmF5KFtcblx0ICAgICAgICAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLFxuXHQgICAgICAgICAgIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsXG5cdCAgICAgICAgICAgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNyxcblx0ICAgICAgICAgICAweGMxOWJmMTc0LCAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuXHQgICAgICAgICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsIDB4OTgzZTUxNTIsXG5cdCAgICAgICAgICAgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0Nyxcblx0ICAgICAgICAgICAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LCAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLFxuXHQgICAgICAgICAgIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG5cdCAgICAgICAgICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSxcblx0ICAgICAgICAgICAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLCAweDE5YTRjMTE2LCAweDFlMzc2YzA4LFxuXHQgICAgICAgICAgIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsXG5cdCAgICAgICAgICAgMHg2ODJlNmZmMywgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcblx0ICAgICAgICAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5cdCAgICAgICBdKTtcblxuXHQgICAgICAgIGxldCBoMCA9IDB4NmEwOWU2NjcsIGgxID0gMHhiYjY3YWU4NSwgaDIgPSAweDNjNmVmMzcyLCBoMyA9IDB4YTU0ZmY1M2E7XG5cdCAgICAgICAgbGV0IGg0ID0gMHg1MTBlNTI3ZiwgaDUgPSAweDliMDU2ODhjLCBoNiA9IDB4MWY4M2Q5YWIsIGg3ID0gMHg1YmUwY2QxOTtcblx0ICAgICAgICBjb25zdCB3ID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIGJsb2NrcyhwKSB7XG5cdCAgICAgICAgICAgIGxldCBvZmYgPSAwLCBsZW4gPSBwLmxlbmd0aDtcblx0ICAgICAgICAgICAgd2hpbGUgKGxlbiA+PSA2NCkge1xuXHQgICAgICAgICAgICAgICAgbGV0IGEgPSBoMCwgYiA9IGgxLCBjID0gaDIsIGQgPSBoMywgZSA9IGg0LCBmID0gaDUsIGcgPSBoNiwgaCA9IGg3LCB1LCBpLCBqLCB0MSwgdDI7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaiA9IG9mZiArIGkqNDtcblx0ICAgICAgICAgICAgICAgICAgICB3W2ldID0gKChwW2pdICYgMHhmZik8PDI0KSB8ICgocFtqKzFdICYgMHhmZik8PDE2KSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKChwW2orMl0gJiAweGZmKTw8OCkgfCAocFtqKzNdICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHUgPSB3W2ktMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdDEgPSAoKHU+Pj4xNykgfCAodTw8KDMyLTE3KSkpIF4gKCh1Pj4+MTkpIHwgKHU8PCgzMi0xOSkpKSBeICh1Pj4+MTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdSA9IHdbaS0xNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdDIgPSAoKHU+Pj43KSB8ICh1PDwoMzItNykpKSBeICgodT4+PjE4KSB8ICh1PDwoMzItMTgpKSkgXiAodT4+PjMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgd1tpXSA9ICgoKHQxICsgd1tpLTddKSB8IDApICsgKCh0MiArIHdbaS0xNl0pIHwgMCkpIHwgMDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0MSA9ICgoKCgoKGU+Pj42KSB8IChlPDwoMzItNikpKSBeICgoZT4+PjExKSB8IChlPDwoMzItMTEpKSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZT4+PjI1KSB8IChlPDwoMzItMjUpKSkpICsgKChlICYgZikgXiAofmUgJiBnKSkpIHwgMCkgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICgoaCArICgoS1tpXSArIHdbaV0pIHwgMCkpIHwgMCkpIHwgMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIHQyID0gKCgoKGE+Pj4yKSB8IChhPDwoMzItMikpKSBeICgoYT4+PjEzKSB8IChhPDwoMzItMTMpKSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGE+Pj4yMikgfCAoYTw8KDMyLTIyKSkpKSArICgoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYykpKSB8IDA7XG5cblx0ICAgICAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBoMCA9IChoMCArIGEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGgxID0gKGgxICsgYikgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDIgPSAoaDIgKyBjKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoMyA9IChoMyArIGQpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg0ID0gKGg0ICsgZSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDUgPSAoaDUgKyBmKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoNiA9IChoNiArIGcpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg3ID0gKGg3ICsgaCkgfCAwO1xuXG5cdCAgICAgICAgICAgICAgICBvZmYgKz0gNjQ7XG5cdCAgICAgICAgICAgICAgICBsZW4gLT0gNjQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBibG9ja3MobSk7XG5cblx0ICAgICAgICBsZXQgaSwgYnl0ZXNMZWZ0ID0gbS5sZW5ndGggJSA2NCxcblx0ICAgICAgICBiaXRMZW5IaSA9IChtLmxlbmd0aCAvIDB4MjAwMDAwMDApIHwgMCxcblx0ICAgICAgICBiaXRMZW5MbyA9IG0ubGVuZ3RoIDw8IDMsXG5cdCAgICAgICAgbnVtWmVyb3MgPSAoYnl0ZXNMZWZ0IDwgNTYpID8gNTYgOiAxMjAsXG5cdCAgICAgICAgcCA9IG0uc2xpY2UobS5sZW5ndGggLSBieXRlc0xlZnQsIG0ubGVuZ3RoKTtcblxuXHQgICAgICAgIHAucHVzaCgweDgwKTtcblx0ICAgICAgICBmb3IgKGkgPSBieXRlc0xlZnQgKyAxOyBpIDwgbnVtWmVyb3M7IGkrKykgeyBwLnB1c2goMCk7IH1cblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiA4KSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAwKSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiA4KSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAwKSAgJiAweGZmKTtcblxuXHQgICAgICAgIGJsb2NrcyhwKTtcblxuXHQgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgIChoMCA+Pj4gMjQpICYgMHhmZiwgKGgwID4+PiAxNikgJiAweGZmLCAoaDAgPj4+IDgpICYgMHhmZiwgKGgwID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMSA+Pj4gMjQpICYgMHhmZiwgKGgxID4+PiAxNikgJiAweGZmLCAoaDEgPj4+IDgpICYgMHhmZiwgKGgxID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMiA+Pj4gMjQpICYgMHhmZiwgKGgyID4+PiAxNikgJiAweGZmLCAoaDIgPj4+IDgpICYgMHhmZiwgKGgyID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMyA+Pj4gMjQpICYgMHhmZiwgKGgzID4+PiAxNikgJiAweGZmLCAoaDMgPj4+IDgpICYgMHhmZiwgKGgzID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNCA+Pj4gMjQpICYgMHhmZiwgKGg0ID4+PiAxNikgJiAweGZmLCAoaDQgPj4+IDgpICYgMHhmZiwgKGg0ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNSA+Pj4gMjQpICYgMHhmZiwgKGg1ID4+PiAxNikgJiAweGZmLCAoaDUgPj4+IDgpICYgMHhmZiwgKGg1ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNiA+Pj4gMjQpICYgMHhmZiwgKGg2ID4+PiAxNikgJiAweGZmLCAoaDYgPj4+IDgpICYgMHhmZiwgKGg2ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNyA+Pj4gMjQpICYgMHhmZiwgKGg3ID4+PiAxNikgJiAweGZmLCAoaDcgPj4+IDgpICYgMHhmZiwgKGg3ID4+PiAwKSAmIDB4ZmZcblx0ICAgICAgICBdO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBQQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCwgc2FsdCwgZGtMZW4pIHtcblx0ICAgICAgICAvLyBjb21wcmVzcyBwYXNzd29yZCBpZiBpdCdzIGxvbmdlciB0aGFuIGhhc2ggYmxvY2sgbGVuZ3RoXG5cdCAgICAgICAgcGFzc3dvcmQgPSAocGFzc3dvcmQubGVuZ3RoIDw9IDY0KSA/IHBhc3N3b3JkIDogU0hBMjU2KHBhc3N3b3JkKTtcblxuXHQgICAgICAgIGNvbnN0IGlubmVyTGVuID0gNjQgKyBzYWx0Lmxlbmd0aCArIDQ7XG5cdCAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgQXJyYXkoaW5uZXJMZW4pO1xuXHQgICAgICAgIGNvbnN0IG91dGVyS2V5ID0gbmV3IEFycmF5KDY0KTtcblxuXHQgICAgICAgIGxldCBpO1xuXHQgICAgICAgIGxldCBkayA9IFtdO1xuXG5cdCAgICAgICAgLy8gaW5uZXIgPSAocGFzc3dvcmQgXiBpcGFkKSB8fCBzYWx0IHx8IGNvdW50ZXJcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeyBpbm5lcltpXSA9IDB4MzY7IH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHsgaW5uZXJbaV0gXj0gcGFzc3dvcmRbaV07IH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FsdC5sZW5ndGg7IGkrKykgeyBpbm5lcls2NCArIGldID0gc2FsdFtpXTsgfVxuXHQgICAgICAgIGZvciAoaSA9IGlubmVyTGVuIC0gNDsgaSA8IGlubmVyTGVuOyBpKyspIHsgaW5uZXJbaV0gPSAwOyB9XG5cblx0ICAgICAgICAvLyBvdXRlcktleSA9IHBhc3N3b3JkIF4gb3BhZFxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBvdXRlcktleVtpXSA9IDB4NWM7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSBvdXRlcktleVtpXSBePSBwYXNzd29yZFtpXTtcblxuXHQgICAgICAgIC8vIGluY3JlbWVudHMgY291bnRlciBpbnNpZGUgaW5uZXJcblx0ICAgICAgICBmdW5jdGlvbiBpbmNyZW1lbnRDb3VudGVyKCkge1xuXHQgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5uZXJMZW4gLSAxOyBpID49IGlubmVyTGVuIC0gNDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICBpbm5lcltpXSsrO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlubmVyW2ldIDw9IDB4ZmYpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIGlubmVyW2ldID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIG91dHB1dCBibG9ja3MgPSBTSEEyNTYob3V0ZXJLZXkgfHwgU0hBMjU2KGlubmVyKSkgLi4uXG5cdCAgICAgICAgd2hpbGUgKGRrTGVuID49IDMyKSB7XG5cdCAgICAgICAgICAgIGluY3JlbWVudENvdW50ZXIoKTtcblx0ICAgICAgICAgICAgZGsgPSBkay5jb25jYXQoU0hBMjU2KG91dGVyS2V5LmNvbmNhdChTSEEyNTYoaW5uZXIpKSkpO1xuXHQgICAgICAgICAgICBka0xlbiAtPSAzMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRrTGVuID4gMCkge1xuXHQgICAgICAgICAgICBpbmNyZW1lbnRDb3VudGVyKCk7XG5cdCAgICAgICAgICAgIGRrID0gZGsuY29uY2F0KFNIQTI1NihvdXRlcktleS5jb25jYXQoU0hBMjU2KGlubmVyKSkpLnNsaWNlKDAsIGRrTGVuKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGRrO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGFuIGFkYXB0YXRpb24gb2Ygc2NyeXB0c3lcblx0ICAgIC8vIFNlZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2NyeXB0c3lcblx0ICAgIGZ1bmN0aW9uIGJsb2NrbWl4X3NhbHNhOChCWSwgWWksIHIsIHgsIF9YKSB7XG5cdCAgICAgICAgbGV0IGk7XG5cblx0ICAgICAgICBhcnJheWNvcHkoQlksICgyICogciAtIDEpICogMTYsIF9YLCAwLCAxNik7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IDIgKiByOyBpKyspIHtcblx0ICAgICAgICAgICAgYmxvY2t4b3IoQlksIGkgKiAxNiwgX1gsIDE2KTtcblx0ICAgICAgICAgICAgc2Fsc2EyMF84KF9YLCB4KTtcblx0ICAgICAgICAgICAgYXJyYXljb3B5KF9YLCAwLCBCWSwgWWkgKyAoaSAqIDE2KSwgMTYpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMikgKiAxNiwgQlksIChpICogMTYpLCAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyICsgMSkgKiAxNiwgQlksIChpICsgcikgKiAxNiwgMTYpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gUihhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIChhIDw8IGIpIHwgKGEgPj4+ICgzMiAtIGIpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2Fsc2EyMF84KEIsIHgpIHtcblx0ICAgICAgICBhcnJheWNvcHkoQiwgMCwgeCwgMCwgMTYpO1xuXG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPiAwOyBpIC09IDIpIHtcblx0ICAgICAgICAgICAgeFsgNF0gXj0gUih4WyAwXSArIHhbMTJdLCA3KTtcblx0ICAgICAgICAgICAgeFsgOF0gXj0gUih4WyA0XSArIHhbIDBdLCA5KTtcblx0ICAgICAgICAgICAgeFsxMl0gXj0gUih4WyA4XSArIHhbIDRdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbIDBdIF49IFIoeFsxMl0gKyB4WyA4XSwgMTgpO1xuXHQgICAgICAgICAgICB4WyA5XSBePSBSKHhbIDVdICsgeFsgMV0sIDcpO1xuXHQgICAgICAgICAgICB4WzEzXSBePSBSKHhbIDldICsgeFsgNV0sIDkpO1xuXHQgICAgICAgICAgICB4WyAxXSBePSBSKHhbMTNdICsgeFsgOV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgNV0gXj0gUih4WyAxXSArIHhbMTNdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbMTRdIF49IFIoeFsxMF0gKyB4WyA2XSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDJdIF49IFIoeFsxNF0gKyB4WzEwXSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDZdIF49IFIoeFsgMl0gKyB4WzE0XSwgMTMpO1xuXHQgICAgICAgICAgICB4WzEwXSBePSBSKHhbIDZdICsgeFsgMl0sIDE4KTtcblx0ICAgICAgICAgICAgeFsgM10gXj0gUih4WzE1XSArIHhbMTFdLCA3KTtcblx0ICAgICAgICAgICAgeFsgN10gXj0gUih4WyAzXSArIHhbMTVdLCA5KTtcblx0ICAgICAgICAgICAgeFsxMV0gXj0gUih4WyA3XSArIHhbIDNdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTVdIF49IFIoeFsxMV0gKyB4WyA3XSwgMTgpO1xuXHQgICAgICAgICAgICB4WyAxXSBePSBSKHhbIDBdICsgeFsgM10sIDcpO1xuXHQgICAgICAgICAgICB4WyAyXSBePSBSKHhbIDFdICsgeFsgMF0sIDkpO1xuXHQgICAgICAgICAgICB4WyAzXSBePSBSKHhbIDJdICsgeFsgMV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgMF0gXj0gUih4WyAzXSArIHhbIDJdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDZdIF49IFIoeFsgNV0gKyB4WyA0XSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDddIF49IFIoeFsgNl0gKyB4WyA1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDRdIF49IFIoeFsgN10gKyB4WyA2XSwgMTMpO1xuXHQgICAgICAgICAgICB4WyA1XSBePSBSKHhbIDRdICsgeFsgN10sIDE4KTtcblx0ICAgICAgICAgICAgeFsxMV0gXj0gUih4WzEwXSArIHhbIDldLCA3KTtcblx0ICAgICAgICAgICAgeFsgOF0gXj0gUih4WzExXSArIHhbMTBdLCA5KTtcblx0ICAgICAgICAgICAgeFsgOV0gXj0gUih4WyA4XSArIHhbMTFdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTBdIF49IFIoeFsgOV0gKyB4WyA4XSwgMTgpO1xuXHQgICAgICAgICAgICB4WzEyXSBePSBSKHhbMTVdICsgeFsxNF0sIDcpO1xuXHQgICAgICAgICAgICB4WzEzXSBePSBSKHhbMTJdICsgeFsxNV0sIDkpO1xuXHQgICAgICAgICAgICB4WzE0XSBePSBSKHhbMTNdICsgeFsxMl0sIDEzKTtcblx0ICAgICAgICAgICAgeFsxNV0gXj0gUih4WzE0XSArIHhbMTNdLCAxOCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG5cdCAgICAgICAgICAgIEJbaV0gKz0geFtpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIG5haXZlIGFwcHJvYWNoLi4uIGdvaW5nIGJhY2sgdG8gbG9vcCB1bnJvbGxpbmcgbWF5IHlpZWxkIGFkZGl0aW9uYWwgcGVyZm9ybWFuY2Vcblx0ICAgIGZ1bmN0aW9uIGJsb2NreG9yKFMsIFNpLCBELCBsZW4pIHtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIERbaV0gXj0gU1tTaSArIGldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXJyYXljb3B5KHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcblx0ICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyaXNoKG8pIHtcblx0ICAgICAgICBpZiAoIW8gfHwgdHlwZW9mKG8ubGVuZ3RoKSAhPT0gJ251bWJlcicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgdiA9IG9baV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YodikgIT09ICdudW1iZXInIHx8IHYgJSAxIHx8IHYgPCAwIHx8IHYgPj0gMjU2KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZW5zdXJlSW50ZWdlcih2YWx1ZSwgbmFtZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm51bWJlclwiIHx8ICh2YWx1ZSAlIDEpKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCAnICsgbmFtZSk7IH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIE4gPSBDcHUgY29zdCwgciA9IE1lbW9yeSBjb3N0LCBwID0gcGFyYWxsZWxpemF0aW9uIGNvc3Rcblx0ICAgIC8vIGNhbGxiYWNrKGVycm9yLCBwcm9ncmVzcywga2V5KVxuXHQgICAgZnVuY3Rpb24gX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIGNhbGxiYWNrKSB7XG5cblx0ICAgICAgICBOID0gZW5zdXJlSW50ZWdlcihOLCAnTicpO1xuXHQgICAgICAgIHIgPSBlbnN1cmVJbnRlZ2VyKHIsICdyJyk7XG5cdCAgICAgICAgcCA9IGVuc3VyZUludGVnZXIocCwgJ3AnKTtcblxuXHQgICAgICAgIGRrTGVuID0gZW5zdXJlSW50ZWdlcihka0xlbiwgJ2RrTGVuJyk7XG5cblx0ICAgICAgICBpZiAoTiA9PT0gMCB8fCAoTiAmIChOIC0gMSkpICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTiBtdXN0IGJlIHBvd2VyIG9mIDInKTsgfVxuXG5cdCAgICAgICAgaWYgKE4gPiBNQVhfVkFMVUUgLyAxMjggLyByKSB7IHRocm93IG5ldyBFcnJvcignTiB0b28gbGFyZ2UnKTsgfVxuXHQgICAgICAgIGlmIChyID4gTUFYX1ZBTFVFIC8gMTI4IC8gcCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3IgdG9vIGxhcmdlJyk7IH1cblxuXHQgICAgICAgIGlmICghY2hlY2tCdWZmZXJpc2gocGFzc3dvcmQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmQgbXVzdCBiZSBhbiBhcnJheSBvciBidWZmZXInKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFzc3dvcmQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXNzd29yZCk7XG5cblx0ICAgICAgICBpZiAoIWNoZWNrQnVmZmVyaXNoKHNhbHQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2FsdCBtdXN0IGJlIGFuIGFycmF5IG9yIGJ1ZmZlcicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzYWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2FsdCk7XG5cblx0ICAgICAgICBsZXQgYiA9IFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLCBzYWx0LCBwICogMTI4ICogcik7XG5cdCAgICAgICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheShwICogMzIgKiByKTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgaiA9IGkgKiA0O1xuXHQgICAgICAgICAgICBCW2ldID0gKChiW2ogKyAzXSAmIDB4ZmYpIDw8IDI0KSB8XG5cdCAgICAgICAgICAgICAgICAgICAoKGJbaiArIDJdICYgMHhmZikgPDwgMTYpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMV0gJiAweGZmKSA8PCA4KSB8XG5cdCAgICAgICAgICAgICAgICAgICAoKGJbaiArIDBdICYgMHhmZikgPDwgMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29uc3QgWFkgPSBuZXcgVWludDMyQXJyYXkoNjQgKiByKTtcblx0ICAgICAgICBjb25zdCBWID0gbmV3IFVpbnQzMkFycmF5KDMyICogciAqIE4pO1xuXG5cdCAgICAgICAgY29uc3QgWWkgPSAzMiAqIHI7XG5cblx0ICAgICAgICAvLyBzY3JhdGNoIHNwYWNlXG5cdCAgICAgICAgY29uc3QgeCA9IG5ldyBVaW50MzJBcnJheSgxNik7ICAgICAgIC8vIHNhbHNhMjBfOFxuXHQgICAgICAgIGNvbnN0IF9YID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAvLyBibG9ja21peF9zYWxzYThcblxuXHQgICAgICAgIGNvbnN0IHRvdGFsT3BzID0gcCAqIE4gKiAyO1xuXHQgICAgICAgIGxldCBjdXJyZW50T3AgPSAwO1xuXHQgICAgICAgIGxldCBsYXN0UGVyY2VudDEwID0gbnVsbDtcblxuXHQgICAgICAgIC8vIFNldCB0aGlzIHRvIHRydWUgdG8gYWJhbmRvbiB0aGUgc2NyeXB0IG9uIHRoZSBuZXh0IHN0ZXBcblx0ICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuXG5cdCAgICAgICAgLy8gU3RhdGUgaW5mb3JtYXRpb25cblx0ICAgICAgICBsZXQgc3RhdGUgPSAwO1xuXHQgICAgICAgIGxldCBpMCA9IDAsIGkxO1xuXHQgICAgICAgIGxldCBCaTtcblxuXHQgICAgICAgIC8vIEhvdyBtYW55IGJsb2NrbWl4X3NhbHNhOCBjYW4gd2UgZG8gcGVyIHN0ZXA/XG5cdCAgICAgICAgY29uc3QgbGltaXQgPSBjYWxsYmFjayA/IHBhcnNlSW50KDEwMDAgLyByKTogMHhmZmZmZmZmZjtcblxuXHQgICAgICAgIC8vIFRyaWNrIGZyb20gc2NyeXB0LWFzeW5jOyBpZiB0aGVyZSBpcyBhIHNldEltbWVkaWF0ZSBzaGltIGluIHBsYWNlLCB1c2UgaXRcblx0ICAgICAgICBjb25zdCBuZXh0VGljayA9ICh0eXBlb2Yoc2V0SW1tZWRpYXRlKSAhPT0gJ3VuZGVmaW5lZCcpID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dDtcblxuXHQgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IGFsbCBJIGNoYW5nZWQ7IG1ha2luZyBzY3J5cHRzeSBhIHN0YXRlIG1hY2hpbmUgc28gd2Ugb2NjYXNpb25hbGx5XG5cdCAgICAgICAgLy8gc3RvcCBhbmQgZ2l2ZSBvdGhlciBldm50cyBvbiB0aGUgZXZudCBsb29wIGEgY2hhbmNlIHRvIHJ1bi4gflJpY01vb1xuXHQgICAgICAgIGNvbnN0IGluY3JlbWVudGFsU01peCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBpZiAoc3RvcCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignY2FuY2VsbGVkJyksIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGxldCBzdGVwcztcblxuXHQgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBwOyBpKyspLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgQmkgPSBpMCAqIDMyICogcjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShCLCBCaSwgWFksIDAsIFlpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gMVxuXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBST01peCAyXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgPSAwO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBmaXJzdCBpbm5lciBzbWl4IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICBzdGVwcyA9IE4gLSBpMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcHMgPiBsaW1pdCkgeyBzdGVwcyA9IGxpbWl0OyB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7ICAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSAyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShYWSwgMCwgViwgKGkxICsgaSkgKiBZaSwgWWkpOyAgICAgICAgIC8vIFJPTWl4IC0gM1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja21peF9zYWxzYTgoWFksIFlpLCByLCB4LCBfWCk7ICAgICAgICAgICAgIC8vIFJPTWl4IC0gNFxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKVxuXHQgICAgICAgICAgICAgICAgICAgIGkxICs9IHN0ZXBzO1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcCArPSBzdGVwcztcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcm9ncmVzcyAob3B0aW9uYWxseSBzdG9wcGluZyB1cylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudDEwID0gcGFyc2VJbnQoMTAwMCAqIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gUk9NaXggNlxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdXAgdG8gMTAwMCBzdGVwcyBvZiB0aGUgc2Vjb25kIGlubmVyIHNtaXggbG9vcFxuXHQgICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gTiAtIGkxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwcyA+IGxpbWl0KSB7IHN0ZXBzID0gbGltaXQ7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHsgICAgICAgICAgICAgICAgLy8gUk9NaXggLSA2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICgyICogciAtIDEpICogMTY7ICAgICAgICAgICAgIC8vIFJPTWl4IC0gN1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gWFlbb2Zmc2V0XSAmIChOIC0gMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NreG9yKFYsIGogKiBZaSwgWFksIFlpKTsgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gOCAoaW5uZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWWksIHIsIHgsIF9YKTsgICAgICAgICAgIC8vIFJPTWl4IC0gOSAob3V0ZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgKz0gc3RlcHM7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wICs9IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJvZ3Jlc3MgKG9wdGlvbmFsbHkgc3RvcHBpbmcgdXMpXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQxMCA9IHBhcnNlSW50KDEwMDAgKiBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50MTAgIT09IGxhc3RQZXJjZW50MTApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjYWxsYmFjayhudWxsLCBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkgeyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBlcmNlbnQxMCA9IHBlcmNlbnQxMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpMSA8IE4pIHsgYnJlYWs7IH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShYWSwgMCwgQiwgQmksIFlpKTsgICAgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDEwXG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHA7IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBpMCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpMCA8IHApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBiID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBCLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAgMCkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+ICA4KSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goKEJbaV0gPj4gMTYpICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsIGIsIGRrTGVuKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIHJlc3VsdCB0byB0aGUgY2FsbGJhY2tcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgMS4wLCBkZXJpdmVkS2V5KTsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRG9uZTsgZG9uJ3QgYnJlYWsgKHdoaWNoIHdvdWxkIHJlc2NoZWR1bGUpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCBzdGVwc1xuXHQgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgbmV4dFRpY2soaW5jcmVtZW50YWxTTWl4KTsgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBSdW4gdGhlIHNtaXggc3RhdGUgbWFjaGluZSB1bnRpbCBjb21wbGV0aW9uXG5cdCAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGluY3JlbWVudGFsU01peCgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlcml2ZWRLZXkgIT0gdW5kZWZpbmVkKSB7IHJldHVybiBkZXJpdmVkS2V5OyB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBCb290c3RyYXAgdGhlIGFzeW5jIGluY3JlbWVudGFsIHNtaXhcblx0ICAgICAgICBpbmNyZW1lbnRhbFNNaXgoKTtcblx0ICAgIH1cblxuXHQgICAgY29uc3QgbGliID0ge1xuXHQgICAgICAgIHNjcnlwdDogZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIGxldCBsYXN0UHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHsgcHJvZ3Jlc3NDYWxsYmFjaygwKTsgfVxuXHQgICAgICAgICAgICAgICAgX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIGZ1bmN0aW9uKGVycm9yLCBwcm9ncmVzcywga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgbGFzdFByb2dyZXNzICE9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoa2V5KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzc0NhbGxiYWNrICYmIHByb2dyZXNzICE9PSBsYXN0UHJvZ3Jlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzc0NhbGxiYWNrKHByb2dyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzeW5jU2NyeXB0OiBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9zY3J5cHQocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLy8gbm9kZS5qc1xuXHQgICAgaWYgKCdvYmplY3QnICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBsaWI7XG5cblx0ICAgIC8vIFJlcXVpcmVKUy9BTURcblx0ICAgIC8vIGh0dHA6Ly93d3cucmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EXG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZih1bmRlZmluZWQpID09PSAnZnVuY3Rpb24nICYmIHVuZGVmaW5lZC5hbWQpIHtcblx0ICAgICAgICB1bmRlZmluZWQobGliKTtcblxuXHQgICAgLy8gV2ViIEJyb3dzZXJzXG5cdCAgICB9IGVsc2UgaWYgKHJvb3QpIHtcblxuXHQgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IFwic2NyeXB0XCIsIG1ha2Ugc3VyZSBpdCBpcyBzdGlsbCBhdmFpbGFibGVcblx0ICAgICAgICBpZiAocm9vdC5zY3J5cHQpIHtcblx0ICAgICAgICAgICAgcm9vdC5fc2NyeXB0ID0gcm9vdC5zY3J5cHQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcm9vdC5zY3J5cHQgPSBsaWI7XG5cdCAgICB9XG5cblx0fSkoY29tbW9uanNHbG9iYWwpO1xuXHR9KTtcblx0dmFyIHNjcnlwdF8xID0gc2NyeXB0LnNjcnlwdDtcblx0dmFyIHNjcnlwdF8yID0gc2NyeXB0LnN5bmNTY3J5cHQ7XG5cblx0dmFyIHJuZztcblxuXHRpZiAoY29tbW9uanNHbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcblx0ICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cblx0ICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuXHQgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5cdCAgcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuXHQgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuXHQgICAgcmV0dXJuIF9ybmRzODtcblx0ICB9O1xuXHR9XG5cblx0aWYgKCFybmcpIHtcblx0ICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG5cdCAgLy9cblx0ICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuXHQgIC8vIHF1YWxpdHkuXG5cdCAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cdCAgcm5nID0gZnVuY3Rpb24oKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG5cdCAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JuZHM7XG5cdCAgfTtcblx0fVxuXG5cdHZhciBybmdCcm93c2VyID0gcm5nO1xuXG5cdC8vICAgICB1dWlkLmpzXG5cdC8vXG5cdC8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuXHQvLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cblx0Ly8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcblx0Ly8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcblx0Ly8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuXG5cdC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG5cdHZhciBfYnl0ZVRvSGV4ID0gW107XG5cdHZhciBfaGV4VG9CeXRlID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcblx0ICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcblx0fVxuXG5cdC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuXHRmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuXHQgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuXHQgIGJ1ZiA9IGJ1ZiB8fCBbXTtcblx0ICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG5cdCAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcblx0ICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG5cdCAgd2hpbGUgKGlpIDwgMTYpIHtcblx0ICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuXHQgIH1cblxuXHQgIHJldHVybiBidWY7XG5cdH1cblxuXHQvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcblx0ZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuXHQgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG5cdCAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG5cdCAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcblx0fVxuXG5cdC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcblx0Ly9cblx0Ly8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcblx0Ly8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuXHQvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuXHR2YXIgX3NlZWRCeXRlcyA9IHJuZ0Jyb3dzZXIoKTtcblxuXHQvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcblx0dmFyIF9ub2RlSWQgPSBbXG5cdCAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG5cdCAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuXHRdO1xuXG5cdC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG5cdHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cblx0Ly8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cdHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuXHRmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuXHQgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXHQgIHZhciBiID0gYnVmIHx8IFtdO1xuXG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0ICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG5cdCAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcblx0ICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuXHQgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuXHQgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cdCAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5cdCAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuXHQgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cdCAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG5cdCAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXHQgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cblx0ICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cdCAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuXHQgIH1cblxuXHQgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG5cdCAgLy8gdGltZSBpbnRlcnZhbFxuXHQgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBuc2VjcyA9IDA7XG5cdCAgfVxuXG5cdCAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXHQgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG5cdCAgfVxuXG5cdCAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuXHQgIF9sYXN0TlNlY3MgPSBuc2Vjcztcblx0ICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuXHQgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXHQgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG5cdCAgLy8gYHRpbWVfbG93YFxuXHQgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcblx0ICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuXHQgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG5cdCAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuXHQgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuXHQgIC8vIGB0aW1lX21pZGBcblx0ICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG5cdCAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcblx0ICBiW2krK10gPSB0bWggJiAweGZmO1xuXG5cdCAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblx0ICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cdCAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cblx0ICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblx0ICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cblx0ICAvLyBgY2xvY2tfc2VxX2xvd2Bcblx0ICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cblx0ICAvLyBgbm9kZWBcblx0ICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuXHQgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG5cdCAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG5cdH1cblxuXHQvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5cdGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG5cdCAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuXHQgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG5cdCAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuXHQgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuXHQgICAgb3B0aW9ucyA9IG51bGw7XG5cdCAgfVxuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nQnJvd3NlcikoKTtcblxuXHQgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblx0ICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG5cdCAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG5cdCAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cdCAgaWYgKGJ1Zikge1xuXHQgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG5cdCAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuXHR9XG5cblx0Ly8gRXhwb3J0IHB1YmxpYyBBUElcblx0dmFyIHV1aWQgPSB2NDtcblx0dXVpZC52MSA9IHYxO1xuXHR1dWlkLnY0ID0gdjQ7XG5cdHV1aWQucGFyc2UgPSBwYXJzZTtcblx0dXVpZC51bnBhcnNlID0gdW5wYXJzZTtcblxuXHR2YXIgdXVpZF8xID0gdXVpZDtcblxuXHR2YXIga2V5c3RvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KGFlc0pzKTtcblx0dmFyIHNjcnlwdCQxID0gX19pbXBvcnRTdGFyKHNjcnlwdCk7XG5cdHZhciB1dWlkXzEkMSA9IF9faW1wb3J0RGVmYXVsdCh1dWlkXzEpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEEudmVyc2lvbik7XG5cdC8vIEV4cG9ydGVkIFR5cGVzXG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUubW5lbW9uaWMgJiYgdmFsdWUubW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgS2V5c3RvcmVBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEtleXN0b3JlQWNjb3VudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEtleXN0b3JlQWNjb3VudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBLZXlzdG9yZUFjY291bnQucHJvdG90eXBlLmlzS2V5c3RvcmVBY2NvdW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0tleXN0b3JlQWNjb3VudCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEtleXN0b3JlQWNjb3VudDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLktleXN0b3JlQWNjb3VudCA9IEtleXN0b3JlQWNjb3VudDtcblx0ZnVuY3Rpb24gX2RlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XG5cdCAgICB2YXIgY2lwaGVyID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2NpcGhlclwiKTtcblx0ICAgIGlmIChjaXBoZXIgPT09IFwiYWVzLTEyOC1jdHJcIikge1xuXHQgICAgICAgIHZhciBpdiA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVycGFyYW1zL2l2XCIpKTtcblx0ICAgICAgICB2YXIgY291bnRlciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0LkNvdW50ZXIoaXYpO1xuXHQgICAgICAgIHZhciBhZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKGtleSwgY291bnRlcik7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGFlc0N0ci5kZWNyeXB0KGNpcGhlcnRleHQpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdGZ1bmN0aW9uIF9nZXRBY2NvdW50KGRhdGEsIGtleSkge1xuXHQgICAgdmFyIGNpcGhlcnRleHQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2NpcGhlcnRleHRcIikpO1xuXHQgICAgdmFyIGNvbXB1dGVkTUFDID0gbGliJDEuaGV4bGlmeShsaWIkNC5rZWNjYWsyNTYobGliJDEuY29uY2F0KFtrZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKSkuc3Vic3RyaW5nKDIpO1xuXHQgICAgaWYgKGNvbXB1dGVkTUFDICE9PSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vbWFjXCIpLnRvTG93ZXJDYXNlKCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhc3N3b3JkXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIHByaXZhdGVLZXkgPSBfZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcblx0ICAgIGlmICghcHJpdmF0ZUtleSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwiZGVjcnlwdFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICB2YXIgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcblx0ICAgIHZhciBhZGRyZXNzID0gbGliJGcuY29tcHV0ZUFkZHJlc3MocHJpdmF0ZUtleSk7XG5cdCAgICBpZiAoZGF0YS5hZGRyZXNzKSB7XG5cdCAgICAgICAgdmFyIGNoZWNrID0gZGF0YS5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKGNoZWNrLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgIGNoZWNrID0gXCIweFwiICsgY2hlY2s7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsaWIkNi5nZXRBZGRyZXNzKGNoZWNrKSAhPT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzIG1pc21hdGNoXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBhY2NvdW50ID0ge1xuXHQgICAgICAgIF9pc0tleXN0b3JlQWNjb3VudDogdHJ1ZSxcblx0ICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuXHQgICAgICAgIHByaXZhdGVLZXk6IGxpYiQxLmhleGxpZnkocHJpdmF0ZUtleSlcblx0ICAgIH07XG5cdCAgICAvLyBWZXJzaW9uIDAuMSB4LWV0aGVycyBtZXRhZGF0YSBtdXN0IGNvbnRhaW4gYW4gZW5jcnlwdGVkIG1uZW1vbmljIHBocmFzZVxuXHQgICAgaWYgKHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcIngtZXRoZXJzL3ZlcnNpb25cIikgPT09IFwiMC4xXCIpIHtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcIngtZXRoZXJzL21uZW1vbmljQ2lwaGVydGV4dFwiKSk7XG5cdCAgICAgICAgdmFyIG1uZW1vbmljSXYgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvbW5lbW9uaWNDb3VudGVyXCIpKTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNDb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihtbmVtb25pY0l2KTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuXHQgICAgICAgIHZhciBwYXRoID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvcGF0aFwiKSB8fCBsaWIkaC5kZWZhdWx0UGF0aDtcblx0ICAgICAgICB2YXIgbG9jYWxlID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvbG9jYWxlXCIpIHx8IFwiZW5cIjtcblx0ICAgICAgICB2YXIgZW50cm9weSA9IGxpYiQxLmFycmF5aWZ5KG1uZW1vbmljQWVzQ3RyLmRlY3J5cHQobW5lbW9uaWNDaXBoZXJ0ZXh0KSk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gbGliJGguZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgbG9jYWxlKTtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSBsaWIkaC5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBudWxsLCBsb2NhbGUpLmRlcml2ZVBhdGgocGF0aCk7XG5cdCAgICAgICAgICAgIGlmIChub2RlLnByaXZhdGVLZXkgIT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0gbm9kZS5tbmVtb25pYztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgdGhlIGxvY2FsZSB3b3JkbGlzdCBpbnN0YWxsZWQgdG9cblx0ICAgICAgICAgICAgLy8gcmVhZCB0aGlzIG1uZW1vbmljLCBqdXN0IGJhaWwgYW5kIGRvbid0IHNldCB0aGVcblx0ICAgICAgICAgICAgLy8gbW5lbW9uaWNcblx0ICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwid29yZGxpc3RcIikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IEtleXN0b3JlQWNjb3VudChhY2NvdW50KTtcblx0fVxuXHRmdW5jdGlvbiBwYmtkZjJTeW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIGNvdW50LCBka0xlbiwgcHJmRnVuYykge1xuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGJyb3dzZXIkMi5wYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSk7XG5cdH1cblx0ZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIGNvdW50LCBka0xlbiwgcHJmRnVuYykge1xuXHQgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYmtkZjJTeW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIGNvdW50LCBka0xlbiwgcHJmRnVuYykpO1xuXHR9XG5cdGZ1bmN0aW9uIF9jb21wdXRlS2RmS2V5KGRhdGEsIHBhc3N3b3JkLCBwYmtkZjJGdW5jLCBzY3J5cHRGdW5jLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICB2YXIgcGFzc3dvcmRCeXRlcyA9IHV0aWxzJDEuZ2V0UGFzc3dvcmQocGFzc3dvcmQpO1xuXHQgICAgdmFyIGtkZiA9IHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZcIik7XG5cdCAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciB0aHJvd0Vycm9yID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXCIsIG5hbWUsIHZhbHVlKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3NhbHRcIikpO1xuXHQgICAgICAgICAgICB2YXIgTiA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvblwiKSk7XG5cdCAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9yXCIpKTtcblx0ICAgICAgICAgICAgdmFyIHAgPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3BcIikpO1xuXHQgICAgICAgICAgICAvLyBDaGVjayBmb3IgYWxsIHJlcXVpcmVkIHBhcmFtZXRlcnNcblx0ICAgICAgICAgICAgaWYgKCFOIHx8ICFyIHx8ICFwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwia2RmXCIsIGtkZik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXG5cdCAgICAgICAgICAgIGlmICgoTiAmIChOIC0gMSkpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiTlwiLCBOKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZGtMZW4gPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtcblx0ICAgICAgICAgICAgaWYgKGRrTGVuICE9PSAzMikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcImRrbGVuXCIsIGRrTGVuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gc2NyeXB0RnVuYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCBOLCByLCBwLCA2NCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInBia2RmMlwiKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSk7XG5cdCAgICAgICAgICAgIHZhciBwcmZGdW5jID0gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIHByZiA9IHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvcHJmXCIpO1xuXHQgICAgICAgICAgICBpZiAocHJmID09PSBcImhtYWMtc2hhMjU2XCIpIHtcblx0ICAgICAgICAgICAgICAgIHByZkZ1bmMgPSBcInNoYTI1NlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHByZiA9PT0gXCJobWFjLXNoYTUxMlwiKSB7XG5cdCAgICAgICAgICAgICAgICBwcmZGdW5jID0gXCJzaGE1MTJcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJwcmZcIiwgcHJmKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY291bnQgPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2NcIikpO1xuXHQgICAgICAgICAgICB2YXIgZGtMZW4gPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtcblx0ICAgICAgICAgICAgaWYgKGRrTGVuICE9PSAzMikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcImRrbGVuXCIsIGRrTGVuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcGJrZGYyRnVuYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZnVuY3Rpb25cIiwgXCJrZGZcIiwga2RmKTtcblx0fVxuXHRmdW5jdGlvbiBkZWNyeXB0U3luYyhqc29uLCBwYXNzd29yZCkge1xuXHQgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgdmFyIGtleSA9IF9jb21wdXRlS2RmS2V5KGRhdGEsIHBhc3N3b3JkLCBwYmtkZjJTeW5jLCBzY3J5cHQkMS5zeW5jU2NyeXB0KTtcblx0ICAgIHJldHVybiBfZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdFN5bmMgPSBkZWNyeXB0U3luYztcblx0ZnVuY3Rpb24gZGVjcnlwdChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBkYXRhLCBrZXk7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMiwgc2NyeXB0JDEuc2NyeXB0LCBwcm9ncmVzc0NhbGxiYWNrKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfZ2V0QWNjb3VudChkYXRhLCBrZXkpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcblx0ZnVuY3Rpb24gZW5jcnlwdChhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICAvLyBDaGVjayB0aGUgYWRkcmVzcyBtYXRjaGVzIHRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIGlmIChsaWIkNi5nZXRBZGRyZXNzKGFjY291bnQuYWRkcmVzcykgIT09IGxpYiRnLmNvbXB1dGVBZGRyZXNzKGFjY291bnQucHJpdmF0ZUtleSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDaGVjayB0aGUgbW5lbW9uaWMgKGlmIGFueSkgbWF0Y2hlcyB0aGUgcHJpdmF0ZSBrZXlcblx0ICAgICAgICBpZiAoaGFzTW5lbW9uaWMoYWNjb3VudCkpIHtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gYWNjb3VudC5tbmVtb25pYztcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSBsaWIkaC5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLnBocmFzZSwgbnVsbCwgbW5lbW9uaWMubG9jYWxlKS5kZXJpdmVQYXRoKG1uZW1vbmljLnBhdGggfHwgbGliJGguZGVmYXVsdFBhdGgpO1xuXHQgICAgICAgICAgICBpZiAobm9kZS5wcml2YXRlS2V5ICE9IGFjY291bnQucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaWMgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcblx0ICAgIH1cblx0ICAgIC8vIFRoZSBvcHRpb25zIGFyZSBvcHRpb25hbCwgc28gYWRqdXN0IHRoZSBjYWxsIGFzIG5lZWRlZFxuXHQgICAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09IFwiZnVuY3Rpb25cIiAmJiAhcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRpb25zO1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBwcml2YXRlS2V5ID0gbGliJDEuYXJyYXlpZnkoYWNjb3VudC5wcml2YXRlS2V5KTtcblx0ICAgIHZhciBwYXNzd29yZEJ5dGVzID0gdXRpbHMkMS5nZXRQYXNzd29yZChwYXNzd29yZCk7XG5cdCAgICB2YXIgZW50cm9weSA9IG51bGw7XG5cdCAgICB2YXIgcGF0aCA9IG51bGw7XG5cdCAgICB2YXIgbG9jYWxlID0gbnVsbDtcblx0ICAgIGlmIChoYXNNbmVtb25pYyhhY2NvdW50KSkge1xuXHQgICAgICAgIHZhciBzcmNNbmVtb25pYyA9IGFjY291bnQubW5lbW9uaWM7XG5cdCAgICAgICAgZW50cm9weSA9IGxpYiQxLmFycmF5aWZ5KGxpYiRoLm1uZW1vbmljVG9FbnRyb3B5KHNyY01uZW1vbmljLnBocmFzZSwgc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIikpO1xuXHQgICAgICAgIHBhdGggPSBzcmNNbmVtb25pYy5wYXRoIHx8IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIGxvY2FsZSA9IHNyY01uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XG5cdCAgICB9XG5cdCAgICB2YXIgY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG5cdCAgICBpZiAoIWNsaWVudCkge1xuXHQgICAgICAgIGNsaWVudCA9IFwiZXRoZXJzLmpzXCI7XG5cdCAgICB9XG5cdCAgICAvLyBDaGVjay9nZW5lcmF0ZSB0aGUgc2FsdFxuXHQgICAgdmFyIHNhbHQgPSBudWxsO1xuXHQgICAgaWYgKG9wdGlvbnMuc2FsdCkge1xuXHQgICAgICAgIHNhbHQgPSBsaWIkMS5hcnJheWlmeShvcHRpb25zLnNhbHQpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgc2FsdCA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygzMik7XG5cdCAgICAgICAgO1xuXHQgICAgfVxuXHQgICAgLy8gT3ZlcnJpZGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yXG5cdCAgICB2YXIgaXYgPSBudWxsO1xuXHQgICAgaWYgKG9wdGlvbnMuaXYpIHtcblx0ICAgICAgICBpdiA9IGxpYiQxLmFycmF5aWZ5KG9wdGlvbnMuaXYpO1xuXHQgICAgICAgIGlmIChpdi5sZW5ndGggIT09IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgaXYgPSBicm93c2VyJDYucmFuZG9tQnl0ZXMoMTYpO1xuXHQgICAgfVxuXHQgICAgLy8gT3ZlcnJpZGUgdGhlIHV1aWRcblx0ICAgIHZhciB1dWlkUmFuZG9tID0gbnVsbDtcblx0ICAgIGlmIChvcHRpb25zLnV1aWQpIHtcblx0ICAgICAgICB1dWlkUmFuZG9tID0gbGliJDEuYXJyYXlpZnkob3B0aW9ucy51dWlkKTtcblx0ICAgICAgICBpZiAodXVpZFJhbmRvbS5sZW5ndGggIT09IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXVpZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICB1dWlkUmFuZG9tID0gYnJvd3NlciQ2LnJhbmRvbUJ5dGVzKDE2KTtcblx0ICAgIH1cblx0ICAgIC8vIE92ZXJyaWRlIHRoZSBzY3J5cHQgcGFzc3dvcmQtYmFzZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVyc1xuXHQgICAgdmFyIE4gPSAoMSA8PCAxNyksIHIgPSA4LCBwID0gMTtcblx0ICAgIGlmIChvcHRpb25zLnNjcnlwdCkge1xuXHQgICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5OKSB7XG5cdCAgICAgICAgICAgIE4gPSBvcHRpb25zLnNjcnlwdC5OO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucikge1xuXHQgICAgICAgICAgICByID0gb3B0aW9ucy5zY3J5cHQucjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnApIHtcblx0ICAgICAgICAgICAgcCA9IG9wdGlvbnMuc2NyeXB0LnA7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gV2UgdGFrZSA2NCBieXRlczpcblx0ICAgIC8vICAgLSAzMiBieXRlcyAgIEFzIG5vcm1hbCBmb3IgdGhlIFdlYjMgc2VjcmV0IHN0b3JhZ2UgKGRlcml2ZWRLZXksIG1hY1ByZWZpeClcblx0ICAgIC8vICAgLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXG5cdCAgICByZXR1cm4gc2NyeXB0JDEuc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIHNhbHQsIE4sIHIsIHAsIDY0LCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICBrZXkgPSBsaWIkMS5hcnJheWlmeShrZXkpO1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXG5cdCAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBrZXkuc2xpY2UoMCwgMTYpO1xuXHQgICAgICAgIHZhciBtYWNQcmVmaXggPSBrZXkuc2xpY2UoMTYsIDMyKTtcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSBtbmVtb25pYyBwaHJhc2UgKGlmIGFueSlcblx0ICAgICAgICB2YXIgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcblx0ICAgICAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIHZhciBjb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihpdik7XG5cdCAgICAgICAgdmFyIGFlc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoZGVyaXZlZEtleSwgY291bnRlcik7XG5cdCAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBsaWIkMS5hcnJheWlmeShhZXNDdHIuZW5jcnlwdChwcml2YXRlS2V5KSk7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLCB1c2VkIHRvIGNoZWNrIHRoZSBwYXNzd29yZFxuXHQgICAgICAgIHZhciBtYWMgPSBsaWIkNC5rZWNjYWsyNTYobGliJDEuY29uY2F0KFttYWNQcmVmaXgsIGNpcGhlcnRleHRdKSk7XG5cdCAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuXHQgICAgICAgIHZhciBkYXRhID0ge1xuXHQgICAgICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCksXG5cdCAgICAgICAgICAgIGlkOiB1dWlkXzEkMS5kZWZhdWx0LnY0KHsgcmFuZG9tOiB1dWlkUmFuZG9tIH0pLFxuXHQgICAgICAgICAgICB2ZXJzaW9uOiAzLFxuXHQgICAgICAgICAgICBDcnlwdG86IHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuXHQgICAgICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXY6IGxpYiQxLmhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBsaWIkMS5oZXhsaWZ5KGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcblx0ICAgICAgICAgICAgICAgIGtkZnBhcmFtczoge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhbHQ6IGxpYiQxLmhleGxpZnkoc2FsdCkuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgICAgIG46IE4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuXHQgICAgICAgICAgICAgICAgICAgIHA6IHAsXG5cdCAgICAgICAgICAgICAgICAgICAgcjogclxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcblx0ICAgICAgICBpZiAoZW50cm9weSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNJdiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICAgICAgICAgIHZhciBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKG1uZW1vbmljSXYpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gbGliJDEuYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0RhdGUoKSwgMikgKyBcIlRcIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNaW51dGVzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENTZWNvbmRzKCksIDIpICsgXCIuMFpcIik7XG5cdCAgICAgICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuXHQgICAgICAgICAgICAgICAgZ2V0aEZpbGVuYW1lOiAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKSxcblx0ICAgICAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogbGliJDEuaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6IGxpYiQxLmhleGxpZnkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG5cdH0pO1xuXG5cdHZhciBrZXlzdG9yZSQxID0gdW53cmFwRXhwb3J0cyhrZXlzdG9yZSk7XG5cdHZhciBrZXlzdG9yZV8xID0ga2V5c3RvcmUuS2V5c3RvcmVBY2NvdW50O1xuXHR2YXIga2V5c3RvcmVfMiA9IGtleXN0b3JlLmRlY3J5cHRTeW5jO1xuXHR2YXIga2V5c3RvcmVfMyA9IGtleXN0b3JlLmRlY3J5cHQ7XG5cdHZhciBrZXlzdG9yZV80ID0ga2V5c3RvcmUuZW5jcnlwdDtcblxuXHR2YXIgbGliJGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5kZWNyeXB0Q3Jvd2RzYWxlID0gY3Jvd2RzYWxlLmRlY3J5cHQ7XG5cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGluc3BlY3QuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cdGV4cG9ydHMuaXNDcm93ZHNhbGVXYWxsZXQgPSBpbnNwZWN0LmlzQ3Jvd2RzYWxlV2FsbGV0O1xuXHRleHBvcnRzLmlzS2V5c3RvcmVXYWxsZXQgPSBpbnNwZWN0LmlzS2V5c3RvcmVXYWxsZXQ7XG5cblx0ZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmUgPSBrZXlzdG9yZS5kZWNyeXB0O1xuXHRleHBvcnRzLmRlY3J5cHRLZXlzdG9yZVN5bmMgPSBrZXlzdG9yZS5kZWNyeXB0U3luYztcblx0ZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmUgPSBrZXlzdG9yZS5lbmNyeXB0O1xuXHRmdW5jdGlvbiBkZWNyeXB0SnNvbldhbGxldChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgaWYgKGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYWNjb3VudCA9IGNyb3dkc2FsZS5kZWNyeXB0KGpzb24sIHBhc3N3b3JkKTtcblx0ICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFjY291bnQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIHJldHVybiBrZXlzdG9yZS5kZWNyeXB0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIpKTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHRKc29uV2FsbGV0ID0gZGVjcnlwdEpzb25XYWxsZXQ7XG5cdGZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0U3luYyhqc29uLCBwYXNzd29yZCkge1xuXHQgICAgaWYgKGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICByZXR1cm4gY3Jvd2RzYWxlLmRlY3J5cHQoanNvbiwgcGFzc3dvcmQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIHJldHVybiBrZXlzdG9yZS5kZWNyeXB0U3luYyhqc29uLCBwYXNzd29yZCk7XG5cdCAgICB9XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdEpzb25XYWxsZXRTeW5jID0gZGVjcnlwdEpzb25XYWxsZXRTeW5jO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkaSA9IHVud3JhcEV4cG9ydHMobGliJGkpO1xuXHR2YXIgbGliXzEkaSA9IGxpYiRpLmRlY3J5cHRDcm93ZHNhbGU7XG5cdHZhciBsaWJfMiRoID0gbGliJGkuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cdHZhciBsaWJfMyRlID0gbGliJGkuaXNDcm93ZHNhbGVXYWxsZXQ7XG5cdHZhciBsaWJfNCRiID0gbGliJGkuaXNLZXlzdG9yZVdhbGxldDtcblx0dmFyIGxpYl81JGEgPSBsaWIkaS5kZWNyeXB0S2V5c3RvcmU7XG5cdHZhciBsaWJfNiQ2ID0gbGliJGkuZGVjcnlwdEtleXN0b3JlU3luYztcblx0dmFyIGxpYl83JDUgPSBsaWIkaS5lbmNyeXB0S2V5c3RvcmU7XG5cdHZhciBsaWJfOCQ0ID0gbGliJGkuZGVjcnlwdEpzb25XYWxsZXQ7XG5cdHZhciBsaWJfOSQ0ID0gbGliJGkuZGVjcnlwdEpzb25XYWxsZXRTeW5jO1xuXG5cdHZhciBfdmVyc2lvbiRDID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIndhbGxldC81LjAuMC1iZXRhLjE0MVwiO1xuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kRCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kQyk7XG5cdHZhciBfdmVyc2lvbl8xJGogPSBfdmVyc2lvbiRDLnZlcnNpb247XG5cblx0dmFyIGxpYiRqID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEMudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGlzQWNjb3VudCh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmIGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLnByaXZhdGVLZXksIDMyKSAmJiB2YWx1ZS5hZGRyZXNzICE9IG51bGwpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICB2YXIgbW5lbW9uaWMgPSB2YWx1ZS5tbmVtb25pYztcblx0ICAgIHJldHVybiAobW5lbW9uaWMgJiYgbW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgV2FsbGV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdhbGxldCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFdhbGxldChwcml2YXRlS2V5LCBwcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBXYWxsZXQpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICBpZiAoaXNBY2NvdW50KHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5XzEgPSBuZXcgbGliJGYuU2lnbmluZ0tleShwcml2YXRlS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduaW5nS2V5XzE7IH0pO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKF90aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgICAgICBpZiAoX3RoaXMuYWRkcmVzcyAhPT0gbGliJDYuZ2V0QWRkcmVzcyhwcml2YXRlS2V5LmFkZHJlc3MpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJpdmF0ZUtleS9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGhhc01uZW1vbmljKHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3JjTW5lbW9uaWNfMSA9IHByaXZhdGVLZXkubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcblx0ICAgICAgICAgICAgICAgICAgICBwaHJhc2U6IHNyY01uZW1vbmljXzEucGhyYXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHBhdGg6IHNyY01uZW1vbmljXzEucGF0aCB8fCBsaWIkaC5kZWZhdWx0UGF0aCxcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHNyY01uZW1vbmljXzEubG9jYWxlIHx8IFwiZW5cIlxuXHQgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gX3RoaXMubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJGcuY29tcHV0ZUFkZHJlc3Mobm9kZS5wcml2YXRlS2V5KSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtbmVtb25pYy9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChsaWIkZi5TaWduaW5nS2V5LmlzU2lnbmluZ0tleShwcml2YXRlS2V5KSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHByaXZhdGVLZXkuY3VydmUgIT09IFwic2VjcDI1NmsxXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgY3VydmU7IG11c3QgYmUgc2VjcDI1NmsxXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwcml2YXRlS2V5OyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWduaW5nS2V5XzIgPSBuZXcgbGliJGYuU2lnbmluZ0tleShwcml2YXRlS2V5KTtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9zaWduaW5nS2V5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25pbmdLZXlfMjsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX21uZW1vbmljXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKF90aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXIgJiYgIWxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIocHJvdmlkZXIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlciB8fCBudWxsKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJtbmVtb25pY1wiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tbmVtb25pYygpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYWxsZXQucHJvdG90eXBlLCBcInByaXZhdGVLZXlcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnByaXZhdGVLZXk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NpZ25pbmdLZXkoKS5wdWJsaWNLZXk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLCBwcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3ModHguZnJvbSkgIT09IF90aGlzLmFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gX3RoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KGxpYiQ0LmtlY2NhazI1NihsaWIkZy5zZXJpYWxpemUodHgpKSk7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkZy5zZXJpYWxpemUodHgsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsaWIkMS5qb2luU2lnbmF0dXJlKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KGxpYiQ5Lmhhc2hNZXNzYWdlKG1lc3NhZ2UpKSkpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSBcImZ1bmN0aW9uXCIgJiYgIXByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgdHlwZW9mIChwcm9ncmVzc0NhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkaS5lbmNyeXB0S2V5c3RvcmUodGhpcywgcGFzc3dvcmQsIG9wdGlvbnMsIHByb2dyZXNzQ2FsbGJhY2spO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogIFN0YXRpYyBtZXRob2RzIHRvIGNyZWF0ZSBXYWxsZXQgaW5zdGFuY2VzLlxuXHQgICAgICovXG5cdCAgICBXYWxsZXQuY3JlYXRlUmFuZG9tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgZW50cm9weSA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZXh0cmFFbnRyb3B5KSB7XG5cdCAgICAgICAgICAgIGVudHJvcHkgPSBsaWIkMS5hcnJheWlmeShsaWIkMS5oZXhEYXRhU2xpY2UobGliJDQua2VjY2FrMjU2KGxpYiQxLmNvbmNhdChbZW50cm9weSwgb3B0aW9ucy5leHRyYUVudHJvcHldKSksIDAsIDE2KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtbmVtb25pYyA9IGxpYiRoLmVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIG9wdGlvbnMubG9jYWxlKTtcblx0ICAgICAgICByZXR1cm4gV2FsbGV0LmZyb21NbmVtb25pYyhtbmVtb25pYywgb3B0aW9ucy5wYXRoLCBvcHRpb25zLmxvY2FsZSk7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LmZyb21FbmNyeXB0ZWRKc29uID0gZnVuY3Rpb24gKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiRpLmRlY3J5cHRKc29uV2FsbGV0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KGFjY291bnQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tRW5jcnlwdGVkSnNvblN5bmMgPSBmdW5jdGlvbiAoanNvbiwgcGFzc3dvcmQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldChsaWIkaS5kZWNyeXB0SnNvbldhbGxldFN5bmMoanNvbiwgcGFzc3dvcmQpKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQuZnJvbU1uZW1vbmljID0gZnVuY3Rpb24gKG1uZW1vbmljLCBwYXRoLCB3b3JkbGlzdCkge1xuXHQgICAgICAgIGlmICghcGF0aCkge1xuXHQgICAgICAgICAgICBwYXRoID0gbGliJGguZGVmYXVsdFBhdGg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG51bGwsIHdvcmRsaXN0KS5kZXJpdmVQYXRoKHBhdGgpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2FsbGV0O1xuXHR9KGxpYiRjLlNpZ25lcikpO1xuXHRleHBvcnRzLldhbGxldCA9IFdhbGxldDtcblx0ZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWduYXR1cmUpIHtcblx0ICAgIHJldHVybiBsaWIkZy5yZWNvdmVyQWRkcmVzcyhsaWIkOS5oYXNoTWVzc2FnZShtZXNzYWdlKSwgc2lnbmF0dXJlKTtcblx0fVxuXHRleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSB2ZXJpZnlNZXNzYWdlO1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkaiA9IHVud3JhcEV4cG9ydHMobGliJGopO1xuXHR2YXIgbGliXzEkaiA9IGxpYiRqLldhbGxldDtcblx0dmFyIGxpYl8yJGkgPSBsaWIkai52ZXJpZnlNZXNzYWdlO1xuXG5cdHZhciBfdmVyc2lvbiRFID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIm5ldHdvcmtzLzUuMC4wLWJldGEuMTM3XCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRGID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRFKTtcblx0dmFyIF92ZXJzaW9uXzEkayA9IF92ZXJzaW9uJEUudmVyc2lvbjtcblxuXHR2YXIgbGliJGsgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kRS52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAocHJvdmlkZXJzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm92aWRlckxpc3QgPSBbXTtcblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuaW5mdXJhKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFsY2hlbXkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlckxpc3QubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdmFyIHF1b3J1bSA9IDE7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBxdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG5cdCAgICAgICAgICAgICAgICBxdW9ydW0gPSAyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcHJvdmlkZXJMaXN0WzBdO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih1cmwsIG5ldHdvcmspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdH1cblx0dmFyIGhvbWVzdGVhZCA9IHtcblx0ICAgIGNoYWluSWQ6IDEsXG5cdCAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuXHQgICAgbmFtZTogXCJob21lc3RlYWRcIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxuXHR9O1xuXHR2YXIgcm9wc3RlbiA9IHtcblx0ICAgIGNoYWluSWQ6IDMsXG5cdCAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuXHQgICAgbmFtZTogXCJyb3BzdGVuXCIsXG5cdCAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyb3BzdGVuXCIpXG5cdH07XG5cdHZhciBjbGFzc2ljTW9yZG9yID0ge1xuXHQgICAgY2hhaW5JZDogNjMsXG5cdCAgICBuYW1lOiBcImNsYXNzaWNNb3Jkb3JcIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxuXHR9O1xuXHR2YXIgbmV0d29ya3MgPSB7XG5cdCAgICB1bnNwZWNpZmllZDoge1xuXHQgICAgICAgIGNoYWluSWQ6IDAsXG5cdCAgICAgICAgbmFtZTogXCJ1bnNwZWNpZmllZFwiXG5cdCAgICB9LFxuXHQgICAgaG9tZXN0ZWFkOiBob21lc3RlYWQsXG5cdCAgICBtYWlubmV0OiBob21lc3RlYWQsXG5cdCAgICBtb3JkZW46IHtcblx0ICAgICAgICBjaGFpbklkOiAyLFxuXHQgICAgICAgIG5hbWU6IFwibW9yZGVuXCJcblx0ICAgIH0sXG5cdCAgICByb3BzdGVuOiByb3BzdGVuLFxuXHQgICAgdGVzdG5ldDogcm9wc3Rlbixcblx0ICAgIHJpbmtlYnk6IHtcblx0ICAgICAgICBjaGFpbklkOiA0LFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICAgICAgbmFtZTogXCJyaW5rZWJ5XCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuXHQgICAgfSxcblx0ICAgIGtvdmFuOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNDIsXG5cdCAgICAgICAgbmFtZTogXCJrb3ZhblwiLFxuXHQgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImtvdmFuXCIpXG5cdCAgICB9LFxuXHQgICAgZ29lcmxpOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNSxcblx0ICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuXHQgICAgICAgIG5hbWU6IFwiZ29lcmxpXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiZ29lcmxpXCIpXG5cdCAgICB9LFxuXHQgICAgLy8gRVRDIChTZWU6ICMzNTEpXG5cdCAgICBjbGFzc2ljOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNjEsXG5cdCAgICAgICAgbmFtZTogXCJjbGFzc2ljXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6Ly93d3cuZXRoZXJjbHVzdGVyLmNvbS9ldGNcIiwgXCJjbGFzc2ljXCIpXG5cdCAgICB9LFxuXHQgICAgY2xhc3NpY01vcmRlbjoge1xuXHQgICAgICAgIGNoYWluSWQ6IDYyLFxuXHQgICAgICAgIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiLFxuXHQgICAgfSxcblx0ICAgIGNsYXNzaWNNb3Jkb3I6IGNsYXNzaWNNb3Jkb3IsXG5cdCAgICBjbGFzc2ljVGVzdG5ldDogY2xhc3NpY01vcmRvcixcblx0ICAgIGNsYXNzaWNLb3R0aToge1xuXHQgICAgICAgIGNoYWluSWQ6IDYsXG5cdCAgICAgICAgbmFtZTogXCJjbGFzc2ljS290dGlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG5cdCAgICB9LFxuXHR9O1xuXHQvKipcblx0ICogIGdldE5ldHdvcmtcblx0ICpcblx0ICogIENvbnZlcnRzIGEgbmFtZWQgY29tbW9uIG5ldHdvcmtzIG9yIGNoYWluIElEIChuZXR3b3JrIElEKSB0byBhIE5ldHdvcmtcblx0ICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuXHQgICAgLy8gTm8gbmV0d29yayAobnVsbClcblx0ICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIG5ldHdvcmtzKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFuZGFyZF8xID0gbmV0d29ya3NbbmFtZV8xXTtcblx0ICAgICAgICAgICAgaWYgKHN0YW5kYXJkXzEuY2hhaW5JZCA9PT0gbmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZF8xLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmRfMS5jaGFpbklkLFxuXHQgICAgICAgICAgICAgICAgICAgIGVuc0FkZHJlc3M6IChzdGFuZGFyZF8xLmVuc0FkZHJlc3MgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkXzEuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuXHQgICAgICAgICAgICBuYW1lOiBcInVua25vd25cIlxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciBzdGFuZGFyZF8yID0gbmV0d29ya3NbbmV0d29ya107XG5cdCAgICAgICAgaWYgKHN0YW5kYXJkXzIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmFtZTogc3RhbmRhcmRfMi5uYW1lLFxuXHQgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZF8yLmNoYWluSWQsXG5cdCAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkXzIuZW5zQWRkcmVzcyxcblx0ICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkXzIuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB2YXIgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrLm5hbWVdO1xuXHQgICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuXHQgICAgaWYgKCFzdGFuZGFyZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldHdvcms7XG5cdCAgICB9XG5cdCAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYWluSWQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbmV0d29yayBjaGFpbklkIChvciBpcyAwOyBkaXNhYmxlIEVJUC0xNTUpXG5cdCAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSAwICYmIG5ldHdvcmsuY2hhaW5JZCAhPT0gc3RhbmRhcmQuY2hhaW5JZCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgfVxuXHQgICAgLy8gU3RhbmRhcmQgTmV0d29yayAoYWxsb3cgb3ZlcnJpZGluZyB0aGUgRU5TIGFkZHJlc3MpXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcblx0ICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAobmV0d29yay5fZGVmYXVsdFByb3ZpZGVyIHx8IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcblx0ICAgIH07XG5cdH1cblx0ZXhwb3J0cy5nZXROZXR3b3JrID0gZ2V0TmV0d29yaztcblx0fSk7XG5cblx0dmFyIGluZGV4JGsgPSB1bndyYXBFeHBvcnRzKGxpYiRrKTtcblx0dmFyIGxpYl8xJGsgPSBsaWIkay5nZXROZXR3b3JrO1xuXG5cdHZhciBicm93c2VyJDggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZnVuY3Rpb24gZGVjb2RlKHRleHREYXRhKSB7XG5cdCAgICB0ZXh0RGF0YSA9IGF0b2IodGV4dERhdGEpO1xuXHQgICAgdmFyIGRhdGEgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBkYXRhLnB1c2godGV4dERhdGEuY2hhckNvZGVBdChpKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdH1cblx0ZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cdGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG5cdCAgICBkYXRhID0gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdCAgICB2YXIgdGV4dERhdGEgPSBcIlwiO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBidG9hKHRleHREYXRhKTtcblx0fVxuXHRleHBvcnRzLmVuY29kZSA9IGVuY29kZTtcblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkOSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQ4KTtcblx0dmFyIGJyb3dzZXJfMSQ0ID0gYnJvd3NlciQ4LmRlY29kZTtcblx0dmFyIGJyb3dzZXJfMiQzID0gYnJvd3NlciQ4LmVuY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kRyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3ZWIvNS4wLjAtYmV0YS4xNDJcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEggPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEcpO1xuXHR2YXIgX3ZlcnNpb25fMSRsID0gX3ZlcnNpb24kRy52ZXJzaW9uO1xuXG5cdHZhciBicm93c2VyR2V0dXJsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGZ1bmN0aW9uIGdldFVybChocmVmLCBvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHJlcXVlc3QsIHJlc3BvbnNlLCBib2R5LCBoZWFkZXJzO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IChvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IChvcHRpb25zLmJvZHkgfHwgdW5kZWZpbmVkKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcIm5vLWNhY2hlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWZlcnJlcjogXCJjbGllbnRcIixcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKGhyZWYsIHJlcXVlc3QpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS50ZXh0KCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmdldFVybCA9IGdldFVybDtcblx0fSk7XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwkMSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlckdldHVybCk7XG5cdHZhciBicm93c2VyR2V0dXJsXzEgPSBicm93c2VyR2V0dXJsLmdldFVybDtcblxuXHR2YXIgbGliJGwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRHLnZlcnNpb24pO1xuXG5cdGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuXHQgICAgdmFyIGhlYWRlcnMgPSB7fTtcblx0ICAgIHZhciB1cmwgPSBudWxsO1xuXHQgICAgLy8gQFRPRE86IEFsbG93IENvbm5lY3Rpb25JbmZvIHRvIG92ZXJyaWRlIHNvbWUgb2YgdGhlc2UgdmFsdWVzXG5cdCAgICB2YXIgb3B0aW9ucyA9IHtcblx0ICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG5cdCAgICB9O1xuXHQgICAgdmFyIGFsbG93MzA0ID0gZmFsc2U7XG5cdCAgICB2YXIgdGltZW91dCA9IDIgKiA2MCAqIDEwMDA7XG5cdCAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHVybCA9IGNvbm5lY3Rpb247XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCB8fCBjb25uZWN0aW9uLnVybCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIFVSTFwiLCBcImNvbm5lY3Rpb24udXJsXCIsIGNvbm5lY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB1cmwgPSBjb25uZWN0aW9uLnVybDtcblx0ICAgICAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uLnRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIGNvbm5lY3Rpb24udGltZW91dCA+IDApIHtcblx0ICAgICAgICAgICAgdGltZW91dCA9IGNvbm5lY3Rpb24udGltZW91dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24uaGVhZGVycykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29ubmVjdGlvbi5oZWFkZXJzKSB7XG5cdCAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHsga2V5OiBrZXksIHZhbHVlOiBTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pIH07XG5cdCAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBhbGxvdzMwNCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24udXNlciAhPSBudWxsICYmIGNvbm5lY3Rpb24ucGFzc3dvcmQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArIGJyb3dzZXIkOC5lbmNvZGUobGliJDgudG9VdGY4Qnl0ZXMoYXV0aG9yaXphdGlvbikpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGpzb24pIHtcblx0ICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuXHQgICAgICAgIG9wdGlvbnMuYm9keSA9IGpzb247XG5cdCAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHsga2V5OiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcblx0ICAgIH1cblx0ICAgIHZhciBmbGF0SGVhZGVycyA9IHt9O1xuXHQgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNba2V5XTtcblx0ICAgICAgICBmbGF0SGVhZGVyc1toZWFkZXIua2V5XSA9IGhlYWRlci52YWx1ZTtcblx0ICAgIH0pO1xuXHQgICAgb3B0aW9ucy5oZWFkZXJzID0gZmxhdEhlYWRlcnM7XG5cdCAgICB2YXIgcnVubmluZ1RpbWVvdXQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG5cdCAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiAob3B0aW9ucy5ib2R5IHx8IG51bGwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIHsgcHJvbWlzZTogcHJvbWlzZSwgY2FuY2VsOiBjYW5jZWwgfTtcblx0ICAgIH0pKCk7XG5cdCAgICB2YXIgcnVubmluZ0ZldGNoID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXNwb25zZSwgZXJyb3JfMSwgYm9keSwganNvbiwgZXJyb3JfMjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm93c2VyR2V0dXJsLmdldFVybCh1cmwsIG9wdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3JfMS5yZXNwb25zZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiAob3B0aW9ucy5ib2R5IHx8IG51bGwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcl8xLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSByZXNwb25zZS5ib2R5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3czMDQgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3BvbnNlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IChvcHRpb25zLmJvZHkgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShib2R5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiAob3B0aW9ucy5ib2R5IHx8IG51bGwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NGdW5jKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFs1LCA3LCAsIDhdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJvY2Vzc0Z1bmMoanNvbiwgcmVzcG9uc2UpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keToganNvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcl8yLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IChvcHRpb25zLmJvZHkgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCBqc29uXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KSgpO1xuXHQgICAgcmV0dXJuIFByb21pc2UucmFjZShbcnVubmluZ1RpbWVvdXQucHJvbWlzZSwgcnVubmluZ0ZldGNoXSk7XG5cdH1cblx0ZXhwb3J0cy5mZXRjaEpzb24gPSBmZXRjaEpzb247XG5cdGZ1bmN0aW9uIHBvbGwoZnVuYywgb3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgb3B0aW9ucyA9IGxpYiQzLnNoYWxsb3dDb3B5KG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuXHQgICAgICAgIG9wdGlvbnMuZmxvb3IgPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5jZWlsaW5nID0gMTAwMDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5pbnRlcnZhbCA9IDI1MDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuXHQgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgIGlmICh0aW1lcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcblx0ICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJldHJ5TGltaXQgPSBvcHRpb25zLnJldHJ5TGltaXQ7XG5cdCAgICAgICAgdmFyIGF0dGVtcHQgPSAwO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlc3VsdCwgb3IgYXJlIGFsbG93ZWQgbnVsbCB0aGVuIHdlJ3JlIGRvbmVcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlUG9sbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlQmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZXhwb25lbnRpYWwgYmFjay1vZmYgKHVwIHRvIDEwcykgb3VyIG5leHQgcmVxdWVzdFxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiByZXRyeUxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJldHJ5IGxpbWl0IHJlYWNoZWRcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLmludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5mbG9vcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuY2VpbGluZztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2hlY2soKTtcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMucG9sbCA9IHBvbGw7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRsID0gdW53cmFwRXhwb3J0cyhsaWIkbCk7XG5cdHZhciBsaWJfMSRsID0gbGliJGwuZmV0Y2hKc29uO1xuXHR2YXIgbGliXzIkaiA9IGxpYiRsLnBvbGw7XG5cblx0dmFyIF92ZXJzaW9uJEkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuMC4wLWJldGEuMTcxXCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRKID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRJKTtcblx0dmFyIF92ZXJzaW9uXzEkbSA9IF92ZXJzaW9uJEkudmVyc2lvbjtcblxuXHR2YXIgZm9ybWF0dGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdHZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBGb3JtYXR0ZXIpO1xuXHQgICAgICAgIHRoaXMuZm9ybWF0cyA9IHRoaXMuZ2V0RGVmYXVsdEZvcm1hdHMoKTtcblx0ICAgIH1cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZm9ybWF0cyA9ICh7fSk7XG5cdCAgICAgICAgdmFyIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBzdHJpY3REYXRhID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG5cdCAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvbiA9IHtcblx0ICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZ2FzUHJpY2U6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIG5vbmNlOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcblx0ICAgICAgICAgICAgczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuXHQgICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHJhdzogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuXHQgICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcblx0ICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93TnVsbChzdHJpY3REYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuXHQgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcblx0ICAgICAgICAgICAgcm9vdDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuXHQgICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgc3RhdHVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcilcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2sgPSB7XG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcblx0ICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcblx0ICAgICAgICAgICAgZGlmZmljdWx0eTogdGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgbWluZXI6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gbGliJDMuc2hhbGxvd0NvcHkoZm9ybWF0cy5ibG9jayk7XG5cdCAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuXHQgICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuXHQgICAgICAgICAgICBmcm9tQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICBhZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9ybWF0cy5maWx0ZXJMb2cgPSB7XG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLCBcIjB4XCIpLFxuXHQgICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gZm9ybWF0cztcblx0ICAgIH07XG5cdCAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5iaWdOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFJlcXVpcmVzIGEgYm9vbGVhbiwgXCJ0cnVlXCIgb3IgIFwiZmFsc2VcIjsgcmV0dXJucyBhIGJvb2xlYW5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9vbGVhbiAtIFwiICsgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG5cdCAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gYWRkcmVzc1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhZGRyZXNzID0gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UodmFsdWUsIDEyKSk7XG5cdCAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBsaWIkNy5BZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tUYWcgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiB8fCBibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgbGliJDEuaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5oZXhWYWx1ZShibG9ja1RhZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuXHQgICAgICAgIGlmIChsaWIkMS5oZXhEYXRhTGVuZ3RoKHJlc3VsdCkgIT09IDMyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kaWZmaWN1bHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS51aW50MjU2ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuX2Jsb2NrID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZS5taW5lciA9IHZhbHVlLmF1dGhvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcblx0ICAgIH07XG5cdCAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXNwb25zZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuXHQgICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogdXNlIHRyYW5zYWN0aW9uLnNlcmlhbGl6ZT8gSGF2ZSB0byBhZGQgc3VwcG9ydCBmb3IgaW5jbHVkaW5nIHYsIHIsIGFuZCBzLi4uXG5cdCAgICAgICAgLypcblx0ICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnJhdykge1xuXHQgXG5cdCAgICAgICAgICAgICAvLyBWZXJ5IGxvb3NlIHByb3ZpZGVycyAoZS5nLiBUZXN0UlBDKSBkbyBub3QgcHJvdmlkZSBhIHNpZ25hdHVyZSBvciByYXdcblx0ICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi52ICYmIHRyYW5zYWN0aW9uLnIgJiYgdHJhbnNhY3Rpb24ucykge1xuXHQgICAgICAgICAgICAgICAgIGxldCByYXcgPSBbXG5cdCAgICAgICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MoaGV4bGlmeSh0cmFuc2FjdGlvbi5ub25jZSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24uZ2FzUHJpY2UpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLmdhc0xpbWl0KSksXG5cdCAgICAgICAgICAgICAgICAgICAgICh0cmFuc2FjdGlvbi50byB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udmFsdWUgfHwgXCIweFwiKSksXG5cdCAgICAgICAgICAgICAgICAgICAgIGhleGxpZnkodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udiB8fCBcIjB4XCIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnMpKSxcblx0ICAgICAgICAgICAgICAgICBdO1xuXHQgXG5cdCAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmF3ID0gcmxwRW5jb2RlKHJhdyk7XG5cdCAgICAgICAgICAgICB9XG5cdCAgICAgICAgIH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFpbklkID0gdHJhbnNhY3Rpb24ubmV0d29ya0lkO1xuXHQgICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcblx0ICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG5cdCAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuXHQgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiRnLnBhcnNlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnJlY2VpcHRMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5maWx0ZXJMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIuY2hlY2sgPSBmdW5jdGlvbiAoZm9ybWF0LCBvYmplY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0W2tleV0ob2JqZWN0W2tleV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tLZXkgPSBrZXk7XG5cdCAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcblx0ICAgIEZvcm1hdHRlci5hbGxvd051bGwgPSBmdW5jdGlvbiAoZm9ybWF0LCBudWxsVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuXHQgICAgRm9ybWF0dGVyLmFsbG93RmFsc2lzaCA9IGZ1bmN0aW9uIChmb3JtYXQsIHJlcGxhY2VWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuXHQgICAgRm9ybWF0dGVyLmFycmF5T2YgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ybWF0dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcblx0fSk7XG5cblx0dmFyIGZvcm1hdHRlciQxID0gdW53cmFwRXhwb3J0cyhmb3JtYXR0ZXIpO1xuXHR2YXIgZm9ybWF0dGVyXzEgPSBmb3JtYXR0ZXIuRm9ybWF0dGVyO1xuXG5cdHZhciBiYXNlUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRXZlbnQgU2VyaWFsaXplaW5nXG5cdGZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcblx0ICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGxpYiQxLmhleERhdGFMZW5ndGgodG9waWMpICE9PSAzMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsIFwidG9waWNcIiwgdG9waWMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0ZnVuY3Rpb24gc2VyaWFsaXplVG9waWNzKHRvcGljcykge1xuXHQgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG5cdCAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcblx0ICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoID4gMCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09IG51bGwpIHtcblx0ICAgICAgICB0b3BpY3MucG9wKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9waWNzLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcblx0ICAgICAgICAgICAgLy8gT25seSB0cmFjayB1bmlxdWUgT1ItdG9waWNzXG5cdCAgICAgICAgICAgIHZhciB1bmlxdWVfMSA9IHt9O1xuXHQgICAgICAgICAgICB0b3BpYy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgICAgICAgICAgdW5pcXVlXzFbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBPUi10b3BpY3MgZG9lcyBub3QgbWF0dGVyXG5cdCAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBPYmplY3Qua2V5cyh1bmlxdWVfMSk7XG5cdCAgICAgICAgICAgIHNvcnRlZC5zb3J0KCk7XG5cdCAgICAgICAgICAgIHJldHVybiBzb3J0ZWQuam9pbihcInxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSkuam9pbihcIiZcIik7XG5cdH1cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuXHQgICAgaWYgKGRhdGEgPT09IFwiXCIpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAoZnVuY3Rpb24gKHRvcGljKSB7XG5cdCAgICAgICAgaWYgKHRvcGljID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgodG9waWMgPT09IFwibnVsbFwiKSA/IG51bGwgOiB0b3BpYyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG5cdCAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKGxpYiQxLmhleERhdGFMZW5ndGgoZXZlbnROYW1lKSA9PT0gMzIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwidHg6XCIgKyBldmVudE5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGxpYiRiLkZvcmtFdmVudC5pc0ZvcmtFdmVudChldmVudE5hbWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZXZlbnROYW1lICYmIHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIiArIGV2ZW50TmFtZSk7XG5cdH1cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIEhlbHBlciBPYmplY3Rcblx0ZnVuY3Rpb24gZ2V0VGltZSgpIHtcblx0ICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHR9XG5cdGZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG5cdCAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcblx0ICAgIH0pO1xuXHR9XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBQcm92aWRlciBPYmplY3Rcblx0LyoqXG5cdCAqICBFdmVudFR5cGVcblx0ICogICAtIFwiYmxvY2tcIlxuXHQgKiAgIC0gXCJwb2xsXCJcblx0ICogICAtIFwiZGlkUG9sbFwiXG5cdCAqICAgLSBcInBlbmRpbmdcIlxuXHQgKiAgIC0gXCJlcnJvclwiXG5cdCAqICAgLSBcIm5ldHdvcmtcIlxuXHQgKiAgIC0gZmlsdGVyXG5cdCAqICAgLSB0b3BpY3MgYXJyYXlcblx0ICogICAtIHRyYW5zYWN0aW9uIGhhc2hcblx0ICovXG5cdHZhciBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xuXHR2YXIgRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBFdmVudCh0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJ0eFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2g7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZy5zcGxpdChcIjpcIilbMF07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImhhc2hcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29tcHNbMV07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcblx0ICAgICAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgYWRkcmVzcyA9IGNvbXBzWzFdO1xuXHQgICAgICAgICAgICB2YXIgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuXHQgICAgICAgICAgICB2YXIgZmlsdGVyID0ge307XG5cdCAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBFdmVudC5wcm90b3R5cGUucG9sbGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLnRhZy5pbmRleE9mKFwiOlwiKSA+PSAwIHx8IFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpID49IDApO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdmVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xuXHR2YXIgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5cdHZhciBuZXh0UG9sbElkID0gMTtcblx0dmFyIEJhc2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhCYXNlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICAvKipcblx0ICAgICAqICByZWFkeVxuXHQgICAgICpcblx0ICAgICAqICBBIFByb21pc2U8TmV0d29yaz4gdGhhdCByZXNvbHZlcyBvbmx5IG9uY2UgdGhlIHByb3ZpZGVyIGlzIHJlYWR5LlxuXHQgICAgICpcblx0ICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG5cdCAgICAgKiAgTVVTVCBzZXQgdGhpcy4gU3RhbmRhcmQgbmFtZWQgbmV0d29ya3MgaGF2ZSBhIGtub3duIGNoYWluSWQuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBCYXNlUHJvdmlkZXIobmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBsaWIkYi5Qcm92aWRlcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIEV2ZW50cyBiZWluZyBsaXN0ZW5lZCB0b1xuXHQgICAgICAgIF90aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICBfdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG5cdCAgICAgICAgX3RoaXMuZm9ybWF0dGVyID0gX25ld1RhcmdldC5nZXRGb3JtYXR0ZXIoKTtcblx0ICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcblx0ICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuXHQgICAgICAgIC8vIGN1cnJlbnQgbmV0d29ya1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcblx0ICAgICAgICBpZiAoX3RoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICBuZXR3b3JrID0gX3RoaXMuZGV0ZWN0TmV0d29yaygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcblx0ICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcblx0ICAgICAgICAgICAgbmV0d29yay5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuXHQgICAgICAgICAgICBfdGhpcy5fcmVhZHkoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBrbm93bk5ldHdvcmsgPSBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG5cdCAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcblx0ICAgICAgICBfdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG5cdCAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG5cdCAgICAgICAgX3RoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3JlYWR5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIGVycm9yXzE7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9uZXR3b3JrUHJvbWlzZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX25ldHdvcmtQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZXRlY3ROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeSBQcm92aWRlciBzdWItY2xhc3Mgc2hvdWxkIGhhdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSB0aGlzIGNhbGwgc3RhY2tlZCBzbyBkbyBub3QgY2FsbCBkZWZpbmVSZWFkT25seSBhZ2FpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IG5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDc7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInJlYWR5XCIsIHtcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBlc3RhYmxpc2hlZCBuZXR3b3JrLlxuXHQgICAgICAgIC8vIEZvciBcImFueVwiLCB0aGlzIGNhbiBjaGFuZ2UgKGEgXCJuZXR3b3JrXCIgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmVcblx0ICAgICAgICAvLyBhbnkgY2hhbmdlIGlzIHJlZmVsY3RlZCk7IG90aGVyd2lzZSB0aGlzIGNhbm5vdCBjaGFuZ2Vcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5KCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuXHQgICAgQmFzZVByb3ZpZGVyLmdldEZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgZm9ybWF0dGVyLkZvcm1hdHRlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcblx0ICAgIEJhc2VQcm92aWRlci5nZXROZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICByZXR1cm4gbGliJGsuZ2V0TmV0d29yaygobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3Ncblx0ICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0SW50ZXJuYWxCbG9ja051bWJlciA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcm5hbEJsb2NrTnVtYmVyLCByZXN1bHQsIHJlcVRpbWUsIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZWFkeV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXhBZ2UgPiAwICYmIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaW50ZXJuYWxCbG9ja051bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2V0VGltZSgpIC0gcmVzdWx0LnJlc3BUaW1lKSA8PSBtYXhBZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuYmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVRpbWUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHsgcmV0dXJuIChudWxsKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoZXJyb3IpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyOiBibG9ja051bWJlciwgcmVxVGltZTogcmVxVGltZSwgcmVzcFRpbWU6IHJlc3BUaW1lIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmJsb2NrTnVtYmVyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBvbGxJZCwgcnVubmVycywgYmxvY2tOdW1iZXIsIGk7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxJZCA9IG5leHRQb2xsSWQrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIiwgcG9sbElkLCBibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlLCB0cmlnZ2VyIGEgXCJibG9ja1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlcjogdGhpcy5fZW1pdHRlZC5ibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuX2VtaXR0ZWQuYmxvY2sgKyAxOyBpIDw9IGJsb2NrTnVtYmVyOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgd2Ugd2VyZSBhdCB3aGVuIHdlIGVtaXR0ZWQgdGhpcyBldmVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEJsb2NrTnVtYmVyID0gX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hfMiA9IGV2ZW50Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5uZXIgPSBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaF8yKS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXzJdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaF8yLCByZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJfMSA9IGV2ZW50LmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEuZnJvbUJsb2NrID0gX3RoaXMuX2xhc3RCbG9ja051bWJlciArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl8xLnRvQmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bm5lciA9IF90aGlzLmdldExvZ3MoZmlsdGVyXzEpLnRoZW4oZnVuY3Rpb24gKGxvZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaChmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChmaWx0ZXJfMSwgbG9nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuXHQgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcIm5ldHdvcmtcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG5cdCAgICAvLyBjYW4gY2hhbmdlLCBzdWNoIGFzIHdoZW4gY29ubmVjdGVkIHRvIGEgSlNPTi1SUEMgYmFja2VuZFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIGN1cnJlbnROZXR3b3JrLCBlcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZWFkeV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbnlOZXR3b3JrKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IGN1cnJlbnROZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgaW50ZXJuYWwgYmxvY2sgbnVtYmVyIGd1YXJkcyBhbmQgY2FjaGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSAtMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwibmV0d29ya1wiIGV2ZW50IE1VU1QgaGFwcGVuIGJlZm9yZSB0aGlzIG1ldGhvZCByZXNvbHZlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBhbnkgZXZlbnRzIGhhdmUgYSBjaGFuY2UgdG8gdW5yZWdpc3Rlciwgc28gd2Ugc3RhbGwgYW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudCBsb29wIGJlZm9yZSByZXR1cm5pbmcgZnJvbSAvdGhpcy8gY2FsbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGN1cnJlbnROZXR3b3JrLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGxvZ2dlci5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXR3b3JrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwiYmxvY2tOdW1iZXJcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbihmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnBvbGwuYmluZCh0aGlzKSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxpbmcgd2FzIGRpc2FibGVkLCBzb21ldGhpbmcgbWF5IHJlcXVpcmUgYSBwb2tlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9sbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ib290c3RyYXBQb2xsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMucG9sbGluZ0ludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb2xsaW5nSW50ZXJ2YWxcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBfdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEZhc3RCbG9ja051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gU3RhbGUgYmxvY2sgbnVtYmVyLCByZXF1ZXN0IGEgbmV3ZXIgdmFsdWVcblx0ICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gX3RoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc2V0RmFzdEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgLy8gT2xkZXIgYmxvY2ssIG1heWJlIGEgc3RhbGUgcmVxdWVzdFxuXHQgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuXHQgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gTmV3ZXIgYmxvY2sgbnVtYmVyLCB1c2UgIGl0XG5cdCAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS53YWl0Rm9yVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVjZWlwdDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXB0IGlzIGFscmVhZHkgZ29vZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sbCB1bnRpbCB0aGUgcmVjZWlwdCBpcyBnb29kLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgdGltZW91dCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0R2FzUHJpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSkudG9OdW1iZXIoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGxpYiQxLmhleGxpZnk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFN0b3JhZ2VBdCA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBwb3NpdGlvbiwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbihmdW5jdGlvbiAocCkgeyByZXR1cm4gbGliJDEuaGV4VmFsdWUocCk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbGliJDEuaGV4bGlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0U3RvcmFnZUF0XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBzdWJjbGFzcyB3cmFwcGluZyBhIFRyYW5zYWN0aW9uUmVzcG9uc2Vcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3dyYXBUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0eCwgaGFzaCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBsaWIkMS5oZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdHg7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcblx0ICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogKGNvbmZpcm1hdGlvbnM/IG51bWJlciwgdGltZW91dD8gbnVtYmVyKVxuXHQgICAgICAgIHJlc3VsdC53YWl0ID0gZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpcHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyB0cmFuc2FjdGlvbiAqbXVzdCogZXhpc3QgKHdoZXRoZXIgaXQgZ2V0cyBtaW5lZCBpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHN0b3J5KSwgc28gc2V0dGluZyBhbiBlbWl0dGVkIHZhbHVlIGZvcmNlcyB1cyB0b1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGV2ZW4gaWYgdGhlIG5vZGUgcmV0dXJucyBudWxsIGZvciB0aGUgcmVjZWlwdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IFwicGVuZGluZ1wiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybWF0aW9ucyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGxvbmdlciBwZW5kaW5nLCBhbGxvdyB0aGUgcG9sbGluZyBsb29wIHRvIGdhcmJhZ2UgY29sbGVjdCB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHJhbnNhY3Rpb24gZmFpbGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eC5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pOyB9O1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmVkVHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoZXhUeCwgdHgsIGhhc2gsIGVycm9yXzI7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHQpOyB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhUeCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yLnRyYW5zYWN0aW9uID0gdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIudHJhbnNhY3Rpb25IYXNoID0gdHguaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0ID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzLCB0eCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmFuc2FjdGlvbl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBfdGhpcy5fZ2V0QWRkcmVzcyh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gbGliJDEuaGV4bGlmeSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLnRyYW5zYWN0aW9uUmVxdWVzdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmaWx0ZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxvY2tIYXNoXCIsIFwidG9waWNzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnJvbUJsb2NrXCIsIFwidG9CbG9ja1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBfdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5oZXhsaWZ5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IGxpYiQyLkJpZ051bWJlcikuZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWUoXCIgKyBKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKSArIFwiKVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9ja051bWJlciwgcGFyYW1zLCBfYSwgX2IsIF9jLCBlcnJvcl8zO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJsb2NrSGFzaE9yQmxvY2tUYWddO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAtMTI4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHBhcmFtcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSB0aGlzLmZvcm1hdHRlcikuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrSGFzaE9yQmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmJsb2NrVGFnID0gX2MuYXBwbHkoX2IsIFtfZC5zZW50KCldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBsaWIkbC5wb2xsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jaywgYmxvY2tOdW1iZXJfMSwgaSwgdHgsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsb2NrIHdhcyBub3QgZm91bmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGlzdC4gSWYgd2UgZGlkIHNlZSBpdCB0aG91Z2gsIHBlcmhhcHMgZnJvbSBhIGxvZywgd2Uga25vd1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgcGFyYW1zLmJsb2NrSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVUcmFuc2FjdGlvbnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja051bWJlcl8xID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXJfMSAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChibG9ja0hhc2hPckJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgdHgsIGJsb2NrTnVtYmVyLCBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5ibG9ja051bWJlciA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgcmVjZWlwdCwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldExvZ3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCBsb2dzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZvcm1hdHRlci5Gb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFdGhlclByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja1RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbmV0d29yaywgdHJhbnNhY3Rpb24sIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gRU5TLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJFTlNcIiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IG5ldHdvcmsuZW5zQWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4MDE3OGI4YmZcIiArIGxpYiQ5Lm5hbWVoYXNoKG5hbWUpLnN1YnN0cmluZygyKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuY2FsbEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbCh0cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXNvbHZlckFkZHJlc3MsIHRyYW5zYWN0aW9uLCBfYSwgX2I7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcobmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkcmVzcyA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDNiM2I1N2RlXCIgKyBsaWIkOS5uYW1laGFzaChuYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLmNhbGxBZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGwodHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5sb29rdXBBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTmFtZSwgcmVzb2x2ZXJBZGRyZXNzLCBieXRlcywgX2EsIGxlbmd0aCwgbmFtZSwgYWRkcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKHJldmVyc2VOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlckFkZHJlc3MgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5hcnJheWlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIGxpYiQ5Lm5hbWVoYXNoKHJldmVyc2VOYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIGR5bmFtaWMgc3RyaW5nIHBvaW50ZXIgKDB4MjApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMiB8fCAhbGliJDIuQmlnTnVtYmVyLmZyb20oYnl0ZXMuc2xpY2UoMCwgMzIpKS5lcSgzMikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKDMyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLCAzMikpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGggbG9uZ2VyIHRoYW4gYXZhaWxhYmxlIGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBsaWIkOC50b1V0ZjhTdHJpbmcoYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUobmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkciA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgIT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuYW1lXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBzdG9wcGVkID0gW107XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseShfdGhpcywgYXJncyk7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuXHQgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTtcblx0ICAgICAgICB9KS5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubGlzdGVuZXI7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcblx0ICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTsgfSlcblx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50Lmxpc3RlbmVyOyB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZm91bmQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHN0b3BwZWQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgX3RoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcblx0ICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcblx0ICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnRUYWdfMSA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZ18xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJhc2VQcm92aWRlcjtcblx0fShsaWIkYi5Qcm92aWRlcikpO1xuXHRleHBvcnRzLkJhc2VQcm92aWRlciA9IEJhc2VQcm92aWRlcjtcblx0fSk7XG5cblx0dmFyIGJhc2VQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhiYXNlUHJvdmlkZXIpO1xuXHR2YXIgYmFzZVByb3ZpZGVyXzEgPSBiYXNlUHJvdmlkZXIuRXZlbnQ7XG5cdHZhciBiYXNlUHJvdmlkZXJfMiA9IGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXI7XG5cblx0dmFyIGpzb25ScGNQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0ZnVuY3Rpb24gdGltZXIodGltZW91dCkge1xuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG5cdCAgICBpZiAocGF5bG9hZC5lcnJvcikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG5cdCAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcblx0ICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEpzb25ScGNTaWduZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBKc29uUnBjU2lnbmVyKGNvbnN0cnVjdG9yR3VhcmQsIHByb3ZpZGVyLCBhZGRyZXNzT3JJbmRleCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBKc29uUnBjU2lnbmVyKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgYWRkcmVzc09ySW5kZXggPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2luZGV4XCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfaW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfYWRkcmVzc1wiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgaW5kZXhcIiwgXCJhZGRyZXNzT3JJbmRleFwiLCBhZGRyZXNzT3JJbmRleCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgYWx0ZXIgSlNPTi1SUEMgU2lnbmVyIGNvbm5lY3Rpb25cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjb25uZWN0XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5jb25uZWN0VW5jaGVja2VkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVW5jaGVja2VkSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcy5wcm92aWRlciwgdGhpcy5fYWRkcmVzcyB8fCB0aGlzLl9pbmRleCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0aGlzLl9hZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYWRkcmVzcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKGFjY291bnRzKSB7XG5cdCAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPD0gX3RoaXMuX2luZGV4KSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVua25vd24gYWNjb3VudCAjXCIgKyBfdGhpcy5faW5kZXgsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRBZGRyZXNzXCJcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1tfdGhpcy5faW5kZXhdKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRyYW5zYWN0aW9uID0gbGliJDMuc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIHZhciBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuXHQgICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuXHQgICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGVzdGltYXRlID0gbGliJDMuc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICBlc3RpbWF0ZS5mcm9tID0gZnJvbUFkZHJlc3M7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyhlc3RpbWF0ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgIHR4OiBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbiksXG5cdCAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3Ncblx0ICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIgdHggPSBfYS50eCwgc2VuZGVyID0gX2Euc2VuZGVyO1xuXHQgICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHguZnJvbSA9IHNlbmRlcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaGV4VHggPSBfdGhpcy5wcm92aWRlci5jb25zdHJ1Y3Rvci5oZXhsaWZ5VHJhbnNhY3Rpb24odHgsIHsgZnJvbTogdHJ1ZSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IEpzb25ScGNQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24gKEBUT0RPOiBFeHBvc2UgYSAuX3Rocm93RXJyb3I/Pylcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwibm9uY2UgdG9vIGxvd1wiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInNpZ25pbmcgdHJhbnNhY3Rpb25zIGlzIHVuc3VwcG9ydGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnblRyYW5zYWN0aW9uXCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJGwucG9sbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHggPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIHsgb25jZUJsb2NrOiBfdGhpcy5wcm92aWRlciB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gbGliJDgudG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgbGliJDEuaGV4bGlmeShkYXRhKV0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnVubG9jayA9IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuXHQgICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMucHJvdmlkZXI7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEpzb25ScGNTaWduZXI7XG5cdH0obGliJGMuU2lnbmVyKSk7XG5cdGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IEpzb25ScGNTaWduZXI7XG5cdHZhciBVbmNoZWNrZWRKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFVuY2hlY2tlZEpzb25ScGNTaWduZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIFVuY2hlY2tlZEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uIChoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBnYXNMaW1pdDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgY2hhaW5JZDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG5cdCAgICAgICAgICAgICAgICBmcm9tOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgd2FpdDogZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHsgcmV0dXJuIF90aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBjb25maXJtYXRpb25zKTsgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBVbmNoZWNrZWRKc29uUnBjU2lnbmVyO1xuXHR9KEpzb25ScGNTaWduZXIpKTtcblx0dmFyIGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG5cdCAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdmFsdWU6IHRydWVcblx0fTtcblx0dmFyIEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBKc29uUnBjUHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEpzb25ScGNQcm92aWRlcik7XG5cdCAgICAgICAgdmFyIG5ldHdvcmtPclJlYWR5ID0gbmV0d29yaztcblx0ICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG5cdCAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbmV0d29ya09yUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihmdW5jdGlvbiAobmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmtPclJlYWR5KSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIERlZmF1bHQgVVJMXG5cdCAgICAgICAgaWYgKCF1cmwpIHtcblx0ICAgICAgICAgICAgdXJsID0gbGliJDMuZ2V0U3RhdGljKF90aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoe1xuXHQgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKGxpYiQzLnNoYWxsb3dDb3B5KHVybCkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMuX25leHRJZCA9IDQyO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEpzb25ScGNQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQsIGVycm9yXzEsIGVycm9yXzIsIGdldE5ldHdvcms7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRpbWVyKDApXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA5XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbNSwgNywgLCA4XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZChcIm5ldF92ZXJzaW9uXCIsIFtdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXROZXR3b3JrID0gbGliJDMuZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0TmV0d29ya1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldE5ldHdvcmsobGliJDIuQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0U2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3NPckluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLCBhZGRyZXNzT3JJbmRleCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRVbmNoZWNrZWRTaWduZXIgPSBmdW5jdGlvbiAoYWRkcmVzc09ySW5kZXgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpLmNvbm5lY3RVbmNoZWNrZWQoKTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmxpc3RBY2NvdW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKGFjY291bnRzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpOyB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dElkKyspLFxuXHQgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgIHJlcXVlc3Q6IGxpYiQzLmRlZXBDb3B5KHJlcXVlc3QpLFxuXHQgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBsaWIkbC5mZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcblx0ICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfYmxvY2tOdW1iZXJcIiwgW11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2FzUHJpY2VcIiwgW11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldENvZGVcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLmJsb2NrSGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhleGxpZnlUcmFuc2FjdGlvbiA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfY2FsbFwiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhleGxpZnlUcmFuc2FjdGlvbiA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZXN0aW1hdGVHYXNcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlciAmJiBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRMb2dzXCIsIFtwYXJhbXMuZmlsdGVyXV07XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFdlIG5lZWQgYSBsaXR0bGUgZXh0cmEgbG9naWMgdG8gcHJvY2VzcyBlcnJvcnMgZnJvbSBzZW5kVHJhbnNhY3Rpb25cblx0ICAgICAgICBpZiAobWV0aG9kID09PSBcInNlbmRUcmFuc2FjdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWVcIlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcImluc3VmZmljaWVudCBmdW5kc1wiKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLCB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwibm9uY2UgdG9vIGxvd1wiKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChhcmdzWzBdLCBhcmdzWzFdKTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRQZW5kaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHBlbmRpbmdGaWx0ZXIgPSB0aGlzLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcblx0ICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcblx0ICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG5cdCAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVzLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VxID0gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHBvbGwoKTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcG9sbCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG5cdCAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiICYmIHRoaXMubGlzdGVuZXJDb3VudChcInBlbmRpbmdcIikgPT09IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0b3BFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgIH07XG5cdCAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cblx0ICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuXHQgICAgLy8gIC0gQWxsIHZhbHVlcyBoZXhsaWZpZWRcblx0ICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcblx0ICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcblx0ICAgIC8vIE5PVEU6IFRoaXMgYWxsb3dzIGEgVHJhbnNhY3Rpb25SZXF1ZXN0LCBidXQgYWxsIHZhbHVlcyBzaG91bGQgYmUgcmVzb2x2ZWRcblx0ICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuXHQgICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG5cdCAgICAvLyAgICAgICAgd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZCBmb3IgdGhpcy5cblx0ICAgIEpzb25ScGNQcm92aWRlci5oZXhsaWZ5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcblx0ICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cblx0ICAgICAgICB2YXIgYWxsb3dlZCA9IGxpYiQzLnNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuXHQgICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxvd0V4dHJhKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYWxsb3dFeHRyYVtrZXldKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5jaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWQpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICAvLyBTb21lIG5vZGVzIChJTkZVUkEgcm9wc3RlbjsgSU5GVVJBIG1haW5uZXQgaXMgZmluZSkgZG8gbm90IGxpa2UgbGVhZGluZyB6ZXJvcy5cblx0ICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpYiQxLmhleFZhbHVlKHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBsaWIkMS5oZXhsaWZ5KHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEpzb25ScGNQcm92aWRlcjtcblx0fShiYXNlUHJvdmlkZXIuQmFzZVByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIganNvblJwY1Byb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGpzb25ScGNQcm92aWRlcik7XG5cdHZhciBqc29uUnBjUHJvdmlkZXJfMSA9IGpzb25ScGNQcm92aWRlci5Kc29uUnBjU2lnbmVyO1xuXHR2YXIganNvblJwY1Byb3ZpZGVyXzIgPSBqc29uUnBjUHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyO1xuXG5cdHZhciB1cmxKc29uUnBjUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIFVybEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhVcmxKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBVcmxKc29uUnBjUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgVXJsSnNvblJwY1Byb3ZpZGVyKTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcblx0ICAgICAgICBuZXR3b3JrID0gbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgIGFwaUtleSA9IGxpYiQzLmdldFN0YXRpYygoX25ld1RhcmdldCksIFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbiwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIGtleSwgYXBpS2V5W2tleV0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMubmV0d29ya107XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcblx0ICAgIH07XG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcImdldFNpZ25lclwiIH0pO1xuXHQgICAgfTtcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUubGlzdEFjY291bnRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybiBhIGRlZmF1bHRBcGlLZXkgaWYgbnVsbCwgb3RoZXJ3aXNlIHZhbGlkYXRlIHRoZSBBUEkga2V5XG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIHJldHVybiBhcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJucyB0aGUgdXJsIG9yIGNvbm5lY3Rpb24gZm9yIHRoZSBnaXZlbiBuZXR3b3JrIGFuZCBBUEkga2V5LiBUaGVcblx0ICAgIC8vIEFQSSBrZXkgd2lsbCBoYXZlIGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBnZXRBcGlLZXkgZmlyc3QsIHNvIGFueSB2YWxpZGF0aW9uXG5cdCAgICAvLyBvciB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRvbmUgdGhlcmUuXG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDsgc3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXRVcmxcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRVcmxcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBVcmxKc29uUnBjUHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLlVybEpzb25ScGNQcm92aWRlciA9IFVybEpzb25ScGNQcm92aWRlcjtcblx0fSk7XG5cblx0dmFyIHVybEpzb25ScGNQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyh1cmxKc29uUnBjUHJvdmlkZXIpO1xuXHR2YXIgdXJsSnNvblJwY1Byb3ZpZGVyXzEgPSB1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyO1xuXG5cdHZhciBhbGNoZW15UHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLyBUaGlzIGtleSB3YXMgcHJvdmlkZWQgdG8gZXRoZXJzLmpzIGJ5IEFsY2hlbXkgdG8gYmUgdXNlZCBieSB0aGVcblx0Ly8gZGVmYXVsdCBwcm92aWRlciwgYnV0IGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgZm9yIHlvdXIgb3duXG5cdC8vIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLCB0aGF0IHlvdSBhY3F1aXJlIHlvdXIgb3duIEFQSSBrZXkgYXQ6XG5cdC8vICAgaHR0cHM6Ly9kYXNoYm9hcmQuYWxjaGVteWFwaS5pb1xuXHR2YXIgZGVmYXVsdEFwaUtleSA9IFwiX2dnN3dTU2kwS01Cc2RLbkdWZkhEdWVxNnhNQjlFa0NcIjtcblx0dmFyIEFsY2hlbXlQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhBbGNoZW15UHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBbGNoZW15UHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBcGlLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXBpS2V5O1xuXHQgICAgfTtcblx0ICAgIEFsY2hlbXlQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW8vanNvbnJwYy9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uYWxjaGVteWFwaS5pby9qc29ucnBjL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtcmlua2VieS5hbGNoZW15YXBpLmlvL2pzb25ycGMvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5hbGNoZW15YXBpLmlvL2pzb25ycGMvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgta292YW4uYWxjaGVteWFwaS5pby9qc29ucnBjL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIChcImh0dHBzOi9cIiArIFwiL1wiICsgaG9zdCArIGFwaUtleSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFsY2hlbXlQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gQWxjaGVteVByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgYWxjaGVteVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFsY2hlbXlQcm92aWRlcik7XG5cdHZhciBhbGNoZW15UHJvdmlkZXJfMSA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXI7XG5cblx0dmFyIGNsb3VkZmxhcmVQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0dmFyIENsb3VkZmxhcmVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDbG91ZGZsYXJlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDbG91ZGZsYXJlUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFwaUtleSBub3Qgc3VwcG9ydGVkIGZvciBjbG91ZGZsYXJlXCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vY2xvdWRmbGFyZS1ldGguY29tL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGhvc3Q7XG5cdCAgICB9O1xuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJnZXRCbG9ja051bWJlclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIFwiZ2V0QmxvY2tcIiwgeyBibG9ja1RhZzogXCJsYXRlc3RcIiB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrLm51bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5wZXJmb3JtLmNhbGwodGhpcywgbWV0aG9kLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENsb3VkZmxhcmVQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgY2xvdWRmbGFyZVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGNsb3VkZmxhcmVQcm92aWRlcik7XG5cdHZhciBjbG91ZGZsYXJlUHJvdmlkZXJfMSA9IGNsb3VkZmxhcmVQcm92aWRlci5DbG91ZGZsYXJlUHJvdmlkZXI7XG5cblx0dmFyIGV0aGVyc2NhblByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLyBUaGUgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGNhbGxzIGluIFByb3ZpZGVyXG5cdGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uU3RyaW5nKHRyYW5zYWN0aW9uKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdmFsdWUgPSBsaWIkMS5oZXhsaWZ5KHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgIGlmICh7IGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHZhbHVlOiB0cnVlIH1ba2V5XSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGxpYiQxLmhleFZhbHVlKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0LnB1c2goa2V5ICsgXCI9XCIgKyB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCImXCIpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJlc3VsdChyZXN1bHQpIHtcblx0ICAgIC8vIGdldExvZ3MsIGdldEhpc3RvcnkgaGF2ZSB3ZWlyZCBzdWNjZXNzIHJlc3BvbnNlc1xuXHQgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gMCAmJiAocmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gcmVjb3JkcyBmb3VuZFwiIHx8IHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHRyYW5zYWN0aW9ucyBmb3VuZFwiKSkge1xuXHQgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXHQgICAgfVxuXHQgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gMSB8fCByZXN1bHQubWVzc2FnZSAhPSBcIk9LXCIpIHtcblx0ICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7XG5cdCAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGdldEpzb25SZXN1bHQocmVzdWx0KSB7XG5cdCAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcblx0ICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcblx0ICAgICAgICBpZiAocmVzdWx0LmVycm9yLmNvZGUpIHtcblx0ICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3VsdC5lcnJvci5jb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LmVycm9yLmRhdGEpIHtcblx0ICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHJlc3VsdC5lcnJvci5kYXRhO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXHR9XG5cdC8vIFRoZSBibG9ja1RhZyB3YXMgbm9ybWFsaXplZCBhcyBhIHN0cmluZyBieSB0aGUgUHJvdmlkZXIgcHJlLXBlcmZvcm0gb3BlcmF0aW9uc1xuXHRmdW5jdGlvbiBjaGVja0xvZ1RhZyhibG9ja1RhZykge1xuXHQgICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBlbmRpbmcgbm90IHN1cHBvcnRlZFwiKTtcblx0ICAgIH1cblx0ICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIikge1xuXHQgICAgICAgIHJldHVybiBibG9ja1RhZztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYXJzZUludChibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcblx0fVxuXHR2YXIgZGVmYXVsdEFwaUtleSA9IFwiOUQxM1pFN1hTQlRKOTROOUJOSjJNQTMzVk1BWTJZUElSQlwiO1xuXHR2YXIgRXRoZXJzY2FuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRXRoZXJzY2FuUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBFdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgRXRoZXJzY2FuUHJvdmlkZXIpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICB2YXIgbmFtZSA9IFwiaW52YWxpZFwiO1xuXHQgICAgICAgIGlmIChfdGhpcy5uZXR3b3JrKSB7XG5cdCAgICAgICAgICAgIG5hbWUgPSBfdGhpcy5uZXR3b3JrLm5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlVXJsID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcblx0ICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLXJpbmtlYnkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImJhc2VVcmxcIiwgYmFzZVVybCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5KTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLm5ldHdvcmtdO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHVybCwgYXBpS2V5LCBnZXQsIF9hLCB0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24sIHRvcGljMCwgbG9ncywgdHhzLCBpLCBsb2csIHR4LCBfYjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5iYXNlVXJsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXkgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleSArPSBcIiZhcGlrZXk9XCIgKyB0aGlzLmFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXQgPSBmdW5jdGlvbiAodXJsLCBwcm9jRnVuYykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkbC5mZXRjaEpzb24odXJsLCBudWxsLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGxpYiQzLmRlZXBDb3B5KHJlc3VsdCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9ibG9ja051bWJlclwiICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nYXNQcmljZVwiICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJucyBiYXNlLTEwIHJlc3VsdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1hY2NvdW50JmFjdGlvbj1iYWxhbmNlJmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwsIGdldFJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkNvdW50JmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0Q29kZSZhZGRyZXNzPVwiICsgcGFyYW1zLmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0YWc9XCIgKyBwYXJhbXMuYmxvY2tUYWcgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsLCBnZXRKc29uUmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFN0b3JhZ2VBdCZhZGRyZXNzPVwiICsgcGFyYW1zLmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZwb3NpdGlvbj1cIiArIHBhcmFtcy5wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwsIGdldEpzb25SZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfc2VuZFJhd1RyYW5zYWN0aW9uJmhleD1cIiArIHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJbnN1ZmZpY2llbnQgZnVuZHMuIFRoZSBhY2NvdW50IHlvdSB0cmllZCB0byBzZW5kIHRyYW5zYWN0aW9uIGZyb20gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkIDIxNDY0MDAwMDAwMDAwIGFuZCBnb3Q6IDBcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImluc3VmZmljaWVudCBmdW5kc1wiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIlRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC5cIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJzYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWRcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiVHJhbnNhY3Rpb24gZ2FzIHByaWNlIGlzIHRvbyBsb3cuIFRoZXJlIGlzIGFub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlIGluIHRoZSBxdWV1ZS4gVHJ5IGluY3JlYXNpbmcgdGhlIGdhcyBwcmljZSBvciBpbmNyZW1lbnRpbmcgdGhlIG5vbmNlLlwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcImFub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlXCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgbGliLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0QmxvY2tCeU51bWJlciZ0YWc9XCIgKyBwYXJhbXMuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImYm9vbGVhbj10cnVlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImYm9vbGVhbj1mYWxzZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QmxvY2sgYnkgYmxvY2tIYXNoIG5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gmdHhoYXNoPVwiICsgcGFyYW1zLnRyYW5zYWN0aW9uSGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCZ0eGhhc2g9XCIgKyBwYXJhbXMudHJhbnNhY3Rpb25IYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gZ2V0VHJhbnNhY3Rpb25TdHJpbmcocGFyYW1zLnRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gXCImXCIgKyB0cmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfY2FsbFwiICsgdHJhbnNhY3Rpb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VybCArPSBcIiZ0YWc9XCIgKyBwYXJhbXMuYmxvY2tUYWcgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9PSBcImxhdGVzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJzY2FuUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBibG9ja1RhZyBmb3IgY2FsbFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBnZXRUcmFuc2FjdGlvblN0cmluZyhwYXJhbXMudHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBcIiZcIiArIHRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9lc3RpbWF0ZUdhcyZcIiArIHRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1sb2dzJmFjdGlvbj1nZXRMb2dzXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmZyb21CbG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJmZyb21CbG9jaz1cIiArIGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImdG9CbG9jaz1cIiArIGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIudG9CbG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJmFkZHJlc3M9XCIgKyBwYXJhbXMuZmlsdGVyLmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdlIGNhbiBoYW5kbGUgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBsb2dzIHVzaW5nIHRoZSBsb2dzIEFQSVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MgJiYgcGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGNvdW50XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljMCkgIT09IFwic3RyaW5nXCIgfHwgdG9waWMwLmxlbmd0aCAhPT0gNjYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBmb3JtYXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljMDogdG9waWMwIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImdG9waWMwPVwiICsgdG9waWMwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldCh1cmwsIGdldFJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4cyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgbG9ncy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZyA9IGxvZ3NbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tIYXNoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eHNbbG9nLnRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhzW2xvZy50cmFuc2FjdGlvbkhhc2hdID0gdHguYmxvY2tIYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTc7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IHR4c1tsb2cudHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxODtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nc107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lICE9PSBcImhvbWVzdGVhZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMC4wXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1zdGF0cyZhY3Rpb249ZXRocHJpY2VcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBwYXJzZUZsb2F0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXQodXJsLCBnZXRSZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkodm9pZCAwLCBbKF9jLnNlbnQoKSkuZXRodXNkXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDIzXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5wZXJmb3JtLmNhbGwodGhpcywgbWV0aG9kLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86IEFsbG93IHN0YXJ0QmxvY2sgYW5kIGVuZEJsb2NrIHRvIGJlIFByb21pc2VzXG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBzdGFydEJsb2NrLCBlbmRCbG9jaykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZVVybDtcblx0ICAgICAgICB2YXIgYXBpS2V5ID0gXCJcIjtcblx0ICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcblx0ICAgICAgICAgICAgYXBpS2V5ICs9IFwiJmFwaWtleT1cIiArIHRoaXMuYXBpS2V5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoc3RhcnRCbG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZW5kQmxvY2sgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBlbmRCbG9jayA9IDk5OTk5OTk5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPVwiICsgYWRkcmVzcztcblx0ICAgICAgICAgICAgdXJsICs9IFwiJnN0YXJ0YmxvY2s9XCIgKyBzdGFydEJsb2NrO1xuXHQgICAgICAgICAgICB1cmwgKz0gXCImZW5kYmxvY2s9XCIgKyBlbmRCbG9jaztcblx0ICAgICAgICAgICAgdXJsICs9IFwiJnNvcnQ9YXNjXCIgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJGwuZmV0Y2hKc29uKHVybCwgbnVsbCwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBsaWIkMy5kZWVwQ29weShyZXN1bHQpLFxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cdCAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBbXCJjb250cmFjdEFkZHJlc3NcIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHguY3JlYXRlcyA9PSBudWxsICYmIHR4LmNvbnRyYWN0QWRkcmVzcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNyZWF0ZXMgPSB0eC5jb250cmFjdEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eC50aW1lU3RhbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV0aGVyc2NhblByb3ZpZGVyO1xuXHR9KGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IEV0aGVyc2NhblByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgZXRoZXJzY2FuUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoZXRoZXJzY2FuUHJvdmlkZXIpO1xuXHR2YXIgZXRoZXJzY2FuUHJvdmlkZXJfMSA9IGV0aGVyc2NhblByb3ZpZGVyLkV0aGVyc2NhblByb3ZpZGVyO1xuXG5cdHZhciBmYWxsYmFja1Byb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBub3coKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5cdC8vIFJldHVybnMgdG8gbmV0d29yayBhcyBsb25nIGFzIGFsbCBhZ3JlZSwgb3IgbnVsbCBpZiBhbnkgaXMgbnVsbC5cblx0Ly8gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB0d28gbmV0d29ya3MgZG8gbm90IG1hdGNoLlxuXHRmdW5jdGlvbiBjaGVja05ldHdvcmtzKG5ldHdvcmtzKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV0d29ya3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgbmV0d29yayA9IG5ldHdvcmtzW2ldO1xuXHQgICAgICAgIC8vIE51bGwhIFdlIGRvIG5vdCBrbm93IG91ciBuZXR3b3JrOyBiYWlsLlxuXHQgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXR3b3JrIG1hdGNoZXMgdGhlIHByZXZpb3VzIG5ldHdvcmtzXG5cdCAgICAgICAgICAgIGlmICghKHJlc3VsdC5uYW1lID09PSBuZXR3b3JrLm5hbWUgJiYgcmVzdWx0LmNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCAmJlxuXHQgICAgICAgICAgICAgICAgKChyZXN1bHQuZW5zQWRkcmVzcyA9PT0gbmV0d29yay5lbnNBZGRyZXNzKSB8fCAocmVzdWx0LmVuc0FkZHJlc3MgPT0gbnVsbCAmJiBuZXR3b3JrLmVuc0FkZHJlc3MgPT0gbnVsbCkpKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsIFwibmV0d29ya3NcIiwgbmV0d29ya3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBuZXR3b3JrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgbWF4RGVsdGEpIHtcblx0ICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgpLnNvcnQoKTtcblx0ICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcblx0ICAgIC8vIE9kZCBsZW5ndGg7IHRha2UgdGhlIG1pZGRsZVxuXHQgICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRkbGVdO1xuXHQgICAgfVxuXHQgICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGVcblx0ICAgIHZhciBhID0gdmFsdWVzW21pZGRsZSAtIDFdLCBiID0gdmFsdWVzW21pZGRsZV07XG5cdCAgICBpZiAobWF4RGVsdGEgIT0gbnVsbCAmJiBNYXRoLmFicyhhIC0gYikgPiBtYXhEZWx0YSkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIChhICsgYikgLyAyO1xuXHR9XG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAobGliJDIuQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBzZXJpYWxpemUoaSk7IH0pKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cdCAgICAgICAga2V5cy5zb3J0KCk7XG5cdCAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICB2YXIgdiA9IHZhbHVlW2tleV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIHYgPSBcIltmdW5jdGlvbl1cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHYgPSBzZXJpYWxpemUodik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjpcIiArIHY7XG5cdCAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIjtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWUgdHlwZTogXCIgKyB0eXBlb2YgKHZhbHVlKSk7XG5cdH1cblx0Ly8gTmV4dCByZXF1ZXN0IElEIHRvIHVzZSBmb3IgZW1pdHRpbmcgZGVidWcgaW5mb1xuXHR2YXIgbmV4dFJpZCA9IDE7XG5cdDtcblx0ZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcblx0ICAgIHZhciBjYW5jZWwgPSBudWxsO1xuXHQgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbmNlbCwgZHVyYXRpb24pO1xuXHQgICAgfSkpO1xuXHQgICAgdmFyIHdhaXQgPSBmdW5jdGlvbiAoZnVuYykge1xuXHQgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuYyk7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gZ2V0UHJvbWlzZSgpIHtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNhbmNlbDogY2FuY2VsLCBnZXRQcm9taXNlOiBnZXRQcm9taXNlLCB3YWl0OiB3YWl0IH07XG5cdH1cblx0O1xuXHRmdW5jdGlvbiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdykge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICBwcm92aWRlcjogY29uZmlnLnByb3ZpZGVyLFxuXHQgICAgICAgIHdlaWdodDogY29uZmlnLndlaWdodFxuXHQgICAgfTtcblx0ICAgIGlmIChjb25maWcuc3RhcnQpIHtcblx0ICAgICAgICByZXN1bHQuc3RhcnQgPSBjb25maWcuc3RhcnQ7XG5cdCAgICB9XG5cdCAgICBpZiAobm93KSB7XG5cdCAgICAgICAgcmVzdWx0LmR1cmF0aW9uID0gKG5vdyAtIGNvbmZpZy5zdGFydCk7XG5cdCAgICB9XG5cdCAgICBpZiAoY29uZmlnLmRvbmUpIHtcblx0ICAgICAgICBpZiAoY29uZmlnLmVycm9yKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGNvbmZpZy5lcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5yZXN1bHQgPSBjb25maWcucmVzdWx0IHx8IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBxdW9ydW0pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgIC8vIENvdW50IHRoZSB2b3RlcyBmb3IgZWFjaCByZXN1bHRcblx0ICAgICAgICB2YXIgdGFsbHkgPSB7fTtcblx0ICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplKGMucmVzdWx0KTtcblx0ICAgICAgICAgICAgaWYgKCF0YWxseVt2YWx1ZV0pIHtcblx0ICAgICAgICAgICAgICAgIHRhbGx5W3ZhbHVlXSA9IHsgY291bnQ6IDAsIHJlc3VsdDogYy5yZXN1bHQgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0YWxseVt2YWx1ZV0uY291bnQrKztcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBDaGVjayBmb3IgYSBxdW9ydW0gb24gYW55IGdpdmVuIHJlc3VsdFxuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFsbHkpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWxseVtrZXlzW2ldXTtcblx0ICAgICAgICAgICAgaWYgKGNoZWNrLmNvdW50ID49IHF1b3J1bSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLnJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBObyBxdXJvdW1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQcm9jZXNzRnVuYyhwcm92aWRlciwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgIHZhciBub3JtYWxpemUgPSBzZXJpYWxpemU7XG5cdCAgICBzd2l0Y2ggKG1ldGhvZCkge1xuXHQgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1lZGlhbiB2YWx1ZSwgdW5sZXNzIHRoZXJlIGlzIChtZWRpYW4gKyAxKSBpcyBhbHNvXG5cdCAgICAgICAgICAgIC8vIHByZXNlbnQsIGluIHdoaWNoIGNhc2UgdGhhdCBpcyBwcm9iYWJseSB0cnVlIGFuZCB0aGUgbWVkaWFuXG5cdCAgICAgICAgICAgIC8vIGlzIGdvaW5nIHRvIGJlIHN0YWxlIHNvb24uIEluIHRoZSBldmVudCBvZiBhIG1hbGljaW91cyBub2RlLFxuXHQgICAgICAgICAgICAvLyB0aGUgbGllIHdpbGwgYmUgdHJ1ZSBzb29uIGVub3VnaC5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KTtcblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbWVkaWFuIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gbWVkaWFuKGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSksIDIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBNYXRoLmNlaWwoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgYmxvY2sgaGVpZ2h0IGlzIHByZXNlbnQsIGl0cyBwcm9sbHkgc2FmZSB0byB1c2Vcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaW5kZXhPZihibG9ja051bWJlciArIDEpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcisrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZXZlciByb2xsIGJhY2sgdGhlIGJsb2NrTnVtYmVyXG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPj0gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1pZGRsZSAocm91bmQgaW5kZXggdXApIHZhbHVlLCBzaW1pbGFyIHRvIG1lZGlhblxuXHQgICAgICAgICAgICAvLyBidXQgZG8gbm90IGF2ZXJhZ2UgZXZlbiBlbnRyaWVzIGFuZCBjaG9vc2UgdGhlIGhpZ2hlci5cblx0ICAgICAgICAgICAgLy8gTWFsaWNpb3VzIGFjdG9ycyBtdXN0IGNvbXByb21pc2UgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSk7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZXMuc29ydCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKV07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjpcblx0ICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgbWVkaWFuIHByaWNlLiBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSBhdFxuXHQgICAgICAgICAgICAvLyBsZWFzdCA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZSAoaW4gYSBtZWFuaW5nZnVsIHdheSkuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhbihjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAvLyBObyBhZGRpdGlvbmFsIG5vcm1hbGl6aW5nIHJlcXVpcmVkOyBzZXJpYWxpemUgaXMgZW5vdWdoXG5cdCAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG5cdCAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuXHQgICAgICAgIGNhc2UgXCJjYWxsXCI6XG5cdCAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG5cdCAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuXHQgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcblx0ICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdHggPSBsaWIkMy5zaGFsbG93Q29weSh0eCk7XG5cdCAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHR4KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuXHQgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuXHQgICAgICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbGliJDMuc2hhbGxvd0NvcHkoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eDtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG5cdCAgICB9XG5cdCAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBpZiBhbmQgb25seSBpZiB0aGUgZXhwZWN0ZWQgcXVvcnVtIGlzXG5cdCAgICAvLyBzYXRpc2ZpZWQgYW5kIGFncmVlZCB1cG9uIGZvciB0aGUgZmluYWwgcmVzdWx0LlxuXHQgICAgcmV0dXJuIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHByb3ZpZGVyLnF1b3J1bSk7XG5cdH1cblx0Ly8gSWYgd2UgYXJlIGRvaW5nIGEgYmxvY2tUYWcgcXVlcnksIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzXG5cdC8vIGNhdWdodCB1cCB0byB0aGUgRmFsbGJhY2tQcm92aWRlciwgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0IHRvIGl0LlxuXHRmdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgcHJvdmlkZXIgPSAoY29uZmlnLnByb3ZpZGVyKTtcblx0ICAgICAgICAgICAgaWYgKChwcm92aWRlci5ibG9ja051bWJlciAhPSBudWxsICYmIHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB8fCBibG9ja051bWJlciA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlcl07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiRsLnBvbGwoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN5bmNlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZTsganVzdCBxdWl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbGxlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluLCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIHsgb25jZVBvbGw6IHByb3ZpZGVyIH0pXTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIsIF9hLCBmaWx0ZXI7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBjb25maWcucHJvdmlkZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX2EgPSBtZXRob2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5nZXRFdGhlclByaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRFdGhlclByaWNlKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gODtcblx0ICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldFN0b3JhZ2VBdChwYXJhbXMuYWRkcmVzcywgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiBsaWIkMS5pc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnNcIiA6IFwiZ2V0QmxvY2tcIildKHBhcmFtcy5ibG9ja1RhZyB8fCBwYXJhbXMuYmxvY2tIYXNoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiBsaWIkMS5pc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEzOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTQ7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbkhhc2gpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTY6XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gcGFyYW1zLmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISgoZmlsdGVyLmZyb21CbG9jayAmJiBsaWIkMS5pc0hleFN0cmluZyhmaWx0ZXIuZnJvbUJsb2NrKSkgfHwgKGZpbHRlci50b0Jsb2NrICYmIGxpYiQxLmlzSGV4U3RyaW5nKGZpbHRlci50b0Jsb2NrKSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxODtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcblx0ICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdHZhciBGYWxsYmFja1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZhbGxiYWNrUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgcXVvcnVtKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZhbGxiYWNrUHJvdmlkZXIpO1xuXHQgICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLCBcInByb3ZpZGVyc1wiLCBwcm92aWRlcnMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJDb25maWdzID0gcHJvdmlkZXJzLm1hcChmdW5jdGlvbiAoY29uZmlnT3JQcm92aWRlciwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKGxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIoY29uZmlnT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgcHJvdmlkZXI6IGNvbmZpZ09yUHJvdmlkZXIsIHdlaWdodDogMSwgc3RhbGxUaW1lb3V0OiA3NTAsIHByaW9yaXR5OiAxIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjb25maWcgPSBsaWIkMy5zaGFsbG93Q29weShjb25maWdPclByb3ZpZGVyKTtcblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy5wcmlvcml0eSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjb25maWcucHJpb3JpdHkgPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjb25maWcuc3RhbGxUaW1lb3V0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbFRpbWVvdXQgPSA3NTA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgY29uZmlnLndlaWdodCA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG5cdCAgICAgICAgICAgIGlmICh3ZWlnaHQgJSAxIHx8IHdlaWdodCA+IDUxMiB8fCB3ZWlnaHQgPCAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB3ZWlnaHQ7IG11c3QgYmUgaW50ZWdlciBpbiBbMSwgNTEyXVwiLCBcInByb3ZpZGVyc1tcIiArIGluZGV4ICsgXCJdLndlaWdodFwiLCB3ZWlnaHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKGNvbmZpZyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIHRvdGFsID0gcHJvdmlkZXJDb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG5cdCAgICAgICAgaWYgKHF1b3J1bSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHF1b3J1bSA9IHRvdGFsIC8gMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocXVvcnVtID4gdG90YWwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInF1b3J1bSB3aWxsIGFsd2F5cyBmYWlsOyBsYXJnZXIgdGhhbiB0b3RhbCB3ZWlnaHRcIiwgXCJxdW9ydW1cIiwgcXVvcnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQXJlIGFsbCBwcm92aWRlcnMnIG5ldHdvcmtzIGFyZSBrbm93blxuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IGNoZWNrTmV0d29ya3MocHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucHJvdmlkZXIpLm5ldHdvcms7IH0pKTtcblx0ICAgICAgICAvLyBOb3QgYWxsIG5ldHdvcmtzIGFyZSBrbm93bjsgd2UgbXVzdCBzdGFsbFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyQ29uZmlnc1wiLCBPYmplY3QuZnJlZXplKHByb3ZpZGVyQ29uZmlncykpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuXHQgICAgICAgIF90aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSAtMTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBGYWxsYmFja1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmtzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucHJvdmlkZXIuZ2V0TmV0d29yaygpOyB9KSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya3MgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja05ldHdvcmtzKG5ldHdvcmtzKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEZhbGxiYWNrUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzLCBpXzEsIHJlc3VsdCwgcHJvY2Vzc0Z1bmMsIGNvbmZpZ3MsIGN1cnJlbnRCbG9ja051bWJlciwgaSwgZmlyc3QsIF9sb29wXzEsIHRoaXNfMSwgc3RhdGVfMTtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kID09PSBcInNlbmRUcmFuc2FjdGlvblwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnkgc3VjY2VzcyBpcyBnb29kIGVub3VnaCAob3RoZXIgZXJyb3JzIGFyZSBsaWtlbHkgXCJhbHJlYWR5IHNlZW5cIiBlcnJvcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpXzEgPSAwOyBpXzEgPCByZXN1bHRzLmxlbmd0aDsgaV8xKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV8xXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdlcmUgYWxsIGFuIGVycm9yOyBwaWNrIHRoZSBmaXJzdCBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHRzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID09PSAtMSAmJiBtZXRob2QgIT09IFwiZ2V0QmxvY2tOdW1iZXJcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJsb2NrTnVtYmVyKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRnVuYyA9IGdldFByb2Nlc3NGdW5jKHRoaXMsIG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncyA9IGJyb3dzZXIkNi5zaHVmZmxlZCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAobGliJDMuc2hhbGxvd0NvcHkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrTnVtYmVyID0gdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQwLCBpbmZsaWdodFdlaWdodCwgX2xvb3BfMiwgd2FpdGluZywgcmVzdWx0cywgcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSBub3coKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ID0gY29uZmlncy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIChjLnJ1bm5lciAmJiAoKHQwIC0gYy5zdGFydCkgPCBjLnN0YWxsVGltZW91dCkpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBjKSB7IHJldHVybiAoYWNjdW0gKyBjLndlaWdodCk7IH0sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gY29uZmlnc1tpKytdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWQgPSBuZXh0UmlkKys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YXJ0ID0gbm93KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIgPSBzdGFsbChjb25maWcuc3RhbGxUaW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlci53YWl0KGZ1bmN0aW9uICgpIHsgY29uZmlnLnN0YWxsZXIgPSBudWxsOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucnVubmVyID0gZ2V0UnVubmVyKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyLCBtZXRob2QsIHBhcmFtcykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJlc3VsdCA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogbGliJDMuZGVlcENvcHkocGFyYW1zKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogbGliJDMuZGVlcENvcHkocGFyYW1zKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHJpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IGxpYiQzLmRlZXBDb3B5KHBhcmFtcykgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXzFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ICs9IGNvbmZpZy53ZWlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgcnVubmluZyBlbm91Z2ggdG8gbWVldCBxdW9ydW1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmZsaWdodFdlaWdodCA8IHRoaXNfMS5xdW9ydW0gJiYgaSA8IGNvbmZpZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuZG9uZSB8fCAhYy5ydW5uZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5ydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZy5wdXNoKGMuc3RhbGxlci5nZXRQcm9taXNlKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWl0aW5nLmxlbmd0aCkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJhY2Uod2FpdGluZyldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMuZG9uZSAmJiBjLmVycm9yID09IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3VsdHMubGVuZ3RoID49IHRoaXNfMS5xdW9ydW0pKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IHZhbHVlOiByZXN1bHQgfV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFmaXJzdCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbCgxMDApLmdldFByb21pc2UoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNvbmZpZ3MgaGF2ZSBydW4gdG8gY29tcGxldGlvbjsgd2Ugd2lsbCBuZXZlciBnZXQgbW9yZSBkYXRhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlncy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICFjLmRvbmU7IH0pLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImJyZWFrXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRydWUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzdGF0ZV8xLnZhbHVlXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnM7IHNob3VsZG4ndCBiZSBhbnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIG1lZXQgcXVvcnVtXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzdWx0czogY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Vycm9yczogY29uZmlncy5tYXAoKGMpID0+IGMuZXJyb3IpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBleHBvc2VEZWJ1Z0NvbmZpZyhjKTsgfSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZhbGxiYWNrUHJvdmlkZXI7XG5cdH0oYmFzZVByb3ZpZGVyLkJhc2VQcm92aWRlcikpO1xuXHRleHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBGYWxsYmFja1Byb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgZmFsbGJhY2tQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhmYWxsYmFja1Byb3ZpZGVyKTtcblx0dmFyIGZhbGxiYWNrUHJvdmlkZXJfMSA9IGZhbGxiYWNrUHJvdmlkZXIuRmFsbGJhY2tQcm92aWRlcjtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIElwY1Byb3ZpZGVyID0gbnVsbDtcblxuXHR2YXIgYnJvd3NlcklwY1Byb3ZpZGVyID0ge1xuXHRcdElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxuXHR9O1xuXG5cdHZhciBicm93c2VyV3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgV1MgPSBudWxsO1xuXHR0cnkge1xuXHQgICAgV1MgPSBXZWJTb2NrZXQ7XG5cdCAgICBpZiAoV1MgPT0gbnVsbCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdCBwbGVhc2VcIik7XG5cdCAgICB9XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdCAgICB2YXIgbG9nZ2VyXzIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQgICAgV1MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgbG9nZ2VyXzIudGhyb3dFcnJvcihcIldlYlNvY2tldHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFdlYlNvY2tldCgpXCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblx0fSk7XG5cblx0dmFyIGJyb3dzZXJXcyQxID0gdW53cmFwRXhwb3J0cyhicm93c2VyV3MpO1xuXG5cdHZhciB3ZWJzb2NrZXRQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0dmFyIF9faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciB3c18xID0gX19pbXBvcnREZWZhdWx0KGJyb3dzZXJXcyk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0LyoqXG5cdCAqICBOb3Rlczpcblx0ICpcblx0ICogIFRoaXMgcHJvdmlkZXIgZGlmZmVycyBhIGJpdCBmcm9tIHRoZSBwb2xsaW5nIHByb3ZpZGVycy4gT25lIG1haW5cblx0ICogIGRpZmZlcmVuY2UgaXMgaG93IGl0IGhhbmRsZXMgY29uc2lzdGVuY3kuIFRoZSBwb2xsaW5nIHByb3ZpZGVyc1xuXHQgKiAgd2lsbCBzdGFsbCByZXNwb25zZXMgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBzdGF0ZSwgd2hpbGUgdGhpc1xuXHQgKiAgV2ViU29ja2V0IHByb3ZpZGVyIGFzc3VtZXMgdGhlIGNvbm5lY3RlZCBiYWNrZW5kIHdpbGwgbWFuYWdlIHRoaXMuXG5cdCAqXG5cdCAqICBGb3IgZXhhbXBsZSwgaWYgYSBwb2xsaW5nIHByb3ZpZGVyIGVtaXRzIGFuIGV2ZW50IHdoaWNoIGluZGljYXRzXG5cdCAqICB0aGUgZXZlbnQgb2NjdXJyZWQgaW4gYmxvY2toYXNoIFhYWCwgYSBjYWxsIHRvIGZldGNoIHRoYXQgYmxvY2sgYnlcblx0ICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG5cdCAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG5cdCAqICB3aXRoIGVhY2ggb3RoZXIuXG5cdCAqL1xuXHR2YXIgTmV4dElkID0gMTtcblx0Ly8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgUmVhbC10aW1lIEV2ZW50IEFQSSBzZWU6XG5cdC8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcblx0dmFyIFdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdlYlNvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2ViU29ja2V0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZTsgcGxlYXNlIG9wZW4gYW4gaXNzdWUgdG8gZXhwZWRpdGVcblx0ICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IC0xO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl93ZWJzb2NrZXRcIiwgbmV3IHdzXzEuZGVmYXVsdChfdGhpcy5jb25uZWN0aW9uLnVybCkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9yZXF1ZXN0c1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3N1YnNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9zdWJJZHNcIiwge30pO1xuXHQgICAgICAgIC8vIFN0YWxsIHNlbmRpbmcgcmVxdWVzdHMgdW50aWwgdGhlIHNvY2tldCBpcyBvcGVuLi4uXG5cdCAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSBmYWxzZTtcblx0ICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSB0cnVlO1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5fcmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0LnNlbmQoX3RoaXMuX3JlcXVlc3RzW2lkXS5wYXlsb2FkKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlRXZlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSBtZXNzYWdlRXZlbnQuZGF0YTtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gU3RyaW5nKHJlc3VsdC5pZCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF90aGlzLl9yZXF1ZXN0c1tpZF07XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX3JlcXVlc3RzW2lkXTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShlcnJvciwgXCJjb2RlXCIsIHJlc3VsdC5lcnJvci5jb2RlIHx8IG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKSwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbi4uLlxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YiA9IF90aGlzLl9zdWJzW3Jlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uXTtcblx0ICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViLnByb2Nlc3NGdW5jKHJlc3VsdC5wYXJhbXMucmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIFRoaXMgUHJvdmlkZXIgZG9lcyBub3QgYWN0dWFsbHkgcG9sbCwgYnV0IHdlIHdhbnQgdG8gdHJpZ2dlclxuXHQgICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3Jcblx0ICAgICAgICAvLyBibG9jayBhbmQgdHJhbnNhY3Rpb24gbG9va3Vwcylcblx0ICAgICAgICB2YXIgZmF1eFBvbGwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwb2xsXCIpO1xuXHQgICAgICAgIH0sIDEwMDApO1xuXHQgICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuXHQgICAgICAgICAgICBmYXV4UG9sbC51bnJlZigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdJbnRlcnZhbFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgaW50ZXJ2YWwgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ0ludGVydmFsXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jayA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ1wiLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmlkID0gTmV4dElkKys7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgICAgIGlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHBheWxvYWQ6IHBheWxvYWQgfTtcblx0ICAgICAgICAgICAgaWYgKF90aGlzLl93c1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBcIndzOi9cXC9sb2NhbGhvc3Q6ODU0NlwiO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3ViSWRQcm9taXNlLCBzdWJJZDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4oZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3ViSWRQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnOiB0YWcsIHByb2Nlc3NGdW5jOiBwcm9jZXNzRnVuYyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgX3RoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZW1pdFJlY2VpcHRfMSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gZXZlbnQuaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuXHQgICAgICAgICAgICAgICAgZW1pdFJlY2VpcHRfMShldmVudCk7XG5cdCAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuXHQgICAgICAgICAgICAgICAgLy8gdG8ga2VlcCBhbiBleWUgb3V0IGZvciB0cmFuc2FjdGlvbnMgd2UgYXJlIHdhdGNoaW5nIGZvci5cblx0ICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgc3Vic2NyaXB0aW9uIGZvciBhbiBldmVudCAoaS5lLiBcInR4XCIpIHRoYXQgaXMgYWxyZWFkeVxuXHQgICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInR4XCIsIFtcIm5ld0hlYWRzXCJdLCBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLnR5cGUgPT09IFwidHhcIik7IH0pLmZvckVhY2goZW1pdFJlY2VpcHRfMSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG5cdCAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuXHQgICAgICAgICAgICBjYXNlIFwicG9sbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImRpZFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5oYW5kbGVkOlwiLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciB0YWcgPSBldmVudC50YWc7XG5cdCAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwidHhcIikge1xuXHQgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XG5cdCAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgaWYgKCFzdWJJZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcblx0ICAgICAgICBzdWJJZC50aGVuKGZ1bmN0aW9uIChzdWJJZCkge1xuXHQgICAgICAgICAgICBpZiAoIV90aGlzLl9zdWJzW3N1YklkXSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fc3Vic1tzdWJJZF07XG5cdCAgICAgICAgICAgIF90aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdlYlNvY2tldFByb3ZpZGVyO1xuXHR9KGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IFdlYlNvY2tldFByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgd2Vic29ja2V0UHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMod2Vic29ja2V0UHJvdmlkZXIpO1xuXHR2YXIgd2Vic29ja2V0UHJvdmlkZXJfMSA9IHdlYnNvY2tldFByb3ZpZGVyLldlYlNvY2tldFByb3ZpZGVyO1xuXG5cdHZhciBpbmZ1cmFQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIGRlZmF1bHRQcm9qZWN0SWQgPSBcIjg0ODQyMDc4YjA5OTQ2NjM4YzAzMTU3ZjgzNDA1MjEzXCI7XG5cdHZhciBJbmZ1cmFQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhJbmZ1cmFQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEluZnVyYVByb3ZpZGVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBJbmZ1cmFQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuXHQgICAgICAgIHZhciBjb25uZWN0aW9uID0gcHJvdmlkZXIuY29ubmVjdGlvbjtcblx0ICAgICAgICBpZiAoY29ubmVjdGlvbi5wYXNzd29yZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHVybCA9IGNvbm5lY3Rpb24udXJsLnJlcGxhY2UoL15odHRwL2ksIFwid3NcIikucmVwbGFjZShcIi92My9cIiwgXCIvd3MvdjMvXCIpO1xuXHQgICAgICAgIHJldHVybiBuZXcgd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICBJbmZ1cmFQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGFwaUtleU9iaiA9IHtcblx0ICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuXHQgICAgICAgICAgICBwcm9qZWN0SWQ6IGRlZmF1bHRQcm9qZWN0SWQsXG5cdCAgICAgICAgICAgIHByb2plY3RTZWNyZXQ6IG51bGxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm9qZWN0U2VjcmV0IHJlcXVpcmVzIGEgcHJvamVjdElkXCIsIFwicHJvamVjdElkXCIsIGFwaUtleS5wcm9qZWN0SWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKGFwaUtleS5wcm9qZWN0U2VjcmV0KSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvamVjdFNlY3JldFwiLCBcInByb2plY3RTZWNyZXRcIiwgXCJbUkVEQUNURURdXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdFNlY3JldCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG5cdCAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcblx0ICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuXHQgICAgfTtcblx0ICAgIEluZnVyYVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwibWFpbm5ldC5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwicm9wc3Rlbi5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwicmlua2VieS5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwia292YW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImtvdmFuLmluZnVyYS5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImdvZXJsaS5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJuZXR3b3JrXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldHdvcmtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHtcblx0ICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBcIi92My9cIiArIGFwaUtleS5wcm9qZWN0SWQpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbmZ1cmFQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBJbmZ1cmFQcm92aWRlcjtcblx0fSk7XG5cblx0dmFyIGluZnVyYVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGluZnVyYVByb3ZpZGVyKTtcblx0dmFyIGluZnVyYVByb3ZpZGVyXzEgPSBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcjtcblxuXHR2YXIgbm9kZXNtaXRoUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQvLyBTcGVjaWFsIEFQSSBrZXkgcHJvdmlkZWQgYnkgTm9kZXNtaXRoIGZvciBldGhlcnMuanNcblx0dmFyIGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcblx0dmFyIE5vZGVzbWl0aFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE5vZGVzbWl0aFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTm9kZXNtaXRoUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXBpS2V5IHx8IGRlZmF1bHRBcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIGxvZ2dlci53YXJuKFwiTm9kZVNtaXRoIHdpbGwgYmUgZGlzY29udGludWVkIG9uIDIwMTktMTItMjA7IHBsZWFzZSBtaWdyYXRlIHRvIGFub3RoZXIgcGxhdGZvcm0uXCIpO1xuXHQgICAgICAgIHZhciBob3N0ID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvbWFpbm5ldC9qc29ucnBjXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yb3BzdGVuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JpbmtlYnkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9nb2VybGkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2tvdmFuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoaG9zdCArIFwiP2FwaUtleT1cIiArIGFwaUtleSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE5vZGVzbWl0aFByb3ZpZGVyO1xuXHR9KHVybEpzb25ScGNQcm92aWRlci5VcmxKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IE5vZGVzbWl0aFByb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgbm9kZXNtaXRoUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMobm9kZXNtaXRoUHJvdmlkZXIpO1xuXHR2YXIgbm9kZXNtaXRoUHJvdmlkZXJfMSA9IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyO1xuXG5cdHZhciB3ZWIzUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdHZhciBfbmV4dElkID0gMTtcblx0ZnVuY3Rpb24gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgc2VuZEZ1bmMpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICAvLyBNZXRhbWFzayBjb21wbGFpbnMgYWJvdXQgZXRoX3NpZ24gKGFuZCBvbiBzb21lIHZlcnNpb25zIGhhbmdzKVxuXHQgICAgICAgIGlmIChtZXRob2QgPT0gXCJldGhfc2lnblwiICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcblx0ICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL3dpa2kvTWFuYWdlbWVudC1BUElzI3BlcnNvbmFsX3NpZ25cblx0ICAgICAgICAgICAgbWV0aG9kID0gXCJwZXJzb25hbF9zaWduXCI7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IFtwYXJhbXNbMV0sIHBhcmFtc1swXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcblx0ICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcl8xID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcl8xLmNvZGUgPSByZXN1bHQuZXJyb3IuY29kZTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcl8xLmRhdGEgPSByZXN1bHQuZXJyb3IuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yXzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQucmVzdWx0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1ldGFtYXNrIGNvbXBsYWlucyBhYm91dCBldGhfc2lnbiAoYW5kIG9uIHNvbWUgdmVyc2lvbnMgaGFuZ3MpXG5cdCAgICAgICAgaWYgKG1ldGhvZCA9PSBcImV0aF9zaWduXCIgJiYgcHJvdmlkZXIuaXNNZXRhTWFzaykge1xuXHQgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vd2lraS9NYW5hZ2VtZW50LUFQSXMjcGVyc29uYWxfc2lnblxuXHQgICAgICAgICAgICBtZXRob2QgPSBcInBlcnNvbmFsX3NpZ25cIjtcblx0ICAgICAgICAgICAgcGFyYW1zID0gW3BhcmFtc1sxXSwgcGFyYW1zWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMgfSk7XG5cdCAgICB9O1xuXHR9XG5cdHZhciBXZWIzUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoV2ViM1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2ViM1Byb3ZpZGVyKHByb3ZpZGVyLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIFdlYjNQcm92aWRlcik7XG5cdCAgICAgICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXRoID0gbnVsbDtcblx0ICAgICAgICB2YXIganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG5cdCAgICAgICAgdmFyIHN1YnByb3ZpZGVyID0gbnVsbDtcblx0ICAgICAgICBpZiAodHlwZW9mIChwcm92aWRlcikgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuXHQgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gcHJvdmlkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwYXRoID0gcHJvdmlkZXIuaG9zdCB8fCBwcm92aWRlci5wYXRoIHx8IFwiXCI7XG5cdCAgICAgICAgICAgIGlmICghcGF0aCAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHN1YnByb3ZpZGVyID0gcHJvdmlkZXI7XG5cdCAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhdGggPSBcImVpcC0xMTkzOlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmRBc3luYy5iaW5kKHByb3ZpZGVyKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmQuYmluZChwcm92aWRlcikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghcGF0aCkge1xuXHQgICAgICAgICAgICAgICAgcGF0aCA9IFwidW5rbm93bjpcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgV2ViM1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdlYjNQcm92aWRlcjtcblx0fShqc29uUnBjUHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gV2ViM1Byb3ZpZGVyO1xuXHR9KTtcblxuXHR2YXIgd2ViM1Byb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKHdlYjNQcm92aWRlcik7XG5cdHZhciB3ZWIzUHJvdmlkZXJfMSA9IHdlYjNQcm92aWRlci5XZWIzUHJvdmlkZXI7XG5cblx0dmFyIGxpYiRtID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuUHJvdmlkZXIgPSBsaWIkYi5Qcm92aWRlcjtcblxuXHRleHBvcnRzLmdldE5ldHdvcmsgPSBsaWIkay5nZXROZXR3b3JrO1xuXG5cdGV4cG9ydHMuQmFzZVByb3ZpZGVyID0gYmFzZVByb3ZpZGVyLkJhc2VQcm92aWRlcjtcblxuXHRleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBjbG91ZGZsYXJlUHJvdmlkZXIuQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBldGhlcnNjYW5Qcm92aWRlci5FdGhlcnNjYW5Qcm92aWRlcjtcblxuXHRleHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBmYWxsYmFja1Byb3ZpZGVyLkZhbGxiYWNrUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5JcGNQcm92aWRlciA9IGJyb3dzZXJJcGNQcm92aWRlci5JcGNQcm92aWRlcjtcblxuXHRleHBvcnRzLkluZnVyYVByb3ZpZGVyID0gaW5mdXJhUHJvdmlkZXIuSW5mdXJhUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBqc29uUnBjUHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyO1xuXHRleHBvcnRzLkpzb25ScGNTaWduZXIgPSBqc29uUnBjUHJvdmlkZXIuSnNvblJwY1NpZ25lcjtcblxuXHRleHBvcnRzLk5vZGVzbWl0aFByb3ZpZGVyID0gbm9kZXNtaXRoUHJvdmlkZXIuTm9kZXNtaXRoUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5XZWIzUHJvdmlkZXIgPSB3ZWIzUHJvdmlkZXIuV2ViM1Byb3ZpZGVyO1xuXG5cdGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSB3ZWJzb2NrZXRQcm92aWRlci5XZWJTb2NrZXRQcm92aWRlcjtcblxuXHRleHBvcnRzLkZvcm1hdHRlciA9IGZvcm1hdHRlci5Gb3JtYXR0ZXI7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIEhlbHBlciBGdW5jdGlvbnNcblx0ZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcblx0ICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICBuZXR3b3JrID0gXCJob21lc3RlYWRcIjtcblx0ICAgIH1cblx0ICAgIHZhciBuID0gbGliJGsuZ2V0TmV0d29yayhuZXR3b3JrKTtcblx0ICAgIGlmICghbiB8fCAhbi5fZGVmYXVsdFByb3ZpZGVyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcblx0ICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7XG5cdCAgICAgICAgRmFsbGJhY2tQcm92aWRlcjogZmFsbGJhY2tQcm92aWRlci5GYWxsYmFja1Byb3ZpZGVyLFxuXHQgICAgICAgIEFsY2hlbXlQcm92aWRlcjogYWxjaGVteVByb3ZpZGVyLkFsY2hlbXlQcm92aWRlcixcblx0ICAgICAgICBDbG91ZGZsYXJlUHJvdmlkZXI6IGNsb3VkZmxhcmVQcm92aWRlci5DbG91ZGZsYXJlUHJvdmlkZXIsXG5cdCAgICAgICAgRXRoZXJzY2FuUHJvdmlkZXI6IGV0aGVyc2NhblByb3ZpZGVyLkV0aGVyc2NhblByb3ZpZGVyLFxuXHQgICAgICAgIEluZnVyYVByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcixcblx0ICAgICAgICBKc29uUnBjUHJvdmlkZXI6IGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIsXG5cdCAgICAgICAgTm9kZXNtaXRoUHJvdmlkZXI6IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyLFxuXHQgICAgICAgIFdlYjNQcm92aWRlcjogd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcixcblx0ICAgICAgICBJcGNQcm92aWRlcjogYnJvd3NlcklwY1Byb3ZpZGVyLklwY1Byb3ZpZGVyLFxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdH1cblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXI7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRtID0gdW53cmFwRXhwb3J0cyhsaWIkbSk7XG5cdHZhciBsaWJfMSRtID0gbGliJG0uUHJvdmlkZXI7XG5cdHZhciBsaWJfMiRrID0gbGliJG0uZ2V0TmV0d29yaztcblx0dmFyIGxpYl8zJGYgPSBsaWIkbS5CYXNlUHJvdmlkZXI7XG5cdHZhciBsaWJfNCRjID0gbGliJG0uQWxjaGVteVByb3ZpZGVyO1xuXHR2YXIgbGliXzUkYiA9IGxpYiRtLkNsb3VkZmxhcmVQcm92aWRlcjtcblx0dmFyIGxpYl82JDcgPSBsaWIkbS5FdGhlcnNjYW5Qcm92aWRlcjtcblx0dmFyIGxpYl83JDYgPSBsaWIkbS5GYWxsYmFja1Byb3ZpZGVyO1xuXHR2YXIgbGliXzgkNSA9IGxpYiRtLklwY1Byb3ZpZGVyO1xuXHR2YXIgbGliXzkkNSA9IGxpYiRtLkluZnVyYVByb3ZpZGVyO1xuXHR2YXIgbGliXzEwJDMgPSBsaWIkbS5Kc29uUnBjUHJvdmlkZXI7XG5cdHZhciBsaWJfMTEkMiA9IGxpYiRtLkpzb25ScGNTaWduZXI7XG5cdHZhciBsaWJfMTIkMiA9IGxpYiRtLk5vZGVzbWl0aFByb3ZpZGVyO1xuXHR2YXIgbGliXzEzJDIgPSBsaWIkbS5XZWIzUHJvdmlkZXI7XG5cdHZhciBsaWJfMTQkMSA9IGxpYiRtLldlYlNvY2tldFByb3ZpZGVyO1xuXHR2YXIgbGliXzE1JDEgPSBsaWIkbS5Gb3JtYXR0ZXI7XG5cdHZhciBsaWJfMTYkMSA9IGxpYiRtLmdldERlZmF1bHRQcm92aWRlcjtcblxuXHR2YXIgbGliJG4gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXHR2YXIgcmVnZXhCeXRlcyA9IG5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIik7XG5cdHZhciByZWdleE51bWJlciA9IG5ldyBSZWdFeHAoXCJeKHU/aW50KShbMC05XSopJFwiKTtcblx0dmFyIHJlZ2V4QXJyYXkgPSBuZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpO1xuXHR2YXIgWmVyb3MgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblx0ZnVuY3Rpb24gX3BhY2sodHlwZSwgdmFsdWUsIGlzQXJyYXkpIHtcblx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG5cdCAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGliJDEuemVyb1BhZCh2YWx1ZSwgMzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDgudG9VdGY4Qnl0ZXModmFsdWUpO1xuXHQgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIGNhc2UgXCJib29sXCI6XG5cdCAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG5cdCAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGliJDEuemVyb1BhZCh2YWx1ZSwgMzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4TnVtYmVyKTtcblx0ICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgIC8vbGV0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJpbnRcIilcblx0ICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuXHQgICAgICAgIGlmICgoc2l6ZSAlIDggIT0gMCkgfHwgc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbnVtYmVyIHR5cGUgLSBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICBzaXplID0gMjU2O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YWx1ZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b1R3b3Moc2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLnplcm9QYWQodmFsdWUsIHNpemUgLyA4KTtcblx0ICAgIH1cblx0ICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEJ5dGVzKTtcblx0ICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHQgICAgICAgIGlmIChTdHJpbmcoc2l6ZSkgIT0gbWF0Y2hbMV0gfHwgc2l6ZSA9PT0gMCB8fCBzaXplID4gMzIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBudW1iZXIgdHlwZSAtIFwiICsgdHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsaWIkMS5hcnJheWlmeSh2YWx1ZSkuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoKHZhbHVlICsgWmVyb3MpLnN1YnN0cmluZygwLCA2NikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheSk7XG5cdCAgICBpZiAobWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICB2YXIgYmFzZVR5cGVfMSA9IG1hdGNoWzFdO1xuXHQgICAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFN0cmluZyh2YWx1ZS5sZW5ndGgpKTtcblx0ICAgICAgICBpZiAoY291bnQgIT0gdmFsdWUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIFwiICsgdHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdF8xLnB1c2goX3BhY2soYmFzZVR5cGVfMSwgdmFsdWUsIHRydWUpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuY29uY2F0KHJlc3VsdF8xKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZSAtIFwiICsgdHlwZSk7XG5cdH1cblx0Ly8gQFRPRE86IEFycmF5IEVudW1cblx0ZnVuY3Rpb24gcGFjayh0eXBlcywgdmFsdWVzKSB7XG5cdCAgICBpZiAodHlwZXMubGVuZ3RoICE9IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlL3ZhbHVlIGNvdW50IG1pc21hdGNoXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpZ2h0ID0gW107XG5cdCAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgIHRpZ2h0LnB1c2goX3BhY2sodHlwZSwgdmFsdWVzW2luZGV4XSkpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShsaWIkMS5jb25jYXQodGlnaHQpKTtcblx0fVxuXHRleHBvcnRzLnBhY2sgPSBwYWNrO1xuXHRmdW5jdGlvbiBrZWNjYWsyNTYodHlwZXMsIHZhbHVlcykge1xuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihwYWNrKHR5cGVzLCB2YWx1ZXMpKTtcblx0fVxuXHRleHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1Njtcblx0ZnVuY3Rpb24gc2hhMjU2KHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgIHJldHVybiBicm93c2VyLnNoYTI1NihwYWNrKHR5cGVzLCB2YWx1ZXMpKTtcblx0fVxuXHRleHBvcnRzLnNoYTI1NiA9IHNoYTI1Njtcblx0fSk7XG5cblx0dmFyIGluZGV4JG4gPSB1bndyYXBFeHBvcnRzKGxpYiRuKTtcblx0dmFyIGxpYl8xJG4gPSBsaWIkbi5wYWNrO1xuXHR2YXIgbGliXzIkbCA9IGxpYiRuLmtlY2NhazI1Njtcblx0dmFyIGxpYl8zJGcgPSBsaWIkbi5zaGEyNTY7XG5cblx0dmFyIF92ZXJzaW9uJEsgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwidW5pdHMvNS4wLjAtYmV0YS4xMzNcIjtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEwgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEspO1xuXHR2YXIgX3ZlcnNpb25fMSRuID0gX3ZlcnNpb24kSy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkbyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEsudmVyc2lvbik7XG5cdHZhciBuYW1lcyA9IFtcblx0ICAgIFwid2VpXCIsXG5cdCAgICBcImt3ZWlcIixcblx0ICAgIFwibXdlaVwiLFxuXHQgICAgXCJnd2VpXCIsXG5cdCAgICBcInN6YWJvXCIsXG5cdCAgICBcImZpbm5leVwiLFxuXHQgICAgXCJldGhlclwiLFxuXHRdO1xuXHQvLyBTb21lIGVudmlyb25tZW50cyBoYXZlIGlzc3VlcyB3aXRoIFJlZ0V4IHRoYXQgY29udGFpbiBiYWNrLXRyYWNraW5nLCBzbyB3ZSBjYW5ub3Rcblx0Ly8gdXNlIHRoZW0uXG5cdGZ1bmN0aW9uIGNvbW1pZnkodmFsdWUpIHtcblx0ICAgIHZhciBjb21wcyA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIuXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIgfHwgIWNvbXBzWzBdLm1hdGNoKC9eLT9bMC05XSokLykgfHwgKGNvbXBzWzFdICYmICFjb21wc1sxXS5tYXRjaCgvXlswLTldKiQvKSkgfHwgdmFsdWUgPT09IFwiLlwiIHx8IHZhbHVlID09PSBcIi0uXCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSB3aG9sZSBkaWdpdCAoMCBpZiBub25lKVxuXHQgICAgdmFyIHdob2xlID0gY29tcHNbMF07XG5cdCAgICB2YXIgbmVnYXRpdmUgPSBcIlwiO1xuXHQgICAgaWYgKHdob2xlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpIHtcblx0ICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuXHQgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3QgMSB3aG9sZSBkaWdpdCB3aXRoIG5vIGxlYWRpbmcgemVyb3Ncblx0ICAgIHdoaWxlICh3aG9sZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiMFwiKSB7XG5cdCAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG5cdCAgICB9XG5cdCAgICBpZiAod2hvbGUgPT09IFwiXCIpIHtcblx0ICAgICAgICB3aG9sZSA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHN1ZmZpeCA9IFwiXCI7XG5cdCAgICBpZiAoY29tcHMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgc3VmZml4ID0gXCIuXCIgKyAoY29tcHNbMV0gfHwgXCIwXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIGZvcm1hdHRlZCA9IFtdO1xuXHQgICAgd2hpbGUgKHdob2xlLmxlbmd0aCkge1xuXHQgICAgICAgIGlmICh3aG9sZS5sZW5ndGggPD0gMykge1xuXHQgICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gd2hvbGUubGVuZ3RoIC0gMztcblx0ICAgICAgICAgICAgZm9ybWF0dGVkLnVuc2hpZnQod2hvbGUuc3Vic3RyaW5nKGluZGV4KSk7XG5cdCAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmVnYXRpdmUgKyBmb3JtYXR0ZWQuam9pbihcIixcIikgKyBzdWZmaXg7XG5cdH1cblx0ZXhwb3J0cy5jb21taWZ5ID0gY29tbWlmeTtcblx0ZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXROYW1lKSB7XG5cdCAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcblx0ICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkMi5mb3JtYXRGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRVbml0cyA9IGZvcm1hdFVuaXRzO1xuXHRmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuXHQgICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDIucGFyc2VGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZVVuaXRzID0gcGFyc2VVbml0cztcblx0ZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG5cdCAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRFdGhlciA9IGZvcm1hdEV0aGVyO1xuXHRmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG5cdCAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xuXHR9XG5cdGV4cG9ydHMucGFyc2VFdGhlciA9IHBhcnNlRXRoZXI7XG5cdH0pO1xuXG5cdHZhciBpbmRleCRvID0gdW53cmFwRXhwb3J0cyhsaWIkbyk7XG5cdHZhciBsaWJfMSRvID0gbGliJG8uY29tbWlmeTtcblx0dmFyIGxpYl8yJG0gPSBsaWIkby5mb3JtYXRVbml0cztcblx0dmFyIGxpYl8zJGggPSBsaWIkby5wYXJzZVVuaXRzO1xuXHR2YXIgbGliXzQkZCA9IGxpYiRvLmZvcm1hdEV0aGVyO1xuXHR2YXIgbGliXzUkYyA9IGxpYiRvLnBhcnNlRXRoZXI7XG5cblx0dmFyIHV0aWxzJDMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuQWJpQ29kZXIgPSBsaWIkYS5BYmlDb2Rlcjtcblx0ZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGxpYiRhLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHRleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IGxpYiRhLmRlZmF1bHRBYmlDb2Rlcjtcblx0ZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gbGliJGEuRXZlbnRGcmFnbWVudDtcblx0ZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IGxpYiRhLkZvcm1hdFR5cGVzO1xuXHRleHBvcnRzLkZyYWdtZW50ID0gbGliJGEuRnJhZ21lbnQ7XG5cdGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGxpYiRhLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IGxpYiRhLkluZGV4ZWQ7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gbGliJGEuSW50ZXJmYWNlO1xuXHRleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gbGliJGEuTG9nRGVzY3JpcHRpb247XG5cdGV4cG9ydHMuUGFyYW1UeXBlID0gbGliJGEuUGFyYW1UeXBlO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBsaWIkYS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXG5cdGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGxpYiQ2LmdldEFkZHJlc3M7XG5cdGV4cG9ydHMuZ2V0Q3JlYXRlMkFkZHJlc3MgPSBsaWIkNi5nZXRDcmVhdGUyQWRkcmVzcztcblx0ZXhwb3J0cy5nZXRDb250cmFjdEFkZHJlc3MgPSBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3M7XG5cdGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBsaWIkNi5nZXRJY2FwQWRkcmVzcztcblx0ZXhwb3J0cy5pc0FkZHJlc3MgPSBsaWIkNi5pc0FkZHJlc3M7XG5cdHZhciBiYXNlNjQgPSBfX2ltcG9ydFN0YXIoYnJvd3NlciQ4KTtcblx0ZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG5cblx0ZXhwb3J0cy5hcnJheWlmeSA9IGxpYiQxLmFycmF5aWZ5O1xuXHRleHBvcnRzLmNvbmNhdCA9IGxpYiQxLmNvbmNhdDtcblx0ZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBsaWIkMS5oZXhEYXRhU2xpY2U7XG5cdGV4cG9ydHMuaGV4RGF0YUxlbmd0aCA9IGxpYiQxLmhleERhdGFMZW5ndGg7XG5cdGV4cG9ydHMuaGV4bGlmeSA9IGxpYiQxLmhleGxpZnk7XG5cdGV4cG9ydHMuaGV4U3RyaXBaZXJvcyA9IGxpYiQxLmhleFN0cmlwWmVyb3M7XG5cdGV4cG9ydHMuaGV4VmFsdWUgPSBsaWIkMS5oZXhWYWx1ZTtcblx0ZXhwb3J0cy5oZXhaZXJvUGFkID0gbGliJDEuaGV4WmVyb1BhZDtcblx0ZXhwb3J0cy5pc0J5dGVzID0gbGliJDEuaXNCeXRlcztcblx0ZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGxpYiQxLmlzQnl0ZXNMaWtlO1xuXHRleHBvcnRzLmlzSGV4U3RyaW5nID0gbGliJDEuaXNIZXhTdHJpbmc7XG5cdGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGxpYiQxLmpvaW5TaWduYXR1cmU7XG5cdGV4cG9ydHMuemVyb1BhZCA9IGxpYiQxLnplcm9QYWQ7XG5cdGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBsaWIkMS5zcGxpdFNpZ25hdHVyZTtcblx0ZXhwb3J0cy5zdHJpcFplcm9zID0gbGliJDEuc3RyaXBaZXJvcztcblxuXHRleHBvcnRzLmhhc2hNZXNzYWdlID0gbGliJDkuaGFzaE1lc3NhZ2U7XG5cdGV4cG9ydHMuaWQgPSBsaWIkOS5pZDtcblx0ZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGxpYiQ5LmlzVmFsaWROYW1lO1xuXHRleHBvcnRzLm5hbWVoYXNoID0gbGliJDkubmFtZWhhc2g7XG5cblx0ZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHRleHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gbGliJGguZW50cm9weVRvTW5lbW9uaWM7XG5cdGV4cG9ydHMuSEROb2RlID0gbGliJGguSEROb2RlO1xuXHRleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGxpYiRoLmlzVmFsaWRNbmVtb25pYztcblx0ZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IGxpYiRoLm1uZW1vbmljVG9FbnRyb3B5O1xuXHRleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbGliJGgubW5lbW9uaWNUb1NlZWQ7XG5cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGxpYiRpLmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXG5cdGV4cG9ydHMua2VjY2FrMjU2ID0gbGliJDQua2VjY2FrMjU2O1xuXG5cdGV4cG9ydHMuTG9nZ2VyID0gbGliLkxvZ2dlcjtcblxuXHRleHBvcnRzLmNvbXB1dGVIbWFjID0gYnJvd3Nlci5jb21wdXRlSG1hYztcblx0ZXhwb3J0cy5yaXBlbWQxNjAgPSBicm93c2VyLnJpcGVtZDE2MDtcblx0ZXhwb3J0cy5zaGEyNTYgPSBicm93c2VyLnNoYTI1Njtcblx0ZXhwb3J0cy5zaGE1MTIgPSBicm93c2VyLnNoYTUxMjtcblxuXHRleHBvcnRzLnNvbGlkaXR5S2VjY2FrMjU2ID0gbGliJG4ua2VjY2FrMjU2O1xuXHRleHBvcnRzLnNvbGlkaXR5UGFjayA9IGxpYiRuLnBhY2s7XG5cdGV4cG9ydHMuc29saWRpdHlTaGEyNTYgPSBsaWIkbi5zaGEyNTY7XG5cblx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcztcblx0ZXhwb3J0cy5zaHVmZmxlZCA9IGJyb3dzZXIkNi5zaHVmZmxlZDtcblxuXHRleHBvcnRzLmNoZWNrUHJvcGVydGllcyA9IGxpYiQzLmNoZWNrUHJvcGVydGllcztcblx0ZXhwb3J0cy5kZWVwQ29weSA9IGxpYiQzLmRlZXBDb3B5O1xuXHRleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gbGliJDMuZGVmaW5lUmVhZE9ubHk7XG5cdGV4cG9ydHMuZ2V0U3RhdGljID0gbGliJDMuZ2V0U3RhdGljO1xuXHRleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gbGliJDMucmVzb2x2ZVByb3BlcnRpZXM7XG5cdGV4cG9ydHMuc2hhbGxvd0NvcHkgPSBsaWIkMy5zaGFsbG93Q29weTtcblx0dmFyIFJMUCA9IF9faW1wb3J0U3RhcihsaWIkNSk7XG5cdGV4cG9ydHMuUkxQID0gUkxQO1xuXG5cdGV4cG9ydHMuY29tcHV0ZVB1YmxpY0tleSA9IGxpYiRmLmNvbXB1dGVQdWJsaWNLZXk7XG5cdGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IGxpYiRmLnJlY292ZXJQdWJsaWNLZXk7XG5cdGV4cG9ydHMuU2lnbmluZ0tleSA9IGxpYiRmLlNpZ25pbmdLZXk7XG5cblx0ZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gbGliJDguZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5uYW1lcHJlcCA9IGxpYiQ4Lm5hbWVwcmVwO1xuXHRleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IGxpYiQ4LnBhcnNlQnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IGxpYiQ4Ll90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gbGliJDgudG9VdGY4Qnl0ZXM7XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGxpYiQ4LnRvVXRmOENvZGVQb2ludHM7XG5cdGV4cG9ydHMudG9VdGY4U3RyaW5nID0gbGliJDgudG9VdGY4U3RyaW5nO1xuXHRleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gbGliJDguVXRmOEVycm9yRnVuY3M7XG5cblx0ZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGxpYiRnLmNvbXB1dGVBZGRyZXNzO1xuXHRleHBvcnRzLnBhcnNlVHJhbnNhY3Rpb24gPSBsaWIkZy5wYXJzZTtcblx0ZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGxpYiRnLnJlY292ZXJBZGRyZXNzO1xuXHRleHBvcnRzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uID0gbGliJGcuc2VyaWFsaXplO1xuXG5cdGV4cG9ydHMuY29tbWlmeSA9IGxpYiRvLmNvbW1pZnk7XG5cdGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBsaWIkby5mb3JtYXRFdGhlcjtcblx0ZXhwb3J0cy5wYXJzZUV0aGVyID0gbGliJG8ucGFyc2VFdGhlcjtcblx0ZXhwb3J0cy5mb3JtYXRVbml0cyA9IGxpYiRvLmZvcm1hdFVuaXRzO1xuXHRleHBvcnRzLnBhcnNlVW5pdHMgPSBsaWIkby5wYXJzZVVuaXRzO1xuXG5cdGV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IGxpYiRqLnZlcmlmeU1lc3NhZ2U7XG5cblx0ZXhwb3J0cy5mZXRjaEpzb24gPSBsaWIkbC5mZXRjaEpzb247XG5cdGV4cG9ydHMucG9sbCA9IGxpYiRsLnBvbGw7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBFbnVtc1xuXHR2YXIgc2hhMl8yID0gYnJvd3Nlcjtcblx0ZXhwb3J0cy5TdXBwb3J0ZWRBbGdvcml0aG0gPSBzaGEyXzIuU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHR2YXIgc3RyaW5nc18yID0gbGliJDg7XG5cdGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0gc3RyaW5nc18yLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0ZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSBzdHJpbmdzXzIuVXRmOEVycm9yUmVhc29uO1xuXHR9KTtcblxuXHR2YXIgdXRpbHMkNCA9IHVud3JhcEV4cG9ydHModXRpbHMkMyk7XG5cdHZhciB1dGlsc18xJDMgPSB1dGlscyQzLkFiaUNvZGVyO1xuXHR2YXIgdXRpbHNfMiQxID0gdXRpbHMkMy5jaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIHV0aWxzXzMkMSA9IHV0aWxzJDMuZGVmYXVsdEFiaUNvZGVyO1xuXHR2YXIgdXRpbHNfNCQxID0gdXRpbHMkMy5FdmVudEZyYWdtZW50O1xuXHR2YXIgdXRpbHNfNSA9IHV0aWxzJDMuRm9ybWF0VHlwZXM7XG5cdHZhciB1dGlsc182ID0gdXRpbHMkMy5GcmFnbWVudDtcblx0dmFyIHV0aWxzXzcgPSB1dGlscyQzLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cdHZhciB1dGlsc184ID0gdXRpbHMkMy5JbmRleGVkO1xuXHR2YXIgdXRpbHNfOSA9IHV0aWxzJDMuSW50ZXJmYWNlO1xuXHR2YXIgdXRpbHNfMTAgPSB1dGlscyQzLkxvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgdXRpbHNfMTEgPSB1dGlscyQzLlBhcmFtVHlwZTtcblx0dmFyIHV0aWxzXzEyID0gdXRpbHMkMy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR2YXIgdXRpbHNfMTMgPSB1dGlscyQzLmdldEFkZHJlc3M7XG5cdHZhciB1dGlsc18xNCA9IHV0aWxzJDMuZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cdHZhciB1dGlsc18xNSA9IHV0aWxzJDMuZ2V0Q29udHJhY3RBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTYgPSB1dGlscyQzLmdldEljYXBBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTcgPSB1dGlscyQzLmlzQWRkcmVzcztcblx0dmFyIHV0aWxzXzE4ID0gdXRpbHMkMy5iYXNlNjQ7XG5cdHZhciB1dGlsc18xOSA9IHV0aWxzJDMuYXJyYXlpZnk7XG5cdHZhciB1dGlsc18yMCA9IHV0aWxzJDMuY29uY2F0O1xuXHR2YXIgdXRpbHNfMjEgPSB1dGlscyQzLmhleERhdGFTbGljZTtcblx0dmFyIHV0aWxzXzIyID0gdXRpbHMkMy5oZXhEYXRhTGVuZ3RoO1xuXHR2YXIgdXRpbHNfMjMgPSB1dGlscyQzLmhleGxpZnk7XG5cdHZhciB1dGlsc18yNCA9IHV0aWxzJDMuaGV4U3RyaXBaZXJvcztcblx0dmFyIHV0aWxzXzI1ID0gdXRpbHMkMy5oZXhWYWx1ZTtcblx0dmFyIHV0aWxzXzI2ID0gdXRpbHMkMy5oZXhaZXJvUGFkO1xuXHR2YXIgdXRpbHNfMjcgPSB1dGlscyQzLmlzQnl0ZXM7XG5cdHZhciB1dGlsc18yOCA9IHV0aWxzJDMuaXNCeXRlc0xpa2U7XG5cdHZhciB1dGlsc18yOSA9IHV0aWxzJDMuaXNIZXhTdHJpbmc7XG5cdHZhciB1dGlsc18zMCA9IHV0aWxzJDMuam9pblNpZ25hdHVyZTtcblx0dmFyIHV0aWxzXzMxID0gdXRpbHMkMy56ZXJvUGFkO1xuXHR2YXIgdXRpbHNfMzIgPSB1dGlscyQzLnNwbGl0U2lnbmF0dXJlO1xuXHR2YXIgdXRpbHNfMzMgPSB1dGlscyQzLnN0cmlwWmVyb3M7XG5cdHZhciB1dGlsc18zNCA9IHV0aWxzJDMuaGFzaE1lc3NhZ2U7XG5cdHZhciB1dGlsc18zNSA9IHV0aWxzJDMuaWQ7XG5cdHZhciB1dGlsc18zNiA9IHV0aWxzJDMuaXNWYWxpZE5hbWU7XG5cdHZhciB1dGlsc18zNyA9IHV0aWxzJDMubmFtZWhhc2g7XG5cdHZhciB1dGlsc18zOCA9IHV0aWxzJDMuZGVmYXVsdFBhdGg7XG5cdHZhciB1dGlsc18zOSA9IHV0aWxzJDMuZW50cm9weVRvTW5lbW9uaWM7XG5cdHZhciB1dGlsc180MCA9IHV0aWxzJDMuSEROb2RlO1xuXHR2YXIgdXRpbHNfNDEgPSB1dGlscyQzLmlzVmFsaWRNbmVtb25pYztcblx0dmFyIHV0aWxzXzQyID0gdXRpbHMkMy5tbmVtb25pY1RvRW50cm9weTtcblx0dmFyIHV0aWxzXzQzID0gdXRpbHMkMy5tbmVtb25pY1RvU2VlZDtcblx0dmFyIHV0aWxzXzQ0ID0gdXRpbHMkMy5nZXRKc29uV2FsbGV0QWRkcmVzcztcblx0dmFyIHV0aWxzXzQ1ID0gdXRpbHMkMy5rZWNjYWsyNTY7XG5cdHZhciB1dGlsc180NiA9IHV0aWxzJDMuTG9nZ2VyO1xuXHR2YXIgdXRpbHNfNDcgPSB1dGlscyQzLmNvbXB1dGVIbWFjO1xuXHR2YXIgdXRpbHNfNDggPSB1dGlscyQzLnJpcGVtZDE2MDtcblx0dmFyIHV0aWxzXzQ5ID0gdXRpbHMkMy5zaGEyNTY7XG5cdHZhciB1dGlsc181MCA9IHV0aWxzJDMuc2hhNTEyO1xuXHR2YXIgdXRpbHNfNTEgPSB1dGlscyQzLnNvbGlkaXR5S2VjY2FrMjU2O1xuXHR2YXIgdXRpbHNfNTIgPSB1dGlscyQzLnNvbGlkaXR5UGFjaztcblx0dmFyIHV0aWxzXzUzID0gdXRpbHMkMy5zb2xpZGl0eVNoYTI1Njtcblx0dmFyIHV0aWxzXzU0ID0gdXRpbHMkMy5yYW5kb21CeXRlcztcblx0dmFyIHV0aWxzXzU1ID0gdXRpbHMkMy5zaHVmZmxlZDtcblx0dmFyIHV0aWxzXzU2ID0gdXRpbHMkMy5jaGVja1Byb3BlcnRpZXM7XG5cdHZhciB1dGlsc181NyA9IHV0aWxzJDMuZGVlcENvcHk7XG5cdHZhciB1dGlsc181OCA9IHV0aWxzJDMuZGVmaW5lUmVhZE9ubHk7XG5cdHZhciB1dGlsc181OSA9IHV0aWxzJDMuZ2V0U3RhdGljO1xuXHR2YXIgdXRpbHNfNjAgPSB1dGlscyQzLnJlc29sdmVQcm9wZXJ0aWVzO1xuXHR2YXIgdXRpbHNfNjEgPSB1dGlscyQzLnNoYWxsb3dDb3B5O1xuXHR2YXIgdXRpbHNfNjIgPSB1dGlscyQzLlJMUDtcblx0dmFyIHV0aWxzXzYzID0gdXRpbHMkMy5jb21wdXRlUHVibGljS2V5O1xuXHR2YXIgdXRpbHNfNjQgPSB1dGlscyQzLnJlY292ZXJQdWJsaWNLZXk7XG5cdHZhciB1dGlsc182NSA9IHV0aWxzJDMuU2lnbmluZ0tleTtcblx0dmFyIHV0aWxzXzY2ID0gdXRpbHMkMy5mb3JtYXRCeXRlczMyU3RyaW5nO1xuXHR2YXIgdXRpbHNfNjcgPSB1dGlscyQzLm5hbWVwcmVwO1xuXHR2YXIgdXRpbHNfNjggPSB1dGlscyQzLnBhcnNlQnl0ZXMzMlN0cmluZztcblx0dmFyIHV0aWxzXzY5ID0gdXRpbHMkMy5fdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0dmFyIHV0aWxzXzcwID0gdXRpbHMkMy50b1V0ZjhCeXRlcztcblx0dmFyIHV0aWxzXzcxID0gdXRpbHMkMy50b1V0ZjhDb2RlUG9pbnRzO1xuXHR2YXIgdXRpbHNfNzIgPSB1dGlscyQzLnRvVXRmOFN0cmluZztcblx0dmFyIHV0aWxzXzczID0gdXRpbHMkMy5VdGY4RXJyb3JGdW5jcztcblx0dmFyIHV0aWxzXzc0ID0gdXRpbHMkMy5jb21wdXRlQWRkcmVzcztcblx0dmFyIHV0aWxzXzc1ID0gdXRpbHMkMy5wYXJzZVRyYW5zYWN0aW9uO1xuXHR2YXIgdXRpbHNfNzYgPSB1dGlscyQzLnJlY292ZXJBZGRyZXNzO1xuXHR2YXIgdXRpbHNfNzcgPSB1dGlscyQzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uO1xuXHR2YXIgdXRpbHNfNzggPSB1dGlscyQzLmNvbW1pZnk7XG5cdHZhciB1dGlsc183OSA9IHV0aWxzJDMuZm9ybWF0RXRoZXI7XG5cdHZhciB1dGlsc184MCA9IHV0aWxzJDMucGFyc2VFdGhlcjtcblx0dmFyIHV0aWxzXzgxID0gdXRpbHMkMy5mb3JtYXRVbml0cztcblx0dmFyIHV0aWxzXzgyID0gdXRpbHMkMy5wYXJzZVVuaXRzO1xuXHR2YXIgdXRpbHNfODMgPSB1dGlscyQzLnZlcmlmeU1lc3NhZ2U7XG5cdHZhciB1dGlsc184NCA9IHV0aWxzJDMuZmV0Y2hKc29uO1xuXHR2YXIgdXRpbHNfODUgPSB1dGlscyQzLnBvbGw7XG5cdHZhciB1dGlsc184NiA9IHV0aWxzJDMuU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHR2YXIgdXRpbHNfODcgPSB1dGlscyQzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0dmFyIHV0aWxzXzg4ID0gdXRpbHMkMy5VdGY4RXJyb3JSZWFzb247XG5cblx0dmFyIF92ZXJzaW9uJE0gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiZXRoZXJzLzUuMC4wLWJldGEuMTkyXCI7XG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiROID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRNKTtcblx0dmFyIF92ZXJzaW9uXzEkbyA9IF92ZXJzaW9uJE0udmVyc2lvbjtcblxuXHR2YXIgZXRoZXJzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLkNvbnRyYWN0ID0gbGliJGQuQ29udHJhY3Q7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliJGQuQ29udHJhY3RGYWN0b3J5O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliJDIuQmlnTnVtYmVyO1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gbGliJDIuRml4ZWROdW1iZXI7XG5cblx0ZXhwb3J0cy5TaWduZXIgPSBsaWIkYy5TaWduZXI7XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYiRjLlZvaWRTaWduZXI7XG5cblx0ZXhwb3J0cy5XYWxsZXQgPSBsaWIkai5XYWxsZXQ7XG5cdHZhciBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIobGliJDcpO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblx0dmFyIHByb3ZpZGVycyA9IF9faW1wb3J0U3RhcihsaWIkbSk7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuXHR2YXIgcHJvdmlkZXJzXzEgPSBsaWIkbTtcblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBwcm92aWRlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGJyb3dzZXIkNC5Xb3JkbGlzdDtcblx0ZXhwb3J0cy53b3JkbGlzdHMgPSBicm93c2VyJDQud29yZGxpc3RzO1xuXHR2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIodXRpbHMkMyk7XG5cdGV4cG9ydHMudXRpbHMgPSB1dGlscztcblxuXHRleHBvcnRzLmVycm9ycyA9IGxpYi5FcnJvckNvZGU7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBDb21waWxlLVRpbWUgQ29uc3RhbnRzXG5cdC8vIFRoaXMgaXMgZ2VuZXJhdGVkIGJ5IFwibnBtIHJ1biBkaXN0XCJcblxuXHRleHBvcnRzLnZlcnNpb24gPSBfdmVyc2lvbiRNLnZlcnNpb247XG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRNLnZlcnNpb24pO1xuXHRleHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcblx0fSk7XG5cblx0dmFyIGV0aGVycyQxID0gdW53cmFwRXhwb3J0cyhldGhlcnMpO1xuXHR2YXIgZXRoZXJzXzEgPSBldGhlcnMuQ29udHJhY3Q7XG5cdHZhciBldGhlcnNfMiA9IGV0aGVycy5Db250cmFjdEZhY3Rvcnk7XG5cdHZhciBldGhlcnNfMyA9IGV0aGVycy5CaWdOdW1iZXI7XG5cdHZhciBldGhlcnNfNCA9IGV0aGVycy5GaXhlZE51bWJlcjtcblx0dmFyIGV0aGVyc181ID0gZXRoZXJzLlNpZ25lcjtcblx0dmFyIGV0aGVyc182ID0gZXRoZXJzLlZvaWRTaWduZXI7XG5cdHZhciBldGhlcnNfNyA9IGV0aGVycy5XYWxsZXQ7XG5cdHZhciBldGhlcnNfOCA9IGV0aGVycy5jb25zdGFudHM7XG5cdHZhciBldGhlcnNfOSA9IGV0aGVycy5wcm92aWRlcnM7XG5cdHZhciBldGhlcnNfMTAgPSBldGhlcnMuZ2V0RGVmYXVsdFByb3ZpZGVyO1xuXHR2YXIgZXRoZXJzXzExID0gZXRoZXJzLldvcmRsaXN0O1xuXHR2YXIgZXRoZXJzXzEyID0gZXRoZXJzLndvcmRsaXN0cztcblx0dmFyIGV0aGVyc18xMyA9IGV0aGVycy51dGlscztcblx0dmFyIGV0aGVyc18xNCA9IGV0aGVycy5lcnJvcnM7XG5cdHZhciBldGhlcnNfMTUgPSBldGhlcnMudmVyc2lvbjtcblx0dmFyIGV0aGVyc18xNiA9IGV0aGVycy5sb2dnZXI7XG5cblx0dmFyIGxpYiRwID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gVG8gbW9kaWZ5IHRoaXMgZmlsZSwgeW91IG11c3QgdXBkYXRlIC4vYWRtaW4vY21kcy91cGRhdGUtZXhwb3J0cy5qc1xuXHR2YXIgZXRoZXJzJDEgPSBfX2ltcG9ydFN0YXIoZXRoZXJzKTtcblx0ZXhwb3J0cy5ldGhlcnMgPSBldGhlcnMkMTtcblx0dHJ5IHtcblx0ICAgIHZhciBhbnlHbG9iYWwgPSB3aW5kb3c7XG5cdCAgICBpZiAoYW55R2xvYmFsLl9ldGhlcnMgPT0gbnVsbCkge1xuXHQgICAgICAgIGFueUdsb2JhbC5fZXRoZXJzID0gZXRoZXJzJDE7XG5cdCAgICB9XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7IH1cblx0dmFyIGV0aGVyc18xID0gZXRoZXJzO1xuXHRleHBvcnRzLlNpZ25lciA9IGV0aGVyc18xLlNpZ25lcjtcblx0ZXhwb3J0cy5XYWxsZXQgPSBldGhlcnNfMS5XYWxsZXQ7XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGV0aGVyc18xLlZvaWRTaWduZXI7XG5cdGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZXRoZXJzXzEuZ2V0RGVmYXVsdFByb3ZpZGVyO1xuXHRleHBvcnRzLnByb3ZpZGVycyA9IGV0aGVyc18xLnByb3ZpZGVycztcblx0ZXhwb3J0cy5Db250cmFjdCA9IGV0aGVyc18xLkNvbnRyYWN0O1xuXHRleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IGV0aGVyc18xLkNvbnRyYWN0RmFjdG9yeTtcblx0ZXhwb3J0cy5CaWdOdW1iZXIgPSBldGhlcnNfMS5CaWdOdW1iZXI7XG5cdGV4cG9ydHMuRml4ZWROdW1iZXIgPSBldGhlcnNfMS5GaXhlZE51bWJlcjtcblx0ZXhwb3J0cy5jb25zdGFudHMgPSBldGhlcnNfMS5jb25zdGFudHM7XG5cdGV4cG9ydHMuZXJyb3JzID0gZXRoZXJzXzEuZXJyb3JzO1xuXHRleHBvcnRzLmxvZ2dlciA9IGV0aGVyc18xLmxvZ2dlcjtcblx0ZXhwb3J0cy51dGlscyA9IGV0aGVyc18xLnV0aWxzO1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IGV0aGVyc18xLndvcmRsaXN0cztcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIENvbXBpbGUtVGltZSBDb25zdGFudHNcblx0ZXhwb3J0cy52ZXJzaW9uID0gZXRoZXJzXzEudmVyc2lvbjtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGV0aGVyc18xLldvcmRsaXN0O1xuXHR9KTtcblxuXHR2YXIgaW5kZXgkcCA9IHVud3JhcEV4cG9ydHMobGliJHApO1xuXHR2YXIgbGliXzEkcCA9IGxpYiRwLmV0aGVycztcblx0dmFyIGxpYl8yJG4gPSBsaWIkcC5TaWduZXI7XG5cdHZhciBsaWJfMyRpID0gbGliJHAuV2FsbGV0O1xuXHR2YXIgbGliXzQkZSA9IGxpYiRwLlZvaWRTaWduZXI7XG5cdHZhciBsaWJfNSRkID0gbGliJHAuZ2V0RGVmYXVsdFByb3ZpZGVyO1xuXHR2YXIgbGliXzYkOCA9IGxpYiRwLnByb3ZpZGVycztcblx0dmFyIGxpYl83JDcgPSBsaWIkcC5Db250cmFjdDtcblx0dmFyIGxpYl84JDYgPSBsaWIkcC5Db250cmFjdEZhY3Rvcnk7XG5cdHZhciBsaWJfOSQ2ID0gbGliJHAuQmlnTnVtYmVyO1xuXHR2YXIgbGliXzEwJDQgPSBsaWIkcC5GaXhlZE51bWJlcjtcblx0dmFyIGxpYl8xMSQzID0gbGliJHAuY29uc3RhbnRzO1xuXHR2YXIgbGliXzEyJDMgPSBsaWIkcC5lcnJvcnM7XG5cdHZhciBsaWJfMTMkMyA9IGxpYiRwLmxvZ2dlcjtcblx0dmFyIGxpYl8xNCQyID0gbGliJHAudXRpbHM7XG5cdHZhciBsaWJfMTUkMiA9IGxpYiRwLndvcmRsaXN0cztcblx0dmFyIGxpYl8xNiQyID0gbGliJHAudmVyc2lvbjtcblx0dmFyIGxpYl8xNyA9IGxpYiRwLldvcmRsaXN0O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliXzkkNjtcblx0ZXhwb3J0cy5Db250cmFjdCA9IGxpYl83JDc7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliXzgkNjtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IGxpYl8xMCQ0O1xuXHRleHBvcnRzLlNpZ25lciA9IGxpYl8yJG47XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYl80JGU7XG5cdGV4cG9ydHMuV2FsbGV0ID0gbGliXzMkaTtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGxpYl8xNztcblx0ZXhwb3J0cy5jb25zdGFudHMgPSBsaWJfMTEkMztcblx0ZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXgkcDtcblx0ZXhwb3J0cy5lcnJvcnMgPSBsaWJfMTIkMztcblx0ZXhwb3J0cy5ldGhlcnMgPSBsaWJfMSRwO1xuXHRleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGxpYl81JGQ7XG5cdGV4cG9ydHMubG9nZ2VyID0gbGliXzEzJDM7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gbGliXzYkODtcblx0ZXhwb3J0cy51dGlscyA9IGxpYl8xNCQyO1xuXHRleHBvcnRzLnZlcnNpb24gPSBsaWJfMTYkMjtcblx0ZXhwb3J0cy53b3JkbGlzdHMgPSBsaWJfMTUkMjtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethers/dist/ethers.umd.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSx5QkFBeUIscUJBQU0seURBQXlELHFCQUFNLHNEQUFzRCxxQkFBTSxXQUFXLG1CQUFPLENBQUMsb0ZBQXdCOztBQUVyTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVmLCByZWYxO1xubW9kdWxlLmV4cG9ydHMgPSAoKHJlZiA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmVudikgJiYgdHlwZW9mICgocmVmMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwiLi4vLi4vY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css":
/*!**********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css ***!
  \**********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\r\\n.container {\\n  width: 100%;\\n}\\r\\n@media (min-width: 640px) {\\n\\n  .container {\\n    max-width: 640px;\\n  }\\n}\\r\\n@media (min-width: 768px) {\\n\\n  .container {\\n    max-width: 768px;\\n  }\\n}\\r\\n@media (min-width: 1024px) {\\n\\n  .container {\\n    max-width: 1024px;\\n  }\\n}\\r\\n@media (min-width: 1280px) {\\n\\n  .container {\\n    max-width: 1280px;\\n  }\\n}\\r\\n@media (min-width: 1536px) {\\n\\n  .container {\\n    max-width: 1536px;\\n  }\\n}\\r\\n.relative {\\n  position: relative;\\n}\\r\\n.sticky {\\n  position: sticky;\\n}\\r\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\r\\n.my-16 {\\n  margin-top: 4rem;\\n  margin-bottom: 4rem;\\n}\\r\\n.mb-2 {\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\r\\n.mb-16 {\\n  margin-bottom: 4rem;\\n}\\r\\n.block {\\n  display: block;\\n}\\r\\n.flex {\\n  display: flex;\\n}\\r\\n.grid {\\n  display: grid;\\n}\\r\\n.h-20 {\\n  height: 5rem;\\n}\\r\\n.h-screen {\\n  height: 100vh;\\n}\\r\\n.h-full {\\n  height: 100%;\\n}\\r\\n.w-10\\\\/12 {\\n  width: 83.333333%;\\n}\\r\\n.w-full {\\n  width: 100%;\\n}\\r\\n.w-screen {\\n  width: 100vw;\\n}\\r\\n.max-w-md {\\n  max-width: 28rem;\\n}\\r\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\r\\n.grid-cols-2 {\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\n}\\r\\n.items-center {\\n  align-items: center;\\n}\\r\\n.justify-center {\\n  justify-content: center;\\n}\\r\\n.justify-between {\\n  justify-content: space-between;\\n}\\r\\n.gap-16 {\\n  gap: 4rem;\\n}\\r\\n.gap-y-20 {\\n  row-gap: 5rem;\\n}\\r\\n.gap-x-10 {\\n  -moz-column-gap: 2.5rem;\\n       column-gap: 2.5rem;\\n}\\r\\n.space-y-20 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(5rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(5rem * var(--tw-space-y-reverse));\\n}\\r\\n.space-x-10 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(2.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(2.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\r\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\r\\n.border {\\n  border-width: 1px;\\n}\\r\\n.bg-red-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(248 113 113 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(203 213 225 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(100 116 139 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(71 85 105 / var(--tw-bg-opacity));\\n}\\r\\n.bg-stone-700 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(68 64 60 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-50 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(248 250 252 / var(--tw-bg-opacity));\\n}\\r\\n.bg-teal-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(45 212 191 / var(--tw-bg-opacity));\\n}\\r\\n.p-4 {\\n  padding: 1rem;\\n}\\r\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\r\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\r\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\r\\n.px-8 {\\n  padding-left: 2rem;\\n  padding-right: 2rem;\\n}\\r\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\r\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\r\\n.py-6 {\\n  padding-top: 1.5rem;\\n  padding-bottom: 1.5rem;\\n}\\r\\n.px-6 {\\n  padding-left: 1.5rem;\\n  padding-right: 1.5rem;\\n}\\r\\n.text-start {\\n  text-align: start;\\n}\\r\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\r\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\r\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\r\\n.font-bold {\\n  font-weight: 700;\\n}\\r\\n.font-extrabold {\\n  font-weight: 800;\\n}\\r\\n.leading-tight {\\n  line-height: 1.25;\\n}\\r\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\r\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n.shadow {\\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.shadow-md {\\n  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.hover\\\\:bg-slate-800:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(30 41 59 / var(--tw-bg-opacity));\\n}\\r\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxM10udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzEzXS51c2VbMl0hLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDd0g7QUFDeEgsOEJBQThCLGtIQUEyQjtBQUN6RDtBQUNBLDBYQUEwWCw0QkFBNEIsNEJBQTRCLGdDQUFnQyxrQ0FBa0MsVUFBVSx3QkFBd0IscUJBQXFCLEdBQUcscVlBQXFZLHNCQUFzQiwyQ0FBMkMsNkJBQTZCLDBCQUEwQixvQkFBb0IsdVBBQXVQLDBDQUEwQyw0Q0FBNEMsVUFBVSxnS0FBZ0ssZUFBZSxpQ0FBaUMsVUFBVSwyTkFBMk4sZUFBZSwyQkFBMkIsa0NBQWtDLFVBQVUsaUdBQWlHLDhDQUE4Qyw4Q0FBOEMsR0FBRyxrR0FBa0csdUJBQXVCLHlCQUF5QixHQUFHLGlGQUFpRixtQkFBbUIsNkJBQTZCLEdBQUcsMkVBQTJFLHdCQUF3QixHQUFHLDBKQUEwSix5SEFBeUgsMkJBQTJCLFVBQVUsaUVBQWlFLG1CQUFtQixHQUFHLDJHQUEyRyxtQkFBbUIsbUJBQW1CLHVCQUF1Qiw2QkFBNkIsR0FBRyxTQUFTLG9CQUFvQixHQUFHLFNBQVMsZ0JBQWdCLEdBQUcsZ2JBQWdiLG9CQUFvQixrQ0FBa0Msc0NBQXNDLFVBQVUsa01BQWtNLDBCQUEwQiw0QkFBNEIsaUNBQWlDLGlDQUFpQywyQkFBMkIsc0JBQXNCLHVCQUF1QixVQUFVLDhGQUE4Rix5QkFBeUIsR0FBRyxtTEFBbUwsZ0NBQWdDLDBDQUEwQyxtQ0FBbUMsVUFBVSwrRkFBK0Ysa0JBQWtCLEdBQUcsK01BQStNLHFCQUFx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TyxNQUFNLEtBQUssb0JBQW9CLHFCQUFxQixNQUFNLFFBQVEsTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sTUFBTSxNQUFNLFVBQVUsV0FBVyxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIscUJBQXFCLE1BQU0sUUFBUSxNQUFNLFNBQVMscUJBQXFCLG9CQUFvQixxQkFBcUIscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUssb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLFlBQVksb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsVUFBVSxNQUFNLFdBQVcsS0FBSyxVQUFVLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyx3Q0FBd0MseUJBQXlCLHdCQUF3Qix3QkFBd0I7QUFDNy9tQjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz8wNGRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcbiEgdGFpbHdpbmRjc3MgdjMuMy4yIHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcbiovLypcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcbiovXFxuXFxuKixcXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxufVxcblxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgLS10dy1jb250ZW50OiAnJztcXG59XFxuXFxuLypcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuNS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuNi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXFxuICAtby10YWItc2l6ZTogNDtcXG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiOyAvKiA0ICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogNSAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogNiAqL1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXG4qL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHIge1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXG4qL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxuKi9cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxudGFibGUge1xcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxcbiovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9J2J1dHRvbiddLFxcblt0eXBlPSdyZXNldCddLFxcblt0eXBlPSdzdWJtaXQnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxcbiovXFxuXFxuOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IGF1dG87XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGA6aW52YWxpZGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcXG4qL1xcblxcbjotbW96LXVpLWludmFsaWQge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLypcXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4qL1xcblxcblt0eXBlPSdzZWFyY2gnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qXFxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxcbiovXFxuXFxuYmxvY2txdW90ZSxcXG5kbCxcXG5kZCxcXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5ocixcXG5maWd1cmUsXFxucCxcXG5wcmUge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5sZWdlbmQge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxub2wsXFxudWwsXFxubWVudSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi8qXFxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxcbiovXFxuXFxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxcbiovXFxuXFxuYnV0dG9uLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi8qXFxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cXG4qL1xcbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qXFxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbjIuIEFkZCBgdmVydGljYWwtYWxpZ246IG1pZGRsZWAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cXG4qL1xcblxcbmltZyxcXG5zdmcsXFxudmlkZW8sXFxuY2FudmFzLFxcbmF1ZGlvLFxcbmlmcmFtZSxcXG5lbWJlZCxcXG5vYmplY3Qge1xcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuKi9cXG5cXG5pbWcsXFxudmlkZW8ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKiBNYWtlIGVsZW1lbnRzIHdpdGggdGhlIEhUTUwgaGlkZGVuIGF0dHJpYnV0ZSBzdGF5IGhpZGRlbiBieSBkZWZhdWx0ICovXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuXFxuOjpiYWNrZHJvcCB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXHJcXG4uY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDY0MHB4O1xcbiAgfVxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDc2OHB4O1xcbiAgfVxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxuXFxuICAuY29udGFpbmVyIHtcXG4gICAgbWF4LXdpZHRoOiAxMDI0cHg7XFxuICB9XFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDEyODBweDtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDE1MzZweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogMTUzNnB4O1xcbiAgfVxcbn1cXHJcXG4ucmVsYXRpdmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXHJcXG4uc3RpY2t5IHtcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxufVxcclxcbi5teC1hdXRvIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXHJcXG4ubXktMTYge1xcbiAgbWFyZ2luLXRvcDogNHJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDRyZW07XFxufVxcclxcbi5tYi0yIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG59XFxyXFxuLm1iLTQge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLm1iLTE2IHtcXG4gIG1hcmdpbi1ib3R0b206IDRyZW07XFxufVxcclxcbi5ibG9jayB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxyXFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxyXFxuLmdyaWQge1xcbiAgZGlzcGxheTogZ3JpZDtcXG59XFxyXFxuLmgtMjAge1xcbiAgaGVpZ2h0OiA1cmVtO1xcbn1cXHJcXG4uaC1zY3JlZW4ge1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxyXFxuLmgtZnVsbCB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcclxcbi53LTEwXFxcXC8xMiB7XFxuICB3aWR0aDogODMuMzMzMzMzJTtcXG59XFxyXFxuLnctZnVsbCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxyXFxuLnctc2NyZWVuIHtcXG4gIHdpZHRoOiAxMDB2dztcXG59XFxyXFxuLm1heC13LW1kIHtcXG4gIG1heC13aWR0aDogMjhyZW07XFxufVxcclxcbi5hcHBlYXJhbmNlLW5vbmUge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgICBhcHBlYXJhbmNlOiBub25lO1xcbn1cXHJcXG4uZ3JpZC1jb2xzLTIge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcbn1cXHJcXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcclxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcclxcbi5nYXAtMTYge1xcbiAgZ2FwOiA0cmVtO1xcbn1cXHJcXG4uZ2FwLXktMjAge1xcbiAgcm93LWdhcDogNXJlbTtcXG59XFxyXFxuLmdhcC14LTEwIHtcXG4gIC1tb3otY29sdW1uLWdhcDogMi41cmVtO1xcbiAgICAgICBjb2x1bW4tZ2FwOiAyLjVyZW07XFxufVxcclxcbi5zcGFjZS15LTIwID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi10b3A6IGNhbGMoNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoNXJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbn1cXHJcXG4uc3BhY2UteC0xMCA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMi41cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygyLjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxufVxcclxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxufVxcclxcbi5yb3VuZGVkLWxnIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcXG59XFxyXFxuLmJvcmRlciB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxyXFxuLmJnLXJlZC00MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0OCAxMTMgMTEzIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctc2xhdGUtMzAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMDMgMjEzIDIyNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXNsYXRlLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTAwIDExNiAxMzkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1zbGF0ZS02MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDcxIDg1IDEwNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXN0b25lLTcwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNjggNjQgNjAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1zbGF0ZS01MCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ4IDI1MCAyNTIgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy10ZWFsLTQwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNDUgMjEyIDE5MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLnAtNCB7XFxuICBwYWRkaW5nOiAxcmVtO1xcbn1cXHJcXG4ucHgtMiB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXG59XFxyXFxuLnB4LTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLnB4LTQge1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXG59XFxyXFxuLnB4LTgge1xcbiAgcGFkZGluZy1sZWZ0OiAycmVtO1xcbiAgcGFkZGluZy1yaWdodDogMnJlbTtcXG59XFxyXFxuLnB5LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxufVxcclxcbi5weS0zIHtcXG4gIHBhZGRpbmctdG9wOiAwLjc1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxufVxcclxcbi5weS02IHtcXG4gIHBhZGRpbmctdG9wOiAxLjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcbn1cXHJcXG4ucHgtNiB7XFxuICBwYWRkaW5nLWxlZnQ6IDEuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTtcXG59XFxyXFxuLnRleHQtc3RhcnQge1xcbiAgdGV4dC1hbGlnbjogc3RhcnQ7XFxufVxcclxcbi50ZXh0LXNtIHtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLnRleHQtM3hsIHtcXG4gIGZvbnQtc2l6ZTogMS44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMi4yNXJlbTtcXG59XFxyXFxuLnRleHQtMnhsIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxufVxcclxcbi5mb250LWJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxyXFxuLmZvbnQtZXh0cmFib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcclxcbi5sZWFkaW5nLXRpZ2h0IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbn1cXHJcXG4udGV4dC1ncmF5LTcwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtd2hpdGUge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5zaGFkb3cge1xcbiAgLS10dy1zaGFkb3c6IDAgMXB4IDNweCAwIHJnYigwIDAgMCAvIDAuMSksIDAgMXB4IDJweCAtMXB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDFweCAzcHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDFweCAycHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxyXFxuLnNoYWRvdy1tZCB7XFxuICAtLXR3LXNoYWRvdzogMCA0cHggNnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKSwgMCAycHggNHB4IC0ycHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgNHB4IDZweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgMnB4IDRweCAtMnB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLXNsYXRlLTgwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzAgNDEgNTkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3VzIHtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIixcIjxubyBzb3VyY2U+XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztDQUFjLENBQWQ7OztDQUFjOztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7Ozs7Ozs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjLEVBQWQsTUFBYztFQUFkLDhCQUFjLEVBQWQsTUFBYztFQUFkLGdCQUFjLEVBQWQsTUFBYztFQUFkLGNBQWM7S0FBZCxXQUFjLEVBQWQsTUFBYztFQUFkLDROQUFjLEVBQWQsTUFBYztFQUFkLDZCQUFjLEVBQWQsTUFBYztFQUFkLCtCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFNBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDtFQUFBLFNBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHlDQUFjO1VBQWQsaUNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7Ozs7O0VBQUEsa0JBQWM7RUFBZCxvQkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsY0FBYztFQUFkLHdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsbUJBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwrR0FBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsY0FBYztBQUFBOztBQUFkOztD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QW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7S0FBbkIscUJBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO09BQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLDREQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixzREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMEVBQW1CO0VBQW5CLDhGQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDZFQUFtQjtFQUFuQixpR0FBbUI7RUFBbkI7QUFBbUI7QUFGbkI7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLCtCQ0FBO0VEQUE7Q0NBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAdGFpbHdpbmQgYmFzZTtcXHJcXG5AdGFpbHdpbmQgY29tcG9uZW50cztcXHJcXG5AdGFpbHdpbmQgdXRpbGl0aWVzO1wiLG51bGxdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.jsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQywyZUFBaVA7O0FBRW5SOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSwyZUFBaVA7QUFDdlA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywyZUFBaVA7O0FBRTNROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz80MmE4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxM10udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzEzXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzEzXS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkxKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpMV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgICB9O1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./components/Nav.jsx":
/*!****************************!*\
  !*** ./components/Nav.jsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _contexts_AppContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/AppContext */ \"./contexts/AppContext.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Nav() {\n    _s();\n    const { ethWallet , account , contract , connectAccount  } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_contexts_AppContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-20 relative w-full p-4\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex justify-between sticky\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: \"VESTING APP\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n                    lineNumber: 10,\n                    columnNumber: 17\n                }, this),\n                account && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: account\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n                    lineNumber: 12,\n                    columnNumber: 21\n                }, this),\n                !account && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"space-x-10\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                            className: \"bg-teal-400 text-white py-3 rounded-lg px-6\",\n                            href: \"/\",\n                            children: \"Users\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n                            lineNumber: 17,\n                            columnNumber: 29\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                            className: \"bg-slate-600 text-white py-3 rounded-lg px-6\",\n                            href: \"/admin\",\n                            children: \"Admin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n                            lineNumber: 21,\n                            columnNumber: 29\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n                    lineNumber: 16,\n                    columnNumber: 25\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n            lineNumber: 9,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\components\\\\Nav.jsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, this);\n}\n_s(Nav, \"+hwT+/Hs6G1/StzVl9Ev5eRases=\");\n_c = Nav;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Nav);\nvar _c;\n$RefreshReg$(_c, \"Nav\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL05hdi5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ25CO0FBRTdCLFNBQVNJLE1BQU07O0lBQ1gsTUFBTSxFQUFFQyxVQUFTLEVBQUVDLFFBQU8sRUFBRUMsU0FBUSxFQUFFQyxlQUFjLEVBQUUsR0FBR1AsaURBQVVBLENBQUNDLDREQUFVQTtJQUM5RSxxQkFDSSw4REFBQ087UUFBSUMsV0FBVTtrQkFDWCw0RUFBQ0Q7WUFBSUMsV0FBVTs7OEJBQ1gsOERBQUNDOzhCQUFFOzs7Ozs7Z0JBQ0ZMLHlCQUNHLDhEQUFDSzs4QkFBR0w7Ozs7OztnQkFHSixDQUFDQSx5QkFDRyw4REFBQ0c7b0JBQUlDLFdBQVU7O3NDQUNYLDhEQUFDUCxrREFBSUE7NEJBQ0RPLFdBQVU7NEJBQ1ZFLE1BQUs7c0NBQUk7Ozs7OztzQ0FFYiw4REFBQ1Qsa0RBQUlBOzRCQUNETyxXQUFVOzRCQUNWRSxNQUFLO3NDQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU85QztHQXpCU1I7S0FBQUE7QUEyQlQsK0RBQWVBLEdBQUdBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXYuanN4Pzk4OTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IEFwcENvbnRleHQgZnJvbSAnLi4vY29udGV4dHMvQXBwQ29udGV4dCc7XHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcblxyXG5mdW5jdGlvbiBOYXYoKSB7XHJcbiAgICBjb25zdCB7IGV0aFdhbGxldCwgYWNjb3VudCwgY29udHJhY3QsIGNvbm5lY3RBY2NvdW50IH0gPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0naC0yMCByZWxhdGl2ZSB3LWZ1bGwgcC00Jz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZsZXgganVzdGlmeS1iZXR3ZWVuIHN0aWNreSc+XHJcbiAgICAgICAgICAgICAgICA8cD5WRVNUSU5HIEFQUDwvcD5cclxuICAgICAgICAgICAgICAgIHthY2NvdW50ICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8cD57YWNjb3VudH08L3A+XHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICFhY2NvdW50ICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3NwYWNlLXgtMTAnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdiZy10ZWFsLTQwMCB0ZXh0LXdoaXRlIHB5LTMgcm91bmRlZC1sZyBweC02J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCIvXCI+VXNlcnM8L0xpbms+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdiZy1zbGF0ZS02MDAgdGV4dC13aGl0ZSBweS0zIHJvdW5kZWQtbGcgcHgtNidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwiL2FkbWluXCI+QWRtaW48L0xpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5hdiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNvbnRleHQiLCJBcHBDb250ZXh0IiwiTGluayIsIk5hdiIsImV0aFdhbGxldCIsImFjY291bnQiLCJjb250cmFjdCIsImNvbm5lY3RBY2NvdW50IiwiZGl2IiwiY2xhc3NOYW1lIiwicCIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Nav.jsx\n"));

/***/ }),

/***/ "./constants/index.js":
/*!****************************!*\
  !*** ./constants/index.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONTRACT_ADDRESS\": function() { return /* binding */ CONTRACT_ADDRESS; }\n/* harmony export */ });\nconst CONTRACT_ADDRESS = \"0x5FbDB2315678afecb367f032d93F642f64180aa3\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb25zdGFudHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLG1CQUFtQiw2Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29uc3RhbnRzL2luZGV4LmpzPzM3MzciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSAnMHg1RmJEQjIzMTU2NzhhZmVjYjM2N2YwMzJkOTNGNjQyZjY0MTgwYWEzJyBcclxuIl0sIm5hbWVzIjpbIkNPTlRSQUNUX0FERFJFU1MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./constants/index.js\n"));

/***/ }),

/***/ "./contexts/AppContext.js":
/*!********************************!*\
  !*** ./contexts/AppContext.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)();\n/* harmony default export */ __webpack_exports__[\"default\"] = (AppContext);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250ZXh0cy9BcHBDb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFzQztBQUV0QyxNQUFNQywyQkFBYUQsb0RBQWFBO0FBRWhDLCtEQUFlQyxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHRzL0FwcENvbnRleHQuanM/Y2IzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5jb25zdCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXBwQ29udGV4dDsiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIkFwcENvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./contexts/AppContext.js\n"));

/***/ }),

/***/ "./contexts/ContextWrapper.js":
/*!************************************!*\
  !*** ./contexts/ContextWrapper.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContextWrapper\": function() { return /* binding */ ContextWrapper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./constants/index.js\");\n/* harmony import */ var _artifacts_contracts_TokenVesting_sol_TokenVesting_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../artifacts/contracts/TokenVesting.sol/TokenVesting.json */ \"./artifacts/contracts/TokenVesting.sol/TokenVesting.json\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _AppContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AppContext */ \"./contexts/AppContext.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/dist/ethers.umd.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ethers__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction ContextWrapper(param) {\n    let { children  } = param;\n    _s();\n    const [ethWallet, setEthWallet] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const [account, setAccount] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const getWallet = async ()=>{\n        if (window.ethereum) {\n            setEthWallet(window.ethereum);\n        }\n        if (ethWallet) {\n            const account = await ethWallet.request({\n                method: \"eth_accounts\"\n            });\n            handleAccount(account);\n        }\n    };\n    const handleAccount = (account)=>{\n        if (account) {\n            console.log(\"Account connected: \", account);\n            setAccount(account);\n        } else {\n            console.log(\"No account found\");\n        }\n    };\n    const connectAccount = async ()=>{\n        if (!ethWallet) {\n            alert(\"MetaMask wallet is required to connect\");\n            return;\n        }\n        const accounts = await ethWallet.request({\n            method: \"eth_requestAccounts\"\n        });\n        handleAccount(accounts);\n        // once wallet is set we can get a reference to our deployed contract\n        getContract();\n    };\n    const getContract = ()=>{\n        console.log(\"CONTRACT_ABI\", _artifacts_contracts_TokenVesting_sol_TokenVesting_json__WEBPACK_IMPORTED_MODULE_2__);\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.providers.Web3Provider(ethWallet);\n        const signer = provider.getSigner();\n        const contractObj = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(_constants__WEBPACK_IMPORTED_MODULE_1__.CONTRACT_ADDRESS, _artifacts_contracts_TokenVesting_sol_TokenVesting_json__WEBPACK_IMPORTED_MODULE_2__.abi, signer);\n        console.log(\"\\uD83D\\uDE80 ~ file: ContextWrapper.js:53 ~ getContract ~ contractObj:\", contractObj);\n        setContract(contractObj);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        getWallet();\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AppContext__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Provider, {\n        value: {\n            ethWallet,\n            account,\n            contract,\n            connectAccount\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\contexts\\\\ContextWrapper.js\",\n        lineNumber: 60,\n        columnNumber: 12\n    }, this);\n}\n_s(ContextWrapper, \"G5nSW/zC1nX0oFEz+JJEuTR/hyo=\");\n_c = ContextWrapper;\nvar _c;\n$RefreshReg$(_c, \"ContextWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250ZXh0cy9Db250ZXh0V3JhcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDcUM7QUFDN0I7QUFDbEI7QUFDTjtBQUV6QixTQUFTTyxlQUFlLEtBQVUsRUFBRTtRQUFaLEVBQUNDLFNBQVEsRUFBQyxHQUFWOztJQUUzQixNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR04sK0NBQVFBLENBQUNPO0lBQzNDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHVCwrQ0FBUUEsQ0FBQ087SUFDdkMsTUFBTSxDQUFDRyxVQUFVQyxZQUFZLEdBQUdYLCtDQUFRQSxDQUFDTztJQUV6QyxNQUFNSyxZQUFZLFVBQVc7UUFDekIsSUFBSUMsT0FBT0MsUUFBUSxFQUFFO1lBQ3JCUixhQUFhTyxPQUFPQyxRQUFRO1FBQzVCLENBQUM7UUFFRCxJQUFJVCxXQUFXO1lBQ2YsTUFBTUcsVUFBVSxNQUFNSCxVQUFVVSxPQUFPLENBQUM7Z0JBQUNDLFFBQVE7WUFBYztZQUMvREMsY0FBY1Q7UUFDZCxDQUFDO0lBQ0w7SUFFQSxNQUFNUyxnQkFBZ0IsQ0FBQ1QsVUFBWTtRQUMvQixJQUFJQSxTQUFTO1lBQ2JVLFFBQVFDLEdBQUcsQ0FBRSx1QkFBdUJYO1lBQ3BDQyxXQUFXRDtRQUNYLE9BQ0s7WUFDTFUsUUFBUUMsR0FBRyxDQUFDO1FBQ1osQ0FBQztJQUNMO0lBRUEsTUFBTUMsaUJBQWlCLFVBQVc7UUFDOUIsSUFBSSxDQUFDZixXQUFXO1lBQ2hCZ0IsTUFBTTtZQUNOO1FBQ0EsQ0FBQztRQUVELE1BQU1DLFdBQVcsTUFBTWpCLFVBQVVVLE9BQU8sQ0FBQztZQUFFQyxRQUFRO1FBQXNCO1FBQ3pFQyxjQUFjSztRQUVkLHFFQUFxRTtRQUNyRUM7SUFDSjtJQUVBLE1BQU1BLGNBQWMsSUFBTTtRQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGdCQUFnQnRCLG9GQUFZQTtRQUV4QyxNQUFNMkIsV0FBVyxJQUFJdEIsaUVBQTZCLENBQUNHO1FBQ25ELE1BQU1zQixTQUFTSCxTQUFTSSxTQUFTO1FBQ2pDLE1BQU1DLGNBQWMsSUFBSTNCLG1EQUFlLENBQUNOLHdEQUFnQkEsRUFBRUMsd0ZBQWdCLEVBQUU4QjtRQUM1RVQsUUFBUUMsR0FBRyxDQUFDLDBFQUFnRVU7UUFFNUVsQixZQUFZa0I7SUFDaEI7SUFFQTlCLGdEQUFTQSxDQUFDLElBQU07UUFBQ2E7SUFBWSxHQUFHLEVBQUU7SUFFbEMscUJBQU8sOERBQUNYLDREQUFtQjtRQUFDZ0MsT0FBTztZQUMvQjVCO1lBQ0FHO1lBQ0FFO1lBQ0FVO1FBQ0g7a0JBQ0loQjs7Ozs7O0FBRVQsQ0FBQztHQTdEZUQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvQ29udGV4dFdyYXBwZXIuanM/ODMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05UUkFDVF9BRERSRVNTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IENPTlRSQUNUX0FCSSBmcm9tICcuLi9hcnRpZmFjdHMvY29udHJhY3RzL1Rva2VuVmVzdGluZy5zb2wvVG9rZW5WZXN0aW5nLmpzb24nO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQXBwQ29udGV4dCBmcm9tICcuL0FwcENvbnRleHQnO1xyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvbnRleHRXcmFwcGVyKHtjaGlsZHJlbn0pIHtcclxuXHJcbiAgICBjb25zdCBbZXRoV2FsbGV0LCBzZXRFdGhXYWxsZXRdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IFthY2NvdW50LCBzZXRBY2NvdW50XSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBbY29udHJhY3QsIHNldENvbnRyYWN0XSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgY29uc3QgZ2V0V2FsbGV0ID0gYXN5bmMoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICAgIHNldEV0aFdhbGxldCh3aW5kb3cuZXRoZXJldW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV0aFdhbGxldCkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBldGhXYWxsZXQucmVxdWVzdCh7bWV0aG9kOiBcImV0aF9hY2NvdW50c1wifSk7XHJcbiAgICAgICAgaGFuZGxlQWNjb3VudChhY2NvdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQWNjb3VudCA9IChhY2NvdW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGFjY291bnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyAoXCJBY2NvdW50IGNvbm5lY3RlZDogXCIsIGFjY291bnQpO1xyXG4gICAgICAgIHNldEFjY291bnQoYWNjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWNjb3VudCBmb3VuZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29ubmVjdEFjY291bnQgPSBhc3luYygpID0+IHtcclxuICAgICAgICBpZiAoIWV0aFdhbGxldCkge1xyXG4gICAgICAgIGFsZXJ0KCdNZXRhTWFzayB3YWxsZXQgaXMgcmVxdWlyZWQgdG8gY29ubmVjdCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGV0aFdhbGxldC5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycgfSk7XHJcbiAgICAgICAgaGFuZGxlQWNjb3VudChhY2NvdW50cyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gb25jZSB3YWxsZXQgaXMgc2V0IHdlIGNhbiBnZXQgYSByZWZlcmVuY2UgdG8gb3VyIGRlcGxveWVkIGNvbnRyYWN0XHJcbiAgICAgICAgZ2V0Q29udHJhY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0Q29udHJhY3QgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NPTlRSQUNUX0FCSScsIENPTlRSQUNUX0FCSSlcclxuXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoZXRoV2FsbGV0KTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgICAgICBjb25zdCBjb250cmFjdE9iaiA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09OVFJBQ1RfQUREUkVTUywgQ09OVFJBQ1RfQUJJLmFiaSwgc2lnbmVyKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfmoAgfiBmaWxlOiBDb250ZXh0V3JhcHBlci5qczo1MyB+IGdldENvbnRyYWN0IH4gY29udHJhY3RPYmo6XCIsIGNvbnRyYWN0T2JqKVxyXG4gICAgXHJcbiAgICAgICAgc2V0Q29udHJhY3QoY29udHJhY3RPYmopO1xyXG4gICAgfVxyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7Z2V0V2FsbGV0KCk7fSwgW10pO1xyXG5cclxuICAgIHJldHVybiA8QXBwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBcclxuICAgICAgICBldGhXYWxsZXQsXHJcbiAgICAgICAgYWNjb3VudCxcclxuICAgICAgICBjb250cmFjdCxcclxuICAgICAgICBjb25uZWN0QWNjb3VudCxcclxuICAgICB9fT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0FwcENvbnRleHQuUHJvdmlkZXI+XHJcbn0iXSwibmFtZXMiOlsiQ09OVFJBQ1RfQUREUkVTUyIsIkNPTlRSQUNUX0FCSSIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJBcHBDb250ZXh0IiwiZXRoZXJzIiwiQ29udGV4dFdyYXBwZXIiLCJjaGlsZHJlbiIsImV0aFdhbGxldCIsInNldEV0aFdhbGxldCIsInVuZGVmaW5lZCIsImFjY291bnQiLCJzZXRBY2NvdW50IiwiY29udHJhY3QiLCJzZXRDb250cmFjdCIsImdldFdhbGxldCIsIndpbmRvdyIsImV0aGVyZXVtIiwicmVxdWVzdCIsIm1ldGhvZCIsImhhbmRsZUFjY291bnQiLCJjb25zb2xlIiwibG9nIiwiY29ubmVjdEFjY291bnQiLCJhbGVydCIsImFjY291bnRzIiwiZ2V0Q29udHJhY3QiLCJwcm92aWRlciIsInByb3ZpZGVycyIsIldlYjNQcm92aWRlciIsInNpZ25lciIsImdldFNpZ25lciIsImNvbnRyYWN0T2JqIiwiQ29udHJhY3QiLCJhYmkiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contexts/ContextWrapper.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTRixnQkFBZ0JLLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGFBQWEsRUFBRTtJQUMzRCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPLEtBQUs7SUFDaEIsQ0FBQztBQUNMO0FBRUEsSUFBSSxDQUFDLE9BQU9KLFFBQVF1QixPQUFPLEtBQUssY0FBZSxPQUFPdkIsUUFBUXVCLE9BQU8sS0FBSyxZQUFZdkIsUUFBUXVCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3ZCLFFBQVF1QixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLMUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRdUIsT0FBTyxFQUFFLGNBQWM7UUFBRXRCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPMkIsTUFBTSxDQUFDekIsUUFBUXVCLE9BQU8sRUFBRXZCO0lBQy9CMEIsT0FBTzFCLE9BQU8sR0FBR0EsUUFBUXVCLE9BQU87QUFDbEMsQ0FBQyxDQUVELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXREb21haW5Mb2NhbGUgPSBnZXREb21haW5Mb2NhbGU7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBnZXREb21haW5Mb2NhbGUocGF0aCwgbG9jYWxlLCBsb2NhbGVzLCBkb21haW5Mb2NhbGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZSgnLi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gYGh0dHAke2RvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vYDtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke3RhcmdldH1gO1xuICAgICAgICAgICAgcmV0dXJuIGAke3Byb3RvfSR7ZG9tYWluLmRvbWFpbn0ke2Jhc2VQYXRofSR7ZmluYWxMb2NhbGV9JHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldERvbWFpbkxvY2FsZSIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInJlcXVpcmUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _resolveHref = __webpack_require__(/*! ../shared/lib/router/utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nvar _isLocalUrl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _formatUrl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName  } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _isLocalUrl).isLocalURL(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        // @ts-expect-error startTransition exists.\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formatUrl).formatUrl(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    let children;\n    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , legacyBehavior =true === false  } = props, restProps = _object_without_properties_loose(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const prefetchEnabled = prefetchProp !== false;\n    const pagesRouter = _react.default.useContext(_routerContext.RouterContext);\n    const appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\".concat(href, \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"));\n                }\n            }\n        }\n    }\n    const { href , as  } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolveHref).resolveHref(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            var ref;\n            if (((ref = children) == null ? void 0 : ref.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useIntersection).useIntersection({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils).isAbsoluteUrl(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getDomainLocale).getDomainLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"ann5/dOH/k5dvIvXTqfdyzq9F1A=\")), \"ann5/dOH/k5dvIvXTqfdyzq9F1A=\");\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQURiO0FBRUFBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxtQ0FBbUNELG1LQUF1RTtBQUM5RyxJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELElBQUlHLGVBQWVILG1CQUFPQSxDQUFDLGlIQUF5QztBQUNwRSxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQyxpSEFBeUM7QUFDbkUsSUFBSUssYUFBYUwsbUJBQU9BLENBQUMsNkdBQXVDO0FBQ2hFLElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLHlFQUFxQjtBQUMxQyxJQUFJTyxhQUFhUCxtQkFBT0EsQ0FBQyxtRUFBYztBQUN2QyxJQUFJUSxpQkFBaUJSLG1CQUFPQSxDQUFDLDJGQUE4QjtBQUMzRCxJQUFJUyxvQkFBb0JULG1CQUFPQSxDQUFDLG1HQUFrQztBQUNsRSxJQUFJVSxtQkFBbUJWLG1CQUFPQSxDQUFDLCtFQUFvQjtBQUNuRCxJQUFJVyxtQkFBbUJYLG1CQUFPQSxDQUFDLGlGQUFxQjtBQUNwRCxJQUFJWSxlQUFlWixtQkFBT0EsQ0FBQyx5RUFBaUI7QUFFNUMsTUFBTWEsYUFBYSxJQUFJQztBQUN2QixTQUFTQyxTQUFTQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRTtJQUN0RCxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDRCxnSkFBZ0o7SUFDaEosSUFBSSxDQUFDQSxlQUFlLENBQUMsQ0FBQyxHQUFHaEIsV0FBVyxFQUFFaUIsVUFBVSxDQUFDSixPQUFPO1FBQ3BEO0lBQ0osQ0FBQztJQUNELDRFQUE0RTtJQUM1RSxZQUFZO0lBQ1osSUFBSSxDQUFDRSxRQUFRRyxxQkFBcUIs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R0FBR2hGLE9BQU9KLE9BQU8sQ0FBQ3FKLFlBQVksQ0FBQzVCLE9BQU9lLGNBQWMsV0FBVyxHQUFHcEksT0FBT0osT0FBTyxDQUFDc0csYUFBYSxDQUFDLEtBQUsxRyxPQUFPMEosTUFBTSxDQUFDLENBQUMsR0FBR2pELFdBQVdtQyxhQUFhNUMsU0FBUztBQUM5TDs7QUFDQSxJQUFJMkQsV0FBV3hGO0FBQ2ZqRSxrQkFBZSxHQUFHeUo7QUFFbEIsSUFBSSxDQUFDLE9BQU96SixRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUN3SixVQUFVLEtBQUssYUFBYTtJQUNySzVKLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8wSixNQUFNLENBQUN4SixRQUFRRSxPQUFPLEVBQUVGO0lBQy9CMkosT0FBTzNKLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVzb2x2ZUhyZWYgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xudmFyIF9pc0xvY2FsVXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmxcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG52YXIgX2FkZExvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG52YXIgX3JvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfdXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbnZhciBfZ2V0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZ2V0LWRvbWFpbi1sb2NhbGVcIik7XG52YXIgX2FkZEJhc2VQYXRoID0gcmVxdWlyZShcIi4vYWRkLWJhc2UtcGF0aFwiKTtcblxuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIG9wdGlvbnMsIGlzQXBwUm91dGVyKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKCFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc0xvY2FsVXJsKS5pc0xvY2FsVVJMKGhyZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgZGVkdXBlIHJlcXVlc3RzIHdoZW4gZXhwZXJpbWVudGFsLm9wdGltaXN0aWNDbGllbnRDYWNoZSBpc1xuICAgIC8vIGRpc2FibGVkLlxuICAgIGlmICghb3B0aW9ucy5ieXBhc3NQcmVmZXRjaGVkQ2hlY2spIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gLy8gTGV0IHRoZSBsaW5rJ3MgbG9jYWxlIHByb3Agb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcm91dGVyIGxvY2FsZS5cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9jYWxlIDogJ2xvY2FsZScgaW4gcm91dGVyID8gcm91dGVyLmxvY2FsZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hlZEtleSA9IGhyZWYgKyAnJScgKyBhcyArICclJyArIGxvY2FsZTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBrZXksIHRoZW4gZG9uJ3QgcHJlZmV0Y2ggaXQgYWdhaW4hXG4gICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhwcmVmZXRjaGVkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhpcyBVUkwgYXMgcHJlZmV0Y2hlZC5cbiAgICAgICAgcHJlZmV0Y2hlZC5hZGQocHJlZmV0Y2hlZEtleSk7XG4gICAgfVxuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgUHJvbWlzZS5yZXNvbHZlKHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykpLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIsIHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgKCFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc0xvY2FsVXJsKS5pc0xvY2FsVVJMKGhyZWYpKSkpIHtcbiAgICAgICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKCk9PntcbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlciBpcyBhbiBOZXh0Um91dGVyIGluc3RhbmNlIGl0IHdpbGwgaGF2ZSBgYmVmb3JlUG9wU3RhdGVgXG4gICAgICAgIGlmICgnYmVmb3JlUG9wU3RhdGUnIGluIHJvdXRlcikge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShhcyB8fCBocmVmLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbjogIXByZWZldGNoRW5hYmxlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0FwcFJvdXRlcikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHMuXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmF2aWdhdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdPclVybCh1cmxPYmpPclN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxPYmpPclN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRVcmwodXJsT2JqT3JTdHJpbmcpO1xufVxuLyoqXG4gKiBSZWFjdCBDb21wb25lbnQgdGhhdCBlbmFibGVzIGNsaWVudC1zaWRlIHRyYW5zaXRpb25zIGJldHdlZW4gcm91dGVzLlxuICovIGNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb25DbGljaycgfHwga2V5ID09PSAnb25Nb3VzZUVudGVyJyB8fCBrZXkgPT09ICdvblRvdWNoU3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgZnVuY3Rpb25gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JlcGxhY2UnIHx8IGtleSA9PT0gJ3Njcm9sbCcgfHwga2V5ID09PSAnc2hhbGxvdycgfHwga2V5ID09PSAncGFzc0hyZWYnIHx8IGtleSA9PT0gJ3ByZWZldGNoJyB8fCBrZXkgPT09ICdsZWdhY3lCZWhhdmlvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIGNvbnN0IHsgaHJlZjogaHJlZlByb3AgLCBhczogYXNQcm9wICwgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCAsIHByZWZldGNoOiBwcmVmZXRjaFByb3AgLCBwYXNzSHJlZiAsIHJlcGxhY2UgLCBzaGFsbG93ICwgc2Nyb2xsICwgbG9jYWxlICwgb25DbGljayAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCAsIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCAsIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyBpbmxpbmVkIGFzIGEgbGl0ZXJhbCBib29sZWFuIG5vdCBhIHN0cmluZ1xuICAgIGxlZ2FjeUJlaGF2aW9yID1wcm9jZXNzLmVudi5fX05FWFRfTkVXX0xJTktfQkVIQVZJT1IgPT09IGZhbHNlICB9ID0gcHJvcHMsIHJlc3RQcm9wcyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHByb3BzLCBbXG4gICAgICAgIFwiaHJlZlwiLFxuICAgICAgICBcImFzXCIsXG4gICAgICAgIFwiY2hpbGRyZW5cIixcbiAgICAgICAgXCJwcmVmZXRjaFwiLFxuICAgICAgICBcInBhc3NIcmVmXCIsXG4gICAgICAgIFwicmVwbGFjZVwiLFxuICAgICAgICBcInNoYWxsb3dcIixcbiAgICAgICAgXCJzY3JvbGxcIixcbiAgICAgICAgXCJsb2NhbGVcIixcbiAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgIFwib25Nb3VzZUVudGVyXCIsXG4gICAgICAgIFwib25Ub3VjaFN0YXJ0XCIsXG4gICAgICAgIFwibGVnYWN5QmVoYXZpb3JcIlxuICAgIF0pO1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuICAgIGNvbnN0IHBhZ2VzUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHJvdXRlciA9IHBhZ2VzUm91dGVyICE9IG51bGwgPyBwYWdlc1JvdXRlciA6IGFwcFJvdXRlcjtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGlzQXBwUm91dGVyICYmICFhc1Byb3ApIHtcbiAgICAgICAgICAgIGxldCBocmVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmLnNwbGl0KCcvJykuc29tZSgoc2VnbWVudCk9PnNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHluYW1pYyBocmVmIFxcYCR7aHJlZn1cXGAgZm91bmQgaW4gPExpbms+IHdoaWxlIHVzaW5nIHRoZSBcXGAvYXBwXFxgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgaHJlZiAsIGFzICB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBpZiAoIXBhZ2VzUm91dGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgICAgICBhczogYXNQcm9wID8gZm9ybWF0U3RyaW5nT3JVcmwoYXNQcm9wKSA6IHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZUhyZWYpLnJlc29sdmVIcmVmKHBhZ2VzUm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yZXNvbHZlSHJlZikucmVzb2x2ZUhyZWYocGFnZXNSb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcGFnZXNSb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlbmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBpZiAoKChyZWYgPSBjaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50eXBlKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRSZWYgPSBsZWdhY3lCZWhhdmlvciA/IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlSW50ZXJzZWN0aW9uKS51c2VJbnRlcnNlY3Rpb24oe1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaXNBcHBSb3V0ZXIsIFxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrIChlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyLCBwcmVmZXRjaEVuYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXIgKGUpIHtcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlclByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0UHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgICAvLyBJZiB0aGUgdXJsIGlzIGFic29sdXRlLCB3ZSBjYW4gYnlwYXNzIHRoZSBsb2dpYyB0byBwcmVwZW5kIHRoZSBkb21haW4gYW5kIGxvY2FsZS5cbiAgICBpZiAoKDAsIF91dGlscykuaXNBYnNvbHV0ZVVybChhcykpIHtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gYXM7XG4gICAgfSBlbHNlIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGU7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IChwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuaXNMb2NhbGVEb21haW4pICYmICgwLCBfZ2V0RG9tYWluTG9jYWxlKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZXMsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kb21haW5Mb2NhbGVzKTtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2FjeUJlaGF2aW9yID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0UHJvcHMsIGNoaWxkUHJvcHMpLCBjaGlsZHJlbik7XG59KTtcbnZhciBfZGVmYXVsdCA9IExpbms7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlIiwiX3JlYWN0IiwiX3Jlc29sdmVIcmVmIiwiX2lzTG9jYWxVcmwiLCJfZm9ybWF0VXJsIiwiX3V0aWxzIiwiX2FkZExvY2FsZSIsIl9yb3V0ZXJDb250ZXh0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfdXNlSW50ZXJzZWN0aW9uIiwiX2dldERvbWFpbkxvY2FsZSIsIl9hZGRCYXNlUGF0aCIsInByZWZldGNoZWQiLCJTZXQiLCJwcmVmZXRjaCIsInJvdXRlciIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJwcmVmZXRjaEVuYWJsZWQiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Ub3VjaFN0YXJ0IiwibGVnYWN5QmVoYXZpb3IiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImNoaWxkcmVuIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaFByb3AiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0UHJvcCIsImVudiIsIl9fTkVYVF9ORVdfTElOS19CRUhBVklPUiIsInJlc3RQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInJlZiIsInR5cGUiLCJjaGlsZFJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0IiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmlvcml0eSIsImlzQWJzb2x1dGVVcmwiLCJjdXJMb2NhbGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiYXNzaWduIiwiX2RlZmF1bHQiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef , rootMargin , disabled  } = param;\n    _s();\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react).useState(false);\n    const elementRef = (0, _react).useRef(null);\n    const setElement = (0, _react).useCallback((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react).useEffect(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true));\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react).useCallback(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\n_s(useIntersection, \"f+30nk3/InClhhpF4v6D3kkuqlo=\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsNENBQU87QUFDNUIsSUFBSUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQsTUFBTUUsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUNoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQVMsRUFBRTtBQUNqQixTQUFTQyxlQUFlQyxPQUFPLEVBQUU7SUFDN0IsTUFBTUMsS0FBSztRQUNQQyxNQUFNRixRQUFRRSxJQUFJLElBQUksSUFBSTtRQUMxQkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVhLEdBQUcsQ0FBQ0o7UUFDekIsSUFBSUcsVUFBVTtZQUNWLE9BQU9BO1FBQ1gsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNRSxXQUFXLElBQUliO0lBQ3JCLE1BQU1jLFdBQVcsSUFBSWhCLHFCQUFxQixDQUFDaUIsVUFBVTtRQUNqREEsUUFBUUMsT0FBTyxDQUFDLENBQUNDLFFBQVE7WUFDckIsTUFBTUMsV0FBV0wsU0FBU0QsR0FBRyxDQUFDSyxNQUFNRSxNQUFNO1lBQzFDLE1BQU1DLFlBQVlILE1BQU1JLGNBQWMsSUFBSUosTUFBTUssaUJBQWlCLEdBQUc7WUFDcEUsSUFBSUosWUFBWUUsV0FBVztnQkFDdkJGLFNBQVNFO1lBQ2IsQ0FBQztRQUNMO0lBQ0osR0FBR2pCO0lB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QUssYUFBYTtJQUNySy9ELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRELE9BQU8sRUFBRSxjQUFjO1FBQUUzRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2dFLE1BQU0sQ0FBQzlELFFBQVE0RCxPQUFPLEVBQUU1RDtJQUMvQitELE9BQU8vRCxPQUFPLEdBQUdBLFFBQVE0RCxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcz9mZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VJbnRlcnNlY3Rpb24gPSB1c2VJbnRlcnNlY3Rpb247XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG5jb25zdCBpZExpc3QgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IHtcbiAgICAgICAgcm9vdDogb3B0aW9ucy5yb290IHx8IG51bGwsXG4gICAgICAgIG1hcmdpbjogb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbih7IHJvb3RSZWYgLCByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlSW50ZXJzZWN0aW9uIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9yZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./pages/_app.jsx":
/*!************************!*\
  !*** ./pages/_app.jsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Nav__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Nav */ \"./components/Nav.jsx\");\n/* harmony import */ var _contexts_ContextWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/ContextWrapper */ \"./contexts/ContextWrapper.js\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction MyApp(param) {\n    let { Component , pageProps  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_ContextWrapper__WEBPACK_IMPORTED_MODULE_2__.ContextWrapper, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-screen h-full bg-slate-300\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Nav__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\pages\\\\_app.jsx\",\n                    lineNumber: 9,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-10/12 mx-auto flex justify-center items-center\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                        ...pageProps\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\pages\\\\_app.jsx\",\n                        lineNumber: 11,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\pages\\\\_app.jsx\",\n                    lineNumber: 10,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\pages\\\\_app.jsx\",\n            lineNumber: 8,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Umaha\\\\Documents\\\\metacrafters\\\\solidity\\\\advanced\\\\vesting-app\\\\pages\\\\_app.jsx\",\n        lineNumber: 7,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUN3QjtBQUM5QjtBQUU5QixTQUFTRSxNQUFNLEtBQXdCLEVBQUU7UUFBMUIsRUFBRUMsVUFBUyxFQUFFQyxVQUFTLEVBQUUsR0FBeEI7SUFDYixxQkFDRSw4REFBQ0gsb0VBQWNBO2tCQUNiLDRFQUFDSTtZQUFJQyxXQUFVOzs4QkFDYiw4REFBQ04sdURBQUdBOzs7Ozs4QkFDSiw4REFBQ0s7b0JBQUlDLFdBQVU7OEJBQ2IsNEVBQUNIO3dCQUFXLEdBQUdDLFNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLbEM7S0FYU0Y7QUFhVCwrREFBZUEsS0FBS0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLmpzeD80Y2IzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOYXYgZnJvbSAnLi4vY29tcG9uZW50cy9OYXYnO1xuaW1wb3J0IHsgQ29udGV4dFdyYXBwZXIgfSBmcm9tICcuLi9jb250ZXh0cy9Db250ZXh0V3JhcHBlcic7XG5pbXBvcnQgJy4uL3N0eWxlcy9nbG9iYWxzLmNzcydcblxuZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gIHJldHVybiAoXG4gICAgPENvbnRleHRXcmFwcGVyPlxuICAgICAgPGRpdiBjbGFzc05hbWU9J3ctc2NyZWVuIGgtZnVsbCBiZy1zbGF0ZS0zMDAnPlxuICAgICAgICA8TmF2IC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3LTEwLzEyIG14LWF1dG8gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXInPlxuICAgICAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L0NvbnRleHRXcmFwcGVyPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNeUFwcFxuIl0sIm5hbWVzIjpbIk5hdiIsIkNvbnRleHRXcmFwcGVyIiwiTXlBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJkaXYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/_app.jsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFr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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./artifacts/contracts/TokenVesting.sol/TokenVesting.json":
/*!****************************************************************!*\
  !*** ./artifacts/contracts/TokenVesting.sol/TokenVesting.json ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"_format":"hh-sol-artifact-1","contractName":"TokenVesting","sourceName":"contracts/TokenVesting.sol","abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"organization","type":"address"},{"indexed":true,"internalType":"address","name":"stakeholder","type":"address"}],"name":"AddressWhitelisted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"organization","type":"address"},{"indexed":true,"internalType":"address","name":"tokenContract","type":"address"}],"name":"OrganizationRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"organization","type":"address"},{"indexed":true,"internalType":"address","name":"stakeholder","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"_organization","type":"address"},{"internalType":"address","name":"_stakeholderAddress","type":"address"},{"internalType":"uint256","name":"_vestingPeriod","type":"uint256"},{"internalType":"uint256","name":"_totalTokens","type":"uint256"}],"name":"addStakeHolder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getStakeholder","outputs":[{"components":[{"internalType":"address","name":"stakerAddress","type":"address"},{"internalType":"uint256","name":"vestingPeriod","type":"uint256"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"totalTokens","type":"uint256"},{"internalType":"uint256","name":"claimedTokens","type":"uint256"}],"internalType":"struct TokenVesting.Stakeholder","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getStakerTokensClaimed","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"organizations","outputs":[{"internalType":"address","name":"organizationAddress","type":"address"},{"internalType":"address","name":"tokenContract","type":"address"},{"internalType":"string","name":"name","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_tokenContract","type":"address"},{"internalType":"string","name":"_name","type":"string"}],"name":"registerOrganization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"stakeHolderBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"stakeholders","outputs":[{"internalType":"address","name":"stakerAddress","type":"address"},{"internalType":"uint256","name":"vestingPeriod","type":"uint256"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"totalTokens","type":"uint256"},{"internalType":"uint256","name":"claimedTokens","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_stakeholder","type":"address"},{"internalType":"uint256","name":"_vestingPeriod","type":"uint256"}],"name":"whitelistAddress","outputs":[],"stateMutability":"nonpayable","type":"function"}],"bytecode":"0x608060405234801561001057600080fd5b50611ba1806100206000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c80635ab3010e116100665780635ab3010e1461010e578063b70336741461012a578063c07cfca914610148578063c9128b091461017c578063d104e79f1461019857610093565b8063200c7295146100985780634281e94f146100b457806348c54b9d146100d25780635a1f7406146100dc575b600080fd5b6100b260048036038101906100ad9190610ff2565b6101c8565b005b6100bc61047f565b6040516100c99190611041565b60405180910390f35b6100da6104c6565b005b6100f660048036038101906100f1919061105c565b610757565b60405161010593929190611128565b60405180910390f35b61012860048036038101906101239190611166565b610849565b005b610132610add565b60405161013f9190611253565b60405180910390f35b610162600480360381019061015d919061105c565b610bb2565b60405161017395949392919061126e565b60405180910390f35b61019660048036038101906101919190611326565b610c08565b005b6101b260048036038101906101ad919061105c565b610ef7565b6040516101bf9190611041565b60405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161022e906113d2565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610307576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102fe9061143e565b60405180910390fd5b60016000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f3d8a67432904f5c76d317bd3d7568237471009d9a286cd487736d0e2d103e6ad60405160405180910390a35050565b6000600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905090565b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541161054b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610542906114aa565b60405180910390fd5b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160030154116105d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105cc90611516565b60405180910390fd5b806003015481600401541061061f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161061690611582565b60405180910390fd5b8060010154816002015461063391906115d1565b421015610675576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066c90611651565b60405180910390fd5b60008160040154826003015461068b9190611671565b9050600081116106d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106c7906116f1565b60405180910390fd5b808260040160008282546106e491906115d1565b9250508190555080600260008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505050565b60006020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060020180546107c690611740565b80601f01602080910402602001604051908101604052809291908181526020018280546107f290611740565b801561083f5780601f106108145761010080835404028352916020019161083f565b820191906000526020600020905b81548152906001019060200180831161082257829003601f168201915b5050505050905083565b600073ffffffffffffffffffffffffffffffffffffffff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610919576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109109061143e565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146109e8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109df906117bd565b60405180910390fd5b6040518060a001604052808473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020014281526020018281526020016000815250600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015590505050505050565b610ae5610f0f565b600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060a00160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815260200160038201548152602001600482015481525050905090565b60016020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010154908060020154908060030154908060040154905085565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610c77576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6e90611829565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d47576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d3e90611895565b60405180910390fd5b336000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002019182610e97929190611a9b565b508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f9f51233d33c6517e4ea55596370510cf6f316777b475e532b8fbe6d3e6b1afaa60405160405180910390a3505050565b60026020528060005260406000206000915090505481565b6040518060a00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081525090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610f8982610f5e565b9050919050565b610f9981610f7e565b8114610fa457600080fd5b50565b600081359050610fb681610f90565b92915050565b6000819050919050565b610fcf81610fbc565b8114610fda57600080fd5b50565b600081359050610fec81610fc6565b92915050565b6000806040838503121561100957611008610f54565b5b600061101785828601610fa7565b925050602061102885828601610fdd565b9150509250929050565b61103b81610fbc565b82525050565b60006020820190506110566000830184611032565b92915050565b60006020828403121561107257611071610f54565b5b600061108084828501610fa7565b91505092915050565b61109281610f7e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156110d25780820151818401526020810190506110b7565b60008484015250505050565b6000601f19601f8301169050919050565b60006110fa82611098565b61110481856110a3565b93506111148185602086016110b4565b61111d816110de565b840191505092915050565b600060608201905061113d6000830186611089565b61114a6020830185611089565b818103604083015261115c81846110ef565b9050949350505050565b600080600080608085870312156111805761117f610f54565b5b600061118e87828801610fa7565b945050602061119f87828801610fa7565b93505060406111b087828801610fdd565b92505060606111c187828801610fdd565b91505092959194509250565b6111d681610f7e565b82525050565b6111e581610fbc565b82525050565b60a08201600082015161120160008501826111cd565b50602082015161121460208501826111dc565b50604082015161122760408501826111dc565b50606082015161123a60608501826111dc565b50608082015161124d60808501826111dc565b50505050565b600060a08201905061126860008301846111eb565b92915050565b600060a0820190506112836000830188611089565b6112906020830187611032565b61129d6040830186611032565b6112aa6060830185611032565b6112b76080830184611032565b9695505050505050565b600080fd5b600080fd5b600080fd5b60008083601f8401126112e6576112e56112c1565b5b8235905067ffffffffffffffff811115611303576113026112c6565b5b60208301915083600182028301111561131f5761131e6112cb565b5b9250929050565b60008060006040848603121561133f5761133e610f54565b5b600061134d86828701610fa7565b935050602084013567ffffffffffffffff81111561136e5761136d610f59565b5b61137a868287016112d0565b92509250509250925092565b7f496e76616c6964207374616b65686f6c64657220616464726573730000000000600082015250565b60006113bc601b836110a3565b91506113c782611386565b602082019050919050565b600060208201905081810360008301526113eb816113af565b9050919050565b7f4f7267616e697a6174696f6e206e6f7420726567697374657265640000000000600082015250565b6000611428601b836110a3565b9150611433826113f2565b602082019050919050565b600060208201905081810360008301526114578161141b565b9050919050565b7f5374616b65686f6c646572206e6f742072656769737465726564000000000000600082015250565b6000611494601a836110a3565b915061149f8261145e565b602082019050919050565b600060208201905081810360008301526114c381611487565b9050919050565b7f4e6f20746f6b656e7320746f20636c61696d0000000000000000000000000000600082015250565b60006115006012836110a3565b915061150b826114ca565b602082019050919050565b6000602082019050818103600083015261152f816114f3565b9050919050565b7f416c6c20746f6b656e7320636c61696d65640000000000000000000000000000600082015250565b600061156c6012836110a3565b915061157782611536565b602082019050919050565b6000602082019050818103600083015261159b8161155f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006115dc82610fbc565b91506115e783610fbc565b92508282019050808211156115ff576115fe6115a2565b5b92915050565b7f56657374696e6720706572696f64206e6f7420656e6465640000000000000000600082015250565b600061163b6018836110a3565b915061164682611605565b602082019050919050565b6000602082019050818103600083015261166a8161162e565b9050919050565b600061167c82610fbc565b915061168783610fbc565b925082820390508181111561169f5761169e6115a2565b5b92915050565b7f4e6f20746f6b656e730000000000000000000000000000000000000000000000600082015250565b60006116db6009836110a3565b91506116e6826116a5565b602082019050919050565b6000602082019050818103600083015261170a816116ce565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061175857607f821691505b60208210810361176b5761176a611711565b5b50919050565b7f556e617574686f72697a65642100000000000000000000000000000000000000600082015250565b60006117a7600d836110a3565b91506117b282611771565b602082019050919050565b600060208201905081810360008301526117d68161179a565b9050919050565b7f496e76616c696420746f6b656e20636f6e747261637420616464726573730000600082015250565b6000611813601e836110a3565b915061181e826117dd565b602082019050919050565b6000602082019050818103600083015261184281611806565b9050919050565b7f4f7267616e697a6174696f6e20616c7265616479207265676973746572656400600082015250565b600061187f601f836110a3565b915061188a82611849565b602082019050919050565b600060208201905081810360008301526118ae81611872565b9050919050565b600082905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026119517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82611914565b61195b8683611914565b95508019841693508086168417925050509392505050565b6000819050919050565b600061199861199361198e84610fbc565b611973565b610fbc565b9050919050565b6000819050919050565b6119b28361197d565b6119c66119be8261199f565b848454611921565b825550505050565b600090565b6119db6119ce565b6119e68184846119a9565b505050565b5b81811015611a0a576119ff6000826119d3565b6001810190506119ec565b5050565b601f821115611a4f57611a20816118ef565b611a2984611904565b81016020851015611a38578190505b611a4c611a4485611904565b8301826119eb565b50505b505050565b600082821c905092915050565b6000611a7260001984600802611a54565b1980831691505092915050565b6000611a8b8383611a61565b9150826002028217905092915050565b611aa583836118b5565b67ffffffffffffffff811115611abe57611abd6118c0565b5b611ac88254611740565b611ad3828285611a0e565b6000601f831160018114611b025760008415611af0578287013590505b611afa8582611a7f565b865550611b62565b601f198416611b10866118ef565b60005b82811015611b3857848901358255600182019150602085019450602081019050611b13565b86831015611b555784890135611b51601f891682611a61565b8355505b6001600288020188555050505b5050505050505056fea2646970667358221220064b3cfbeb9a2d97f04fca56bc519240b1da365fbfaa8e396ff69b20498853f964736f6c63430008110033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106100935760003560e01c80635ab3010e116100665780635ab3010e1461010e578063b70336741461012a578063c07cfca914610148578063c9128b091461017c578063d104e79f1461019857610093565b8063200c7295146100985780634281e94f146100b457806348c54b9d146100d25780635a1f7406146100dc575b600080fd5b6100b260048036038101906100ad9190610ff2565b6101c8565b005b6100bc61047f565b6040516100c99190611041565b60405180910390f35b6100da6104c6565b005b6100f660048036038101906100f1919061105c565b610757565b60405161010593929190611128565b60405180910390f35b61012860048036038101906101239190611166565b610849565b005b610132610add565b60405161013f9190611253565b60405180910390f35b610162600480360381019061015d919061105c565b610bb2565b60405161017395949392919061126e565b60405180910390f35b61019660048036038101906101919190611326565b610c08565b005b6101b260048036038101906101ad919061105c565b610ef7565b6040516101bf9190611041565b60405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161022e906113d2565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610307576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102fe9061143e565b60405180910390fd5b60016000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f3d8a67432904f5c76d317bd3d7568237471009d9a286cd487736d0e2d103e6ad60405160405180910390a35050565b6000600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905090565b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541161054b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610542906114aa565b60405180910390fd5b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160030154116105d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105cc90611516565b60405180910390fd5b806003015481600401541061061f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161061690611582565b60405180910390fd5b8060010154816002015461063391906115d1565b421015610675576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066c90611651565b60405180910390fd5b60008160040154826003015461068b9190611671565b9050600081116106d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106c7906116f1565b60405180910390fd5b808260040160008282546106e491906115d1565b9250508190555080600260008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505050565b60006020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060020180546107c690611740565b80601f01602080910402602001604051908101604052809291908181526020018280546107f290611740565b801561083f5780601f106108145761010080835404028352916020019161083f565b820191906000526020600020905b81548152906001019060200180831161082257829003601f168201915b5050505050905083565b600073ffffffffffffffffffffffffffffffffffffffff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610919576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109109061143e565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146109e8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109df906117bd565b60405180910390fd5b6040518060a001604052808473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020014281526020018281526020016000815250600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015590505050505050565b610ae5610f0f565b600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060a00160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815260200160038201548152602001600482015481525050905090565b60016020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010154908060020154908060030154908060040154905085565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610c77576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6e90611829565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d47576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d3e90611895565b60405180910390fd5b336000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002019182610e97929190611a9b565b508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f9f51233d33c6517e4ea55596370510cf6f316777b475e532b8fbe6d3e6b1afaa60405160405180910390a3505050565b60026020528060005260406000206000915090505481565b6040518060a00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081525090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610f8982610f5e565b9050919050565b610f9981610f7e565b8114610fa457600080fd5b50565b600081359050610fb681610f90565b92915050565b6000819050919050565b610fcf81610fbc565b8114610fda57600080fd5b50565b600081359050610fec81610fc6565b92915050565b6000806040838503121561100957611008610f54565b5b600061101785828601610fa7565b925050602061102885828601610fdd565b9150509250929050565b61103b81610fbc565b82525050565b60006020820190506110566000830184611032565b92915050565b60006020828403121561107257611071610f54565b5b600061108084828501610fa7565b91505092915050565b61109281610f7e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156110d25780820151818401526020810190506110b7565b60008484015250505050565b6000601f19601f8301169050919050565b60006110fa82611098565b61110481856110a3565b93506111148185602086016110b4565b61111d816110de565b840191505092915050565b600060608201905061113d6000830186611089565b61114a6020830185611089565b818103604083015261115c81846110ef565b9050949350505050565b600080600080608085870312156111805761117f610f54565b5b600061118e87828801610fa7565b945050602061119f87828801610fa7565b93505060406111b087828801610fdd565b92505060606111c187828801610fdd565b91505092959194509250565b6111d681610f7e565b82525050565b6111e581610fbc565b82525050565b60a08201600082015161120160008501826111cd565b50602082015161121460208501826111dc565b50604082015161122760408501826111dc565b50606082015161123a60608501826111dc565b50608082015161124d60808501826111dc565b50505050565b600060a08201905061126860008301846111eb565b92915050565b600060a0820190506112836000830188611089565b6112906020830187611032565b61129d6040830186611032565b6112aa6060830185611032565b6112b76080830184611032565b9695505050505050565b600080fd5b600080fd5b600080fd5b60008083601f8401126112e6576112e56112c1565b5b8235905067ffffffffffffffff811115611303576113026112c6565b5b60208301915083600182028301111561131f5761131e6112cb565b5b9250929050565b60008060006040848603121561133f5761133e610f54565b5b600061134d86828701610fa7565b935050602084013567ffffffffffffffff81111561136e5761136d610f59565b5b61137a868287016112d0565b92509250509250925092565b7f496e76616c6964207374616b65686f6c64657220616464726573730000000000600082015250565b60006113bc601b836110a3565b91506113c782611386565b602082019050919050565b600060208201905081810360008301526113eb816113af565b9050919050565b7f4f7267616e697a6174696f6e206e6f7420726567697374657265640000000000600082015250565b6000611428601b836110a3565b9150611433826113f2565b602082019050919050565b600060208201905081810360008301526114578161141b565b9050919050565b7f5374616b65686f6c646572206e6f742072656769737465726564000000000000600082015250565b6000611494601a836110a3565b915061149f8261145e565b602082019050919050565b600060208201905081810360008301526114c381611487565b9050919050565b7f4e6f20746f6b656e7320746f20636c61696d0000000000000000000000000000600082015250565b60006115006012836110a3565b915061150b826114ca565b602082019050919050565b6000602082019050818103600083015261152f816114f3565b9050919050565b7f416c6c20746f6b656e7320636c61696d65640000000000000000000000000000600082015250565b600061156c6012836110a3565b915061157782611536565b602082019050919050565b6000602082019050818103600083015261159b8161155f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006115dc82610fbc565b91506115e783610fbc565b92508282019050808211156115ff576115fe6115a2565b5b92915050565b7f56657374696e6720706572696f64206e6f7420656e6465640000000000000000600082015250565b600061163b6018836110a3565b915061164682611605565b602082019050919050565b6000602082019050818103600083015261166a8161162e565b9050919050565b600061167c82610fbc565b915061168783610fbc565b925082820390508181111561169f5761169e6115a2565b5b92915050565b7f4e6f20746f6b656e730000000000000000000000000000000000000000000000600082015250565b60006116db6009836110a3565b91506116e6826116a5565b602082019050919050565b6000602082019050818103600083015261170a816116ce565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061175857607f821691505b60208210810361176b5761176a611711565b5b50919050565b7f556e617574686f72697a65642100000000000000000000000000000000000000600082015250565b60006117a7600d836110a3565b91506117b282611771565b602082019050919050565b600060208201905081810360008301526117d68161179a565b9050919050565b7f496e76616c696420746f6b656e20636f6e747261637420616464726573730000600082015250565b6000611813601e836110a3565b915061181e826117dd565b602082019050919050565b6000602082019050818103600083015261184281611806565b9050919050565b7f4f7267616e697a6174696f6e20616c7265616479207265676973746572656400600082015250565b600061187f601f836110a3565b915061188a82611849565b602082019050919050565b600060208201905081810360008301526118ae81611872565b9050919050565b600082905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026119517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82611914565b61195b8683611914565b95508019841693508086168417925050509392505050565b6000819050919050565b600061199861199361198e84610fbc565b611973565b610fbc565b9050919050565b6000819050919050565b6119b28361197d565b6119c66119be8261199f565b848454611921565b825550505050565b600090565b6119db6119ce565b6119e68184846119a9565b505050565b5b81811015611a0a576119ff6000826119d3565b6001810190506119ec565b5050565b601f821115611a4f57611a20816118ef565b611a2984611904565b81016020851015611a38578190505b611a4c611a4485611904565b8301826119eb565b50505b505050565b600082821c905092915050565b6000611a7260001984600802611a54565b1980831691505092915050565b6000611a8b8383611a61565b9150826002028217905092915050565b611aa583836118b5565b67ffffffffffffffff811115611abe57611abd6118c0565b5b611ac88254611740565b611ad3828285611a0e565b6000601f831160018114611b025760008415611af0578287013590505b611afa8582611a7f565b865550611b62565b601f198416611b10866118ef565b60005b82811015611b3857848901358255600182019150602085019450602081019050611b13565b86831015611b555784890135611b51601f891682611a61565b8355505b6001600288020188555050505b5050505050505056fea2646970667358221220064b3cfbeb9a2d97f04fca56bc519240b1da365fbfaa8e396ff69b20498853f964736f6c63430008110033","linkReferences":{},"deployedLinkReferences":{}}');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);